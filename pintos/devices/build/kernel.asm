
kernel.o:     file format elf32-i386


Disassembly of section .text:

c0020078 <start>:
start:

# The loader called into us with CS = 0x2000, SS = 0x0000, ESP = 0xf000,
# but we should initialize the other segment registers.

	mov $0x2000, %ax
c0020078:	b8 00 20 8e d8       	mov    $0xd88e2000,%eax
	mov %ax, %ds
	mov %ax, %es
c002007d:	8e c0                	mov    %eax,%es

# Set string instructions to go upward.
	cld
c002007f:	fc                   	cld    
#### which returns AX = (kB of physical memory) - 1024.  This only
#### works for memory sizes <= 65 MB, which should be fine for our
#### purposes.  We cap memory at 64 MB because that's all we prepare
#### page tables for, below.

	movb $0x88, %ah
c0020080:	b4 88                	mov    $0x88,%ah
	int $0x15
c0020082:	cd 15                	int    $0x15
	addl $1024, %eax	# Total kB memory
c0020084:	66 05 00 04          	add    $0x400,%ax
c0020088:	00 00                	add    %al,(%eax)
	cmp $0x10000, %eax	# Cap at 64 MB
c002008a:	66 3d 00 00          	cmp    $0x0,%ax
c002008e:	01 00                	add    %eax,(%eax)
	jbe 1f
c0020090:	76 06                	jbe    c0020098 <start+0x20>
	mov $0x10000, %eax
c0020092:	66 b8 00 00          	mov    $0x0,%ax
c0020096:	01 00                	add    %eax,(%eax)
1:	shrl $2, %eax		# Total 4 kB pages
c0020098:	66 c1 e8 02          	shr    $0x2,%ax
	addr32 movl %eax, init_ram_pages - LOADER_PHYS_BASE - 0x20000
c002009c:	67 66 a3 7e 01       	addr16 mov %ax,0x17e
c00200a1:	00 00                	add    %al,(%eax)
#### Enable A20.  Address line 20 is tied low when the machine boots,
#### which prevents addressing memory about 1 MB.  This code fixes it.

# Poll status register while busy.

1:	inb $0x64, %al
c00200a3:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200a5:	a8 02                	test   $0x2,%al
	jnz 1b
c00200a7:	75 fa                	jne    c00200a3 <start+0x2b>

# Send command for writing output port.

	movb $0xd1, %al
c00200a9:	b0 d1                	mov    $0xd1,%al
	outb %al, $0x64
c00200ab:	e6 64                	out    %al,$0x64

# Poll status register while busy.

1:	inb $0x64, %al
c00200ad:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200af:	a8 02                	test   $0x2,%al
	jnz 1b
c00200b1:	75 fa                	jne    c00200ad <start+0x35>

# Enable A20 line.

	movb $0xdf, %al
c00200b3:	b0 df                	mov    $0xdf,%al
	outb %al, $0x60
c00200b5:	e6 60                	out    %al,$0x60

# Poll status register while busy.

1:	inb $0x64, %al
c00200b7:	e4 64                	in     $0x64,%al
	testb $0x2, %al
c00200b9:	a8 02                	test   $0x2,%al
	jnz 1b
c00200bb:	75 fa                	jne    c00200b7 <start+0x3f>

#### Create temporary page directory and page table and set page
#### directory base register.

# Create page directory at 0xf000 (60 kB) and fill with zeroes.
	mov $0xf00, %ax
c00200bd:	b8 00 0f 8e c0       	mov    $0xc08e0f00,%eax
	mov %ax, %es
	subl %eax, %eax
c00200c2:	66 29 c0             	sub    %ax,%ax
	subl %edi, %edi
c00200c5:	66 29 ff             	sub    %di,%di
	movl $0x400, %ecx
c00200c8:	66 b9 00 04          	mov    $0x400,%cx
c00200cc:	00 00                	add    %al,(%eax)
	rep stosl
c00200ce:	66 f3 ab             	rep stos %ax,%es:(%edi)
# Add PDEs to point to page tables for the first 64 MB of RAM.
# Also add identical PDEs starting at LOADER_PHYS_BASE.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movl $0x10007, %eax
c00200d1:	66 b8 07 00          	mov    $0x7,%ax
c00200d5:	01 00                	add    %eax,(%eax)
	movl $0x11, %ecx
c00200d7:	66 b9 11 00          	mov    $0x11,%cx
c00200db:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c00200dd:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c00200e0:	26 66 89 05 26 66 89 	mov    %ax,%es:0x85896626
c00200e7:	85 
	movl %eax, %es:LOADER_PHYS_BASE >> 20(%di)
c00200e8:	00 0c 83             	add    %cl,(%ebx,%eax,4)
	addw $4, %di
c00200eb:	c7 04 66 05 00 10 00 	movl   $0x100005,(%esi,%eiz,2)
	addl $0x1000, %eax
c00200f2:	00 e2                	add    %ah,%dl
	loop 1b
c00200f4:	eb b8                	jmp    c00200ae <start+0x36>
# Set up page tables for one-to-map linear to physical map for the
# first 64 MB of RAM.
# See [IA32-v3a] section 3.7.6 "Page-Directory and Page-Table Entries"
# for a description of the bits in %eax.

	movw $0x1000, %ax
c00200f6:	00 10                	add    %dl,(%eax)
	movw %ax, %es
c00200f8:	8e c0                	mov    %eax,%es
	movl $0x7, %eax
c00200fa:	66 b8 07 00          	mov    $0x7,%ax
c00200fe:	00 00                	add    %al,(%eax)
	movl $0x4000, %ecx
c0020100:	66 b9 00 40          	mov    $0x4000,%cx
c0020104:	00 00                	add    %al,(%eax)
	subl %edi, %edi
c0020106:	66 29 ff             	sub    %di,%di
1:	movl %eax, %es:(%di)
c0020109:	26 66 89 05 83 c7 04 	mov    %ax,%es:0x6604c783
c0020110:	66 
	addw $4, %di
	addl $0x1000, %eax
c0020111:	05 00 10 00 00       	add    $0x1000,%eax
	loop 1b
c0020116:	e2 f1                	loop   c0020109 <start+0x91>

# Set page directory base register.

	movl $0xf000, %eax
c0020118:	66 b8 00 f0          	mov    $0xf000,%ax
c002011c:	00 00                	add    %al,(%eax)
	movl %eax, %cr3
c002011e:	0f 22 d8             	mov    %eax,%cr3
#### Switch to protected mode.

# First, disable interrupts.  We won't set up the IDT until we get
# into C code, so any interrupt would blow us away.

	cli
c0020121:	fa                   	cli    
# We need a data32 prefix to ensure that all 32 bits of the GDT
# descriptor are loaded (default is to load only 24 bits).
# The CPU doesn't need an addr32 prefix but ELF doesn't do 16-bit
# relocations.

	data32 addr32 lgdt gdtdesc - LOADER_PHYS_BASE - 0x20000
c0020122:	67 66 0f 01 15       	lgdtw  (%di)
c0020127:	78 01                	js     c002012a <start+0xb2>
c0020129:	00 00                	add    %al,(%eax)
#    WP (Write Protect): if unset, ring 0 code ignores
#       write-protect bits in page tables (!).
#    EM (Emulation): forces floating-point instructions to trap.
#       We don't support floating point.

	movl %cr0, %eax
c002012b:	0f 20 c0             	mov    %cr0,%eax
	orl $CR0_PE | CR0_PG | CR0_WP | CR0_EM, %eax
c002012e:	66 0d 05 00          	or     $0x5,%ax
c0020132:	01 80 0f 22 c0 66    	add    %eax,0x66c0220f(%eax)
# the real-mode code segment cached in %cs's segment descriptor.  We
# need to reload %cs, and the easiest way is to use a far jump.
# Because we're not running in a 32-bit segment the data32 prefix is
# needed to jump to a 32-bit offset in the target segment.

	data32 ljmp $SEL_KCSEG, $1f
c0020138:	ea 3f 01 02 c0 08 00 	ljmp   $0x8,$0xc002013f
	.code32

# Reload all the other segment registers and the stack pointer to
# point into our new GDT.

1:	mov $SEL_KDSEG, %ax
c002013f:	66 b8 10 00          	mov    $0x10,%ax
	mov %ax, %ds
c0020143:	8e d8                	mov    %eax,%ds
	mov %ax, %es
c0020145:	8e c0                	mov    %eax,%es
	mov %ax, %fs
c0020147:	8e e0                	mov    %eax,%fs
	mov %ax, %gs
c0020149:	8e e8                	mov    %eax,%gs
	mov %ax, %ss
c002014b:	8e d0                	mov    %eax,%ss
	addl $LOADER_PHYS_BASE, %esp
c002014d:	81 c4 00 00 00 c0    	add    $0xc0000000,%esp
	movl $0, %ebp			# Null-terminate main()'s backtrace
c0020153:	bd 00 00 00 00       	mov    $0x0,%ebp

#### Call pintos_init().

	call pintos_init
c0020158:	e8 79 01 00 00       	call   c00202d6 <pintos_init>

# pintos_init() shouldn't ever return.  If it does, spin.

1:	jmp 1b
c002015d:	eb fe                	jmp    c002015d <start+0xe5>
	...

c0020160 <gdt>:
	...
c0020168:	ff                   	(bad)  
c0020169:	ff 00                	incl   (%eax)
c002016b:	00 00                	add    %al,(%eax)
c002016d:	9a cf 00 ff ff 00 00 	lcall  $0x0,$0xffff00cf
c0020174:	00                   	.byte 0x0
c0020175:	92                   	xchg   %eax,%edx
c0020176:	cf                   	iret   
	...

c0020178 <gdtdesc>:
c0020178:	17                   	pop    %ss
c0020179:	00 60 01             	add    %ah,0x1(%eax)
c002017c:	02 c0                	add    %al,%al

c002017e <init_ram_pages>:
c002017e:	00 00                	add    %al,(%eax)
	...

c0020182 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0020182:	55                   	push   %ebp
c0020183:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0020185:	8b 45 08             	mov    0x8(%ebp),%eax
c0020188:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002018d:	5d                   	pop    %ebp
c002018e:	c3                   	ret    

c002018f <is_kernel_vaddr>:
}

/* Returns true if VADDR is a kernel virtual address. */
static inline bool
is_kernel_vaddr (const void *vaddr) 
{
c002018f:	55                   	push   %ebp
c0020190:	89 e5                	mov    %esp,%ebp
  return vaddr >= PHYS_BASE;
c0020192:	81 7d 08 ff ff ff bf 	cmpl   $0xbfffffff,0x8(%ebp)
c0020199:	0f 97 c0             	seta   %al
}
c002019c:	5d                   	pop    %ebp
c002019d:	c3                   	ret    

c002019e <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c002019e:	55                   	push   %ebp
c002019f:	89 e5                	mov    %esp,%ebp
c00201a1:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c00201a4:	8b 45 08             	mov    0x8(%ebp),%eax
c00201a7:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c00201ac:	76 1e                	jbe    c00201cc <ptov+0x2e>
c00201ae:	83 ec 0c             	sub    $0xc,%esp
c00201b1:	68 00 eb 02 c0       	push   $0xc002eb00
c00201b6:	68 1b eb 02 c0       	push   $0xc002eb1b
c00201bb:	68 a8 ee 02 c0       	push   $0xc002eea8
c00201c0:	6a 4a                	push   $0x4a
c00201c2:	68 32 eb 02 c0       	push   $0xc002eb32
c00201c7:	e8 4f 9a 00 00       	call   c0029c1b <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c00201cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00201cf:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c00201d4:	c9                   	leave  
c00201d5:	c3                   	ret    

c00201d6 <vtop>:

/* Returns physical address at which kernel virtual address VADDR
   is mapped. */
static inline uintptr_t
vtop (const void *vaddr)
{
c00201d6:	55                   	push   %ebp
c00201d7:	89 e5                	mov    %esp,%ebp
c00201d9:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_kernel_vaddr (vaddr));
c00201dc:	ff 75 08             	pushl  0x8(%ebp)
c00201df:	e8 ab ff ff ff       	call   c002018f <is_kernel_vaddr>
c00201e4:	83 c4 04             	add    $0x4,%esp
c00201e7:	84 c0                	test   %al,%al
c00201e9:	75 1e                	jne    c0020209 <vtop+0x33>
c00201eb:	83 ec 0c             	sub    $0xc,%esp
c00201ee:	68 48 eb 02 c0       	push   $0xc002eb48
c00201f3:	68 1b eb 02 c0       	push   $0xc002eb1b
c00201f8:	68 d0 ee 02 c0       	push   $0xc002eed0
c00201fd:	6a 54                	push   $0x54
c00201ff:	68 32 eb 02 c0       	push   $0xc002eb32
c0020204:	e8 12 9a 00 00       	call   c0029c1b <debug_panic>

  return (uintptr_t) vaddr - (uintptr_t) PHYS_BASE;
c0020209:	8b 45 08             	mov    0x8(%ebp),%eax
c002020c:	05 00 00 00 40       	add    $0x40000000,%eax
}
c0020211:	c9                   	leave  
c0020212:	c3                   	ret    

c0020213 <pt_no>:
#define PDSHIFT (PTSHIFT + PTBITS)         /* First page directory bit. */
#define PDBITS  10                         /* Number of page dir bits. */
#define PDMASK  BITMASK(PDSHIFT, PDBITS)   /* Page directory bits (22:31). */

/* Obtains page table index from a virtual address. */
static inline unsigned pt_no (const void *va) {
c0020213:	55                   	push   %ebp
c0020214:	89 e5                	mov    %esp,%ebp
  return ((uintptr_t) va & PTMASK) >> PTSHIFT;
c0020216:	8b 45 08             	mov    0x8(%ebp),%eax
c0020219:	25 00 f0 3f 00       	and    $0x3ff000,%eax
c002021e:	c1 e8 0c             	shr    $0xc,%eax
}
c0020221:	5d                   	pop    %ebp
c0020222:	c3                   	ret    

c0020223 <pd_no>:

/* Obtains page directory index from a virtual address. */
static inline uintptr_t pd_no (const void *va) {
c0020223:	55                   	push   %ebp
c0020224:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PDSHIFT;
c0020226:	8b 45 08             	mov    0x8(%ebp),%eax
c0020229:	c1 e8 16             	shr    $0x16,%eax
}
c002022c:	5d                   	pop    %ebp
c002022d:	c3                   	ret    

c002022e <pde_create>:
#define PTE_U 0x4               /* 1=user/kernel, 0=kernel only. */
#define PTE_A 0x20              /* 1=accessed, 0=not acccessed. */
#define PTE_D 0x40              /* 1=dirty, 0=not dirty (PTEs only). */

/* Returns a PDE that points to page table PT. */
static inline uint32_t pde_create (uint32_t *pt) {
c002022e:	55                   	push   %ebp
c002022f:	89 e5                	mov    %esp,%ebp
c0020231:	83 ec 08             	sub    $0x8,%esp
  ASSERT (pg_ofs (pt) == 0);
c0020234:	ff 75 08             	pushl  0x8(%ebp)
c0020237:	e8 46 ff ff ff       	call   c0020182 <pg_ofs>
c002023c:	83 c4 04             	add    $0x4,%esp
c002023f:	85 c0                	test   %eax,%eax
c0020241:	74 1e                	je     c0020261 <pde_create+0x33>
c0020243:	83 ec 0c             	sub    $0xc,%esp
c0020246:	68 60 eb 02 c0       	push   $0xc002eb60
c002024b:	68 1b eb 02 c0       	push   $0xc002eb1b
c0020250:	68 b0 ee 02 c0       	push   $0xc002eeb0
c0020255:	6a 48                	push   $0x48
c0020257:	68 71 eb 02 c0       	push   $0xc002eb71
c002025c:	e8 ba 99 00 00       	call   c0029c1b <debug_panic>
  return vtop (pt) | PTE_U | PTE_P | PTE_W;
c0020261:	83 ec 0c             	sub    $0xc,%esp
c0020264:	ff 75 08             	pushl  0x8(%ebp)
c0020267:	e8 6a ff ff ff       	call   c00201d6 <vtop>
c002026c:	83 c4 10             	add    $0x10,%esp
c002026f:	83 c8 07             	or     $0x7,%eax
}
c0020272:	c9                   	leave  
c0020273:	c3                   	ret    

c0020274 <pte_create_kernel>:

/* Returns a PTE that points to PAGE.
   The PTE's page is readable.
   If WRITABLE is true then it will be writable as well.
   The page will be usable only by ring 0 code (the kernel). */
static inline uint32_t pte_create_kernel (void *page, bool writable) {
c0020274:	55                   	push   %ebp
c0020275:	89 e5                	mov    %esp,%ebp
c0020277:	83 ec 18             	sub    $0x18,%esp
c002027a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002027d:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (pg_ofs (page) == 0);
c0020280:	ff 75 08             	pushl  0x8(%ebp)
c0020283:	e8 fa fe ff ff       	call   c0020182 <pg_ofs>
c0020288:	83 c4 04             	add    $0x4,%esp
c002028b:	85 c0                	test   %eax,%eax
c002028d:	74 1e                	je     c00202ad <pte_create_kernel+0x39>
c002028f:	83 ec 0c             	sub    $0xc,%esp
c0020292:	68 85 eb 02 c0       	push   $0xc002eb85
c0020297:	68 1b eb 02 c0       	push   $0xc002eb1b
c002029c:	68 bc ee 02 c0       	push   $0xc002eebc
c00202a1:	6a 58                	push   $0x58
c00202a3:	68 71 eb 02 c0       	push   $0xc002eb71
c00202a8:	e8 6e 99 00 00       	call   c0029c1b <debug_panic>
  return vtop (page) | PTE_P | (writable ? PTE_W : 0);
c00202ad:	83 ec 0c             	sub    $0xc,%esp
c00202b0:	ff 75 08             	pushl  0x8(%ebp)
c00202b3:	e8 1e ff ff ff       	call   c00201d6 <vtop>
c00202b8:	83 c4 10             	add    $0x10,%esp
c00202bb:	89 c2                	mov    %eax,%edx
c00202bd:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c00202c1:	74 07                	je     c00202ca <pte_create_kernel+0x56>
c00202c3:	b8 02 00 00 00       	mov    $0x2,%eax
c00202c8:	eb 05                	jmp    c00202cf <pte_create_kernel+0x5b>
c00202ca:	b8 00 00 00 00       	mov    $0x0,%eax
c00202cf:	09 d0                	or     %edx,%eax
c00202d1:	83 c8 01             	or     $0x1,%eax
}
c00202d4:	c9                   	leave  
c00202d5:	c3                   	ret    

c00202d6 <pintos_init>:
int pintos_init (void) NO_RETURN;

/* Pintos main entry point. */
int
pintos_init (void)
{
c00202d6:	55                   	push   %ebp
c00202d7:	89 e5                	mov    %esp,%ebp
c00202d9:	83 ec 18             	sub    $0x18,%esp
  char **argv;

  /* Clear BSS. */  
  bss_init ();
c00202dc:	e8 ae 00 00 00       	call   c002038f <bss_init>

  /* Break command line into arguments and parse options. */
  argv = read_command_line ();
c00202e1:	e8 04 02 00 00       	call   c00204ea <read_command_line>
c00202e6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  argv = parse_options (argv);
c00202e9:	83 ec 0c             	sub    $0xc,%esp
c00202ec:	ff 75 f4             	pushl  -0xc(%ebp)
c00202ef:	e8 2a 03 00 00       	call   c002061e <parse_options>
c00202f4:	83 c4 10             	add    $0x10,%esp
c00202f7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Initialize ourselves as a thread so we can use locks,
     then enable console locking. */
  thread_init ();
c00202fa:	e8 07 06 00 00       	call   c0020906 <thread_init>
  console_init ();  
c00202ff:	e8 67 b9 00 00       	call   c002bc6b <console_init>

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
          init_ram_pages * PGSIZE / 1024);
c0020304:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c0020309:	c1 e0 0c             	shl    $0xc,%eax
     then enable console locking. */
  thread_init ();
  console_init ();  

  /* Greet user. */
  printf ("Pintos booting with %'"PRIu32" kB RAM...\n",
c002030c:	c1 e8 0a             	shr    $0xa,%eax
c002030f:	83 ec 08             	sub    $0x8,%esp
c0020312:	50                   	push   %eax
c0020313:	68 98 eb 02 c0       	push   $0xc002eb98
c0020318:	e8 cb 74 00 00       	call   c00277e8 <printf>
c002031d:	83 c4 10             	add    $0x10,%esp
          init_ram_pages * PGSIZE / 1024);

  /* Initialize memory system. */
  palloc_init (user_page_limit);
c0020320:	a1 60 79 03 c0       	mov    0xc0037960,%eax
c0020325:	83 ec 0c             	sub    $0xc,%esp
c0020328:	50                   	push   %eax
c0020329:	e8 6a 31 00 00       	call   c0023498 <palloc_init>
c002032e:	83 c4 10             	add    $0x10,%esp
  malloc_init ();
c0020331:	e8 73 35 00 00       	call   c00238a9 <malloc_init>
  paging_init ();
c0020336:	e8 7e 00 00 00       	call   c00203b9 <paging_init>
  tss_init ();
  gdt_init ();
#endif

  /* Initialize interrupt handlers. */
  intr_init ();
c002033b:	e8 db 11 00 00       	call   c002151b <intr_init>
  timer_init ();
c0020340:	e8 64 3d 00 00       	call   c00240a9 <timer_init>
  kbd_init ();
c0020345:	e8 2a 44 00 00       	call   c0024774 <kbd_init>
  input_init ();
c002034a:	e8 13 67 00 00       	call   c0026a62 <input_init>
  exception_init ();
  syscall_init ();
#endif

  /* Start thread scheduler and enable interrupts. */
  thread_start ();
c002034f:	e8 51 06 00 00       	call   c00209a5 <thread_start>
  serial_init_queue ();
c0020354:	e8 16 4c 00 00       	call   c0024f6f <serial_init_queue>
  timer_calibrate ();
c0020359:	e8 8c 3d 00 00       	call   c00240ea <timer_calibrate>
  ide_init ();
  locate_block_devices ();
  filesys_init (format_filesys);
#endif

  printf ("Boot complete.\n");
c002035e:	83 ec 0c             	sub    $0xc,%esp
c0020361:	68 bb eb 02 c0       	push   $0xc002ebbb
c0020366:	e8 63 ba 00 00       	call   c002bdce <puts>
c002036b:	83 c4 10             	add    $0x10,%esp
  
  if (*argv != NULL) {
c002036e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020371:	8b 00                	mov    (%eax),%eax
c0020373:	85 c0                	test   %eax,%eax
c0020375:	74 0e                	je     c0020385 <pintos_init+0xaf>
    /* Run actions specified on kernel command line. */
    run_actions (argv);
c0020377:	83 ec 0c             	sub    $0xc,%esp
c002037a:	ff 75 f4             	pushl  -0xc(%ebp)
c002037d:	e8 38 04 00 00       	call   c00207ba <run_actions>
c0020382:	83 c4 10             	add    $0x10,%esp
  } else {
    // TODO: no command line passed to kernel. Run interactively 
  }

  /* Finish up. */
  shutdown ();
c0020385:	e8 96 6e 00 00       	call   c0027220 <shutdown>
  thread_exit ();
c002038a:	e8 dd 09 00 00       	call   c0020d6c <thread_exit>

c002038f <bss_init>:

   The start and end of the BSS segment is recorded by the
   linker as _start_bss and _end_bss.  See kernel.lds. */
static void
bss_init (void) 
{
c002038f:	55                   	push   %ebp
c0020390:	89 e5                	mov    %esp,%ebp
c0020392:	83 ec 08             	sub    $0x8,%esp
  extern char _start_bss, _end_bss;
  memset (&_start_bss, 0, &_end_bss - &_start_bss);
c0020395:	ba b8 9e 03 c0       	mov    $0xc0039eb8,%edx
c002039a:	b8 e4 81 03 c0       	mov    $0xc00381e4,%eax
c002039f:	29 c2                	sub    %eax,%edx
c00203a1:	89 d0                	mov    %edx,%eax
c00203a3:	83 ec 04             	sub    $0x4,%esp
c00203a6:	50                   	push   %eax
c00203a7:	6a 00                	push   $0x0
c00203a9:	68 e4 81 03 c0       	push   $0xc00381e4
c00203ae:	e8 5c 8c 00 00       	call   c002900f <memset>
c00203b3:	83 c4 10             	add    $0x10,%esp
}
c00203b6:	90                   	nop
c00203b7:	c9                   	leave  
c00203b8:	c3                   	ret    

c00203b9 <paging_init>:
   kernel virtual mapping, and then sets up the CPU to use the
   new page directory.  Points init_page_dir to the page
   directory it creates. */
static void
paging_init (void)
{
c00203b9:	55                   	push   %ebp
c00203ba:	89 e5                	mov    %esp,%ebp
c00203bc:	53                   	push   %ebx
c00203bd:	83 ec 24             	sub    $0x24,%esp
  uint32_t *pd, *pt;
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c00203c0:	83 ec 0c             	sub    $0xc,%esp
c00203c3:	6a 03                	push   $0x3
c00203c5:	e8 4a 32 00 00       	call   c0023614 <palloc_get_page>
c00203ca:	83 c4 10             	add    $0x10,%esp
c00203cd:	a3 a0 9e 03 c0       	mov    %eax,0xc0039ea0
c00203d2:	a1 a0 9e 03 c0       	mov    0xc0039ea0,%eax
c00203d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
  pt = NULL;
c00203da:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  for (page = 0; page < init_ram_pages; page++)
c00203e1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00203e8:	e9 d5 00 00 00       	jmp    c00204c2 <paging_init+0x109>
    {
      uintptr_t paddr = page * PGSIZE;
c00203ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00203f0:	c1 e0 0c             	shl    $0xc,%eax
c00203f3:	89 45 e8             	mov    %eax,-0x18(%ebp)
      char *vaddr = ptov (paddr);
c00203f6:	83 ec 0c             	sub    $0xc,%esp
c00203f9:	ff 75 e8             	pushl  -0x18(%ebp)
c00203fc:	e8 9d fd ff ff       	call   c002019e <ptov>
c0020401:	83 c4 10             	add    $0x10,%esp
c0020404:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      size_t pde_idx = pd_no (vaddr);
c0020407:	83 ec 0c             	sub    $0xc,%esp
c002040a:	ff 75 e4             	pushl  -0x1c(%ebp)
c002040d:	e8 11 fe ff ff       	call   c0020223 <pd_no>
c0020412:	83 c4 10             	add    $0x10,%esp
c0020415:	89 45 e0             	mov    %eax,-0x20(%ebp)
      size_t pte_idx = pt_no (vaddr);
c0020418:	83 ec 0c             	sub    $0xc,%esp
c002041b:	ff 75 e4             	pushl  -0x1c(%ebp)
c002041e:	e8 f0 fd ff ff       	call   c0020213 <pt_no>
c0020423:	83 c4 10             	add    $0x10,%esp
c0020426:	89 45 dc             	mov    %eax,-0x24(%ebp)
      bool in_kernel_text = &_start <= vaddr && vaddr < &_end_kernel_text;
c0020429:	81 7d e4 00 00 02 c0 	cmpl   $0xc0020000,-0x1c(%ebp)
c0020430:	72 10                	jb     c0020442 <paging_init+0x89>
c0020432:	81 7d e4 00 40 03 c0 	cmpl   $0xc0034000,-0x1c(%ebp)
c0020439:	73 07                	jae    c0020442 <paging_init+0x89>
c002043b:	b8 01 00 00 00       	mov    $0x1,%eax
c0020440:	eb 05                	jmp    c0020447 <paging_init+0x8e>
c0020442:	b8 00 00 00 00       	mov    $0x0,%eax
c0020447:	88 45 db             	mov    %al,-0x25(%ebp)
c002044a:	80 65 db 01          	andb   $0x1,-0x25(%ebp)

      if (pd[pde_idx] == 0)
c002044e:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020451:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c0020458:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002045b:	01 d0                	add    %edx,%eax
c002045d:	8b 00                	mov    (%eax),%eax
c002045f:	85 c0                	test   %eax,%eax
c0020461:	75 30                	jne    c0020493 <paging_init+0xda>
        {
          pt = palloc_get_page (PAL_ASSERT | PAL_ZERO);
c0020463:	83 ec 0c             	sub    $0xc,%esp
c0020466:	6a 03                	push   $0x3
c0020468:	e8 a7 31 00 00       	call   c0023614 <palloc_get_page>
c002046d:	83 c4 10             	add    $0x10,%esp
c0020470:	89 45 f4             	mov    %eax,-0xc(%ebp)
          pd[pde_idx] = pde_create (pt);
c0020473:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0020476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002047d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020480:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0020483:	83 ec 0c             	sub    $0xc,%esp
c0020486:	ff 75 f4             	pushl  -0xc(%ebp)
c0020489:	e8 a0 fd ff ff       	call   c002022e <pde_create>
c002048e:	83 c4 10             	add    $0x10,%esp
c0020491:	89 03                	mov    %eax,(%ebx)
        }

      pt[pte_idx] = pte_create_kernel (vaddr, !in_kernel_text);
c0020493:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0020496:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002049d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00204a0:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c00204a3:	0f b6 45 db          	movzbl -0x25(%ebp),%eax
c00204a7:	83 f0 01             	xor    $0x1,%eax
c00204aa:	0f b6 c0             	movzbl %al,%eax
c00204ad:	83 ec 08             	sub    $0x8,%esp
c00204b0:	50                   	push   %eax
c00204b1:	ff 75 e4             	pushl  -0x1c(%ebp)
c00204b4:	e8 bb fd ff ff       	call   c0020274 <pte_create_kernel>
c00204b9:	83 c4 10             	add    $0x10,%esp
c00204bc:	89 03                	mov    %eax,(%ebx)
  size_t page;
  extern char _start, _end_kernel_text;

  pd = init_page_dir = palloc_get_page (PAL_ASSERT | PAL_ZERO);
  pt = NULL;
  for (page = 0; page < init_ram_pages; page++)
c00204be:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c00204c2:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00204c7:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c00204ca:	0f 82 1d ff ff ff    	jb     c00203ed <paging_init+0x34>
  /* Store the physical address of the page directory into CR3
     aka PDBR (page directory base register).  This activates our
     new page tables immediately.  See [IA32-v2a] "MOV--Move
     to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
     of the Page Directory". */
  asm volatile ("movl %0, %%cr3" : : "r" (vtop (init_page_dir)));
c00204d0:	a1 a0 9e 03 c0       	mov    0xc0039ea0,%eax
c00204d5:	83 ec 0c             	sub    $0xc,%esp
c00204d8:	50                   	push   %eax
c00204d9:	e8 f8 fc ff ff       	call   c00201d6 <vtop>
c00204de:	83 c4 10             	add    $0x10,%esp
c00204e1:	0f 22 d8             	mov    %eax,%cr3
}
c00204e4:	90                   	nop
c00204e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00204e8:	c9                   	leave  
c00204e9:	c3                   	ret    

c00204ea <read_command_line>:

/* Breaks the kernel command line into words and returns them as
   an argv-like array. */
static char **
read_command_line (void) 
{
c00204ea:	55                   	push   %ebp
c00204eb:	89 e5                	mov    %esp,%ebp
c00204ed:	83 ec 18             	sub    $0x18,%esp
  static char *argv[LOADER_ARGS_LEN / 2 + 1];
  char *p, *end;
  int argc;
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
c00204f0:	83 ec 0c             	sub    $0xc,%esp
c00204f3:	68 3a 7d 00 00       	push   $0x7d3a
c00204f8:	e8 a1 fc ff ff       	call   c002019e <ptov>
c00204fd:	83 c4 10             	add    $0x10,%esp
c0020500:	8b 00                	mov    (%eax),%eax
c0020502:	89 45 ec             	mov    %eax,-0x14(%ebp)
  p = ptov (LOADER_ARGS);
c0020505:	83 ec 0c             	sub    $0xc,%esp
c0020508:	68 3e 7d 00 00       	push   $0x7d3e
c002050d:	e8 8c fc ff ff       	call   c002019e <ptov>
c0020512:	83 c4 10             	add    $0x10,%esp
c0020515:	89 45 f4             	mov    %eax,-0xc(%ebp)
  end = p + LOADER_ARGS_LEN;
c0020518:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002051b:	83 e8 80             	sub    $0xffffff80,%eax
c002051e:	89 45 e8             	mov    %eax,-0x18(%ebp)
  for (i = 0; i < argc; i++) 
c0020521:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0020528:	eb 51                	jmp    c002057b <read_command_line+0x91>
    {
      if (p >= end)
c002052a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002052d:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0020530:	72 19                	jb     c002054b <read_command_line+0x61>
        PANIC ("command line arguments overflow");
c0020532:	68 cc eb 02 c0       	push   $0xc002ebcc
c0020537:	68 d8 ee 02 c0       	push   $0xc002eed8
c002053c:	68 d3 00 00 00       	push   $0xd3
c0020541:	68 ec eb 02 c0       	push   $0xc002ebec
c0020546:	e8 d0 96 00 00       	call   c0029c1b <debug_panic>

      argv[i] = p;
c002054b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002054e:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0020551:	89 14 85 00 82 03 c0 	mov    %edx,-0x3ffc7e00(,%eax,4)
      p += strnlen (p, end - p) + 1;
c0020558:	8b 55 e8             	mov    -0x18(%ebp),%edx
c002055b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002055e:	29 c2                	sub    %eax,%edx
c0020560:	89 d0                	mov    %edx,%eax
c0020562:	83 ec 08             	sub    $0x8,%esp
c0020565:	50                   	push   %eax
c0020566:	ff 75 f4             	pushl  -0xc(%ebp)
c0020569:	e8 49 8b 00 00       	call   c00290b7 <strnlen>
c002056e:	83 c4 10             	add    $0x10,%esp
c0020571:	83 c0 01             	add    $0x1,%eax
c0020574:	01 45 f4             	add    %eax,-0xc(%ebp)
  int i;

  argc = *(uint32_t *) ptov (LOADER_ARG_CNT);
  p = ptov (LOADER_ARGS);
  end = p + LOADER_ARGS_LEN;
  for (i = 0; i < argc; i++) 
c0020577:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002057b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002057e:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020581:	7c a7                	jl     c002052a <read_command_line+0x40>
        PANIC ("command line arguments overflow");

      argv[i] = p;
      p += strnlen (p, end - p) + 1;
    }
  argv[argc] = NULL;
c0020583:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020586:	c7 04 85 00 82 03 c0 	movl   $0x0,-0x3ffc7e00(,%eax,4)
c002058d:	00 00 00 00 

  /* Print kernel command line. */
  printf ("Kernel command line:");
c0020591:	83 ec 0c             	sub    $0xc,%esp
c0020594:	68 01 ec 02 c0       	push   $0xc002ec01
c0020599:	e8 4a 72 00 00       	call   c00277e8 <printf>
c002059e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < argc; i++)
c00205a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c00205a8:	eb 58                	jmp    c0020602 <read_command_line+0x118>
    if (strchr (argv[i], ' ') == NULL)
c00205aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205ad:	8b 04 85 00 82 03 c0 	mov    -0x3ffc7e00(,%eax,4),%eax
c00205b4:	83 ec 08             	sub    $0x8,%esp
c00205b7:	6a 20                	push   $0x20
c00205b9:	50                   	push   %eax
c00205ba:	e8 5f 87 00 00       	call   c0028d1e <strchr>
c00205bf:	83 c4 10             	add    $0x10,%esp
c00205c2:	85 c0                	test   %eax,%eax
c00205c4:	75 1d                	jne    c00205e3 <read_command_line+0xf9>
      printf (" %s", argv[i]);
c00205c6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205c9:	8b 04 85 00 82 03 c0 	mov    -0x3ffc7e00(,%eax,4),%eax
c00205d0:	83 ec 08             	sub    $0x8,%esp
c00205d3:	50                   	push   %eax
c00205d4:	68 16 ec 02 c0       	push   $0xc002ec16
c00205d9:	e8 0a 72 00 00       	call   c00277e8 <printf>
c00205de:	83 c4 10             	add    $0x10,%esp
c00205e1:	eb 1b                	jmp    c00205fe <read_command_line+0x114>
    else
      printf (" '%s'", argv[i]);
c00205e3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00205e6:	8b 04 85 00 82 03 c0 	mov    -0x3ffc7e00(,%eax,4),%eax
c00205ed:	83 ec 08             	sub    $0x8,%esp
c00205f0:	50                   	push   %eax
c00205f1:	68 1a ec 02 c0       	push   $0xc002ec1a
c00205f6:	e8 ed 71 00 00       	call   c00277e8 <printf>
c00205fb:	83 c4 10             	add    $0x10,%esp
    }
  argv[argc] = NULL;

  /* Print kernel command line. */
  printf ("Kernel command line:");
  for (i = 0; i < argc; i++)
c00205fe:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020602:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020605:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0020608:	7c a0                	jl     c00205aa <read_command_line+0xc0>
    if (strchr (argv[i], ' ') == NULL)
      printf (" %s", argv[i]);
    else
      printf (" '%s'", argv[i]);
  printf ("\n");
c002060a:	83 ec 0c             	sub    $0xc,%esp
c002060d:	6a 0a                	push   $0xa
c002060f:	e8 42 b8 00 00       	call   c002be56 <putchar>
c0020614:	83 c4 10             	add    $0x10,%esp

  return argv;
c0020617:	b8 00 82 03 c0       	mov    $0xc0038200,%eax
}
c002061c:	c9                   	leave  
c002061d:	c3                   	ret    

c002061e <parse_options>:

/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
c002061e:	55                   	push   %ebp
c002061f:	89 e5                	mov    %esp,%ebp
c0020621:	83 ec 18             	sub    $0x18,%esp
  for (; *argv != NULL && **argv == '-'; argv++)
c0020624:	e9 1c 01 00 00       	jmp    c0020745 <parse_options+0x127>
    {
      char *save_ptr;
      char *name = strtok_r (*argv, "=", &save_ptr);
c0020629:	8b 45 08             	mov    0x8(%ebp),%eax
c002062c:	8b 00                	mov    (%eax),%eax
c002062e:	83 ec 04             	sub    $0x4,%esp
c0020631:	8d 55 ec             	lea    -0x14(%ebp),%edx
c0020634:	52                   	push   %edx
c0020635:	68 20 ec 02 c0       	push   $0xc002ec20
c002063a:	50                   	push   %eax
c002063b:	e8 bb 88 00 00       	call   c0028efb <strtok_r>
c0020640:	83 c4 10             	add    $0x10,%esp
c0020643:	89 45 f4             	mov    %eax,-0xc(%ebp)
      char *value = strtok_r (NULL, "", &save_ptr);
c0020646:	83 ec 04             	sub    $0x4,%esp
c0020649:	8d 45 ec             	lea    -0x14(%ebp),%eax
c002064c:	50                   	push   %eax
c002064d:	68 22 ec 02 c0       	push   $0xc002ec22
c0020652:	6a 00                	push   $0x0
c0020654:	e8 a2 88 00 00       	call   c0028efb <strtok_r>
c0020659:	83 c4 10             	add    $0x10,%esp
c002065c:	89 45 f0             	mov    %eax,-0x10(%ebp)
      
      if (!strcmp (name, "-h"))
c002065f:	83 ec 08             	sub    $0x8,%esp
c0020662:	68 23 ec 02 c0       	push   $0xc002ec23
c0020667:	ff 75 f4             	pushl  -0xc(%ebp)
c002066a:	e8 a2 85 00 00       	call   c0028c11 <strcmp>
c002066f:	83 c4 10             	add    $0x10,%esp
c0020672:	85 c0                	test   %eax,%eax
c0020674:	75 0a                	jne    c0020680 <parse_options+0x62>
        usage ();
c0020676:	e8 24 02 00 00       	call   c002089f <usage>
c002067b:	e9 c1 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-q"))
c0020680:	83 ec 08             	sub    $0x8,%esp
c0020683:	68 26 ec 02 c0       	push   $0xc002ec26
c0020688:	ff 75 f4             	pushl  -0xc(%ebp)
c002068b:	e8 81 85 00 00       	call   c0028c11 <strcmp>
c0020690:	83 c4 10             	add    $0x10,%esp
c0020693:	85 c0                	test   %eax,%eax
c0020695:	75 12                	jne    c00206a9 <parse_options+0x8b>
        shutdown_configure (SHUTDOWN_POWER_OFF);
c0020697:	83 ec 0c             	sub    $0xc,%esp
c002069a:	6a 01                	push   $0x1
c002069c:	e8 a3 6b 00 00       	call   c0027244 <shutdown_configure>
c00206a1:	83 c4 10             	add    $0x10,%esp
c00206a4:	e9 98 00 00 00       	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-r"))
c00206a9:	83 ec 08             	sub    $0x8,%esp
c00206ac:	68 29 ec 02 c0       	push   $0xc002ec29
c00206b1:	ff 75 f4             	pushl  -0xc(%ebp)
c00206b4:	e8 58 85 00 00       	call   c0028c11 <strcmp>
c00206b9:	83 c4 10             	add    $0x10,%esp
c00206bc:	85 c0                	test   %eax,%eax
c00206be:	75 0f                	jne    c00206cf <parse_options+0xb1>
        shutdown_configure (SHUTDOWN_REBOOT);
c00206c0:	83 ec 0c             	sub    $0xc,%esp
c00206c3:	6a 02                	push   $0x2
c00206c5:	e8 7a 6b 00 00       	call   c0027244 <shutdown_configure>
c00206ca:	83 c4 10             	add    $0x10,%esp
c00206cd:	eb 72                	jmp    c0020741 <parse_options+0x123>
#ifdef VM
      else if (!strcmp (name, "-swap"))
        swap_bdev_name = value;
#endif
#endif
      else if (!strcmp (name, "-rs"))
c00206cf:	83 ec 08             	sub    $0x8,%esp
c00206d2:	68 2c ec 02 c0       	push   $0xc002ec2c
c00206d7:	ff 75 f4             	pushl  -0xc(%ebp)
c00206da:	e8 32 85 00 00       	call   c0028c11 <strcmp>
c00206df:	83 c4 10             	add    $0x10,%esp
c00206e2:	85 c0                	test   %eax,%eax
c00206e4:	75 1c                	jne    c0020702 <parse_options+0xe4>
        random_init (atoi (value));
c00206e6:	83 ec 0c             	sub    $0xc,%esp
c00206e9:	ff 75 f0             	pushl  -0x10(%ebp)
c00206ec:	e8 fc 7e 00 00       	call   c00285ed <atoi>
c00206f1:	83 c4 10             	add    $0x10,%esp
c00206f4:	83 ec 0c             	sub    $0xc,%esp
c00206f7:	50                   	push   %eax
c00206f8:	e8 6a 6e 00 00       	call   c0027567 <random_init>
c00206fd:	83 c4 10             	add    $0x10,%esp
c0020700:	eb 3f                	jmp    c0020741 <parse_options+0x123>
      else if (!strcmp (name, "-mlfqs"))
c0020702:	83 ec 08             	sub    $0x8,%esp
c0020705:	68 30 ec 02 c0       	push   $0xc002ec30
c002070a:	ff 75 f4             	pushl  -0xc(%ebp)
c002070d:	e8 ff 84 00 00       	call   c0028c11 <strcmp>
c0020712:	83 c4 10             	add    $0x10,%esp
c0020715:	85 c0                	test   %eax,%eax
c0020717:	75 09                	jne    c0020722 <parse_options+0x104>
        thread_mlfqs = true;
c0020719:	c6 05 a4 9e 03 c0 01 	movb   $0x1,0xc0039ea4
c0020720:	eb 1f                	jmp    c0020741 <parse_options+0x123>
#ifdef USERPROG
      else if (!strcmp (name, "-ul"))
        user_page_limit = atoi (value);
#endif
      else
        PANIC ("unknown option `%s' (use -h for help)", name);
c0020722:	83 ec 0c             	sub    $0xc,%esp
c0020725:	ff 75 f4             	pushl  -0xc(%ebp)
c0020728:	68 38 ec 02 c0       	push   $0xc002ec38
c002072d:	68 ec ee 02 c0       	push   $0xc002eeec
c0020732:	68 0c 01 00 00       	push   $0x10c
c0020737:	68 ec eb 02 c0       	push   $0xc002ebec
c002073c:	e8 da 94 00 00       	call   c0029c1b <debug_panic>
/* Parses options in ARGV[]
   and returns the first non-option argument. */
static char **
parse_options (char **argv) 
{
  for (; *argv != NULL && **argv == '-'; argv++)
c0020741:	83 45 08 04          	addl   $0x4,0x8(%ebp)
c0020745:	8b 45 08             	mov    0x8(%ebp),%eax
c0020748:	8b 00                	mov    (%eax),%eax
c002074a:	85 c0                	test   %eax,%eax
c002074c:	74 10                	je     c002075e <parse_options+0x140>
c002074e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020751:	8b 00                	mov    (%eax),%eax
c0020753:	0f b6 00             	movzbl (%eax),%eax
c0020756:	3c 2d                	cmp    $0x2d,%al
c0020758:	0f 84 cb fe ff ff    	je     c0020629 <parse_options+0xb>
     When running under Bochs, this is not enough by itself to
     get a good seed value, because the pintos script sets the
     initial time to a predictable value, not to the local time,
     for reproducibility.  To fix this, give the "-r" option to
     the pintos script to request real-time execution. */
  random_init (rtc_get_time ());
c002075e:	e8 7b 68 00 00       	call   c0026fde <rtc_get_time>
c0020763:	83 ec 0c             	sub    $0xc,%esp
c0020766:	50                   	push   %eax
c0020767:	e8 fb 6d 00 00       	call   c0027567 <random_init>
c002076c:	83 c4 10             	add    $0x10,%esp
  
  return argv;
c002076f:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0020772:	c9                   	leave  
c0020773:	c3                   	ret    

c0020774 <run_task>:

/* Runs the task specified in ARGV[1]. */
static void
run_task (char **argv)
{
c0020774:	55                   	push   %ebp
c0020775:	89 e5                	mov    %esp,%ebp
c0020777:	83 ec 18             	sub    $0x18,%esp
  const char *task = argv[1];
c002077a:	8b 45 08             	mov    0x8(%ebp),%eax
c002077d:	8b 40 04             	mov    0x4(%eax),%eax
c0020780:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  printf ("Executing '%s':\n", task);
c0020783:	83 ec 08             	sub    $0x8,%esp
c0020786:	ff 75 f4             	pushl  -0xc(%ebp)
c0020789:	68 5e ec 02 c0       	push   $0xc002ec5e
c002078e:	e8 55 70 00 00       	call   c00277e8 <printf>
c0020793:	83 c4 10             	add    $0x10,%esp
#ifdef USERPROG
  process_wait (process_execute (task));
#else
  run_test (task);
c0020796:	83 ec 0c             	sub    $0xc,%esp
c0020799:	ff 75 f4             	pushl  -0xc(%ebp)
c002079c:	e8 86 b7 00 00       	call   c002bf27 <run_test>
c00207a1:	83 c4 10             	add    $0x10,%esp
#endif
  printf ("Execution of '%s' complete.\n", task);
c00207a4:	83 ec 08             	sub    $0x8,%esp
c00207a7:	ff 75 f4             	pushl  -0xc(%ebp)
c00207aa:	68 6f ec 02 c0       	push   $0xc002ec6f
c00207af:	e8 34 70 00 00       	call   c00277e8 <printf>
c00207b4:	83 c4 10             	add    $0x10,%esp
}
c00207b7:	90                   	nop
c00207b8:	c9                   	leave  
c00207b9:	c3                   	ret    

c00207ba <run_actions>:

/* Executes all of the actions specified in ARGV[]
   up to the null pointer sentinel. */
static void
run_actions (char **argv) 
{
c00207ba:	55                   	push   %ebp
c00207bb:	89 e5                	mov    %esp,%ebp
c00207bd:	83 ec 18             	sub    $0x18,%esp
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c00207c0:	e9 ca 00 00 00       	jmp    c002088f <run_actions+0xd5>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c00207c5:	c7 45 f4 00 ef 02 c0 	movl   $0xc002ef00,-0xc(%ebp)
        if (a->name == NULL)
c00207cc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207cf:	8b 00                	mov    (%eax),%eax
c00207d1:	85 c0                	test   %eax,%eax
c00207d3:	75 22                	jne    c00207f7 <run_actions+0x3d>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
c00207d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00207d8:	8b 00                	mov    (%eax),%eax
c00207da:	83 ec 0c             	sub    $0xc,%esp
c00207dd:	50                   	push   %eax
c00207de:	68 8c ec 02 c0       	push   $0xc002ec8c
c00207e3:	68 18 ef 02 c0       	push   $0xc002ef18
c00207e8:	68 4e 01 00 00       	push   $0x14e
c00207ed:	68 ec eb 02 c0       	push   $0xc002ebec
c00207f2:	e8 24 94 00 00       	call   c0029c1b <debug_panic>
        else if (!strcmp (*argv, a->name))
c00207f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00207fa:	8b 10                	mov    (%eax),%edx
c00207fc:	8b 45 08             	mov    0x8(%ebp),%eax
c00207ff:	8b 00                	mov    (%eax),%eax
c0020801:	83 ec 08             	sub    $0x8,%esp
c0020804:	52                   	push   %edx
c0020805:	50                   	push   %eax
c0020806:	e8 06 84 00 00       	call   c0028c11 <strcmp>
c002080b:	83 c4 10             	add    $0x10,%esp
c002080e:	85 c0                	test   %eax,%eax
c0020810:	74 06                	je     c0020818 <run_actions+0x5e>
    {
      const struct action *a;
      int i;

      /* Find action name. */
      for (a = actions; ; a++)
c0020812:	83 45 f4 0c          	addl   $0xc,-0xc(%ebp)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020816:	eb b4                	jmp    c00207cc <run_actions+0x12>
      /* Find action name. */
      for (a = actions; ; a++)
        if (a->name == NULL)
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;
c0020818:	90                   	nop

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020819:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)
c0020820:	eb 45                	jmp    c0020867 <run_actions+0xad>
        if (argv[i] == NULL)
c0020822:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020825:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002082c:	8b 45 08             	mov    0x8(%ebp),%eax
c002082f:	01 d0                	add    %edx,%eax
c0020831:	8b 00                	mov    (%eax),%eax
c0020833:	85 c0                	test   %eax,%eax
c0020835:	75 2c                	jne    c0020863 <run_actions+0xa9>
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);
c0020837:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002083a:	8b 40 04             	mov    0x4(%eax),%eax
c002083d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0020840:	8b 45 08             	mov    0x8(%ebp),%eax
c0020843:	8b 00                	mov    (%eax),%eax
c0020845:	83 ec 08             	sub    $0x8,%esp
c0020848:	52                   	push   %edx
c0020849:	50                   	push   %eax
c002084a:	68 b4 ec 02 c0       	push   $0xc002ecb4
c002084f:	68 18 ef 02 c0       	push   $0xc002ef18
c0020854:	68 55 01 00 00       	push   $0x155
c0020859:	68 ec eb 02 c0       	push   $0xc002ebec
c002085e:	e8 b8 93 00 00       	call   c0029c1b <debug_panic>
          PANIC ("unknown action `%s' (use -h for help)", *argv);
        else if (!strcmp (*argv, a->name))
          break;

      /* Check for required arguments. */
      for (i = 1; i < a->argc; i++)
c0020863:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0020867:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002086a:	8b 40 04             	mov    0x4(%eax),%eax
c002086d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0020870:	7f b0                	jg     c0020822 <run_actions+0x68>
        if (argv[i] == NULL)
          PANIC ("action `%s' requires %d argument(s)", *argv, a->argc - 1);

      /* Invoke action and advance. */
      a->function (argv);
c0020872:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020875:	8b 40 08             	mov    0x8(%eax),%eax
c0020878:	83 ec 0c             	sub    $0xc,%esp
c002087b:	ff 75 08             	pushl  0x8(%ebp)
c002087e:	ff d0                	call   *%eax
c0020880:	83 c4 10             	add    $0x10,%esp
      argv += a->argc;
c0020883:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020886:	8b 40 04             	mov    0x4(%eax),%eax
c0020889:	c1 e0 02             	shl    $0x2,%eax
c002088c:	01 45 08             	add    %eax,0x8(%ebp)
      {"append", 2, fsutil_append},
#endif
      {NULL, 0, NULL},
    };

  while (*argv != NULL)
c002088f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020892:	8b 00                	mov    (%eax),%eax
c0020894:	85 c0                	test   %eax,%eax
c0020896:	0f 85 29 ff ff ff    	jne    c00207c5 <run_actions+0xb>
      /* Invoke action and advance. */
      a->function (argv);
      argv += a->argc;
    }
  
}
c002089c:	90                   	nop
c002089d:	c9                   	leave  
c002089e:	c3                   	ret    

c002089f <usage>:

/* Prints a kernel command line help message and powers off the
   machine. */
static void
usage (void)
{
c002089f:	55                   	push   %ebp
c00208a0:	89 e5                	mov    %esp,%ebp
c00208a2:	83 ec 08             	sub    $0x8,%esp
  printf ("\nCommand line syntax: [OPTION...] [ACTION...]\n"
c00208a5:	83 ec 0c             	sub    $0xc,%esp
c00208a8:	68 d8 ec 02 c0       	push   $0xc002ecd8
c00208ad:	e8 1c b5 00 00       	call   c002bdce <puts>
c00208b2:	83 c4 10             	add    $0x10,%esp
          "  -mlfqs             Use multi-level feedback queue scheduler.\n"
#ifdef USERPROG
          "  -ul=COUNT          Limit user memory to COUNT pages.\n"
#endif
          );
  shutdown_power_off ();
c00208b5:	e8 1f 6a 00 00       	call   c00272d9 <shutdown_power_off>

c00208ba <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c00208ba:	55                   	push   %ebp
c00208bb:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c00208bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00208c0:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00208c5:	5d                   	pop    %ebp
c00208c6:	c3                   	ret    

c00208c7 <priority_compare>:
static void schedule (void);
void thread_schedule_tail (struct thread *prev);
static tid_t allocate_tid (void);

//updated to always compare threads' donated_priority
static bool priority_compare(struct list_elem* a, struct list_elem* b, void* aux UNUSED) {
c00208c7:	55                   	push   %ebp
c00208c8:	89 e5                	mov    %esp,%ebp
c00208ca:	56                   	push   %esi
c00208cb:	53                   	push   %ebx
  return list_entry(a, struct thread, elem)->donated_priority > list_entry(b, struct thread, elem)->donated_priority;
c00208cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00208cf:	83 c0 04             	add    $0x4,%eax
c00208d2:	83 e8 2c             	sub    $0x2c,%eax
c00208d5:	8b 48 38             	mov    0x38(%eax),%ecx
c00208d8:	8b 58 3c             	mov    0x3c(%eax),%ebx
c00208db:	8b 45 0c             	mov    0xc(%ebp),%eax
c00208de:	83 c0 04             	add    $0x4,%eax
c00208e1:	83 e8 2c             	sub    $0x2c,%eax
c00208e4:	8b 50 3c             	mov    0x3c(%eax),%edx
c00208e7:	8b 40 38             	mov    0x38(%eax),%eax
c00208ea:	be 01 00 00 00       	mov    $0x1,%esi
c00208ef:	39 d3                	cmp    %edx,%ebx
c00208f1:	7f 0d                	jg     c0020900 <priority_compare+0x39>
c00208f3:	39 d3                	cmp    %edx,%ebx
c00208f5:	7c 04                	jl     c00208fb <priority_compare+0x34>
c00208f7:	39 c1                	cmp    %eax,%ecx
c00208f9:	77 05                	ja     c0020900 <priority_compare+0x39>
c00208fb:	be 00 00 00 00       	mov    $0x0,%esi
c0020900:	89 f0                	mov    %esi,%eax
}
c0020902:	5b                   	pop    %ebx
c0020903:	5e                   	pop    %esi
c0020904:	5d                   	pop    %ebp
c0020905:	c3                   	ret    

c0020906 <thread_init>:

   It is not safe to call thread_current() until this function
   finishes. */
void
thread_init (void) 
{
c0020906:	55                   	push   %ebp
c0020907:	89 e5                	mov    %esp,%ebp
c0020909:	53                   	push   %ebx
c002090a:	83 ec 04             	sub    $0x4,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c002090d:	e8 80 0b 00 00       	call   c0021492 <intr_get_level>
c0020912:	85 c0                	test   %eax,%eax
c0020914:	74 1e                	je     c0020934 <thread_init+0x2e>
c0020916:	83 ec 0c             	sub    $0xc,%esp
c0020919:	68 24 ef 02 c0       	push   $0xc002ef24
c002091e:	68 42 ef 02 c0       	push   $0xc002ef42
c0020923:	68 e4 f0 02 c0       	push   $0xc002f0e4
c0020928:	6a 63                	push   $0x63
c002092a:	68 59 ef 02 c0       	push   $0xc002ef59
c002092f:	e8 e7 92 00 00       	call   c0029c1b <debug_panic>

  lock_init (&tid_lock);
c0020934:	83 ec 0c             	sub    $0xc,%esp
c0020937:	68 60 83 03 c0       	push   $0xc0038360
c002093c:	e8 55 23 00 00       	call   c0022c96 <lock_init>
c0020941:	83 c4 10             	add    $0x10,%esp
  list_init (&ready_list);
c0020944:	83 ec 0c             	sub    $0xc,%esp
c0020947:	68 20 83 03 c0       	push   $0xc0038320
c002094c:	e8 3d 95 00 00       	call   c0029e8e <list_init>
c0020951:	83 c4 10             	add    $0x10,%esp
  list_init (&all_list);
c0020954:	83 ec 0c             	sub    $0xc,%esp
c0020957:	68 30 83 03 c0       	push   $0xc0038330
c002095c:	e8 2d 95 00 00       	call   c0029e8e <list_init>
c0020961:	83 c4 10             	add    $0x10,%esp

  /* Set up a thread structure for the running thread. */
  initial_thread = running_thread ();
c0020964:	e8 df 06 00 00       	call   c0021048 <running_thread>
c0020969:	a3 44 83 03 c0       	mov    %eax,0xc0038344
  init_thread (initial_thread, "main", PRI_DEFAULT);
c002096e:	a1 44 83 03 c0       	mov    0xc0038344,%eax
c0020973:	83 ec 04             	sub    $0x4,%esp
c0020976:	6a 1f                	push   $0x1f
c0020978:	68 70 ef 02 c0       	push   $0xc002ef70
c002097d:	50                   	push   %eax
c002097e:	e8 04 07 00 00       	call   c0021087 <init_thread>
c0020983:	83 c4 10             	add    $0x10,%esp
  initial_thread->status = THREAD_RUNNING;
c0020986:	a1 44 83 03 c0       	mov    0xc0038344,%eax
c002098b:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  initial_thread->tid = allocate_tid ();
c0020992:	8b 1d 44 83 03 c0    	mov    0xc0038344,%ebx
c0020998:	e8 70 0a 00 00       	call   c002140d <allocate_tid>
c002099d:	89 03                	mov    %eax,(%ebx)
}
c002099f:	90                   	nop
c00209a0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00209a3:	c9                   	leave  
c00209a4:	c3                   	ret    

c00209a5 <thread_start>:

/* Starts preemptive thread scheduling by enabling interrupts.
   Also creates the idle thread. */
void
thread_start (void) 
{
c00209a5:	55                   	push   %ebp
c00209a6:	89 e5                	mov    %esp,%ebp
c00209a8:	83 ec 28             	sub    $0x28,%esp
  /* Create the idle thread. */
  struct semaphore idle_started;
  sema_init (&idle_started, 0);
c00209ab:	83 ec 08             	sub    $0x8,%esp
c00209ae:	6a 00                	push   $0x0
c00209b0:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00209b3:	50                   	push   %eax
c00209b4:	e8 d8 1f 00 00       	call   c0022991 <sema_init>
c00209b9:	83 c4 10             	add    $0x10,%esp
  thread_create ("idle", PRI_MIN, idle, &idle_started);
c00209bc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00209bf:	50                   	push   %eax
c00209c0:	68 d1 0f 02 c0       	push   $0xc0020fd1
c00209c5:	6a 00                	push   $0x0
c00209c7:	68 75 ef 02 c0       	push   $0xc002ef75
c00209cc:	e8 d6 00 00 00       	call   c0020aa7 <thread_create>
c00209d1:	83 c4 10             	add    $0x10,%esp

  /* Start preemptive thread scheduling. */
  intr_enable ();
c00209d4:	e8 f0 0a 00 00       	call   c00214c9 <intr_enable>

  /* Wait for the idle thread to initialize idle_thread. */
  sema_down (&idle_started);
c00209d9:	83 ec 0c             	sub    $0xc,%esp
c00209dc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
c00209df:	50                   	push   %eax
c00209e0:	e8 f3 1f 00 00       	call   c00229d8 <sema_down>
c00209e5:	83 c4 10             	add    $0x10,%esp
}
c00209e8:	90                   	nop
c00209e9:	c9                   	leave  
c00209ea:	c3                   	ret    

c00209eb <thread_tick>:

/* Called by the timer interrupt handler at each timer tick.
   Thus, this function runs in an external interrupt context. */
void
thread_tick (void) 
{
c00209eb:	55                   	push   %ebp
c00209ec:	89 e5                	mov    %esp,%ebp
c00209ee:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current ();
c00209f1:	e8 f6 02 00 00       	call   c0020cec <thread_current>
c00209f6:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Update statistics. */
  if (t == idle_thread)
c00209f9:	a1 40 83 03 c0       	mov    0xc0038340,%eax
c00209fe:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020a01:	75 1e                	jne    c0020a21 <thread_tick+0x36>
    idle_ticks++;
c0020a03:	a1 80 83 03 c0       	mov    0xc0038380,%eax
c0020a08:	8b 15 84 83 03 c0    	mov    0xc0038384,%edx
c0020a0e:	83 c0 01             	add    $0x1,%eax
c0020a11:	83 d2 00             	adc    $0x0,%edx
c0020a14:	a3 80 83 03 c0       	mov    %eax,0xc0038380
c0020a19:	89 15 84 83 03 c0    	mov    %edx,0xc0038384
c0020a1f:	eb 1c                	jmp    c0020a3d <thread_tick+0x52>
#ifdef USERPROG
  else if (t->pagedir != NULL)
    user_ticks++;
#endif
  else
    kernel_ticks++;
c0020a21:	a1 88 83 03 c0       	mov    0xc0038388,%eax
c0020a26:	8b 15 8c 83 03 c0    	mov    0xc003838c,%edx
c0020a2c:	83 c0 01             	add    $0x1,%eax
c0020a2f:	83 d2 00             	adc    $0x0,%edx
c0020a32:	a3 88 83 03 c0       	mov    %eax,0xc0038388
c0020a37:	89 15 8c 83 03 c0    	mov    %edx,0xc003838c

  /* Enforce preemption. */
  if (++thread_ticks >= TIME_SLICE)
c0020a3d:	a1 98 83 03 c0       	mov    0xc0038398,%eax
c0020a42:	83 c0 01             	add    $0x1,%eax
c0020a45:	a3 98 83 03 c0       	mov    %eax,0xc0038398
c0020a4a:	a1 98 83 03 c0       	mov    0xc0038398,%eax
c0020a4f:	83 f8 03             	cmp    $0x3,%eax
c0020a52:	76 05                	jbe    c0020a59 <thread_tick+0x6e>
    intr_yield_on_return ();
c0020a54:	e8 89 0d 00 00       	call   c00217e2 <intr_yield_on_return>
}
c0020a59:	90                   	nop
c0020a5a:	c9                   	leave  
c0020a5b:	c3                   	ret    

c0020a5c <thread_print_stats>:

/* Prints thread statistics. */
void
thread_print_stats (void) 
{
c0020a5c:	55                   	push   %ebp
c0020a5d:	89 e5                	mov    %esp,%ebp
c0020a5f:	57                   	push   %edi
c0020a60:	56                   	push   %esi
c0020a61:	53                   	push   %ebx
c0020a62:	83 ec 0c             	sub    $0xc,%esp
  printf ("Thread: %lld idle ticks, %lld kernel ticks, %lld user ticks\n",
c0020a65:	8b 35 90 83 03 c0    	mov    0xc0038390,%esi
c0020a6b:	8b 3d 94 83 03 c0    	mov    0xc0038394,%edi
c0020a71:	8b 0d 88 83 03 c0    	mov    0xc0038388,%ecx
c0020a77:	8b 1d 8c 83 03 c0    	mov    0xc003838c,%ebx
c0020a7d:	a1 80 83 03 c0       	mov    0xc0038380,%eax
c0020a82:	8b 15 84 83 03 c0    	mov    0xc0038384,%edx
c0020a88:	83 ec 04             	sub    $0x4,%esp
c0020a8b:	57                   	push   %edi
c0020a8c:	56                   	push   %esi
c0020a8d:	53                   	push   %ebx
c0020a8e:	51                   	push   %ecx
c0020a8f:	52                   	push   %edx
c0020a90:	50                   	push   %eax
c0020a91:	68 7c ef 02 c0       	push   $0xc002ef7c
c0020a96:	e8 4d 6d 00 00       	call   c00277e8 <printf>
c0020a9b:	83 c4 20             	add    $0x20,%esp
          idle_ticks, kernel_ticks, user_ticks);
}
c0020a9e:	90                   	nop
c0020a9f:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0020aa2:	5b                   	pop    %ebx
c0020aa3:	5e                   	pop    %esi
c0020aa4:	5f                   	pop    %edi
c0020aa5:	5d                   	pop    %ebp
c0020aa6:	c3                   	ret    

c0020aa7 <thread_create>:
   PRIORITY, but no actual priority scheduling is implemented.
   Priority scheduling is the goal of Problem 1-3. */
tid_t
thread_create (const char *name, int priority,
               thread_func *function, void *aux) 
{
c0020aa7:	55                   	push   %ebp
c0020aa8:	89 e5                	mov    %esp,%ebp
c0020aaa:	56                   	push   %esi
c0020aab:	53                   	push   %ebx
c0020aac:	83 ec 20             	sub    $0x20,%esp
  struct kernel_thread_frame *kf;
  struct switch_entry_frame *ef;
  struct switch_threads_frame *sf;
  tid_t tid;

  ASSERT (function != NULL);
c0020aaf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0020ab3:	75 21                	jne    c0020ad6 <thread_create+0x2f>
c0020ab5:	83 ec 0c             	sub    $0xc,%esp
c0020ab8:	68 b9 ef 02 c0       	push   $0xc002efb9
c0020abd:	68 42 ef 02 c0       	push   $0xc002ef42
c0020ac2:	68 f0 f0 02 c0       	push   $0xc002f0f0
c0020ac7:	68 b8 00 00 00       	push   $0xb8
c0020acc:	68 59 ef 02 c0       	push   $0xc002ef59
c0020ad1:	e8 45 91 00 00       	call   c0029c1b <debug_panic>

  /* Allocate thread. */
  t = palloc_get_page (PAL_ZERO);
c0020ad6:	83 ec 0c             	sub    $0xc,%esp
c0020ad9:	6a 02                	push   $0x2
c0020adb:	e8 34 2b 00 00       	call   c0023614 <palloc_get_page>
c0020ae0:	83 c4 10             	add    $0x10,%esp
c0020ae3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (t == NULL)
c0020ae6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0020aea:	75 0a                	jne    c0020af6 <thread_create+0x4f>
    return TID_ERROR;
c0020aec:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0020af1:	e9 cf 00 00 00       	jmp    c0020bc5 <thread_create+0x11e>

  /* Initialize thread. */
  init_thread (t, name, priority);
c0020af6:	83 ec 04             	sub    $0x4,%esp
c0020af9:	ff 75 0c             	pushl  0xc(%ebp)
c0020afc:	ff 75 08             	pushl  0x8(%ebp)
c0020aff:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b02:	e8 80 05 00 00       	call   c0021087 <init_thread>
c0020b07:	83 c4 10             	add    $0x10,%esp
  tid = t->tid = allocate_tid ();
c0020b0a:	e8 fe 08 00 00       	call   c002140d <allocate_tid>
c0020b0f:	89 c2                	mov    %eax,%edx
c0020b11:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b14:	89 10                	mov    %edx,(%eax)
c0020b16:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020b19:	8b 00                	mov    (%eax),%eax
c0020b1b:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Stack frame for kernel_thread(). */
  kf = alloc_frame (t, sizeof *kf);
c0020b1e:	83 ec 08             	sub    $0x8,%esp
c0020b21:	6a 0c                	push   $0xc
c0020b23:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b26:	e8 a3 06 00 00       	call   c00211ce <alloc_frame>
c0020b2b:	83 c4 10             	add    $0x10,%esp
c0020b2e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  kf->eip = NULL;
c0020b31:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020b34:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  kf->function = function;
c0020b3a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020b3d:	8b 55 10             	mov    0x10(%ebp),%edx
c0020b40:	89 50 04             	mov    %edx,0x4(%eax)
  kf->aux = aux;
c0020b43:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0020b46:	8b 55 14             	mov    0x14(%ebp),%edx
c0020b49:	89 50 08             	mov    %edx,0x8(%eax)

  /* Stack frame for switch_entry(). */
  ef = alloc_frame (t, sizeof *ef);
c0020b4c:	83 ec 08             	sub    $0x8,%esp
c0020b4f:	6a 04                	push   $0x4
c0020b51:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b54:	e8 75 06 00 00       	call   c00211ce <alloc_frame>
c0020b59:	83 c4 10             	add    $0x10,%esp
c0020b5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
  ef->eip = (void (*) (void)) kernel_thread;
c0020b5f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0020b62:	c7 00 03 10 02 c0    	movl   $0xc0021003,(%eax)

  /* Stack frame for switch_threads(). */
  sf = alloc_frame (t, sizeof *sf);
c0020b68:	83 ec 08             	sub    $0x8,%esp
c0020b6b:	6a 1c                	push   $0x1c
c0020b6d:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b70:	e8 59 06 00 00       	call   c00211ce <alloc_frame>
c0020b75:	83 c4 10             	add    $0x10,%esp
c0020b78:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  sf->eip = switch_entry;
c0020b7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b7e:	c7 40 10 66 14 02 c0 	movl   $0xc0021466,0x10(%eax)
  sf->ebp = 0;
c0020b85:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0020b88:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

  /* Add to run queue. */
  thread_unblock (t);
c0020b8f:	83 ec 0c             	sub    $0xc,%esp
c0020b92:	ff 75 f4             	pushl  -0xc(%ebp)
c0020b95:	e8 a3 00 00 00       	call   c0020c3d <thread_unblock>
c0020b9a:	83 c4 10             	add    $0x10,%esp

  //if new thread has higher priority than current thread then yield it
  if (t->donated_priority > thread_current()->donated_priority) {
c0020b9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020ba0:	8b 58 38             	mov    0x38(%eax),%ebx
c0020ba3:	8b 70 3c             	mov    0x3c(%eax),%esi
c0020ba6:	e8 41 01 00 00       	call   c0020cec <thread_current>
c0020bab:	8b 50 3c             	mov    0x3c(%eax),%edx
c0020bae:	8b 40 38             	mov    0x38(%eax),%eax
c0020bb1:	39 d6                	cmp    %edx,%esi
c0020bb3:	7c 0d                	jl     c0020bc2 <thread_create+0x11b>
c0020bb5:	39 d6                	cmp    %edx,%esi
c0020bb7:	7f 04                	jg     c0020bbd <thread_create+0x116>
c0020bb9:	39 c3                	cmp    %eax,%ebx
c0020bbb:	76 05                	jbe    c0020bc2 <thread_create+0x11b>
  	thread_yield();
c0020bbd:	e8 20 02 00 00       	call   c0020de2 <thread_yield>
  }

  return tid;
c0020bc2:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0020bc5:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0020bc8:	5b                   	pop    %ebx
c0020bc9:	5e                   	pop    %esi
c0020bca:	5d                   	pop    %ebp
c0020bcb:	c3                   	ret    

c0020bcc <thread_block>:
   This function must be called with interrupts turned off.  It
   is usually a better idea to use one of the synchronization
   primitives in synch.h. */
void
thread_block (void) 
{
c0020bcc:	55                   	push   %ebp
c0020bcd:	89 e5                	mov    %esp,%ebp
c0020bcf:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020bd2:	e8 ff 0b 00 00       	call   c00217d6 <intr_context>
c0020bd7:	83 f0 01             	xor    $0x1,%eax
c0020bda:	84 c0                	test   %al,%al
c0020bdc:	75 21                	jne    c0020bff <thread_block+0x33>
c0020bde:	83 ec 0c             	sub    $0xc,%esp
c0020be1:	68 ca ef 02 c0       	push   $0xc002efca
c0020be6:	68 42 ef 02 c0       	push   $0xc002ef42
c0020beb:	68 00 f1 02 c0       	push   $0xc002f100
c0020bf0:	68 e6 00 00 00       	push   $0xe6
c0020bf5:	68 59 ef 02 c0       	push   $0xc002ef59
c0020bfa:	e8 1c 90 00 00       	call   c0029c1b <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0020bff:	e8 8e 08 00 00       	call   c0021492 <intr_get_level>
c0020c04:	85 c0                	test   %eax,%eax
c0020c06:	74 21                	je     c0020c29 <thread_block+0x5d>
c0020c08:	83 ec 0c             	sub    $0xc,%esp
c0020c0b:	68 24 ef 02 c0       	push   $0xc002ef24
c0020c10:	68 42 ef 02 c0       	push   $0xc002ef42
c0020c15:	68 00 f1 02 c0       	push   $0xc002f100
c0020c1a:	68 e7 00 00 00       	push   $0xe7
c0020c1f:	68 59 ef 02 c0       	push   $0xc002ef59
c0020c24:	e8 f2 8f 00 00       	call   c0029c1b <debug_panic>

  thread_current ()->status = THREAD_BLOCKED;
c0020c29:	e8 be 00 00 00       	call   c0020cec <thread_current>
c0020c2e:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  schedule ();
c0020c35:	e8 01 07 00 00       	call   c002133b <schedule>
}
c0020c3a:	90                   	nop
c0020c3b:	c9                   	leave  
c0020c3c:	c3                   	ret    

c0020c3d <thread_unblock>:
   be important: if the caller had disabled interrupts itself,
   it may expect that it can atomically unblock a thread and
   update other data. */
void
thread_unblock (struct thread *t) 
{
c0020c3d:	55                   	push   %ebp
c0020c3e:	89 e5                	mov    %esp,%ebp
c0020c40:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (is_thread (t));
c0020c43:	83 ec 0c             	sub    $0xc,%esp
c0020c46:	ff 75 08             	pushl  0x8(%ebp)
c0020c49:	e8 12 04 00 00       	call   c0021060 <is_thread>
c0020c4e:	83 c4 10             	add    $0x10,%esp
c0020c51:	84 c0                	test   %al,%al
c0020c53:	75 21                	jne    c0020c76 <thread_unblock+0x39>
c0020c55:	83 ec 0c             	sub    $0xc,%esp
c0020c58:	68 db ef 02 c0       	push   $0xc002efdb
c0020c5d:	68 42 ef 02 c0       	push   $0xc002ef42
c0020c62:	68 10 f1 02 c0       	push   $0xc002f110
c0020c67:	68 fa 00 00 00       	push   $0xfa
c0020c6c:	68 59 ef 02 c0       	push   $0xc002ef59
c0020c71:	e8 a5 8f 00 00       	call   c0029c1b <debug_panic>

  old_level = intr_disable ();
c0020c76:	e8 8c 08 00 00       	call   c0021507 <intr_disable>
c0020c7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (t->status == THREAD_BLOCKED);
c0020c7e:	8b 45 08             	mov    0x8(%ebp),%eax
c0020c81:	8b 40 04             	mov    0x4(%eax),%eax
c0020c84:	83 f8 02             	cmp    $0x2,%eax
c0020c87:	74 21                	je     c0020caa <thread_unblock+0x6d>
c0020c89:	83 ec 0c             	sub    $0xc,%esp
c0020c8c:	68 e9 ef 02 c0       	push   $0xc002efe9
c0020c91:	68 42 ef 02 c0       	push   $0xc002ef42
c0020c96:	68 10 f1 02 c0       	push   $0xc002f110
c0020c9b:	68 fd 00 00 00       	push   $0xfd
c0020ca0:	68 59 ef 02 c0       	push   $0xc002ef59
c0020ca5:	e8 71 8f 00 00       	call   c0029c1b <debug_panic>
  list_push_back (&ready_list, &t->elem);
c0020caa:	8b 45 08             	mov    0x8(%ebp),%eax
c0020cad:	83 c0 28             	add    $0x28,%eax
c0020cb0:	83 ec 08             	sub    $0x8,%esp
c0020cb3:	50                   	push   %eax
c0020cb4:	68 20 83 03 c0       	push   $0xc0038320
c0020cb9:	e8 b0 95 00 00       	call   c002a26e <list_push_back>
c0020cbe:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_READY;
c0020cc1:	8b 45 08             	mov    0x8(%ebp),%eax
c0020cc4:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  intr_set_level (old_level);
c0020ccb:	83 ec 0c             	sub    $0xc,%esp
c0020cce:	ff 75 f4             	pushl  -0xc(%ebp)
c0020cd1:	e8 d9 07 00 00       	call   c00214af <intr_set_level>
c0020cd6:	83 c4 10             	add    $0x10,%esp
}
c0020cd9:	90                   	nop
c0020cda:	c9                   	leave  
c0020cdb:	c3                   	ret    

c0020cdc <thread_name>:

/* Returns the name of the running thread. */
const char *
thread_name (void) 
{
c0020cdc:	55                   	push   %ebp
c0020cdd:	89 e5                	mov    %esp,%ebp
c0020cdf:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->name;
c0020ce2:	e8 05 00 00 00       	call   c0020cec <thread_current>
c0020ce7:	83 c0 08             	add    $0x8,%eax
}
c0020cea:	c9                   	leave  
c0020ceb:	c3                   	ret    

c0020cec <thread_current>:
/* Returns the running thread.
   This is running_thread() plus a couple of sanity checks.
   See the big comment at the top of thread.h for details. */
struct thread *
thread_current (void) 
{
c0020cec:	55                   	push   %ebp
c0020ced:	89 e5                	mov    %esp,%ebp
c0020cef:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = running_thread ();
c0020cf2:	e8 51 03 00 00       	call   c0021048 <running_thread>
c0020cf7:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Make sure T is really a thread.
     If either of these assertions fire, then your thread may
     have overflowed its stack.  Each thread has less than 4 kB
     of stack, so a few big automatic arrays or moderate
     recursion can cause stack overflow. */
  ASSERT (is_thread (t));
c0020cfa:	83 ec 0c             	sub    $0xc,%esp
c0020cfd:	ff 75 f4             	pushl  -0xc(%ebp)
c0020d00:	e8 5b 03 00 00       	call   c0021060 <is_thread>
c0020d05:	83 c4 10             	add    $0x10,%esp
c0020d08:	84 c0                	test   %al,%al
c0020d0a:	75 21                	jne    c0020d2d <thread_current+0x41>
c0020d0c:	83 ec 0c             	sub    $0xc,%esp
c0020d0f:	68 db ef 02 c0       	push   $0xc002efdb
c0020d14:	68 42 ef 02 c0       	push   $0xc002ef42
c0020d19:	68 20 f1 02 c0       	push   $0xc002f120
c0020d1e:	68 17 01 00 00       	push   $0x117
c0020d23:	68 59 ef 02 c0       	push   $0xc002ef59
c0020d28:	e8 ee 8e 00 00       	call   c0029c1b <debug_panic>
  ASSERT (t->status == THREAD_RUNNING);
c0020d2d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020d30:	8b 40 04             	mov    0x4(%eax),%eax
c0020d33:	85 c0                	test   %eax,%eax
c0020d35:	74 21                	je     c0020d58 <thread_current+0x6c>
c0020d37:	83 ec 0c             	sub    $0xc,%esp
c0020d3a:	68 05 f0 02 c0       	push   $0xc002f005
c0020d3f:	68 42 ef 02 c0       	push   $0xc002ef42
c0020d44:	68 20 f1 02 c0       	push   $0xc002f120
c0020d49:	68 18 01 00 00       	push   $0x118
c0020d4e:	68 59 ef 02 c0       	push   $0xc002ef59
c0020d53:	e8 c3 8e 00 00       	call   c0029c1b <debug_panic>

  return t;
c0020d58:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0020d5b:	c9                   	leave  
c0020d5c:	c3                   	ret    

c0020d5d <thread_tid>:

/* Returns the running thread's tid. */
tid_t
thread_tid (void) 
{
c0020d5d:	55                   	push   %ebp
c0020d5e:	89 e5                	mov    %esp,%ebp
c0020d60:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->tid;
c0020d63:	e8 84 ff ff ff       	call   c0020cec <thread_current>
c0020d68:	8b 00                	mov    (%eax),%eax
}
c0020d6a:	c9                   	leave  
c0020d6b:	c3                   	ret    

c0020d6c <thread_exit>:

/* Deschedules the current thread and destroys it.  Never
   returns to the caller. */
void
thread_exit (void) 
{
c0020d6c:	55                   	push   %ebp
c0020d6d:	89 e5                	mov    %esp,%ebp
c0020d6f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0020d72:	e8 5f 0a 00 00       	call   c00217d6 <intr_context>
c0020d77:	83 f0 01             	xor    $0x1,%eax
c0020d7a:	84 c0                	test   %al,%al
c0020d7c:	75 21                	jne    c0020d9f <thread_exit+0x33>
c0020d7e:	83 ec 0c             	sub    $0xc,%esp
c0020d81:	68 ca ef 02 c0       	push   $0xc002efca
c0020d86:	68 42 ef 02 c0       	push   $0xc002ef42
c0020d8b:	68 30 f1 02 c0       	push   $0xc002f130
c0020d90:	68 29 01 00 00       	push   $0x129
c0020d95:	68 59 ef 02 c0       	push   $0xc002ef59
c0020d9a:	e8 7c 8e 00 00       	call   c0029c1b <debug_panic>
#endif

  /* Remove thread from all threads list, set our status to dying,
     and schedule another process.  That process will destroy us
     when it calls thread_schedule_tail(). */
  intr_disable ();
c0020d9f:	e8 63 07 00 00       	call   c0021507 <intr_disable>
  list_remove (&thread_current()->allelem);
c0020da4:	e8 43 ff ff ff       	call   c0020cec <thread_current>
c0020da9:	83 c0 20             	add    $0x20,%eax
c0020dac:	83 ec 0c             	sub    $0xc,%esp
c0020daf:	50                   	push   %eax
c0020db0:	e8 df 94 00 00       	call   c002a294 <list_remove>
c0020db5:	83 c4 10             	add    $0x10,%esp
  thread_current ()->status = THREAD_DYING;
c0020db8:	e8 2f ff ff ff       	call   c0020cec <thread_current>
c0020dbd:	c7 40 04 03 00 00 00 	movl   $0x3,0x4(%eax)
  schedule ();
c0020dc4:	e8 72 05 00 00       	call   c002133b <schedule>
  NOT_REACHED ();
c0020dc9:	68 24 f0 02 c0       	push   $0xc002f024
c0020dce:	68 30 f1 02 c0       	push   $0xc002f130
c0020dd3:	68 36 01 00 00       	push   $0x136
c0020dd8:	68 59 ef 02 c0       	push   $0xc002ef59
c0020ddd:	e8 39 8e 00 00       	call   c0029c1b <debug_panic>

c0020de2 <thread_yield>:

/* Yields the CPU.  The current thread is not put to sleep and
   may be scheduled again immediately at the scheduler's whim. */
void
thread_yield (void) 
{
c0020de2:	55                   	push   %ebp
c0020de3:	89 e5                	mov    %esp,%ebp
c0020de5:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = thread_current ();
c0020de8:	e8 ff fe ff ff       	call   c0020cec <thread_current>
c0020ded:	89 45 f4             	mov    %eax,-0xc(%ebp)
  enum intr_level old_level;
  
  ASSERT (!intr_context ());
c0020df0:	e8 e1 09 00 00       	call   c00217d6 <intr_context>
c0020df5:	83 f0 01             	xor    $0x1,%eax
c0020df8:	84 c0                	test   %al,%al
c0020dfa:	75 21                	jne    c0020e1d <thread_yield+0x3b>
c0020dfc:	83 ec 0c             	sub    $0xc,%esp
c0020dff:	68 ca ef 02 c0       	push   $0xc002efca
c0020e04:	68 42 ef 02 c0       	push   $0xc002ef42
c0020e09:	68 3c f1 02 c0       	push   $0xc002f13c
c0020e0e:	68 41 01 00 00       	push   $0x141
c0020e13:	68 59 ef 02 c0       	push   $0xc002ef59
c0020e18:	e8 fe 8d 00 00       	call   c0029c1b <debug_panic>

  old_level = intr_disable ();
c0020e1d:	e8 e5 06 00 00       	call   c0021507 <intr_disable>
c0020e22:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (cur != idle_thread) 
c0020e25:	a1 40 83 03 c0       	mov    0xc0038340,%eax
c0020e2a:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0020e2d:	74 17                	je     c0020e46 <thread_yield+0x64>
    list_push_back (&ready_list, &cur->elem);
c0020e2f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e32:	83 c0 28             	add    $0x28,%eax
c0020e35:	83 ec 08             	sub    $0x8,%esp
c0020e38:	50                   	push   %eax
c0020e39:	68 20 83 03 c0       	push   $0xc0038320
c0020e3e:	e8 2b 94 00 00       	call   c002a26e <list_push_back>
c0020e43:	83 c4 10             	add    $0x10,%esp
  cur->status = THREAD_READY;
c0020e46:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020e49:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
  schedule ();
c0020e50:	e8 e6 04 00 00       	call   c002133b <schedule>
  intr_set_level (old_level);
c0020e55:	83 ec 0c             	sub    $0xc,%esp
c0020e58:	ff 75 f0             	pushl  -0x10(%ebp)
c0020e5b:	e8 4f 06 00 00       	call   c00214af <intr_set_level>
c0020e60:	83 c4 10             	add    $0x10,%esp
}
c0020e63:	90                   	nop
c0020e64:	c9                   	leave  
c0020e65:	c3                   	ret    

c0020e66 <thread_foreach>:

/* Invoke function 'func' on all threads, passing along 'aux'.
   This function must be called with interrupts off. */
void
thread_foreach (thread_action_func *func, void *aux)
{
c0020e66:	55                   	push   %ebp
c0020e67:	89 e5                	mov    %esp,%ebp
c0020e69:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);
c0020e6c:	e8 21 06 00 00       	call   c0021492 <intr_get_level>
c0020e71:	85 c0                	test   %eax,%eax
c0020e73:	74 21                	je     c0020e96 <thread_foreach+0x30>
c0020e75:	83 ec 0c             	sub    $0xc,%esp
c0020e78:	68 24 ef 02 c0       	push   $0xc002ef24
c0020e7d:	68 42 ef 02 c0       	push   $0xc002ef42
c0020e82:	68 4c f1 02 c0       	push   $0xc002f14c
c0020e87:	68 52 01 00 00       	push   $0x152
c0020e8c:	68 59 ef 02 c0       	push   $0xc002ef59
c0020e91:	e8 85 8d 00 00       	call   c0029c1b <debug_panic>

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020e96:	83 ec 0c             	sub    $0xc,%esp
c0020e99:	68 30 83 03 c0       	push   $0xc0038330
c0020e9e:	e8 40 90 00 00       	call   c0029ee3 <list_begin>
c0020ea3:	83 c4 10             	add    $0x10,%esp
c0020ea6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0020ea9:	eb 2e                	jmp    c0020ed9 <thread_foreach+0x73>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
c0020eab:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0020eae:	83 c0 04             	add    $0x4,%eax
c0020eb1:	83 e8 24             	sub    $0x24,%eax
c0020eb4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      func (t, aux);
c0020eb7:	83 ec 08             	sub    $0x8,%esp
c0020eba:	ff 75 0c             	pushl  0xc(%ebp)
c0020ebd:	ff 75 f0             	pushl  -0x10(%ebp)
c0020ec0:	8b 45 08             	mov    0x8(%ebp),%eax
c0020ec3:	ff d0                	call   *%eax
c0020ec5:	83 c4 10             	add    $0x10,%esp
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
       e = list_next (e))
c0020ec8:	83 ec 0c             	sub    $0xc,%esp
c0020ecb:	ff 75 f4             	pushl  -0xc(%ebp)
c0020ece:	e8 42 90 00 00       	call   c0029f15 <list_next>
c0020ed3:	83 c4 10             	add    $0x10,%esp
c0020ed6:	89 45 f4             	mov    %eax,-0xc(%ebp)
{
  struct list_elem *e;

  ASSERT (intr_get_level () == INTR_OFF);

  for (e = list_begin (&all_list); e != list_end (&all_list);
c0020ed9:	83 ec 0c             	sub    $0xc,%esp
c0020edc:	68 30 83 03 c0       	push   $0xc0038330
c0020ee1:	e8 79 90 00 00       	call   c0029f5f <list_end>
c0020ee6:	83 c4 10             	add    $0x10,%esp
c0020ee9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0020eec:	75 bd                	jne    c0020eab <thread_foreach+0x45>
       e = list_next (e))
    {
      struct thread *t = list_entry (e, struct thread, allelem);
      func (t, aux);
    }
}
c0020eee:	90                   	nop
c0020eef:	c9                   	leave  
c0020ef0:	c3                   	ret    

c0020ef1 <thread_set_priority>:

/* Sets the current thread's priority to NEW_PRIORITY. */
void
thread_set_priority (int new_priority) 
{
c0020ef1:	55                   	push   %ebp
c0020ef2:	89 e5                	mov    %esp,%ebp
c0020ef4:	56                   	push   %esi
c0020ef5:	53                   	push   %ebx
c0020ef6:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level;
  old_level = intr_disable ();
c0020ef9:	e8 09 06 00 00       	call   c0021507 <intr_disable>
c0020efe:	89 45 f4             	mov    %eax,-0xc(%ebp)

  //stores old donated_priority for later comparison
  int oldPriority = thread_current()->donated_priority;
c0020f01:	e8 e6 fd ff ff       	call   c0020cec <thread_current>
c0020f06:	8b 50 3c             	mov    0x3c(%eax),%edx
c0020f09:	8b 40 38             	mov    0x38(%eax),%eax
c0020f0c:	89 45 f0             	mov    %eax,-0x10(%ebp)

  //only updates donated_priority if the new priority is greater or the thread has no donation
  if (!thread_current()->has_donation ||
c0020f0f:	e8 d8 fd ff ff       	call   c0020cec <thread_current>
c0020f14:	0f b6 40 40          	movzbl 0x40(%eax),%eax
c0020f18:	83 f0 01             	xor    $0x1,%eax
c0020f1b:	84 c0                	test   %al,%al
c0020f1d:	75 21                	jne    c0020f40 <thread_set_priority+0x4f>
      new_priority > thread_current()->donated_priority) {
c0020f1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f22:	89 c3                	mov    %eax,%ebx
c0020f24:	89 c6                	mov    %eax,%esi
c0020f26:	c1 fe 1f             	sar    $0x1f,%esi
c0020f29:	e8 be fd ff ff       	call   c0020cec <thread_current>
c0020f2e:	8b 50 3c             	mov    0x3c(%eax),%edx
c0020f31:	8b 40 38             	mov    0x38(%eax),%eax

  //stores old donated_priority for later comparison
  int oldPriority = thread_current()->donated_priority;

  //only updates donated_priority if the new priority is greater or the thread has no donation
  if (!thread_current()->has_donation ||
c0020f34:	39 d6                	cmp    %edx,%esi
c0020f36:	7c 19                	jl     c0020f51 <thread_set_priority+0x60>
c0020f38:	39 d6                	cmp    %edx,%esi
c0020f3a:	7f 04                	jg     c0020f40 <thread_set_priority+0x4f>
c0020f3c:	39 c3                	cmp    %eax,%ebx
c0020f3e:	76 11                	jbe    c0020f51 <thread_set_priority+0x60>
      new_priority > thread_current()->donated_priority) {
    thread_current()->donated_priority = new_priority;
c0020f40:	e8 a7 fd ff ff       	call   c0020cec <thread_current>
c0020f45:	89 c1                	mov    %eax,%ecx
c0020f47:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f4a:	99                   	cltd   
c0020f4b:	89 41 38             	mov    %eax,0x38(%ecx)
c0020f4e:	89 51 3c             	mov    %edx,0x3c(%ecx)
  }

  //update thread priority
  thread_current ()->priority = new_priority;
c0020f51:	e8 96 fd ff ff       	call   c0020cec <thread_current>
c0020f56:	89 c2                	mov    %eax,%edx
c0020f58:	8b 45 08             	mov    0x8(%ebp),%eax
c0020f5b:	89 42 1c             	mov    %eax,0x1c(%edx)

  //yield iff the thread has decreased in scheduling priority
  if (oldPriority>thread_current()->donated_priority) {
c0020f5e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0020f61:	89 c3                	mov    %eax,%ebx
c0020f63:	89 c6                	mov    %eax,%esi
c0020f65:	c1 fe 1f             	sar    $0x1f,%esi
c0020f68:	e8 7f fd ff ff       	call   c0020cec <thread_current>
c0020f6d:	8b 50 3c             	mov    0x3c(%eax),%edx
c0020f70:	8b 40 38             	mov    0x38(%eax),%eax
c0020f73:	39 d6                	cmp    %edx,%esi
c0020f75:	7c 0d                	jl     c0020f84 <thread_set_priority+0x93>
c0020f77:	39 d6                	cmp    %edx,%esi
c0020f79:	7f 04                	jg     c0020f7f <thread_set_priority+0x8e>
c0020f7b:	39 c3                	cmp    %eax,%ebx
c0020f7d:	76 05                	jbe    c0020f84 <thread_set_priority+0x93>
    thread_yield();
c0020f7f:	e8 5e fe ff ff       	call   c0020de2 <thread_yield>
  }

  intr_set_level (old_level);
c0020f84:	83 ec 0c             	sub    $0xc,%esp
c0020f87:	ff 75 f4             	pushl  -0xc(%ebp)
c0020f8a:	e8 20 05 00 00       	call   c00214af <intr_set_level>
c0020f8f:	83 c4 10             	add    $0x10,%esp
}
c0020f92:	90                   	nop
c0020f93:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0020f96:	5b                   	pop    %ebx
c0020f97:	5e                   	pop    %esi
c0020f98:	5d                   	pop    %ebp
c0020f99:	c3                   	ret    

c0020f9a <thread_get_priority>:

/* Returns the current thread's priority. */
int
thread_get_priority (void) 
{
c0020f9a:	55                   	push   %ebp
c0020f9b:	89 e5                	mov    %esp,%ebp
c0020f9d:	83 ec 08             	sub    $0x8,%esp
  return thread_current ()->donated_priority;
c0020fa0:	e8 47 fd ff ff       	call   c0020cec <thread_current>
c0020fa5:	8b 50 3c             	mov    0x3c(%eax),%edx
c0020fa8:	8b 40 38             	mov    0x38(%eax),%eax
}
c0020fab:	c9                   	leave  
c0020fac:	c3                   	ret    

c0020fad <thread_set_nice>:

/* Sets the current thread's nice value to NICE. */
void
thread_set_nice (int nice UNUSED) 
{
c0020fad:	55                   	push   %ebp
c0020fae:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
}
c0020fb0:	90                   	nop
c0020fb1:	5d                   	pop    %ebp
c0020fb2:	c3                   	ret    

c0020fb3 <thread_get_nice>:

/* Returns the current thread's nice value. */
int
thread_get_nice (void) 
{
c0020fb3:	55                   	push   %ebp
c0020fb4:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fb6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fbb:	5d                   	pop    %ebp
c0020fbc:	c3                   	ret    

c0020fbd <thread_get_load_avg>:

/* Returns 100 times the system load average. */
int
thread_get_load_avg (void) 
{
c0020fbd:	55                   	push   %ebp
c0020fbe:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fc0:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fc5:	5d                   	pop    %ebp
c0020fc6:	c3                   	ret    

c0020fc7 <thread_get_recent_cpu>:

/* Returns 100 times the current thread's recent_cpu value. */
int
thread_get_recent_cpu (void) 
{
c0020fc7:	55                   	push   %ebp
c0020fc8:	89 e5                	mov    %esp,%ebp
  /* Not yet implemented. */
  return 0;
c0020fca:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0020fcf:	5d                   	pop    %ebp
c0020fd0:	c3                   	ret    

c0020fd1 <idle>:
   blocks.  After that, the idle thread never appears in the
   ready list.  It is returned by next_thread_to_run() as a
   special case when the ready list is empty. */
static void
idle (void *idle_started_ UNUSED) 
{
c0020fd1:	55                   	push   %ebp
c0020fd2:	89 e5                	mov    %esp,%ebp
c0020fd4:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *idle_started = idle_started_;
c0020fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0020fda:	89 45 f4             	mov    %eax,-0xc(%ebp)
  idle_thread = thread_current ();
c0020fdd:	e8 0a fd ff ff       	call   c0020cec <thread_current>
c0020fe2:	a3 40 83 03 c0       	mov    %eax,0xc0038340
  sema_up (idle_started);
c0020fe7:	83 ec 0c             	sub    $0xc,%esp
c0020fea:	ff 75 f4             	pushl  -0xc(%ebp)
c0020fed:	e8 f1 1a 00 00       	call   c0022ae3 <sema_up>
c0020ff2:	83 c4 10             	add    $0x10,%esp

  for (;;) 
    {
      /* Let someone else run. */
      intr_disable ();
c0020ff5:	e8 0d 05 00 00       	call   c0021507 <intr_disable>
      thread_block ();
c0020ffa:	e8 cd fb ff ff       	call   c0020bcc <thread_block>
         one to occur, wasting as much as one clock tick worth of
         time.

         See [IA32-v2a] "HLT", [IA32-v2b] "STI", and [IA32-v3a]
         7.11.1 "HLT Instruction". */
      asm volatile ("sti; hlt" : : : "memory");
c0020fff:	fb                   	sti    
c0021000:	f4                   	hlt    
    }
c0021001:	eb f2                	jmp    c0020ff5 <idle+0x24>

c0021003 <kernel_thread>:
}

/* Function used as the basis for a kernel thread. */
static void
kernel_thread (thread_func *function, void *aux) 
{
c0021003:	55                   	push   %ebp
c0021004:	89 e5                	mov    %esp,%ebp
c0021006:	83 ec 08             	sub    $0x8,%esp
  ASSERT (function != NULL);
c0021009:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002100d:	75 21                	jne    c0021030 <kernel_thread+0x2d>
c002100f:	83 ec 0c             	sub    $0xc,%esp
c0021012:	68 b9 ef 02 c0       	push   $0xc002efb9
c0021017:	68 42 ef 02 c0       	push   $0xc002ef42
c002101c:	68 5c f1 02 c0       	push   $0xc002f15c
c0021021:	68 c7 01 00 00       	push   $0x1c7
c0021026:	68 59 ef 02 c0       	push   $0xc002ef59
c002102b:	e8 eb 8b 00 00       	call   c0029c1b <debug_panic>

  intr_enable ();       /* The scheduler runs with interrupts off. */
c0021030:	e8 94 04 00 00       	call   c00214c9 <intr_enable>
  function (aux);       /* Execute the thread function. */
c0021035:	83 ec 0c             	sub    $0xc,%esp
c0021038:	ff 75 0c             	pushl  0xc(%ebp)
c002103b:	8b 45 08             	mov    0x8(%ebp),%eax
c002103e:	ff d0                	call   *%eax
c0021040:	83 c4 10             	add    $0x10,%esp
  thread_exit ();       /* If function() returns, kill the thread. */
c0021043:	e8 24 fd ff ff       	call   c0020d6c <thread_exit>

c0021048 <running_thread>:
}

/* Returns the running thread. */
struct thread *
running_thread (void) 
{
c0021048:	55                   	push   %ebp
c0021049:	89 e5                	mov    %esp,%ebp
c002104b:	83 ec 10             	sub    $0x10,%esp

  /* Copy the CPU's stack pointer into `esp', and then round that
     down to the start of a page.  Because `struct thread' is
     always at the beginning of a page and the stack pointer is
     somewhere in the middle, this locates the curent thread. */
  asm ("mov %%esp, %0" : "=g" (esp));
c002104e:	89 e0                	mov    %esp,%eax
c0021050:	89 45 fc             	mov    %eax,-0x4(%ebp)
  return pg_round_down (esp);
c0021053:	ff 75 fc             	pushl  -0x4(%ebp)
c0021056:	e8 5f f8 ff ff       	call   c00208ba <pg_round_down>
c002105b:	83 c4 04             	add    $0x4,%esp
}
c002105e:	c9                   	leave  
c002105f:	c3                   	ret    

c0021060 <is_thread>:

/* Returns true if T appears to point to a valid thread. */
static bool
is_thread (struct thread *t)
{
c0021060:	55                   	push   %ebp
c0021061:	89 e5                	mov    %esp,%ebp
  return t != NULL && t->magic == THREAD_MAGIC;
c0021063:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021067:	74 14                	je     c002107d <is_thread+0x1d>
c0021069:	8b 45 08             	mov    0x8(%ebp),%eax
c002106c:	8b 40 58             	mov    0x58(%eax),%eax
c002106f:	3d 4b bf 6a cd       	cmp    $0xcd6abf4b,%eax
c0021074:	75 07                	jne    c002107d <is_thread+0x1d>
c0021076:	b8 01 00 00 00       	mov    $0x1,%eax
c002107b:	eb 05                	jmp    c0021082 <is_thread+0x22>
c002107d:	b8 00 00 00 00       	mov    $0x0,%eax
c0021082:	83 e0 01             	and    $0x1,%eax
}
c0021085:	5d                   	pop    %ebp
c0021086:	c3                   	ret    

c0021087 <init_thread>:

/* Does basic initialization of T as a blocked thread named
   NAME. */
static void
init_thread (struct thread *t, const char *name, int priority)
{
c0021087:	55                   	push   %ebp
c0021088:	89 e5                	mov    %esp,%ebp
c002108a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  ASSERT (t != NULL);
c002108d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021091:	75 21                	jne    c00210b4 <init_thread+0x2d>
c0021093:	83 ec 0c             	sub    $0xc,%esp
c0021096:	68 46 f0 02 c0       	push   $0xc002f046
c002109b:	68 42 ef 02 c0       	push   $0xc002ef42
c00210a0:	68 6c f1 02 c0       	push   $0xc002f16c
c00210a5:	68 ea 01 00 00       	push   $0x1ea
c00210aa:	68 59 ef 02 c0       	push   $0xc002ef59
c00210af:	e8 67 8b 00 00       	call   c0029c1b <debug_panic>
  ASSERT (PRI_MIN <= priority && priority <= PRI_MAX);
c00210b4:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00210b8:	78 06                	js     c00210c0 <init_thread+0x39>
c00210ba:	83 7d 10 3f          	cmpl   $0x3f,0x10(%ebp)
c00210be:	7e 21                	jle    c00210e1 <init_thread+0x5a>
c00210c0:	83 ec 0c             	sub    $0xc,%esp
c00210c3:	68 50 f0 02 c0       	push   $0xc002f050
c00210c8:	68 42 ef 02 c0       	push   $0xc002ef42
c00210cd:	68 6c f1 02 c0       	push   $0xc002f16c
c00210d2:	68 eb 01 00 00       	push   $0x1eb
c00210d7:	68 59 ef 02 c0       	push   $0xc002ef59
c00210dc:	e8 3a 8b 00 00       	call   c0029c1b <debug_panic>
  ASSERT (name != NULL);
c00210e1:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00210e5:	75 21                	jne    c0021108 <init_thread+0x81>
c00210e7:	83 ec 0c             	sub    $0xc,%esp
c00210ea:	68 7b f0 02 c0       	push   $0xc002f07b
c00210ef:	68 42 ef 02 c0       	push   $0xc002ef42
c00210f4:	68 6c f1 02 c0       	push   $0xc002f16c
c00210f9:	68 ec 01 00 00       	push   $0x1ec
c00210fe:	68 59 ef 02 c0       	push   $0xc002ef59
c0021103:	e8 13 8b 00 00       	call   c0029c1b <debug_panic>

  memset (t, 0, sizeof *t);
c0021108:	83 ec 04             	sub    $0x4,%esp
c002110b:	6a 5c                	push   $0x5c
c002110d:	6a 00                	push   $0x0
c002110f:	ff 75 08             	pushl  0x8(%ebp)
c0021112:	e8 f8 7e 00 00       	call   c002900f <memset>
c0021117:	83 c4 10             	add    $0x10,%esp
  t->status = THREAD_BLOCKED;
c002111a:	8b 45 08             	mov    0x8(%ebp),%eax
c002111d:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
  strlcpy (t->name, name, sizeof t->name);
c0021124:	8b 45 08             	mov    0x8(%ebp),%eax
c0021127:	83 c0 08             	add    $0x8,%eax
c002112a:	83 ec 04             	sub    $0x4,%esp
c002112d:	6a 10                	push   $0x10
c002112f:	ff 75 0c             	pushl  0xc(%ebp)
c0021132:	50                   	push   %eax
c0021133:	e8 ae 7f 00 00       	call   c00290e6 <strlcpy>
c0021138:	83 c4 10             	add    $0x10,%esp
  t->stack = (uint8_t *) t + PGSIZE;
c002113b:	8b 45 08             	mov    0x8(%ebp),%eax
c002113e:	8d 90 00 10 00 00    	lea    0x1000(%eax),%edx
c0021144:	8b 45 08             	mov    0x8(%ebp),%eax
c0021147:	89 50 18             	mov    %edx,0x18(%eax)
  t->priority = priority;
c002114a:	8b 45 08             	mov    0x8(%ebp),%eax
c002114d:	8b 55 10             	mov    0x10(%ebp),%edx
c0021150:	89 50 1c             	mov    %edx,0x1c(%eax)
  t->magic = THREAD_MAGIC;
c0021153:	8b 45 08             	mov    0x8(%ebp),%eax
c0021156:	c7 40 58 4b bf 6a cd 	movl   $0xcd6abf4b,0x58(%eax)
  t->wake_time = -1; // menos 1
c002115d:	8b 45 08             	mov    0x8(%ebp),%eax
c0021160:	c7 40 30 ff ff ff ff 	movl   $0xffffffff,0x30(%eax)
c0021167:	c7 40 34 ff ff ff ff 	movl   $0xffffffff,0x34(%eax)

  //initialize donated priority to regular priority
  t->donated_priority = priority;
c002116e:	8b 45 10             	mov    0x10(%ebp),%eax
c0021171:	99                   	cltd   
c0021172:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0021175:	89 41 38             	mov    %eax,0x38(%ecx)
c0021178:	89 51 3c             	mov    %edx,0x3c(%ecx)
  //initially thread has no donation
  t->has_donation = false;
c002117b:	8b 45 08             	mov    0x8(%ebp),%eax
c002117e:	c6 40 40 00          	movb   $0x0,0x40(%eax)
  //initially thread is not waiting on any lock
  t->wait_on_lock = NULL;
c0021182:	8b 45 08             	mov    0x8(%ebp),%eax
c0021185:	c7 40 44 00 00 00 00 	movl   $0x0,0x44(%eax)

  list_init(&t->locks_held);
c002118c:	8b 45 08             	mov    0x8(%ebp),%eax
c002118f:	83 c0 48             	add    $0x48,%eax
c0021192:	83 ec 0c             	sub    $0xc,%esp
c0021195:	50                   	push   %eax
c0021196:	e8 f3 8c 00 00       	call   c0029e8e <list_init>
c002119b:	83 c4 10             	add    $0x10,%esp

  old_level = intr_disable ();
c002119e:	e8 64 03 00 00       	call   c0021507 <intr_disable>
c00211a3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_push_back (&all_list, &t->allelem);
c00211a6:	8b 45 08             	mov    0x8(%ebp),%eax
c00211a9:	83 c0 20             	add    $0x20,%eax
c00211ac:	83 ec 08             	sub    $0x8,%esp
c00211af:	50                   	push   %eax
c00211b0:	68 30 83 03 c0       	push   $0xc0038330
c00211b5:	e8 b4 90 00 00       	call   c002a26e <list_push_back>
c00211ba:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c00211bd:	83 ec 0c             	sub    $0xc,%esp
c00211c0:	ff 75 f4             	pushl  -0xc(%ebp)
c00211c3:	e8 e7 02 00 00       	call   c00214af <intr_set_level>
c00211c8:	83 c4 10             	add    $0x10,%esp
}
c00211cb:	90                   	nop
c00211cc:	c9                   	leave  
c00211cd:	c3                   	ret    

c00211ce <alloc_frame>:

/* Allocates a SIZE-byte frame at the top of thread T's stack and
   returns a pointer to the frame's base. */
static void *
alloc_frame (struct thread *t, size_t size) 
{
c00211ce:	55                   	push   %ebp
c00211cf:	89 e5                	mov    %esp,%ebp
c00211d1:	83 ec 08             	sub    $0x8,%esp
  /* Stack data is always allocated in word-size units. */
  ASSERT (is_thread (t));
c00211d4:	ff 75 08             	pushl  0x8(%ebp)
c00211d7:	e8 84 fe ff ff       	call   c0021060 <is_thread>
c00211dc:	83 c4 04             	add    $0x4,%esp
c00211df:	84 c0                	test   %al,%al
c00211e1:	75 21                	jne    c0021204 <alloc_frame+0x36>
c00211e3:	83 ec 0c             	sub    $0xc,%esp
c00211e6:	68 db ef 02 c0       	push   $0xc002efdb
c00211eb:	68 42 ef 02 c0       	push   $0xc002ef42
c00211f0:	68 78 f1 02 c0       	push   $0xc002f178
c00211f5:	68 0a 02 00 00       	push   $0x20a
c00211fa:	68 59 ef 02 c0       	push   $0xc002ef59
c00211ff:	e8 17 8a 00 00       	call   c0029c1b <debug_panic>
  ASSERT (size % sizeof (uint32_t) == 0);
c0021204:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021207:	83 e0 03             	and    $0x3,%eax
c002120a:	85 c0                	test   %eax,%eax
c002120c:	74 21                	je     c002122f <alloc_frame+0x61>
c002120e:	83 ec 0c             	sub    $0xc,%esp
c0021211:	68 88 f0 02 c0       	push   $0xc002f088
c0021216:	68 42 ef 02 c0       	push   $0xc002ef42
c002121b:	68 78 f1 02 c0       	push   $0xc002f178
c0021220:	68 0b 02 00 00       	push   $0x20b
c0021225:	68 59 ef 02 c0       	push   $0xc002ef59
c002122a:	e8 ec 89 00 00       	call   c0029c1b <debug_panic>

  t->stack -= size;
c002122f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021232:	8b 40 18             	mov    0x18(%eax),%eax
c0021235:	8b 55 0c             	mov    0xc(%ebp),%edx
c0021238:	f7 da                	neg    %edx
c002123a:	01 c2                	add    %eax,%edx
c002123c:	8b 45 08             	mov    0x8(%ebp),%eax
c002123f:	89 50 18             	mov    %edx,0x18(%eax)
  return t->stack;
c0021242:	8b 45 08             	mov    0x8(%ebp),%eax
c0021245:	8b 40 18             	mov    0x18(%eax),%eax
}
c0021248:	c9                   	leave  
c0021249:	c3                   	ret    

c002124a <next_thread_to_run>:
   empty.  (If the running thread can continue running, then it
   will be in the run queue.)  If the run queue is empty, return
   idle_thread. */
static struct thread *
next_thread_to_run (void) 
{
c002124a:	55                   	push   %ebp
c002124b:	89 e5                	mov    %esp,%ebp
c002124d:	83 ec 08             	sub    $0x8,%esp
  if (list_empty (&ready_list))
c0021250:	83 ec 0c             	sub    $0xc,%esp
c0021253:	68 20 83 03 c0       	push   $0xc0038320
c0021258:	e8 b9 91 00 00       	call   c002a416 <list_empty>
c002125d:	83 c4 10             	add    $0x10,%esp
c0021260:	84 c0                	test   %al,%al
c0021262:	74 07                	je     c002126b <next_thread_to_run+0x21>
    return idle_thread;
c0021264:	a1 40 83 03 c0       	mov    0xc0038340,%eax
c0021269:	eb 2d                	jmp    c0021298 <next_thread_to_run+0x4e>
  else {
    //ordene ready_list por prioridad, luego devuelva el mas alto priority thread
  	list_sort(&ready_list, (list_less_func*)&priority_compare, NULL);
c002126b:	83 ec 04             	sub    $0x4,%esp
c002126e:	6a 00                	push   $0x0
c0021270:	68 c7 08 02 c0       	push   $0xc00208c7
c0021275:	68 20 83 03 c0       	push   $0xc0038320
c002127a:	e8 4e 95 00 00       	call   c002a7cd <list_sort>
c002127f:	83 c4 10             	add    $0x10,%esp
    return list_entry (list_pop_front (&ready_list), struct thread, elem);
c0021282:	83 ec 0c             	sub    $0xc,%esp
c0021285:	68 20 83 03 c0       	push   $0xc0038320
c002128a:	e8 5e 90 00 00       	call   c002a2ed <list_pop_front>
c002128f:	83 c4 10             	add    $0x10,%esp
c0021292:	83 c0 04             	add    $0x4,%eax
c0021295:	83 e8 2c             	sub    $0x2c,%eax
  }
}
c0021298:	c9                   	leave  
c0021299:	c3                   	ret    

c002129a <thread_schedule_tail>:

   After this function and its caller returns, the thread switch
   is complete. */
void
thread_schedule_tail (struct thread *prev)
{
c002129a:	55                   	push   %ebp
c002129b:	89 e5                	mov    %esp,%ebp
c002129d:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c00212a0:	e8 a3 fd ff ff       	call   c0021048 <running_thread>
c00212a5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (intr_get_level () == INTR_OFF);
c00212a8:	e8 e5 01 00 00       	call   c0021492 <intr_get_level>
c00212ad:	85 c0                	test   %eax,%eax
c00212af:	74 21                	je     c00212d2 <thread_schedule_tail+0x38>
c00212b1:	83 ec 0c             	sub    $0xc,%esp
c00212b4:	68 24 ef 02 c0       	push   $0xc002ef24
c00212b9:	68 42 ef 02 c0       	push   $0xc002ef42
c00212be:	68 84 f1 02 c0       	push   $0xc002f184
c00212c3:	68 37 02 00 00       	push   $0x237
c00212c8:	68 59 ef 02 c0       	push   $0xc002ef59
c00212cd:	e8 49 89 00 00       	call   c0029c1b <debug_panic>

  /* Mark us as running. */
  cur->status = THREAD_RUNNING;
c00212d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00212d5:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

  /* Start new time slice. */
  thread_ticks = 0;
c00212dc:	c7 05 98 83 03 c0 00 	movl   $0x0,0xc0038398
c00212e3:	00 00 00 
  /* If the thread we switched from is dying, destroy its struct
     thread.  This must happen late so that thread_exit() doesn't
     pull out the rug under itself.  (We don't free
     initial_thread because its memory was not obtained via
     palloc().) */
  if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread) 
c00212e6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00212ea:	74 4c                	je     c0021338 <thread_schedule_tail+0x9e>
c00212ec:	8b 45 08             	mov    0x8(%ebp),%eax
c00212ef:	8b 40 04             	mov    0x4(%eax),%eax
c00212f2:	83 f8 03             	cmp    $0x3,%eax
c00212f5:	75 41                	jne    c0021338 <thread_schedule_tail+0x9e>
c00212f7:	a1 44 83 03 c0       	mov    0xc0038344,%eax
c00212fc:	39 45 08             	cmp    %eax,0x8(%ebp)
c00212ff:	74 37                	je     c0021338 <thread_schedule_tail+0x9e>
    {
      ASSERT (prev != cur);
c0021301:	8b 45 08             	mov    0x8(%ebp),%eax
c0021304:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0021307:	75 21                	jne    c002132a <thread_schedule_tail+0x90>
c0021309:	83 ec 0c             	sub    $0xc,%esp
c002130c:	68 a6 f0 02 c0       	push   $0xc002f0a6
c0021311:	68 42 ef 02 c0       	push   $0xc002ef42
c0021316:	68 84 f1 02 c0       	push   $0xc002f184
c002131b:	68 4b 02 00 00       	push   $0x24b
c0021320:	68 59 ef 02 c0       	push   $0xc002ef59
c0021325:	e8 f1 88 00 00       	call   c0029c1b <debug_panic>
      palloc_free_page (prev);
c002132a:	83 ec 0c             	sub    $0xc,%esp
c002132d:	ff 75 08             	pushl  0x8(%ebp)
c0021330:	e8 37 24 00 00       	call   c002376c <palloc_free_page>
c0021335:	83 c4 10             	add    $0x10,%esp
    }
}
c0021338:	90                   	nop
c0021339:	c9                   	leave  
c002133a:	c3                   	ret    

c002133b <schedule>:

   It's not safe to call printf() until thread_schedule_tail()
   has completed. */
static void
schedule (void) 
{
c002133b:	55                   	push   %ebp
c002133c:	89 e5                	mov    %esp,%ebp
c002133e:	83 ec 18             	sub    $0x18,%esp
  struct thread *cur = running_thread ();
c0021341:	e8 02 fd ff ff       	call   c0021048 <running_thread>
c0021346:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct thread *next = next_thread_to_run ();
c0021349:	e8 fc fe ff ff       	call   c002124a <next_thread_to_run>
c002134e:	89 45 ec             	mov    %eax,-0x14(%ebp)
  struct thread *prev = NULL;
c0021351:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c0021358:	e8 35 01 00 00       	call   c0021492 <intr_get_level>
c002135d:	85 c0                	test   %eax,%eax
c002135f:	74 21                	je     c0021382 <schedule+0x47>
c0021361:	83 ec 0c             	sub    $0xc,%esp
c0021364:	68 24 ef 02 c0       	push   $0xc002ef24
c0021369:	68 42 ef 02 c0       	push   $0xc002ef42
c002136e:	68 9c f1 02 c0       	push   $0xc002f19c
c0021373:	68 5e 02 00 00       	push   $0x25e
c0021378:	68 59 ef 02 c0       	push   $0xc002ef59
c002137d:	e8 99 88 00 00       	call   c0029c1b <debug_panic>
  ASSERT (cur->status != THREAD_RUNNING);
c0021382:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021385:	8b 40 04             	mov    0x4(%eax),%eax
c0021388:	85 c0                	test   %eax,%eax
c002138a:	75 21                	jne    c00213ad <schedule+0x72>
c002138c:	83 ec 0c             	sub    $0xc,%esp
c002138f:	68 b2 f0 02 c0       	push   $0xc002f0b2
c0021394:	68 42 ef 02 c0       	push   $0xc002ef42
c0021399:	68 9c f1 02 c0       	push   $0xc002f19c
c002139e:	68 5f 02 00 00       	push   $0x25f
c00213a3:	68 59 ef 02 c0       	push   $0xc002ef59
c00213a8:	e8 6e 88 00 00       	call   c0029c1b <debug_panic>
  ASSERT (is_thread (next));
c00213ad:	83 ec 0c             	sub    $0xc,%esp
c00213b0:	ff 75 ec             	pushl  -0x14(%ebp)
c00213b3:	e8 a8 fc ff ff       	call   c0021060 <is_thread>
c00213b8:	83 c4 10             	add    $0x10,%esp
c00213bb:	84 c0                	test   %al,%al
c00213bd:	75 21                	jne    c00213e0 <schedule+0xa5>
c00213bf:	83 ec 0c             	sub    $0xc,%esp
c00213c2:	68 d0 f0 02 c0       	push   $0xc002f0d0
c00213c7:	68 42 ef 02 c0       	push   $0xc002ef42
c00213cc:	68 9c f1 02 c0       	push   $0xc002f19c
c00213d1:	68 60 02 00 00       	push   $0x260
c00213d6:	68 59 ef 02 c0       	push   $0xc002ef59
c00213db:	e8 3b 88 00 00       	call   c0029c1b <debug_panic>

  if (cur != next)
c00213e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00213e3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00213e6:	74 14                	je     c00213fc <schedule+0xc1>
    prev = switch_threads (cur, next);
c00213e8:	83 ec 08             	sub    $0x8,%esp
c00213eb:	ff 75 ec             	pushl  -0x14(%ebp)
c00213ee:	ff 75 f0             	pushl  -0x10(%ebp)
c00213f1:	e8 53 00 00 00       	call   c0021449 <switch_threads>
c00213f6:	83 c4 10             	add    $0x10,%esp
c00213f9:	89 45 f4             	mov    %eax,-0xc(%ebp)
  thread_schedule_tail (prev);
c00213fc:	83 ec 0c             	sub    $0xc,%esp
c00213ff:	ff 75 f4             	pushl  -0xc(%ebp)
c0021402:	e8 93 fe ff ff       	call   c002129a <thread_schedule_tail>
c0021407:	83 c4 10             	add    $0x10,%esp
}
c002140a:	90                   	nop
c002140b:	c9                   	leave  
c002140c:	c3                   	ret    

c002140d <allocate_tid>:

/* Returns a tid to use for a new thread. */
static tid_t
allocate_tid (void) 
{
c002140d:	55                   	push   %ebp
c002140e:	89 e5                	mov    %esp,%ebp
c0021410:	83 ec 18             	sub    $0x18,%esp
  static tid_t next_tid = 1;
  tid_t tid;

  lock_acquire (&tid_lock);
c0021413:	83 ec 0c             	sub    $0xc,%esp
c0021416:	68 60 83 03 c0       	push   $0xc0038360
c002141b:	e8 c3 18 00 00       	call   c0022ce3 <lock_acquire>
c0021420:	83 c4 10             	add    $0x10,%esp
  tid = next_tid++;
c0021423:	a1 68 79 03 c0       	mov    0xc0037968,%eax
c0021428:	8d 50 01             	lea    0x1(%eax),%edx
c002142b:	89 15 68 79 03 c0    	mov    %edx,0xc0037968
c0021431:	89 45 f4             	mov    %eax,-0xc(%ebp)
  lock_release (&tid_lock);
c0021434:	83 ec 0c             	sub    $0xc,%esp
c0021437:	68 60 83 03 c0       	push   $0xc0038360
c002143c:	e8 85 1a 00 00       	call   c0022ec6 <lock_release>
c0021441:	83 c4 10             	add    $0x10,%esp

  return tid;
c0021444:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021447:	c9                   	leave  
c0021448:	c3                   	ret    

c0021449 <switch_threads>:
	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
	#
	# This stack frame must match the one set up by thread_create()
	# in size.
	pushl %ebx
c0021449:	53                   	push   %ebx
	pushl %ebp
c002144a:	55                   	push   %ebp
	pushl %esi
c002144b:	56                   	push   %esi
	pushl %edi
c002144c:	57                   	push   %edi

	# Get offsetof (struct thread, stack).
.globl thread_stack_ofs
	mov thread_stack_ofs, %edx
c002144d:	8b 15 64 79 03 c0    	mov    0xc0037964,%edx

	# Save current stack pointer to old thread's stack, if any.
	movl SWITCH_CUR(%esp), %eax
c0021453:	8b 44 24 14          	mov    0x14(%esp),%eax
	movl %esp, (%eax,%edx,1)
c0021457:	89 24 10             	mov    %esp,(%eax,%edx,1)

	# Restore stack pointer from new thread's stack.
	movl SWITCH_NEXT(%esp), %ecx
c002145a:	8b 4c 24 18          	mov    0x18(%esp),%ecx
	movl (%ecx,%edx,1), %esp
c002145e:	8b 24 11             	mov    (%ecx,%edx,1),%esp

	# Restore caller's register state.
	popl %edi
c0021461:	5f                   	pop    %edi
	popl %esi
c0021462:	5e                   	pop    %esi
	popl %ebp
c0021463:	5d                   	pop    %ebp
	popl %ebx
c0021464:	5b                   	pop    %ebx
        ret
c0021465:	c3                   	ret    

c0021466 <switch_entry>:

.globl switch_entry
.func switch_entry
switch_entry:
	# Discard switch_threads() arguments.
	addl $8, %esp
c0021466:	83 c4 08             	add    $0x8,%esp

	# Call thread_schedule_tail(prev).
	pushl %eax
c0021469:	50                   	push   %eax
.globl thread_schedule_tail
	call thread_schedule_tail
c002146a:	e8 2b fe ff ff       	call   c002129a <thread_schedule_tail>
	addl $4, %esp
c002146f:	83 c4 04             	add    $0x4,%esp

	# Start thread proper.
	ret
c0021472:	c3                   	ret    

c0021473 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0021473:	55                   	push   %ebp
c0021474:	89 e5                	mov    %esp,%ebp
c0021476:	83 ec 08             	sub    $0x8,%esp
c0021479:	8b 55 08             	mov    0x8(%ebp),%edx
c002147c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002147f:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0021483:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0021486:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c002148a:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c002148e:	ee                   	out    %al,(%dx)
}
c002148f:	90                   	nop
c0021490:	c9                   	leave  
c0021491:	c3                   	ret    

c0021492 <intr_get_level>:
static void unexpected_interrupt (const struct intr_frame *);

/* Returns the current interrupt status. */
enum intr_level
intr_get_level (void) 
{
c0021492:	55                   	push   %ebp
c0021493:	89 e5                	mov    %esp,%ebp
c0021495:	83 ec 10             	sub    $0x10,%esp

  /* Push the flags register on the processor stack, then pop the
     value off the stack into `flags'.  See [IA32-v2b] "PUSHF"
     and "POP" and [IA32-v3a] 5.8.1 "Masking Maskable Hardware
     Interrupts". */
  asm volatile ("pushfl; popl %0" : "=g" (flags));
c0021498:	9c                   	pushf  
c0021499:	58                   	pop    %eax
c002149a:	89 45 fc             	mov    %eax,-0x4(%ebp)

  return flags & FLAG_IF ? INTR_ON : INTR_OFF;
c002149d:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00214a0:	25 00 02 00 00       	and    $0x200,%eax
c00214a5:	85 c0                	test   %eax,%eax
c00214a7:	0f 95 c0             	setne  %al
c00214aa:	0f b6 c0             	movzbl %al,%eax
}
c00214ad:	c9                   	leave  
c00214ae:	c3                   	ret    

c00214af <intr_set_level>:

/* Enables or disables interrupts as specified by LEVEL and
   returns the previous interrupt status. */
enum intr_level
intr_set_level (enum intr_level level) 
{
c00214af:	55                   	push   %ebp
c00214b0:	89 e5                	mov    %esp,%ebp
c00214b2:	83 ec 08             	sub    $0x8,%esp
  return level == INTR_ON ? intr_enable () : intr_disable ();
c00214b5:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
c00214b9:	75 07                	jne    c00214c2 <intr_set_level+0x13>
c00214bb:	e8 09 00 00 00       	call   c00214c9 <intr_enable>
c00214c0:	eb 05                	jmp    c00214c7 <intr_set_level+0x18>
c00214c2:	e8 40 00 00 00       	call   c0021507 <intr_disable>
}
c00214c7:	c9                   	leave  
c00214c8:	c3                   	ret    

c00214c9 <intr_enable>:

/* Enables interrupts and returns the previous interrupt status. */
enum intr_level
intr_enable (void) 
{
c00214c9:	55                   	push   %ebp
c00214ca:	89 e5                	mov    %esp,%ebp
c00214cc:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_get_level ();
c00214cf:	e8 be ff ff ff       	call   c0021492 <intr_get_level>
c00214d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (!intr_context ());
c00214d7:	e8 fa 02 00 00       	call   c00217d6 <intr_context>
c00214dc:	83 f0 01             	xor    $0x1,%eax
c00214df:	84 c0                	test   %al,%al
c00214e1:	75 1e                	jne    c0021501 <intr_enable+0x38>
c00214e3:	83 ec 0c             	sub    $0xc,%esp
c00214e6:	68 a8 f1 02 c0       	push   $0xc002f1a8
c00214eb:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00214f0:	68 b8 f5 02 c0       	push   $0xc002f5b8
c00214f5:	6a 5b                	push   $0x5b
c00214f7:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00214fc:	e8 1a 87 00 00       	call   c0029c1b <debug_panic>

  /* Enable interrupts by setting the interrupt flag.

     See [IA32-v2b] "STI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("sti");
c0021501:	fb                   	sti    

  return old_level;
c0021502:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0021505:	c9                   	leave  
c0021506:	c3                   	ret    

c0021507 <intr_disable>:

/* Disables interrupts and returns the previous interrupt status. */
enum intr_level
intr_disable (void) 
{
c0021507:	55                   	push   %ebp
c0021508:	89 e5                	mov    %esp,%ebp
c002150a:	83 ec 10             	sub    $0x10,%esp
  enum intr_level old_level = intr_get_level ();
c002150d:	e8 80 ff ff ff       	call   c0021492 <intr_get_level>
c0021512:	89 45 fc             	mov    %eax,-0x4(%ebp)

  /* Disable interrupts by clearing the interrupt flag.
     See [IA32-v2b] "CLI" and [IA32-v3a] 5.8.1 "Masking Maskable
     Hardware Interrupts". */
  asm volatile ("cli" : : : "memory");
c0021515:	fa                   	cli    

  return old_level;
c0021516:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0021519:	c9                   	leave  
c002151a:	c3                   	ret    

c002151b <intr_init>:

/* Initializes the interrupt system. */
void
intr_init (void)
{
c002151b:	55                   	push   %ebp
c002151c:	89 e5                	mov    %esp,%ebp
c002151e:	83 ec 18             	sub    $0x18,%esp
  uint64_t idtr_operand;
  int i;

  /* Initialize interrupt controller. */
  pic_init ();
c0021521:	e8 f6 02 00 00       	call   c002181c <pic_init>

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c0021526:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002152d:	eb 2d                	jmp    c002155c <intr_init+0x41>
    idt[i] = make_intr_gate (intr_stubs[i], 0);
c002152f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021532:	8b 04 85 6c 79 03 c0 	mov    -0x3ffc8694(,%eax,4),%eax
c0021539:	83 ec 08             	sub    $0x8,%esp
c002153c:	6a 00                	push   $0x0
c002153e:	50                   	push   %eax
c002153f:	e8 d1 04 00 00       	call   c0021a15 <make_intr_gate>
c0021544:	83 c4 10             	add    $0x10,%esp
c0021547:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002154a:	89 04 cd a0 83 03 c0 	mov    %eax,-0x3ffc7c60(,%ecx,8)
c0021551:	89 14 cd a4 83 03 c0 	mov    %edx,-0x3ffc7c5c(,%ecx,8)

  /* Initialize interrupt controller. */
  pic_init ();

  /* Initialize IDT. */
  for (i = 0; i < INTR_CNT; i++)
c0021558:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002155c:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c0021563:	7e ca                	jle    c002152f <intr_init+0x14>
    idt[i] = make_intr_gate (intr_stubs[i], 0);

  /* Load IDT register.
     See [IA32-v2a] "LIDT" and [IA32-v3a] 5.10 "Interrupt
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
c0021565:	83 ec 08             	sub    $0x8,%esp
c0021568:	68 a0 83 03 c0       	push   $0xc00383a0
c002156d:	68 ff 07 00 00       	push   $0x7ff
c0021572:	e8 d4 04 00 00       	call   c0021a4b <make_idtr_operand>
c0021577:	83 c4 10             	add    $0x10,%esp
c002157a:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002157d:	89 55 ec             	mov    %edx,-0x14(%ebp)
  asm volatile ("lidt %0" : : "m" (idtr_operand));
c0021580:	0f 01 5d e8          	lidtl  -0x18(%ebp)

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c0021584:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002158b:	eb 12                	jmp    c002159f <intr_init+0x84>
    intr_names[i] = "unknown";
c002158d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021590:	c7 04 85 a0 8f 03 c0 	movl   $0xc002f1ea,-0x3ffc7060(,%eax,4)
c0021597:	ea f1 02 c0 
     Descriptor Table (IDT)". */
  idtr_operand = make_idtr_operand (sizeof idt - 1, idt);
  asm volatile ("lidt %0" : : "m" (idtr_operand));

  /* Initialize intr_names. */
  for (i = 0; i < INTR_CNT; i++)
c002159b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002159f:	81 7d f4 ff 00 00 00 	cmpl   $0xff,-0xc(%ebp)
c00215a6:	7e e5                	jle    c002158d <intr_init+0x72>
    intr_names[i] = "unknown";
  intr_names[0] = "#DE Divide Error";
c00215a8:	c7 05 a0 8f 03 c0 f2 	movl   $0xc002f1f2,0xc0038fa0
c00215af:	f1 02 c0 
  intr_names[1] = "#DB Debug Exception";
c00215b2:	c7 05 a4 8f 03 c0 03 	movl   $0xc002f203,0xc0038fa4
c00215b9:	f2 02 c0 
  intr_names[2] = "NMI Interrupt";
c00215bc:	c7 05 a8 8f 03 c0 17 	movl   $0xc002f217,0xc0038fa8
c00215c3:	f2 02 c0 
  intr_names[3] = "#BP Breakpoint Exception";
c00215c6:	c7 05 ac 8f 03 c0 25 	movl   $0xc002f225,0xc0038fac
c00215cd:	f2 02 c0 
  intr_names[4] = "#OF Overflow Exception";
c00215d0:	c7 05 b0 8f 03 c0 3e 	movl   $0xc002f23e,0xc0038fb0
c00215d7:	f2 02 c0 
  intr_names[5] = "#BR BOUND Range Exceeded Exception";
c00215da:	c7 05 b4 8f 03 c0 58 	movl   $0xc002f258,0xc0038fb4
c00215e1:	f2 02 c0 
  intr_names[6] = "#UD Invalid Opcode Exception";
c00215e4:	c7 05 b8 8f 03 c0 7b 	movl   $0xc002f27b,0xc0038fb8
c00215eb:	f2 02 c0 
  intr_names[7] = "#NM Device Not Available Exception";
c00215ee:	c7 05 bc 8f 03 c0 98 	movl   $0xc002f298,0xc0038fbc
c00215f5:	f2 02 c0 
  intr_names[8] = "#DF Double Fault Exception";
c00215f8:	c7 05 c0 8f 03 c0 bb 	movl   $0xc002f2bb,0xc0038fc0
c00215ff:	f2 02 c0 
  intr_names[9] = "Coprocessor Segment Overrun";
c0021602:	c7 05 c4 8f 03 c0 d6 	movl   $0xc002f2d6,0xc0038fc4
c0021609:	f2 02 c0 
  intr_names[10] = "#TS Invalid TSS Exception";
c002160c:	c7 05 c8 8f 03 c0 f2 	movl   $0xc002f2f2,0xc0038fc8
c0021613:	f2 02 c0 
  intr_names[11] = "#NP Segment Not Present";
c0021616:	c7 05 cc 8f 03 c0 0c 	movl   $0xc002f30c,0xc0038fcc
c002161d:	f3 02 c0 
  intr_names[12] = "#SS Stack Fault Exception";
c0021620:	c7 05 d0 8f 03 c0 24 	movl   $0xc002f324,0xc0038fd0
c0021627:	f3 02 c0 
  intr_names[13] = "#GP General Protection Exception";
c002162a:	c7 05 d4 8f 03 c0 40 	movl   $0xc002f340,0xc0038fd4
c0021631:	f3 02 c0 
  intr_names[14] = "#PF Page-Fault Exception";
c0021634:	c7 05 d8 8f 03 c0 61 	movl   $0xc002f361,0xc0038fd8
c002163b:	f3 02 c0 
  intr_names[16] = "#MF x87 FPU Floating-Point Error";
c002163e:	c7 05 e0 8f 03 c0 7c 	movl   $0xc002f37c,0xc0038fe0
c0021645:	f3 02 c0 
  intr_names[17] = "#AC Alignment Check Exception";
c0021648:	c7 05 e4 8f 03 c0 9d 	movl   $0xc002f39d,0xc0038fe4
c002164f:	f3 02 c0 
  intr_names[18] = "#MC Machine-Check Exception";
c0021652:	c7 05 e8 8f 03 c0 bb 	movl   $0xc002f3bb,0xc0038fe8
c0021659:	f3 02 c0 
  intr_names[19] = "#XF SIMD Floating-Point Exception";
c002165c:	c7 05 ec 8f 03 c0 d8 	movl   $0xc002f3d8,0xc0038fec
c0021663:	f3 02 c0 
}
c0021666:	90                   	nop
c0021667:	c9                   	leave  
c0021668:	c3                   	ret    

c0021669 <register_handler>:
   purposes.  The interrupt handler will be invoked with
   interrupt status set to LEVEL. */
static void
register_handler (uint8_t vec_no, int dpl, enum intr_level level,
                  intr_handler_func *handler, const char *name)
{
c0021669:	55                   	push   %ebp
c002166a:	89 e5                	mov    %esp,%ebp
c002166c:	53                   	push   %ebx
c002166d:	83 ec 14             	sub    $0x14,%esp
c0021670:	8b 45 08             	mov    0x8(%ebp),%eax
c0021673:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_handlers[vec_no] == NULL);
c0021676:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002167a:	8b 04 85 a0 8b 03 c0 	mov    -0x3ffc7460(,%eax,4),%eax
c0021681:	85 c0                	test   %eax,%eax
c0021683:	74 21                	je     c00216a6 <register_handler+0x3d>
c0021685:	83 ec 0c             	sub    $0xc,%esp
c0021688:	68 fa f3 02 c0       	push   $0xc002f3fa
c002168d:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021692:	68 c4 f5 02 c0       	push   $0xc002f5c4
c0021697:	68 a8 00 00 00       	push   $0xa8
c002169c:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00216a1:	e8 75 85 00 00       	call   c0029c1b <debug_panic>
  if (level == INTR_ON)
c00216a6:	83 7d 10 01          	cmpl   $0x1,0x10(%ebp)
c00216aa:	75 2e                	jne    c00216da <register_handler+0x71>
    idt[vec_no] = make_trap_gate (intr_stubs[vec_no], dpl);
c00216ac:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c00216b0:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00216b4:	8b 04 85 6c 79 03 c0 	mov    -0x3ffc8694(,%eax,4),%eax
c00216bb:	83 ec 08             	sub    $0x8,%esp
c00216be:	ff 75 0c             	pushl  0xc(%ebp)
c00216c1:	50                   	push   %eax
c00216c2:	e8 69 03 00 00       	call   c0021a30 <make_trap_gate>
c00216c7:	83 c4 10             	add    $0x10,%esp
c00216ca:	89 04 dd a0 83 03 c0 	mov    %eax,-0x3ffc7c60(,%ebx,8)
c00216d1:	89 14 dd a4 83 03 c0 	mov    %edx,-0x3ffc7c5c(,%ebx,8)
c00216d8:	eb 2c                	jmp    c0021706 <register_handler+0x9d>
  else
    idt[vec_no] = make_intr_gate (intr_stubs[vec_no], dpl);
c00216da:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c00216de:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00216e2:	8b 04 85 6c 79 03 c0 	mov    -0x3ffc8694(,%eax,4),%eax
c00216e9:	83 ec 08             	sub    $0x8,%esp
c00216ec:	ff 75 0c             	pushl  0xc(%ebp)
c00216ef:	50                   	push   %eax
c00216f0:	e8 20 03 00 00       	call   c0021a15 <make_intr_gate>
c00216f5:	83 c4 10             	add    $0x10,%esp
c00216f8:	89 04 dd a0 83 03 c0 	mov    %eax,-0x3ffc7c60(,%ebx,8)
c00216ff:	89 14 dd a4 83 03 c0 	mov    %edx,-0x3ffc7c5c(,%ebx,8)
  intr_handlers[vec_no] = handler;
c0021706:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002170a:	8b 55 14             	mov    0x14(%ebp),%edx
c002170d:	89 14 85 a0 8b 03 c0 	mov    %edx,-0x3ffc7460(,%eax,4)
  intr_names[vec_no] = name;
c0021714:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021718:	8b 55 18             	mov    0x18(%ebp),%edx
c002171b:	89 14 85 a0 8f 03 c0 	mov    %edx,-0x3ffc7060(,%eax,4)
}
c0021722:	90                   	nop
c0021723:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021726:	c9                   	leave  
c0021727:	c3                   	ret    

c0021728 <intr_register_ext>:
   is named NAME for debugging purposes.  The handler will
   execute with interrupts disabled. */
void
intr_register_ext (uint8_t vec_no, intr_handler_func *handler,
                   const char *name) 
{
c0021728:	55                   	push   %ebp
c0021729:	89 e5                	mov    %esp,%ebp
c002172b:	83 ec 18             	sub    $0x18,%esp
c002172e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021731:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no >= 0x20 && vec_no <= 0x2f);
c0021734:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c0021738:	76 06                	jbe    c0021740 <intr_register_ext+0x18>
c002173a:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c002173e:	76 21                	jbe    c0021761 <intr_register_ext+0x39>
c0021740:	83 ec 0c             	sub    $0xc,%esp
c0021743:	68 18 f4 02 c0       	push   $0xc002f418
c0021748:	68 b9 f1 02 c0       	push   $0xc002f1b9
c002174d:	68 d8 f5 02 c0       	push   $0xc002f5d8
c0021752:	68 b8 00 00 00       	push   $0xb8
c0021757:	68 d0 f1 02 c0       	push   $0xc002f1d0
c002175c:	e8 ba 84 00 00       	call   c0029c1b <debug_panic>
  register_handler (vec_no, 0, INTR_OFF, handler, name);
c0021761:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0021765:	83 ec 0c             	sub    $0xc,%esp
c0021768:	ff 75 10             	pushl  0x10(%ebp)
c002176b:	ff 75 0c             	pushl  0xc(%ebp)
c002176e:	6a 00                	push   $0x0
c0021770:	6a 00                	push   $0x0
c0021772:	50                   	push   %eax
c0021773:	e8 f1 fe ff ff       	call   c0021669 <register_handler>
c0021778:	83 c4 20             	add    $0x20,%esp
}
c002177b:	90                   	nop
c002177c:	c9                   	leave  
c002177d:	c3                   	ret    

c002177e <intr_register_int>:
   "Accessing Nonconforming Code Segments" for further
   discussion. */
void
intr_register_int (uint8_t vec_no, int dpl, enum intr_level level,
                   intr_handler_func *handler, const char *name)
{
c002177e:	55                   	push   %ebp
c002177f:	89 e5                	mov    %esp,%ebp
c0021781:	83 ec 18             	sub    $0x18,%esp
c0021784:	8b 45 08             	mov    0x8(%ebp),%eax
c0021787:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (vec_no < 0x20 || vec_no > 0x2f);
c002178a:	80 7d f4 1f          	cmpb   $0x1f,-0xc(%ebp)
c002178e:	76 27                	jbe    c00217b7 <intr_register_int+0x39>
c0021790:	80 7d f4 2f          	cmpb   $0x2f,-0xc(%ebp)
c0021794:	77 21                	ja     c00217b7 <intr_register_int+0x39>
c0021796:	83 ec 0c             	sub    $0xc,%esp
c0021799:	68 3c f4 02 c0       	push   $0xc002f43c
c002179e:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00217a3:	68 ec f5 02 c0       	push   $0xc002f5ec
c00217a8:	68 cd 00 00 00       	push   $0xcd
c00217ad:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00217b2:	e8 64 84 00 00       	call   c0029c1b <debug_panic>
  register_handler (vec_no, dpl, level, handler, name);
c00217b7:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c00217bb:	83 ec 0c             	sub    $0xc,%esp
c00217be:	ff 75 18             	pushl  0x18(%ebp)
c00217c1:	ff 75 14             	pushl  0x14(%ebp)
c00217c4:	ff 75 10             	pushl  0x10(%ebp)
c00217c7:	ff 75 0c             	pushl  0xc(%ebp)
c00217ca:	50                   	push   %eax
c00217cb:	e8 99 fe ff ff       	call   c0021669 <register_handler>
c00217d0:	83 c4 20             	add    $0x20,%esp
}
c00217d3:	90                   	nop
c00217d4:	c9                   	leave  
c00217d5:	c3                   	ret    

c00217d6 <intr_context>:

/* Returns true during processing of an external interrupt
   and false at all other times. */
bool
intr_context (void) 
{
c00217d6:	55                   	push   %ebp
c00217d7:	89 e5                	mov    %esp,%ebp
  return in_external_intr;
c00217d9:	0f b6 05 a0 97 03 c0 	movzbl 0xc00397a0,%eax
}
c00217e0:	5d                   	pop    %ebp
c00217e1:	c3                   	ret    

c00217e2 <intr_yield_on_return>:
   interrupt handler to yield to a new process just before
   returning from the interrupt.  May not be called at any other
   time. */
void
intr_yield_on_return (void) 
{
c00217e2:	55                   	push   %ebp
c00217e3:	89 e5                	mov    %esp,%ebp
c00217e5:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_context ());
c00217e8:	e8 e9 ff ff ff       	call   c00217d6 <intr_context>
c00217ed:	84 c0                	test   %al,%al
c00217ef:	75 21                	jne    c0021812 <intr_yield_on_return+0x30>
c00217f1:	83 ec 0c             	sub    $0xc,%esp
c00217f4:	68 5b f4 02 c0       	push   $0xc002f45b
c00217f9:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00217fe:	68 00 f6 02 c0       	push   $0xc002f600
c0021803:	68 e0 00 00 00       	push   $0xe0
c0021808:	68 d0 f1 02 c0       	push   $0xc002f1d0
c002180d:	e8 09 84 00 00       	call   c0029c1b <debug_panic>
  yield_on_return = true;
c0021812:	c6 05 a1 97 03 c0 01 	movb   $0x1,0xc00397a1
}
c0021819:	90                   	nop
c002181a:	c9                   	leave  
c002181b:	c3                   	ret    

c002181c <pic_init>:
   traps and exceptions, so we reprogram the PICs so that
   interrupts 0...15 are delivered to interrupt vectors 32...47
   (0x20...0x2f) instead. */
static void
pic_init (void)
{
c002181c:	55                   	push   %ebp
c002181d:	89 e5                	mov    %esp,%ebp
  /* Mask all interrupts on both PICs. */
  outb (PIC0_DATA, 0xff);
c002181f:	68 ff 00 00 00       	push   $0xff
c0021824:	6a 21                	push   $0x21
c0021826:	e8 48 fc ff ff       	call   c0021473 <outb>
c002182b:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0xff);
c002182e:	68 ff 00 00 00       	push   $0xff
c0021833:	68 a1 00 00 00       	push   $0xa1
c0021838:	e8 36 fc ff ff       	call   c0021473 <outb>
c002183d:	83 c4 08             	add    $0x8,%esp

  /* Initialize master. */
  outb (PIC0_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021840:	6a 11                	push   $0x11
c0021842:	6a 20                	push   $0x20
c0021844:	e8 2a fc ff ff       	call   c0021473 <outb>
c0021849:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x20); /* ICW2: line IR0...7 -> irq 0x20...0x27. */
c002184c:	6a 20                	push   $0x20
c002184e:	6a 21                	push   $0x21
c0021850:	e8 1e fc ff ff       	call   c0021473 <outb>
c0021855:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x04); /* ICW3: slave PIC on line IR2. */
c0021858:	6a 04                	push   $0x4
c002185a:	6a 21                	push   $0x21
c002185c:	e8 12 fc ff ff       	call   c0021473 <outb>
c0021861:	83 c4 08             	add    $0x8,%esp
  outb (PIC0_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c0021864:	6a 01                	push   $0x1
c0021866:	6a 21                	push   $0x21
c0021868:	e8 06 fc ff ff       	call   c0021473 <outb>
c002186d:	83 c4 08             	add    $0x8,%esp

  /* Initialize slave. */
  outb (PIC1_CTRL, 0x11); /* ICW1: single mode, edge triggered, expect ICW4. */
c0021870:	6a 11                	push   $0x11
c0021872:	68 a0 00 00 00       	push   $0xa0
c0021877:	e8 f7 fb ff ff       	call   c0021473 <outb>
c002187c:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x28); /* ICW2: line IR0...7 -> irq 0x28...0x2f. */
c002187f:	6a 28                	push   $0x28
c0021881:	68 a1 00 00 00       	push   $0xa1
c0021886:	e8 e8 fb ff ff       	call   c0021473 <outb>
c002188b:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x02); /* ICW3: slave ID is 2. */
c002188e:	6a 02                	push   $0x2
c0021890:	68 a1 00 00 00       	push   $0xa1
c0021895:	e8 d9 fb ff ff       	call   c0021473 <outb>
c002189a:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x01); /* ICW4: 8086 mode, normal EOI, non-buffered. */
c002189d:	6a 01                	push   $0x1
c002189f:	68 a1 00 00 00       	push   $0xa1
c00218a4:	e8 ca fb ff ff       	call   c0021473 <outb>
c00218a9:	83 c4 08             	add    $0x8,%esp

  /* Unmask all interrupts. */
  outb (PIC0_DATA, 0x00);
c00218ac:	6a 00                	push   $0x0
c00218ae:	6a 21                	push   $0x21
c00218b0:	e8 be fb ff ff       	call   c0021473 <outb>
c00218b5:	83 c4 08             	add    $0x8,%esp
  outb (PIC1_DATA, 0x00);
c00218b8:	6a 00                	push   $0x0
c00218ba:	68 a1 00 00 00       	push   $0xa1
c00218bf:	e8 af fb ff ff       	call   c0021473 <outb>
c00218c4:	83 c4 08             	add    $0x8,%esp
}
c00218c7:	90                   	nop
c00218c8:	c9                   	leave  
c00218c9:	c3                   	ret    

c00218ca <pic_end_of_interrupt>:
/* Sends an end-of-interrupt signal to the PIC for the given IRQ.
   If we don't acknowledge the IRQ, it will never be delivered to
   us again, so this is important.  */
static void
pic_end_of_interrupt (int irq) 
{
c00218ca:	55                   	push   %ebp
c00218cb:	89 e5                	mov    %esp,%ebp
c00218cd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (irq >= 0x20 && irq < 0x30);
c00218d0:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c00218d4:	7e 06                	jle    c00218dc <pic_end_of_interrupt+0x12>
c00218d6:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00218da:	7e 21                	jle    c00218fd <pic_end_of_interrupt+0x33>
c00218dc:	83 ec 0c             	sub    $0xc,%esp
c00218df:	68 6b f4 02 c0       	push   $0xc002f46b
c00218e4:	68 b9 f1 02 c0       	push   $0xc002f1b9
c00218e9:	68 18 f6 02 c0       	push   $0xc002f618
c00218ee:	68 0b 01 00 00       	push   $0x10b
c00218f3:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00218f8:	e8 1e 83 00 00       	call   c0029c1b <debug_panic>

  /* Acknowledge master PIC. */
  outb (0x20, 0x20);
c00218fd:	83 ec 08             	sub    $0x8,%esp
c0021900:	6a 20                	push   $0x20
c0021902:	6a 20                	push   $0x20
c0021904:	e8 6a fb ff ff       	call   c0021473 <outb>
c0021909:	83 c4 10             	add    $0x10,%esp

  /* Acknowledge slave PIC if this is a slave interrupt. */
  if (irq >= 0x28)
c002190c:	83 7d 08 27          	cmpl   $0x27,0x8(%ebp)
c0021910:	7e 12                	jle    c0021924 <pic_end_of_interrupt+0x5a>
    outb (0xa0, 0x20);
c0021912:	83 ec 08             	sub    $0x8,%esp
c0021915:	6a 20                	push   $0x20
c0021917:	68 a0 00 00 00       	push   $0xa0
c002191c:	e8 52 fb ff ff       	call   c0021473 <outb>
c0021921:	83 c4 10             	add    $0x10,%esp
}
c0021924:	90                   	nop
c0021925:	c9                   	leave  
c0021926:	c3                   	ret    

c0021927 <make_gate>:
   disables interrupts, but entering a trap gate does not.  See
   [IA32-v3a] section 5.12.1.2 "Flag Usage By Exception- or
   Interrupt-Handler Procedure" for discussion. */
static uint64_t
make_gate (void (*function) (void), int dpl, int type)
{
c0021927:	55                   	push   %ebp
c0021928:	89 e5                	mov    %esp,%ebp
c002192a:	57                   	push   %edi
c002192b:	56                   	push   %esi
c002192c:	53                   	push   %ebx
c002192d:	83 ec 2c             	sub    $0x2c,%esp
  uint32_t e0, e1;

  ASSERT (function != NULL);
c0021930:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0021934:	75 21                	jne    c0021957 <make_gate+0x30>
c0021936:	83 ec 0c             	sub    $0xc,%esp
c0021939:	68 85 f4 02 c0       	push   $0xc002f485
c002193e:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021943:	68 30 f6 02 c0       	push   $0xc002f630
c0021948:	68 2a 01 00 00       	push   $0x12a
c002194d:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0021952:	e8 c4 82 00 00       	call   c0029c1b <debug_panic>
  ASSERT (dpl >= 0 && dpl <= 3);
c0021957:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002195b:	78 06                	js     c0021963 <make_gate+0x3c>
c002195d:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0021961:	7e 21                	jle    c0021984 <make_gate+0x5d>
c0021963:	83 ec 0c             	sub    $0xc,%esp
c0021966:	68 96 f4 02 c0       	push   $0xc002f496
c002196b:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021970:	68 30 f6 02 c0       	push   $0xc002f630
c0021975:	68 2b 01 00 00       	push   $0x12b
c002197a:	68 d0 f1 02 c0       	push   $0xc002f1d0
c002197f:	e8 97 82 00 00       	call   c0029c1b <debug_panic>
  ASSERT (type >= 0 && type <= 15);
c0021984:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0021988:	78 06                	js     c0021990 <make_gate+0x69>
c002198a:	83 7d 10 0f          	cmpl   $0xf,0x10(%ebp)
c002198e:	7e 21                	jle    c00219b1 <make_gate+0x8a>
c0021990:	83 ec 0c             	sub    $0xc,%esp
c0021993:	68 ab f4 02 c0       	push   $0xc002f4ab
c0021998:	68 b9 f1 02 c0       	push   $0xc002f1b9
c002199d:	68 30 f6 02 c0       	push   $0xc002f630
c00219a2:	68 2c 01 00 00       	push   $0x12c
c00219a7:	68 d0 f1 02 c0       	push   $0xc002f1d0
c00219ac:	e8 6a 82 00 00       	call   c0029c1b <debug_panic>

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
c00219b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00219b4:	0f b7 c0             	movzwl %ax,%eax
c00219b7:	0d 00 00 08 00       	or     $0x80000,%eax
c00219bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00219bf:	8b 45 08             	mov    0x8(%ebp),%eax
c00219c2:	66 b8 00 00          	mov    $0x0,%ax
c00219c6:	89 c2                	mov    %eax,%edx
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
c00219c8:	8b 45 0c             	mov    0xc(%ebp),%eax
c00219cb:	c1 e0 0d             	shl    $0xd,%eax
c00219ce:	09 c2                	or     %eax,%edx
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */
c00219d0:	8b 45 10             	mov    0x10(%ebp),%eax
c00219d3:	c1 e0 08             	shl    $0x8,%eax
c00219d6:	09 d0                	or     %edx,%eax
  ASSERT (type >= 0 && type <= 15);

  e0 = (((uint32_t) function & 0xffff)     /* Offset 15:0. */
        | (SEL_KCSEG << 16));              /* Target code segment. */

  e1 = (((uint32_t) function & 0xffff0000) /* Offset 31:16. */
c00219d8:	80 cc 80             	or     $0x80,%ah
c00219db:	89 45 e0             	mov    %eax,-0x20(%ebp)
        | (1 << 15)                        /* Present. */
        | ((uint32_t) dpl << 13)           /* Descriptor privilege level. */
        | (0 << 12)                        /* System. */
        | ((uint32_t) type << 8));         /* Gate type. */

  return e0 | ((uint64_t) e1 << 32);
c00219de:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c00219e1:	bf 00 00 00 00       	mov    $0x0,%edi
c00219e6:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00219e9:	ba 00 00 00 00       	mov    $0x0,%edx
c00219ee:	89 c2                	mov    %eax,%edx
c00219f0:	b8 00 00 00 00       	mov    $0x0,%eax
c00219f5:	89 45 d0             	mov    %eax,-0x30(%ebp)
c00219f8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
c00219fb:	89 f0                	mov    %esi,%eax
c00219fd:	0b 45 d0             	or     -0x30(%ebp),%eax
c0021a00:	89 c1                	mov    %eax,%ecx
c0021a02:	89 f8                	mov    %edi,%eax
c0021a04:	0b 45 d4             	or     -0x2c(%ebp),%eax
c0021a07:	89 c3                	mov    %eax,%ebx
c0021a09:	89 c8                	mov    %ecx,%eax
c0021a0b:	89 da                	mov    %ebx,%edx
}
c0021a0d:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0021a10:	5b                   	pop    %ebx
c0021a11:	5e                   	pop    %esi
c0021a12:	5f                   	pop    %edi
c0021a13:	5d                   	pop    %ebp
c0021a14:	c3                   	ret    

c0021a15 <make_intr_gate>:

/* Creates an interrupt gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_intr_gate (void (*function) (void), int dpl)
{
c0021a15:	55                   	push   %ebp
c0021a16:	89 e5                	mov    %esp,%ebp
c0021a18:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 14);
c0021a1b:	83 ec 04             	sub    $0x4,%esp
c0021a1e:	6a 0e                	push   $0xe
c0021a20:	ff 75 0c             	pushl  0xc(%ebp)
c0021a23:	ff 75 08             	pushl  0x8(%ebp)
c0021a26:	e8 fc fe ff ff       	call   c0021927 <make_gate>
c0021a2b:	83 c4 10             	add    $0x10,%esp
}
c0021a2e:	c9                   	leave  
c0021a2f:	c3                   	ret    

c0021a30 <make_trap_gate>:

/* Creates a trap gate that invokes FUNCTION with the given
   DPL. */
static uint64_t
make_trap_gate (void (*function) (void), int dpl)
{
c0021a30:	55                   	push   %ebp
c0021a31:	89 e5                	mov    %esp,%ebp
c0021a33:	83 ec 08             	sub    $0x8,%esp
  return make_gate (function, dpl, 15);
c0021a36:	83 ec 04             	sub    $0x4,%esp
c0021a39:	6a 0f                	push   $0xf
c0021a3b:	ff 75 0c             	pushl  0xc(%ebp)
c0021a3e:	ff 75 08             	pushl  0x8(%ebp)
c0021a41:	e8 e1 fe ff ff       	call   c0021927 <make_gate>
c0021a46:	83 c4 10             	add    $0x10,%esp
}
c0021a49:	c9                   	leave  
c0021a4a:	c3                   	ret    

c0021a4b <make_idtr_operand>:

/* Returns a descriptor that yields the given LIMIT and BASE when
   used as an operand for the LIDT instruction. */
static inline uint64_t
make_idtr_operand (uint16_t limit, void *base)
{
c0021a4b:	55                   	push   %ebp
c0021a4c:	89 e5                	mov    %esp,%ebp
c0021a4e:	57                   	push   %edi
c0021a4f:	56                   	push   %esi
c0021a50:	53                   	push   %ebx
c0021a51:	83 ec 14             	sub    $0x14,%esp
c0021a54:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a57:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  return limit | ((uint64_t) (uint32_t) base << 16);
c0021a5b:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0021a5f:	89 c6                	mov    %eax,%esi
c0021a61:	bf 00 00 00 00       	mov    $0x0,%edi
c0021a66:	8b 45 0c             	mov    0xc(%ebp),%eax
c0021a69:	ba 00 00 00 00       	mov    $0x0,%edx
c0021a6e:	0f a4 c2 10          	shld   $0x10,%eax,%edx
c0021a72:	c1 e0 10             	shl    $0x10,%eax
c0021a75:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0021a78:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0021a7b:	89 f0                	mov    %esi,%eax
c0021a7d:	0b 45 e0             	or     -0x20(%ebp),%eax
c0021a80:	89 c1                	mov    %eax,%ecx
c0021a82:	89 f8                	mov    %edi,%eax
c0021a84:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0021a87:	89 c3                	mov    %eax,%ebx
c0021a89:	89 c8                	mov    %ecx,%eax
c0021a8b:	89 da                	mov    %ebx,%edx
}
c0021a8d:	83 c4 14             	add    $0x14,%esp
c0021a90:	5b                   	pop    %ebx
c0021a91:	5e                   	pop    %esi
c0021a92:	5f                   	pop    %edi
c0021a93:	5d                   	pop    %ebp
c0021a94:	c3                   	ret    

c0021a95 <intr_handler>:
   function is called by the assembly language interrupt stubs in
   intr-stubs.S.  FRAME describes the interrupt and the
   interrupted thread's registers. */
void
intr_handler (struct intr_frame *frame) 
{
c0021a95:	55                   	push   %ebp
c0021a96:	89 e5                	mov    %esp,%ebp
c0021a98:	83 ec 18             	sub    $0x18,%esp

  /* External interrupts are special.
     We only handle one at a time (so interrupts must be off)
     and they need to be acknowledged on the PIC (see below).
     An external interrupt handler cannot sleep. */
  external = frame->vec_no >= 0x20 && frame->vec_no < 0x30;
c0021a9b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021a9e:	8b 40 30             	mov    0x30(%eax),%eax
c0021aa1:	83 f8 1f             	cmp    $0x1f,%eax
c0021aa4:	76 12                	jbe    c0021ab8 <intr_handler+0x23>
c0021aa6:	8b 45 08             	mov    0x8(%ebp),%eax
c0021aa9:	8b 40 30             	mov    0x30(%eax),%eax
c0021aac:	83 f8 2f             	cmp    $0x2f,%eax
c0021aaf:	77 07                	ja     c0021ab8 <intr_handler+0x23>
c0021ab1:	b8 01 00 00 00       	mov    $0x1,%eax
c0021ab6:	eb 05                	jmp    c0021abd <intr_handler+0x28>
c0021ab8:	b8 00 00 00 00       	mov    $0x0,%eax
c0021abd:	88 45 f7             	mov    %al,-0x9(%ebp)
c0021ac0:	80 65 f7 01          	andb   $0x1,-0x9(%ebp)
  if (external) 
c0021ac4:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021ac8:	74 65                	je     c0021b2f <intr_handler+0x9a>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021aca:	e8 c3 f9 ff ff       	call   c0021492 <intr_get_level>
c0021acf:	85 c0                	test   %eax,%eax
c0021ad1:	74 21                	je     c0021af4 <intr_handler+0x5f>
c0021ad3:	83 ec 0c             	sub    $0xc,%esp
c0021ad6:	68 c3 f4 02 c0       	push   $0xc002f4c3
c0021adb:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021ae0:	68 3c f6 02 c0       	push   $0xc002f63c
c0021ae5:	68 65 01 00 00       	push   $0x165
c0021aea:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0021aef:	e8 27 81 00 00       	call   c0029c1b <debug_panic>
      ASSERT (!intr_context ());
c0021af4:	e8 dd fc ff ff       	call   c00217d6 <intr_context>
c0021af9:	83 f0 01             	xor    $0x1,%eax
c0021afc:	84 c0                	test   %al,%al
c0021afe:	75 21                	jne    c0021b21 <intr_handler+0x8c>
c0021b00:	83 ec 0c             	sub    $0xc,%esp
c0021b03:	68 a8 f1 02 c0       	push   $0xc002f1a8
c0021b08:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021b0d:	68 3c f6 02 c0       	push   $0xc002f63c
c0021b12:	68 66 01 00 00       	push   $0x166
c0021b17:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0021b1c:	e8 fa 80 00 00       	call   c0029c1b <debug_panic>

      in_external_intr = true;
c0021b21:	c6 05 a0 97 03 c0 01 	movb   $0x1,0xc00397a0
      yield_on_return = false;
c0021b28:	c6 05 a1 97 03 c0 00 	movb   $0x0,0xc00397a1
    }

  /* Invoke the interrupt's handler. */
  handler = intr_handlers[frame->vec_no];
c0021b2f:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b32:	8b 40 30             	mov    0x30(%eax),%eax
c0021b35:	8b 04 85 a0 8b 03 c0 	mov    -0x3ffc7460(,%eax,4),%eax
c0021b3c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (handler != NULL)
c0021b3f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0021b43:	74 10                	je     c0021b55 <intr_handler+0xc0>
    handler (frame);
c0021b45:	83 ec 0c             	sub    $0xc,%esp
c0021b48:	ff 75 08             	pushl  0x8(%ebp)
c0021b4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0021b4e:	ff d0                	call   *%eax
c0021b50:	83 c4 10             	add    $0x10,%esp
c0021b53:	eb 24                	jmp    c0021b79 <intr_handler+0xe4>
  else if (frame->vec_no == 0x27 || frame->vec_no == 0x2f)
c0021b55:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b58:	8b 40 30             	mov    0x30(%eax),%eax
c0021b5b:	83 f8 27             	cmp    $0x27,%eax
c0021b5e:	74 19                	je     c0021b79 <intr_handler+0xe4>
c0021b60:	8b 45 08             	mov    0x8(%ebp),%eax
c0021b63:	8b 40 30             	mov    0x30(%eax),%eax
c0021b66:	83 f8 2f             	cmp    $0x2f,%eax
c0021b69:	74 0e                	je     c0021b79 <intr_handler+0xe4>
      /* There is no handler, but this interrupt can trigger
         spuriously due to a hardware fault or hardware race
         condition.  Ignore it. */
    }
  else
    unexpected_interrupt (frame);
c0021b6b:	83 ec 0c             	sub    $0xc,%esp
c0021b6e:	ff 75 08             	pushl  0x8(%ebp)
c0021b71:	e8 89 00 00 00       	call   c0021bff <unexpected_interrupt>
c0021b76:	83 c4 10             	add    $0x10,%esp

  /* Complete the processing of an external interrupt. */
  if (external) 
c0021b79:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0021b7d:	74 7d                	je     c0021bfc <intr_handler+0x167>
    {
      ASSERT (intr_get_level () == INTR_OFF);
c0021b7f:	e8 0e f9 ff ff       	call   c0021492 <intr_get_level>
c0021b84:	85 c0                	test   %eax,%eax
c0021b86:	74 21                	je     c0021ba9 <intr_handler+0x114>
c0021b88:	83 ec 0c             	sub    $0xc,%esp
c0021b8b:	68 c3 f4 02 c0       	push   $0xc002f4c3
c0021b90:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021b95:	68 3c f6 02 c0       	push   $0xc002f63c
c0021b9a:	68 7c 01 00 00       	push   $0x17c
c0021b9f:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0021ba4:	e8 72 80 00 00       	call   c0029c1b <debug_panic>
      ASSERT (intr_context ());
c0021ba9:	e8 28 fc ff ff       	call   c00217d6 <intr_context>
c0021bae:	84 c0                	test   %al,%al
c0021bb0:	75 21                	jne    c0021bd3 <intr_handler+0x13e>
c0021bb2:	83 ec 0c             	sub    $0xc,%esp
c0021bb5:	68 5b f4 02 c0       	push   $0xc002f45b
c0021bba:	68 b9 f1 02 c0       	push   $0xc002f1b9
c0021bbf:	68 3c f6 02 c0       	push   $0xc002f63c
c0021bc4:	68 7d 01 00 00       	push   $0x17d
c0021bc9:	68 d0 f1 02 c0       	push   $0xc002f1d0
c0021bce:	e8 48 80 00 00       	call   c0029c1b <debug_panic>

      in_external_intr = false;
c0021bd3:	c6 05 a0 97 03 c0 00 	movb   $0x0,0xc00397a0
      pic_end_of_interrupt (frame->vec_no); 
c0021bda:	8b 45 08             	mov    0x8(%ebp),%eax
c0021bdd:	8b 40 30             	mov    0x30(%eax),%eax
c0021be0:	83 ec 0c             	sub    $0xc,%esp
c0021be3:	50                   	push   %eax
c0021be4:	e8 e1 fc ff ff       	call   c00218ca <pic_end_of_interrupt>
c0021be9:	83 c4 10             	add    $0x10,%esp

      if (yield_on_return) 
c0021bec:	0f b6 05 a1 97 03 c0 	movzbl 0xc00397a1,%eax
c0021bf3:	84 c0                	test   %al,%al
c0021bf5:	74 05                	je     c0021bfc <intr_handler+0x167>
        thread_yield (); 
c0021bf7:	e8 e6 f1 ff ff       	call   c0020de2 <thread_yield>
    }
}
c0021bfc:	90                   	nop
c0021bfd:	c9                   	leave  
c0021bfe:	c3                   	ret    

c0021bff <unexpected_interrupt>:

/* Handles an unexpected interrupt with interrupt frame F.  An
   unexpected interrupt is one that has no registered handler. */
static void
unexpected_interrupt (const struct intr_frame *f)
{
c0021bff:	55                   	push   %ebp
c0021c00:	89 e5                	mov    %esp,%ebp
c0021c02:	83 ec 18             	sub    $0x18,%esp
  /* Count the number so far. */
  unsigned int n = ++unexpected_cnt[f->vec_no];
c0021c05:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c08:	8b 40 30             	mov    0x30(%eax),%eax
c0021c0b:	8b 14 85 a0 93 03 c0 	mov    -0x3ffc6c60(,%eax,4),%edx
c0021c12:	83 c2 01             	add    $0x1,%edx
c0021c15:	89 14 85 a0 93 03 c0 	mov    %edx,-0x3ffc6c60(,%eax,4)
c0021c1c:	8b 04 85 a0 93 03 c0 	mov    -0x3ffc6c60(,%eax,4),%eax
c0021c23:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* If the number is a power of 2, print a message.  This rate
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
c0021c26:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0021c29:	83 e8 01             	sub    $0x1,%eax
c0021c2c:	23 45 f4             	and    -0xc(%ebp),%eax
c0021c2f:	85 c0                	test   %eax,%eax
c0021c31:	75 25                	jne    c0021c58 <unexpected_interrupt+0x59>
    printf ("Unexpected interrupt %#04x (%s)\n",
    f->vec_no, intr_names[f->vec_no]);
c0021c33:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c36:	8b 40 30             	mov    0x30(%eax),%eax
     limiting means that we get information about an uncommon
     unexpected interrupt the first time and fairly often after
     that, but one that occurs many times will not overwhelm the
     console. */
  if ((n & (n - 1)) == 0)
    printf ("Unexpected interrupt %#04x (%s)\n",
c0021c39:	8b 14 85 a0 8f 03 c0 	mov    -0x3ffc7060(,%eax,4),%edx
c0021c40:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c43:	8b 40 30             	mov    0x30(%eax),%eax
c0021c46:	83 ec 04             	sub    $0x4,%esp
c0021c49:	52                   	push   %edx
c0021c4a:	50                   	push   %eax
c0021c4b:	68 e4 f4 02 c0       	push   $0xc002f4e4
c0021c50:	e8 93 5b 00 00       	call   c00277e8 <printf>
c0021c55:	83 c4 10             	add    $0x10,%esp
    f->vec_no, intr_names[f->vec_no]);
}
c0021c58:	90                   	nop
c0021c59:	c9                   	leave  
c0021c5a:	c3                   	ret    

c0021c5b <intr_dump_frame>:

/* Dumps interrupt frame F to the console, for debugging. */
void
intr_dump_frame (const struct intr_frame *f) 
{
c0021c5b:	55                   	push   %ebp
c0021c5c:	89 e5                	mov    %esp,%ebp
c0021c5e:	53                   	push   %ebx
c0021c5f:	83 ec 14             	sub    $0x14,%esp
  /* Store current value of CR2 into `cr2'.
     CR2 is the linear address of the last page fault.
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));
c0021c62:	0f 20 d0             	mov    %cr2,%eax
c0021c65:	89 45 f4             	mov    %eax,-0xc(%ebp)

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021c68:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c6b:	8b 48 3c             	mov    0x3c(%eax),%ecx
          f->vec_no, intr_names[f->vec_no], f->eip);
c0021c6e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c71:	8b 40 30             	mov    0x30(%eax),%eax
     See [IA32-v2a] "MOV--Move to/from Control Registers" and
     [IA32-v3a] 5.14 "Interrupt 14--Page Fault Exception
     (#PF)". */
  asm ("movl %%cr2, %0" : "=r" (cr2));

  printf ("Interrupt %#04x (%s) at eip=%p\n",
c0021c74:	8b 14 85 a0 8f 03 c0 	mov    -0x3ffc7060(,%eax,4),%edx
c0021c7b:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c7e:	8b 40 30             	mov    0x30(%eax),%eax
c0021c81:	51                   	push   %ecx
c0021c82:	52                   	push   %edx
c0021c83:	50                   	push   %eax
c0021c84:	68 08 f5 02 c0       	push   $0xc002f508
c0021c89:	e8 5a 5b 00 00       	call   c00277e8 <printf>
c0021c8e:	83 c4 10             	add    $0x10,%esp
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
c0021c91:	8b 45 08             	mov    0x8(%ebp),%eax
c0021c94:	8b 40 34             	mov    0x34(%eax),%eax
c0021c97:	83 ec 04             	sub    $0x4,%esp
c0021c9a:	50                   	push   %eax
c0021c9b:	ff 75 f4             	pushl  -0xc(%ebp)
c0021c9e:	68 28 f5 02 c0       	push   $0xc002f528
c0021ca3:	e8 40 5b 00 00       	call   c00277e8 <printf>
c0021ca8:	83 c4 10             	add    $0x10,%esp
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
c0021cab:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cae:	8b 58 14             	mov    0x14(%eax),%ebx
c0021cb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cb4:	8b 48 18             	mov    0x18(%eax),%ecx
c0021cb7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cba:	8b 50 10             	mov    0x10(%eax),%edx
c0021cbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cc0:	8b 40 1c             	mov    0x1c(%eax),%eax
c0021cc3:	83 ec 0c             	sub    $0xc,%esp
c0021cc6:	53                   	push   %ebx
c0021cc7:	51                   	push   %ecx
c0021cc8:	52                   	push   %edx
c0021cc9:	50                   	push   %eax
c0021cca:	68 40 f5 02 c0       	push   $0xc002f540
c0021ccf:	e8 14 5b 00 00       	call   c00277e8 <printf>
c0021cd4:	83 c4 20             	add    $0x20,%esp
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021cd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0021cda:	8b 48 08             	mov    0x8(%eax),%ecx
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
c0021cdd:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ce0:	8b 40 48             	mov    0x48(%eax),%eax
  printf ("Interrupt %#04x (%s) at eip=%p\n",
          f->vec_no, intr_names[f->vec_no], f->eip);
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
c0021ce3:	89 c3                	mov    %eax,%ebx
c0021ce5:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ce8:	8b 10                	mov    (%eax),%edx
c0021cea:	8b 45 08             	mov    0x8(%ebp),%eax
c0021ced:	8b 40 04             	mov    0x4(%eax),%eax
c0021cf0:	83 ec 0c             	sub    $0xc,%esp
c0021cf3:	51                   	push   %ecx
c0021cf4:	53                   	push   %ebx
c0021cf5:	52                   	push   %edx
c0021cf6:	50                   	push   %eax
c0021cf7:	68 68 f5 02 c0       	push   $0xc002f568
c0021cfc:	e8 e7 5a 00 00       	call   c00277e8 <printf>
c0021d01:	83 c4 20             	add    $0x20,%esp
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
          f->cs, f->ds, f->es, f->ss);
c0021d04:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d07:	0f b7 40 4c          	movzwl 0x4c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021d0b:	0f b7 d8             	movzwl %ax,%ebx
          f->cs, f->ds, f->es, f->ss);
c0021d0e:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d11:	0f b7 40 28          	movzwl 0x28(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021d15:	0f b7 c8             	movzwl %ax,%ecx
          f->cs, f->ds, f->es, f->ss);
c0021d18:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d1b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021d1f:	0f b7 d0             	movzwl %ax,%edx
          f->cs, f->ds, f->es, f->ss);
c0021d22:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d25:	0f b7 40 40          	movzwl 0x40(%eax),%eax
  printf (" cr2=%08"PRIx32" error=%08"PRIx32"\n", cr2, f->error_code);
  printf (" eax=%08"PRIx32" ebx=%08"PRIx32" ecx=%08"PRIx32" edx=%08"PRIx32"\n",
          f->eax, f->ebx, f->ecx, f->edx);
  printf (" esi=%08"PRIx32" edi=%08"PRIx32" esp=%08"PRIx32" ebp=%08"PRIx32"\n",
          f->esi, f->edi, (uint32_t) f->esp, f->ebp);
  printf (" cs=%04"PRIx16" ds=%04"PRIx16" es=%04"PRIx16" ss=%04"PRIx16"\n",
c0021d29:	0f b7 c0             	movzwl %ax,%eax
c0021d2c:	83 ec 0c             	sub    $0xc,%esp
c0021d2f:	53                   	push   %ebx
c0021d30:	51                   	push   %ecx
c0021d31:	52                   	push   %edx
c0021d32:	50                   	push   %eax
c0021d33:	68 90 f5 02 c0       	push   $0xc002f590
c0021d38:	e8 ab 5a 00 00       	call   c00277e8 <printf>
c0021d3d:	83 c4 20             	add    $0x20,%esp
          f->cs, f->ds, f->es, f->ss);
}
c0021d40:	90                   	nop
c0021d41:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0021d44:	c9                   	leave  
c0021d45:	c3                   	ret    

c0021d46 <intr_name>:

/* Returns the name of interrupt VEC. */
const char *
intr_name (uint8_t vec) 
{
c0021d46:	55                   	push   %ebp
c0021d47:	89 e5                	mov    %esp,%ebp
c0021d49:	83 ec 04             	sub    $0x4,%esp
c0021d4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0021d4f:	88 45 fc             	mov    %al,-0x4(%ebp)
  return intr_names[vec];
c0021d52:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0021d56:	8b 04 85 a0 8f 03 c0 	mov    -0x3ffc7060(,%eax,4),%eax
}
c0021d5d:	c9                   	leave  
c0021d5e:	c3                   	ret    

c0021d5f <intr_entry>:
   We "fall through" to intr_exit to return from the interrupt.
*/
.func intr_entry
intr_entry:
	/* Save caller's registers. */
	pushl %ds
c0021d5f:	1e                   	push   %ds
	pushl %es
c0021d60:	06                   	push   %es
	pushl %fs
c0021d61:	0f a0                	push   %fs
	pushl %gs
c0021d63:	0f a8                	push   %gs
	pushal
c0021d65:	60                   	pusha  
        
	/* Set up kernel environment. */
	cld			/* String instructions go upward. */
c0021d66:	fc                   	cld    
	mov $SEL_KDSEG, %eax	/* Initialize segment registers. */
c0021d67:	b8 10 00 00 00       	mov    $0x10,%eax
	mov %eax, %ds
c0021d6c:	8e d8                	mov    %eax,%ds
	mov %eax, %es
c0021d6e:	8e c0                	mov    %eax,%es
	leal 56(%esp), %ebp	/* Set up frame pointer. */
c0021d70:	8d 6c 24 38          	lea    0x38(%esp),%ebp

	/* Call interrupt handler. */
	pushl %esp
c0021d74:	54                   	push   %esp
.globl intr_handler
	call intr_handler
c0021d75:	e8 1b fd ff ff       	call   c0021a95 <intr_handler>
	addl $4, %esp
c0021d7a:	83 c4 04             	add    $0x4,%esp

c0021d7d <intr_exit>:
   userprog/process.c). */
.globl intr_exit
.func intr_exit
intr_exit:
        /* Restore caller's registers. */
	popal
c0021d7d:	61                   	popa   
	popl %gs
c0021d7e:	0f a9                	pop    %gs
	popl %fs
c0021d80:	0f a1                	pop    %fs
	popl %es
c0021d82:	07                   	pop    %es
	popl %ds
c0021d83:	1f                   	pop    %ds

        /* Discard `struct intr_frame' vec_no, error_code,
           frame_pointer members. */
	addl $12, %esp
c0021d84:	83 c4 0c             	add    $0xc,%esp

        /* Return to caller. */
	iret
c0021d87:	cf                   	iret   

c0021d88 <intr00_stub>:
                                                \
	.data;                                  \
	.long intr##NUMBER##_stub;

/* All the stubs. */
STUB(00, zero) STUB(01, zero) STUB(02, zero) STUB(03, zero)
c0021d88:	55                   	push   %ebp
c0021d89:	6a 00                	push   $0x0
c0021d8b:	6a 00                	push   $0x0
c0021d8d:	eb d0                	jmp    c0021d5f <intr_entry>

c0021d8f <intr01_stub>:
c0021d8f:	55                   	push   %ebp
c0021d90:	6a 00                	push   $0x0
c0021d92:	6a 01                	push   $0x1
c0021d94:	eb c9                	jmp    c0021d5f <intr_entry>

c0021d96 <intr02_stub>:
c0021d96:	55                   	push   %ebp
c0021d97:	6a 00                	push   $0x0
c0021d99:	6a 02                	push   $0x2
c0021d9b:	eb c2                	jmp    c0021d5f <intr_entry>

c0021d9d <intr03_stub>:
c0021d9d:	55                   	push   %ebp
c0021d9e:	6a 00                	push   $0x0
c0021da0:	6a 03                	push   $0x3
c0021da2:	eb bb                	jmp    c0021d5f <intr_entry>

c0021da4 <intr04_stub>:
STUB(04, zero) STUB(05, zero) STUB(06, zero) STUB(07, zero)
c0021da4:	55                   	push   %ebp
c0021da5:	6a 00                	push   $0x0
c0021da7:	6a 04                	push   $0x4
c0021da9:	eb b4                	jmp    c0021d5f <intr_entry>

c0021dab <intr05_stub>:
c0021dab:	55                   	push   %ebp
c0021dac:	6a 00                	push   $0x0
c0021dae:	6a 05                	push   $0x5
c0021db0:	eb ad                	jmp    c0021d5f <intr_entry>

c0021db2 <intr06_stub>:
c0021db2:	55                   	push   %ebp
c0021db3:	6a 00                	push   $0x0
c0021db5:	6a 06                	push   $0x6
c0021db7:	eb a6                	jmp    c0021d5f <intr_entry>

c0021db9 <intr07_stub>:
c0021db9:	55                   	push   %ebp
c0021dba:	6a 00                	push   $0x0
c0021dbc:	6a 07                	push   $0x7
c0021dbe:	eb 9f                	jmp    c0021d5f <intr_entry>

c0021dc0 <intr08_stub>:
STUB(08, REAL) STUB(09, zero) STUB(0a, REAL) STUB(0b, REAL)
c0021dc0:	ff 34 24             	pushl  (%esp)
c0021dc3:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021dc7:	6a 08                	push   $0x8
c0021dc9:	eb 94                	jmp    c0021d5f <intr_entry>

c0021dcb <intr09_stub>:
c0021dcb:	55                   	push   %ebp
c0021dcc:	6a 00                	push   $0x0
c0021dce:	6a 09                	push   $0x9
c0021dd0:	eb 8d                	jmp    c0021d5f <intr_entry>

c0021dd2 <intr0a_stub>:
c0021dd2:	ff 34 24             	pushl  (%esp)
c0021dd5:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021dd9:	6a 0a                	push   $0xa
c0021ddb:	eb 82                	jmp    c0021d5f <intr_entry>

c0021ddd <intr0b_stub>:
c0021ddd:	ff 34 24             	pushl  (%esp)
c0021de0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021de4:	6a 0b                	push   $0xb
c0021de6:	e9 74 ff ff ff       	jmp    c0021d5f <intr_entry>

c0021deb <intr0c_stub>:
STUB(0c, zero) STUB(0d, REAL) STUB(0e, REAL) STUB(0f, zero)
c0021deb:	55                   	push   %ebp
c0021dec:	6a 00                	push   $0x0
c0021dee:	6a 0c                	push   $0xc
c0021df0:	e9 6a ff ff ff       	jmp    c0021d5f <intr_entry>

c0021df5 <intr0d_stub>:
c0021df5:	ff 34 24             	pushl  (%esp)
c0021df8:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021dfc:	6a 0d                	push   $0xd
c0021dfe:	e9 5c ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e03 <intr0e_stub>:
c0021e03:	ff 34 24             	pushl  (%esp)
c0021e06:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e0a:	6a 0e                	push   $0xe
c0021e0c:	e9 4e ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e11 <intr0f_stub>:
c0021e11:	55                   	push   %ebp
c0021e12:	6a 00                	push   $0x0
c0021e14:	6a 0f                	push   $0xf
c0021e16:	e9 44 ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e1b <intr10_stub>:

STUB(10, zero) STUB(11, REAL) STUB(12, zero) STUB(13, zero)
c0021e1b:	55                   	push   %ebp
c0021e1c:	6a 00                	push   $0x0
c0021e1e:	6a 10                	push   $0x10
c0021e20:	e9 3a ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e25 <intr11_stub>:
c0021e25:	ff 34 24             	pushl  (%esp)
c0021e28:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e2c:	6a 11                	push   $0x11
c0021e2e:	e9 2c ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e33 <intr12_stub>:
c0021e33:	55                   	push   %ebp
c0021e34:	6a 00                	push   $0x0
c0021e36:	6a 12                	push   $0x12
c0021e38:	e9 22 ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e3d <intr13_stub>:
c0021e3d:	55                   	push   %ebp
c0021e3e:	6a 00                	push   $0x0
c0021e40:	6a 13                	push   $0x13
c0021e42:	e9 18 ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e47 <intr14_stub>:
STUB(14, zero) STUB(15, zero) STUB(16, zero) STUB(17, zero)
c0021e47:	55                   	push   %ebp
c0021e48:	6a 00                	push   $0x0
c0021e4a:	6a 14                	push   $0x14
c0021e4c:	e9 0e ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e51 <intr15_stub>:
c0021e51:	55                   	push   %ebp
c0021e52:	6a 00                	push   $0x0
c0021e54:	6a 15                	push   $0x15
c0021e56:	e9 04 ff ff ff       	jmp    c0021d5f <intr_entry>

c0021e5b <intr16_stub>:
c0021e5b:	55                   	push   %ebp
c0021e5c:	6a 00                	push   $0x0
c0021e5e:	6a 16                	push   $0x16
c0021e60:	e9 fa fe ff ff       	jmp    c0021d5f <intr_entry>

c0021e65 <intr17_stub>:
c0021e65:	55                   	push   %ebp
c0021e66:	6a 00                	push   $0x0
c0021e68:	6a 17                	push   $0x17
c0021e6a:	e9 f0 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021e6f <intr18_stub>:
STUB(18, REAL) STUB(19, zero) STUB(1a, REAL) STUB(1b, REAL)
c0021e6f:	ff 34 24             	pushl  (%esp)
c0021e72:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e76:	6a 18                	push   $0x18
c0021e78:	e9 e2 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021e7d <intr19_stub>:
c0021e7d:	55                   	push   %ebp
c0021e7e:	6a 00                	push   $0x0
c0021e80:	6a 19                	push   $0x19
c0021e82:	e9 d8 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021e87 <intr1a_stub>:
c0021e87:	ff 34 24             	pushl  (%esp)
c0021e8a:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e8e:	6a 1a                	push   $0x1a
c0021e90:	e9 ca fe ff ff       	jmp    c0021d5f <intr_entry>

c0021e95 <intr1b_stub>:
c0021e95:	ff 34 24             	pushl  (%esp)
c0021e98:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021e9c:	6a 1b                	push   $0x1b
c0021e9e:	e9 bc fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ea3 <intr1c_stub>:
STUB(1c, zero) STUB(1d, REAL) STUB(1e, REAL) STUB(1f, zero)
c0021ea3:	55                   	push   %ebp
c0021ea4:	6a 00                	push   $0x0
c0021ea6:	6a 1c                	push   $0x1c
c0021ea8:	e9 b2 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ead <intr1d_stub>:
c0021ead:	ff 34 24             	pushl  (%esp)
c0021eb0:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021eb4:	6a 1d                	push   $0x1d
c0021eb6:	e9 a4 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ebb <intr1e_stub>:
c0021ebb:	ff 34 24             	pushl  (%esp)
c0021ebe:	89 6c 24 04          	mov    %ebp,0x4(%esp)
c0021ec2:	6a 1e                	push   $0x1e
c0021ec4:	e9 96 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ec9 <intr1f_stub>:
c0021ec9:	55                   	push   %ebp
c0021eca:	6a 00                	push   $0x0
c0021ecc:	6a 1f                	push   $0x1f
c0021ece:	e9 8c fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ed3 <intr20_stub>:

STUB(20, zero) STUB(21, zero) STUB(22, zero) STUB(23, zero)
c0021ed3:	55                   	push   %ebp
c0021ed4:	6a 00                	push   $0x0
c0021ed6:	6a 20                	push   $0x20
c0021ed8:	e9 82 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021edd <intr21_stub>:
c0021edd:	55                   	push   %ebp
c0021ede:	6a 00                	push   $0x0
c0021ee0:	6a 21                	push   $0x21
c0021ee2:	e9 78 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ee7 <intr22_stub>:
c0021ee7:	55                   	push   %ebp
c0021ee8:	6a 00                	push   $0x0
c0021eea:	6a 22                	push   $0x22
c0021eec:	e9 6e fe ff ff       	jmp    c0021d5f <intr_entry>

c0021ef1 <intr23_stub>:
c0021ef1:	55                   	push   %ebp
c0021ef2:	6a 00                	push   $0x0
c0021ef4:	6a 23                	push   $0x23
c0021ef6:	e9 64 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021efb <intr24_stub>:
STUB(24, zero) STUB(25, zero) STUB(26, zero) STUB(27, zero)
c0021efb:	55                   	push   %ebp
c0021efc:	6a 00                	push   $0x0
c0021efe:	6a 24                	push   $0x24
c0021f00:	e9 5a fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f05 <intr25_stub>:
c0021f05:	55                   	push   %ebp
c0021f06:	6a 00                	push   $0x0
c0021f08:	6a 25                	push   $0x25
c0021f0a:	e9 50 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f0f <intr26_stub>:
c0021f0f:	55                   	push   %ebp
c0021f10:	6a 00                	push   $0x0
c0021f12:	6a 26                	push   $0x26
c0021f14:	e9 46 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f19 <intr27_stub>:
c0021f19:	55                   	push   %ebp
c0021f1a:	6a 00                	push   $0x0
c0021f1c:	6a 27                	push   $0x27
c0021f1e:	e9 3c fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f23 <intr28_stub>:
STUB(28, zero) STUB(29, zero) STUB(2a, zero) STUB(2b, zero)
c0021f23:	55                   	push   %ebp
c0021f24:	6a 00                	push   $0x0
c0021f26:	6a 28                	push   $0x28
c0021f28:	e9 32 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f2d <intr29_stub>:
c0021f2d:	55                   	push   %ebp
c0021f2e:	6a 00                	push   $0x0
c0021f30:	6a 29                	push   $0x29
c0021f32:	e9 28 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f37 <intr2a_stub>:
c0021f37:	55                   	push   %ebp
c0021f38:	6a 00                	push   $0x0
c0021f3a:	6a 2a                	push   $0x2a
c0021f3c:	e9 1e fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f41 <intr2b_stub>:
c0021f41:	55                   	push   %ebp
c0021f42:	6a 00                	push   $0x0
c0021f44:	6a 2b                	push   $0x2b
c0021f46:	e9 14 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f4b <intr2c_stub>:
STUB(2c, zero) STUB(2d, zero) STUB(2e, zero) STUB(2f, zero)
c0021f4b:	55                   	push   %ebp
c0021f4c:	6a 00                	push   $0x0
c0021f4e:	6a 2c                	push   $0x2c
c0021f50:	e9 0a fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f55 <intr2d_stub>:
c0021f55:	55                   	push   %ebp
c0021f56:	6a 00                	push   $0x0
c0021f58:	6a 2d                	push   $0x2d
c0021f5a:	e9 00 fe ff ff       	jmp    c0021d5f <intr_entry>

c0021f5f <intr2e_stub>:
c0021f5f:	55                   	push   %ebp
c0021f60:	6a 00                	push   $0x0
c0021f62:	6a 2e                	push   $0x2e
c0021f64:	e9 f6 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f69 <intr2f_stub>:
c0021f69:	55                   	push   %ebp
c0021f6a:	6a 00                	push   $0x0
c0021f6c:	6a 2f                	push   $0x2f
c0021f6e:	e9 ec fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f73 <intr30_stub>:

STUB(30, zero) STUB(31, zero) STUB(32, zero) STUB(33, zero)
c0021f73:	55                   	push   %ebp
c0021f74:	6a 00                	push   $0x0
c0021f76:	6a 30                	push   $0x30
c0021f78:	e9 e2 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f7d <intr31_stub>:
c0021f7d:	55                   	push   %ebp
c0021f7e:	6a 00                	push   $0x0
c0021f80:	6a 31                	push   $0x31
c0021f82:	e9 d8 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f87 <intr32_stub>:
c0021f87:	55                   	push   %ebp
c0021f88:	6a 00                	push   $0x0
c0021f8a:	6a 32                	push   $0x32
c0021f8c:	e9 ce fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f91 <intr33_stub>:
c0021f91:	55                   	push   %ebp
c0021f92:	6a 00                	push   $0x0
c0021f94:	6a 33                	push   $0x33
c0021f96:	e9 c4 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021f9b <intr34_stub>:
STUB(34, zero) STUB(35, zero) STUB(36, zero) STUB(37, zero)
c0021f9b:	55                   	push   %ebp
c0021f9c:	6a 00                	push   $0x0
c0021f9e:	6a 34                	push   $0x34
c0021fa0:	e9 ba fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fa5 <intr35_stub>:
c0021fa5:	55                   	push   %ebp
c0021fa6:	6a 00                	push   $0x0
c0021fa8:	6a 35                	push   $0x35
c0021faa:	e9 b0 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021faf <intr36_stub>:
c0021faf:	55                   	push   %ebp
c0021fb0:	6a 00                	push   $0x0
c0021fb2:	6a 36                	push   $0x36
c0021fb4:	e9 a6 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fb9 <intr37_stub>:
c0021fb9:	55                   	push   %ebp
c0021fba:	6a 00                	push   $0x0
c0021fbc:	6a 37                	push   $0x37
c0021fbe:	e9 9c fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fc3 <intr38_stub>:
STUB(38, zero) STUB(39, zero) STUB(3a, zero) STUB(3b, zero)
c0021fc3:	55                   	push   %ebp
c0021fc4:	6a 00                	push   $0x0
c0021fc6:	6a 38                	push   $0x38
c0021fc8:	e9 92 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fcd <intr39_stub>:
c0021fcd:	55                   	push   %ebp
c0021fce:	6a 00                	push   $0x0
c0021fd0:	6a 39                	push   $0x39
c0021fd2:	e9 88 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fd7 <intr3a_stub>:
c0021fd7:	55                   	push   %ebp
c0021fd8:	6a 00                	push   $0x0
c0021fda:	6a 3a                	push   $0x3a
c0021fdc:	e9 7e fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fe1 <intr3b_stub>:
c0021fe1:	55                   	push   %ebp
c0021fe2:	6a 00                	push   $0x0
c0021fe4:	6a 3b                	push   $0x3b
c0021fe6:	e9 74 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021feb <intr3c_stub>:
STUB(3c, zero) STUB(3d, zero) STUB(3e, zero) STUB(3f, zero)
c0021feb:	55                   	push   %ebp
c0021fec:	6a 00                	push   $0x0
c0021fee:	6a 3c                	push   $0x3c
c0021ff0:	e9 6a fd ff ff       	jmp    c0021d5f <intr_entry>

c0021ff5 <intr3d_stub>:
c0021ff5:	55                   	push   %ebp
c0021ff6:	6a 00                	push   $0x0
c0021ff8:	6a 3d                	push   $0x3d
c0021ffa:	e9 60 fd ff ff       	jmp    c0021d5f <intr_entry>

c0021fff <intr3e_stub>:
c0021fff:	55                   	push   %ebp
c0022000:	6a 00                	push   $0x0
c0022002:	6a 3e                	push   $0x3e
c0022004:	e9 56 fd ff ff       	jmp    c0021d5f <intr_entry>

c0022009 <intr3f_stub>:
c0022009:	55                   	push   %ebp
c002200a:	6a 00                	push   $0x0
c002200c:	6a 3f                	push   $0x3f
c002200e:	e9 4c fd ff ff       	jmp    c0021d5f <intr_entry>

c0022013 <intr40_stub>:

STUB(40, zero) STUB(41, zero) STUB(42, zero) STUB(43, zero)
c0022013:	55                   	push   %ebp
c0022014:	6a 00                	push   $0x0
c0022016:	6a 40                	push   $0x40
c0022018:	e9 42 fd ff ff       	jmp    c0021d5f <intr_entry>

c002201d <intr41_stub>:
c002201d:	55                   	push   %ebp
c002201e:	6a 00                	push   $0x0
c0022020:	6a 41                	push   $0x41
c0022022:	e9 38 fd ff ff       	jmp    c0021d5f <intr_entry>

c0022027 <intr42_stub>:
c0022027:	55                   	push   %ebp
c0022028:	6a 00                	push   $0x0
c002202a:	6a 42                	push   $0x42
c002202c:	e9 2e fd ff ff       	jmp    c0021d5f <intr_entry>

c0022031 <intr43_stub>:
c0022031:	55                   	push   %ebp
c0022032:	6a 00                	push   $0x0
c0022034:	6a 43                	push   $0x43
c0022036:	e9 24 fd ff ff       	jmp    c0021d5f <intr_entry>

c002203b <intr44_stub>:
STUB(44, zero) STUB(45, zero) STUB(46, zero) STUB(47, zero)
c002203b:	55                   	push   %ebp
c002203c:	6a 00                	push   $0x0
c002203e:	6a 44                	push   $0x44
c0022040:	e9 1a fd ff ff       	jmp    c0021d5f <intr_entry>

c0022045 <intr45_stub>:
c0022045:	55                   	push   %ebp
c0022046:	6a 00                	push   $0x0
c0022048:	6a 45                	push   $0x45
c002204a:	e9 10 fd ff ff       	jmp    c0021d5f <intr_entry>

c002204f <intr46_stub>:
c002204f:	55                   	push   %ebp
c0022050:	6a 00                	push   $0x0
c0022052:	6a 46                	push   $0x46
c0022054:	e9 06 fd ff ff       	jmp    c0021d5f <intr_entry>

c0022059 <intr47_stub>:
c0022059:	55                   	push   %ebp
c002205a:	6a 00                	push   $0x0
c002205c:	6a 47                	push   $0x47
c002205e:	e9 fc fc ff ff       	jmp    c0021d5f <intr_entry>

c0022063 <intr48_stub>:
STUB(48, zero) STUB(49, zero) STUB(4a, zero) STUB(4b, zero)
c0022063:	55                   	push   %ebp
c0022064:	6a 00                	push   $0x0
c0022066:	6a 48                	push   $0x48
c0022068:	e9 f2 fc ff ff       	jmp    c0021d5f <intr_entry>

c002206d <intr49_stub>:
c002206d:	55                   	push   %ebp
c002206e:	6a 00                	push   $0x0
c0022070:	6a 49                	push   $0x49
c0022072:	e9 e8 fc ff ff       	jmp    c0021d5f <intr_entry>

c0022077 <intr4a_stub>:
c0022077:	55                   	push   %ebp
c0022078:	6a 00                	push   $0x0
c002207a:	6a 4a                	push   $0x4a
c002207c:	e9 de fc ff ff       	jmp    c0021d5f <intr_entry>

c0022081 <intr4b_stub>:
c0022081:	55                   	push   %ebp
c0022082:	6a 00                	push   $0x0
c0022084:	6a 4b                	push   $0x4b
c0022086:	e9 d4 fc ff ff       	jmp    c0021d5f <intr_entry>

c002208b <intr4c_stub>:
STUB(4c, zero) STUB(4d, zero) STUB(4e, zero) STUB(4f, zero)
c002208b:	55                   	push   %ebp
c002208c:	6a 00                	push   $0x0
c002208e:	6a 4c                	push   $0x4c
c0022090:	e9 ca fc ff ff       	jmp    c0021d5f <intr_entry>

c0022095 <intr4d_stub>:
c0022095:	55                   	push   %ebp
c0022096:	6a 00                	push   $0x0
c0022098:	6a 4d                	push   $0x4d
c002209a:	e9 c0 fc ff ff       	jmp    c0021d5f <intr_entry>

c002209f <intr4e_stub>:
c002209f:	55                   	push   %ebp
c00220a0:	6a 00                	push   $0x0
c00220a2:	6a 4e                	push   $0x4e
c00220a4:	e9 b6 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220a9 <intr4f_stub>:
c00220a9:	55                   	push   %ebp
c00220aa:	6a 00                	push   $0x0
c00220ac:	6a 4f                	push   $0x4f
c00220ae:	e9 ac fc ff ff       	jmp    c0021d5f <intr_entry>

c00220b3 <intr50_stub>:

STUB(50, zero) STUB(51, zero) STUB(52, zero) STUB(53, zero)
c00220b3:	55                   	push   %ebp
c00220b4:	6a 00                	push   $0x0
c00220b6:	6a 50                	push   $0x50
c00220b8:	e9 a2 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220bd <intr51_stub>:
c00220bd:	55                   	push   %ebp
c00220be:	6a 00                	push   $0x0
c00220c0:	6a 51                	push   $0x51
c00220c2:	e9 98 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220c7 <intr52_stub>:
c00220c7:	55                   	push   %ebp
c00220c8:	6a 00                	push   $0x0
c00220ca:	6a 52                	push   $0x52
c00220cc:	e9 8e fc ff ff       	jmp    c0021d5f <intr_entry>

c00220d1 <intr53_stub>:
c00220d1:	55                   	push   %ebp
c00220d2:	6a 00                	push   $0x0
c00220d4:	6a 53                	push   $0x53
c00220d6:	e9 84 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220db <intr54_stub>:
STUB(54, zero) STUB(55, zero) STUB(56, zero) STUB(57, zero)
c00220db:	55                   	push   %ebp
c00220dc:	6a 00                	push   $0x0
c00220de:	6a 54                	push   $0x54
c00220e0:	e9 7a fc ff ff       	jmp    c0021d5f <intr_entry>

c00220e5 <intr55_stub>:
c00220e5:	55                   	push   %ebp
c00220e6:	6a 00                	push   $0x0
c00220e8:	6a 55                	push   $0x55
c00220ea:	e9 70 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220ef <intr56_stub>:
c00220ef:	55                   	push   %ebp
c00220f0:	6a 00                	push   $0x0
c00220f2:	6a 56                	push   $0x56
c00220f4:	e9 66 fc ff ff       	jmp    c0021d5f <intr_entry>

c00220f9 <intr57_stub>:
c00220f9:	55                   	push   %ebp
c00220fa:	6a 00                	push   $0x0
c00220fc:	6a 57                	push   $0x57
c00220fe:	e9 5c fc ff ff       	jmp    c0021d5f <intr_entry>

c0022103 <intr58_stub>:
STUB(58, zero) STUB(59, zero) STUB(5a, zero) STUB(5b, zero)
c0022103:	55                   	push   %ebp
c0022104:	6a 00                	push   $0x0
c0022106:	6a 58                	push   $0x58
c0022108:	e9 52 fc ff ff       	jmp    c0021d5f <intr_entry>

c002210d <intr59_stub>:
c002210d:	55                   	push   %ebp
c002210e:	6a 00                	push   $0x0
c0022110:	6a 59                	push   $0x59
c0022112:	e9 48 fc ff ff       	jmp    c0021d5f <intr_entry>

c0022117 <intr5a_stub>:
c0022117:	55                   	push   %ebp
c0022118:	6a 00                	push   $0x0
c002211a:	6a 5a                	push   $0x5a
c002211c:	e9 3e fc ff ff       	jmp    c0021d5f <intr_entry>

c0022121 <intr5b_stub>:
c0022121:	55                   	push   %ebp
c0022122:	6a 00                	push   $0x0
c0022124:	6a 5b                	push   $0x5b
c0022126:	e9 34 fc ff ff       	jmp    c0021d5f <intr_entry>

c002212b <intr5c_stub>:
STUB(5c, zero) STUB(5d, zero) STUB(5e, zero) STUB(5f, zero)
c002212b:	55                   	push   %ebp
c002212c:	6a 00                	push   $0x0
c002212e:	6a 5c                	push   $0x5c
c0022130:	e9 2a fc ff ff       	jmp    c0021d5f <intr_entry>

c0022135 <intr5d_stub>:
c0022135:	55                   	push   %ebp
c0022136:	6a 00                	push   $0x0
c0022138:	6a 5d                	push   $0x5d
c002213a:	e9 20 fc ff ff       	jmp    c0021d5f <intr_entry>

c002213f <intr5e_stub>:
c002213f:	55                   	push   %ebp
c0022140:	6a 00                	push   $0x0
c0022142:	6a 5e                	push   $0x5e
c0022144:	e9 16 fc ff ff       	jmp    c0021d5f <intr_entry>

c0022149 <intr5f_stub>:
c0022149:	55                   	push   %ebp
c002214a:	6a 00                	push   $0x0
c002214c:	6a 5f                	push   $0x5f
c002214e:	e9 0c fc ff ff       	jmp    c0021d5f <intr_entry>

c0022153 <intr60_stub>:

STUB(60, zero) STUB(61, zero) STUB(62, zero) STUB(63, zero)
c0022153:	55                   	push   %ebp
c0022154:	6a 00                	push   $0x0
c0022156:	6a 60                	push   $0x60
c0022158:	e9 02 fc ff ff       	jmp    c0021d5f <intr_entry>

c002215d <intr61_stub>:
c002215d:	55                   	push   %ebp
c002215e:	6a 00                	push   $0x0
c0022160:	6a 61                	push   $0x61
c0022162:	e9 f8 fb ff ff       	jmp    c0021d5f <intr_entry>

c0022167 <intr62_stub>:
c0022167:	55                   	push   %ebp
c0022168:	6a 00                	push   $0x0
c002216a:	6a 62                	push   $0x62
c002216c:	e9 ee fb ff ff       	jmp    c0021d5f <intr_entry>

c0022171 <intr63_stub>:
c0022171:	55                   	push   %ebp
c0022172:	6a 00                	push   $0x0
c0022174:	6a 63                	push   $0x63
c0022176:	e9 e4 fb ff ff       	jmp    c0021d5f <intr_entry>

c002217b <intr64_stub>:
STUB(64, zero) STUB(65, zero) STUB(66, zero) STUB(67, zero)
c002217b:	55                   	push   %ebp
c002217c:	6a 00                	push   $0x0
c002217e:	6a 64                	push   $0x64
c0022180:	e9 da fb ff ff       	jmp    c0021d5f <intr_entry>

c0022185 <intr65_stub>:
c0022185:	55                   	push   %ebp
c0022186:	6a 00                	push   $0x0
c0022188:	6a 65                	push   $0x65
c002218a:	e9 d0 fb ff ff       	jmp    c0021d5f <intr_entry>

c002218f <intr66_stub>:
c002218f:	55                   	push   %ebp
c0022190:	6a 00                	push   $0x0
c0022192:	6a 66                	push   $0x66
c0022194:	e9 c6 fb ff ff       	jmp    c0021d5f <intr_entry>

c0022199 <intr67_stub>:
c0022199:	55                   	push   %ebp
c002219a:	6a 00                	push   $0x0
c002219c:	6a 67                	push   $0x67
c002219e:	e9 bc fb ff ff       	jmp    c0021d5f <intr_entry>

c00221a3 <intr68_stub>:
STUB(68, zero) STUB(69, zero) STUB(6a, zero) STUB(6b, zero)
c00221a3:	55                   	push   %ebp
c00221a4:	6a 00                	push   $0x0
c00221a6:	6a 68                	push   $0x68
c00221a8:	e9 b2 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221ad <intr69_stub>:
c00221ad:	55                   	push   %ebp
c00221ae:	6a 00                	push   $0x0
c00221b0:	6a 69                	push   $0x69
c00221b2:	e9 a8 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221b7 <intr6a_stub>:
c00221b7:	55                   	push   %ebp
c00221b8:	6a 00                	push   $0x0
c00221ba:	6a 6a                	push   $0x6a
c00221bc:	e9 9e fb ff ff       	jmp    c0021d5f <intr_entry>

c00221c1 <intr6b_stub>:
c00221c1:	55                   	push   %ebp
c00221c2:	6a 00                	push   $0x0
c00221c4:	6a 6b                	push   $0x6b
c00221c6:	e9 94 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221cb <intr6c_stub>:
STUB(6c, zero) STUB(6d, zero) STUB(6e, zero) STUB(6f, zero)
c00221cb:	55                   	push   %ebp
c00221cc:	6a 00                	push   $0x0
c00221ce:	6a 6c                	push   $0x6c
c00221d0:	e9 8a fb ff ff       	jmp    c0021d5f <intr_entry>

c00221d5 <intr6d_stub>:
c00221d5:	55                   	push   %ebp
c00221d6:	6a 00                	push   $0x0
c00221d8:	6a 6d                	push   $0x6d
c00221da:	e9 80 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221df <intr6e_stub>:
c00221df:	55                   	push   %ebp
c00221e0:	6a 00                	push   $0x0
c00221e2:	6a 6e                	push   $0x6e
c00221e4:	e9 76 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221e9 <intr6f_stub>:
c00221e9:	55                   	push   %ebp
c00221ea:	6a 00                	push   $0x0
c00221ec:	6a 6f                	push   $0x6f
c00221ee:	e9 6c fb ff ff       	jmp    c0021d5f <intr_entry>

c00221f3 <intr70_stub>:

STUB(70, zero) STUB(71, zero) STUB(72, zero) STUB(73, zero)
c00221f3:	55                   	push   %ebp
c00221f4:	6a 00                	push   $0x0
c00221f6:	6a 70                	push   $0x70
c00221f8:	e9 62 fb ff ff       	jmp    c0021d5f <intr_entry>

c00221fd <intr71_stub>:
c00221fd:	55                   	push   %ebp
c00221fe:	6a 00                	push   $0x0
c0022200:	6a 71                	push   $0x71
c0022202:	e9 58 fb ff ff       	jmp    c0021d5f <intr_entry>

c0022207 <intr72_stub>:
c0022207:	55                   	push   %ebp
c0022208:	6a 00                	push   $0x0
c002220a:	6a 72                	push   $0x72
c002220c:	e9 4e fb ff ff       	jmp    c0021d5f <intr_entry>

c0022211 <intr73_stub>:
c0022211:	55                   	push   %ebp
c0022212:	6a 00                	push   $0x0
c0022214:	6a 73                	push   $0x73
c0022216:	e9 44 fb ff ff       	jmp    c0021d5f <intr_entry>

c002221b <intr74_stub>:
STUB(74, zero) STUB(75, zero) STUB(76, zero) STUB(77, zero)
c002221b:	55                   	push   %ebp
c002221c:	6a 00                	push   $0x0
c002221e:	6a 74                	push   $0x74
c0022220:	e9 3a fb ff ff       	jmp    c0021d5f <intr_entry>

c0022225 <intr75_stub>:
c0022225:	55                   	push   %ebp
c0022226:	6a 00                	push   $0x0
c0022228:	6a 75                	push   $0x75
c002222a:	e9 30 fb ff ff       	jmp    c0021d5f <intr_entry>

c002222f <intr76_stub>:
c002222f:	55                   	push   %ebp
c0022230:	6a 00                	push   $0x0
c0022232:	6a 76                	push   $0x76
c0022234:	e9 26 fb ff ff       	jmp    c0021d5f <intr_entry>

c0022239 <intr77_stub>:
c0022239:	55                   	push   %ebp
c002223a:	6a 00                	push   $0x0
c002223c:	6a 77                	push   $0x77
c002223e:	e9 1c fb ff ff       	jmp    c0021d5f <intr_entry>

c0022243 <intr78_stub>:
STUB(78, zero) STUB(79, zero) STUB(7a, zero) STUB(7b, zero)
c0022243:	55                   	push   %ebp
c0022244:	6a 00                	push   $0x0
c0022246:	6a 78                	push   $0x78
c0022248:	e9 12 fb ff ff       	jmp    c0021d5f <intr_entry>

c002224d <intr79_stub>:
c002224d:	55                   	push   %ebp
c002224e:	6a 00                	push   $0x0
c0022250:	6a 79                	push   $0x79
c0022252:	e9 08 fb ff ff       	jmp    c0021d5f <intr_entry>

c0022257 <intr7a_stub>:
c0022257:	55                   	push   %ebp
c0022258:	6a 00                	push   $0x0
c002225a:	6a 7a                	push   $0x7a
c002225c:	e9 fe fa ff ff       	jmp    c0021d5f <intr_entry>

c0022261 <intr7b_stub>:
c0022261:	55                   	push   %ebp
c0022262:	6a 00                	push   $0x0
c0022264:	6a 7b                	push   $0x7b
c0022266:	e9 f4 fa ff ff       	jmp    c0021d5f <intr_entry>

c002226b <intr7c_stub>:
STUB(7c, zero) STUB(7d, zero) STUB(7e, zero) STUB(7f, zero)
c002226b:	55                   	push   %ebp
c002226c:	6a 00                	push   $0x0
c002226e:	6a 7c                	push   $0x7c
c0022270:	e9 ea fa ff ff       	jmp    c0021d5f <intr_entry>

c0022275 <intr7d_stub>:
c0022275:	55                   	push   %ebp
c0022276:	6a 00                	push   $0x0
c0022278:	6a 7d                	push   $0x7d
c002227a:	e9 e0 fa ff ff       	jmp    c0021d5f <intr_entry>

c002227f <intr7e_stub>:
c002227f:	55                   	push   %ebp
c0022280:	6a 00                	push   $0x0
c0022282:	6a 7e                	push   $0x7e
c0022284:	e9 d6 fa ff ff       	jmp    c0021d5f <intr_entry>

c0022289 <intr7f_stub>:
c0022289:	55                   	push   %ebp
c002228a:	6a 00                	push   $0x0
c002228c:	6a 7f                	push   $0x7f
c002228e:	e9 cc fa ff ff       	jmp    c0021d5f <intr_entry>

c0022293 <intr80_stub>:

STUB(80, zero) STUB(81, zero) STUB(82, zero) STUB(83, zero)
c0022293:	55                   	push   %ebp
c0022294:	6a 00                	push   $0x0
c0022296:	68 80 00 00 00       	push   $0x80
c002229b:	e9 bf fa ff ff       	jmp    c0021d5f <intr_entry>

c00222a0 <intr81_stub>:
c00222a0:	55                   	push   %ebp
c00222a1:	6a 00                	push   $0x0
c00222a3:	68 81 00 00 00       	push   $0x81
c00222a8:	e9 b2 fa ff ff       	jmp    c0021d5f <intr_entry>

c00222ad <intr82_stub>:
c00222ad:	55                   	push   %ebp
c00222ae:	6a 00                	push   $0x0
c00222b0:	68 82 00 00 00       	push   $0x82
c00222b5:	e9 a5 fa ff ff       	jmp    c0021d5f <intr_entry>

c00222ba <intr83_stub>:
c00222ba:	55                   	push   %ebp
c00222bb:	6a 00                	push   $0x0
c00222bd:	68 83 00 00 00       	push   $0x83
c00222c2:	e9 98 fa ff ff       	jmp    c0021d5f <intr_entry>

c00222c7 <intr84_stub>:
STUB(84, zero) STUB(85, zero) STUB(86, zero) STUB(87, zero)
c00222c7:	55                   	push   %ebp
c00222c8:	6a 00                	push   $0x0
c00222ca:	68 84 00 00 00       	push   $0x84
c00222cf:	e9 8b fa ff ff       	jmp    c0021d5f <intr_entry>

c00222d4 <intr85_stub>:
c00222d4:	55                   	push   %ebp
c00222d5:	6a 00                	push   $0x0
c00222d7:	68 85 00 00 00       	push   $0x85
c00222dc:	e9 7e fa ff ff       	jmp    c0021d5f <intr_entry>

c00222e1 <intr86_stub>:
c00222e1:	55                   	push   %ebp
c00222e2:	6a 00                	push   $0x0
c00222e4:	68 86 00 00 00       	push   $0x86
c00222e9:	e9 71 fa ff ff       	jmp    c0021d5f <intr_entry>

c00222ee <intr87_stub>:
c00222ee:	55                   	push   %ebp
c00222ef:	6a 00                	push   $0x0
c00222f1:	68 87 00 00 00       	push   $0x87
c00222f6:	e9 64 fa ff ff       	jmp    c0021d5f <intr_entry>

c00222fb <intr88_stub>:
STUB(88, zero) STUB(89, zero) STUB(8a, zero) STUB(8b, zero)
c00222fb:	55                   	push   %ebp
c00222fc:	6a 00                	push   $0x0
c00222fe:	68 88 00 00 00       	push   $0x88
c0022303:	e9 57 fa ff ff       	jmp    c0021d5f <intr_entry>

c0022308 <intr89_stub>:
c0022308:	55                   	push   %ebp
c0022309:	6a 00                	push   $0x0
c002230b:	68 89 00 00 00       	push   $0x89
c0022310:	e9 4a fa ff ff       	jmp    c0021d5f <intr_entry>

c0022315 <intr8a_stub>:
c0022315:	55                   	push   %ebp
c0022316:	6a 00                	push   $0x0
c0022318:	68 8a 00 00 00       	push   $0x8a
c002231d:	e9 3d fa ff ff       	jmp    c0021d5f <intr_entry>

c0022322 <intr8b_stub>:
c0022322:	55                   	push   %ebp
c0022323:	6a 00                	push   $0x0
c0022325:	68 8b 00 00 00       	push   $0x8b
c002232a:	e9 30 fa ff ff       	jmp    c0021d5f <intr_entry>

c002232f <intr8c_stub>:
STUB(8c, zero) STUB(8d, zero) STUB(8e, zero) STUB(8f, zero)
c002232f:	55                   	push   %ebp
c0022330:	6a 00                	push   $0x0
c0022332:	68 8c 00 00 00       	push   $0x8c
c0022337:	e9 23 fa ff ff       	jmp    c0021d5f <intr_entry>

c002233c <intr8d_stub>:
c002233c:	55                   	push   %ebp
c002233d:	6a 00                	push   $0x0
c002233f:	68 8d 00 00 00       	push   $0x8d
c0022344:	e9 16 fa ff ff       	jmp    c0021d5f <intr_entry>

c0022349 <intr8e_stub>:
c0022349:	55                   	push   %ebp
c002234a:	6a 00                	push   $0x0
c002234c:	68 8e 00 00 00       	push   $0x8e
c0022351:	e9 09 fa ff ff       	jmp    c0021d5f <intr_entry>

c0022356 <intr8f_stub>:
c0022356:	55                   	push   %ebp
c0022357:	6a 00                	push   $0x0
c0022359:	68 8f 00 00 00       	push   $0x8f
c002235e:	e9 fc f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022363 <intr90_stub>:

STUB(90, zero) STUB(91, zero) STUB(92, zero) STUB(93, zero)
c0022363:	55                   	push   %ebp
c0022364:	6a 00                	push   $0x0
c0022366:	68 90 00 00 00       	push   $0x90
c002236b:	e9 ef f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022370 <intr91_stub>:
c0022370:	55                   	push   %ebp
c0022371:	6a 00                	push   $0x0
c0022373:	68 91 00 00 00       	push   $0x91
c0022378:	e9 e2 f9 ff ff       	jmp    c0021d5f <intr_entry>

c002237d <intr92_stub>:
c002237d:	55                   	push   %ebp
c002237e:	6a 00                	push   $0x0
c0022380:	68 92 00 00 00       	push   $0x92
c0022385:	e9 d5 f9 ff ff       	jmp    c0021d5f <intr_entry>

c002238a <intr93_stub>:
c002238a:	55                   	push   %ebp
c002238b:	6a 00                	push   $0x0
c002238d:	68 93 00 00 00       	push   $0x93
c0022392:	e9 c8 f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022397 <intr94_stub>:
STUB(94, zero) STUB(95, zero) STUB(96, zero) STUB(97, zero)
c0022397:	55                   	push   %ebp
c0022398:	6a 00                	push   $0x0
c002239a:	68 94 00 00 00       	push   $0x94
c002239f:	e9 bb f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223a4 <intr95_stub>:
c00223a4:	55                   	push   %ebp
c00223a5:	6a 00                	push   $0x0
c00223a7:	68 95 00 00 00       	push   $0x95
c00223ac:	e9 ae f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223b1 <intr96_stub>:
c00223b1:	55                   	push   %ebp
c00223b2:	6a 00                	push   $0x0
c00223b4:	68 96 00 00 00       	push   $0x96
c00223b9:	e9 a1 f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223be <intr97_stub>:
c00223be:	55                   	push   %ebp
c00223bf:	6a 00                	push   $0x0
c00223c1:	68 97 00 00 00       	push   $0x97
c00223c6:	e9 94 f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223cb <intr98_stub>:
STUB(98, zero) STUB(99, zero) STUB(9a, zero) STUB(9b, zero)
c00223cb:	55                   	push   %ebp
c00223cc:	6a 00                	push   $0x0
c00223ce:	68 98 00 00 00       	push   $0x98
c00223d3:	e9 87 f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223d8 <intr99_stub>:
c00223d8:	55                   	push   %ebp
c00223d9:	6a 00                	push   $0x0
c00223db:	68 99 00 00 00       	push   $0x99
c00223e0:	e9 7a f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223e5 <intr9a_stub>:
c00223e5:	55                   	push   %ebp
c00223e6:	6a 00                	push   $0x0
c00223e8:	68 9a 00 00 00       	push   $0x9a
c00223ed:	e9 6d f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223f2 <intr9b_stub>:
c00223f2:	55                   	push   %ebp
c00223f3:	6a 00                	push   $0x0
c00223f5:	68 9b 00 00 00       	push   $0x9b
c00223fa:	e9 60 f9 ff ff       	jmp    c0021d5f <intr_entry>

c00223ff <intr9c_stub>:
STUB(9c, zero) STUB(9d, zero) STUB(9e, zero) STUB(9f, zero)
c00223ff:	55                   	push   %ebp
c0022400:	6a 00                	push   $0x0
c0022402:	68 9c 00 00 00       	push   $0x9c
c0022407:	e9 53 f9 ff ff       	jmp    c0021d5f <intr_entry>

c002240c <intr9d_stub>:
c002240c:	55                   	push   %ebp
c002240d:	6a 00                	push   $0x0
c002240f:	68 9d 00 00 00       	push   $0x9d
c0022414:	e9 46 f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022419 <intr9e_stub>:
c0022419:	55                   	push   %ebp
c002241a:	6a 00                	push   $0x0
c002241c:	68 9e 00 00 00       	push   $0x9e
c0022421:	e9 39 f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022426 <intr9f_stub>:
c0022426:	55                   	push   %ebp
c0022427:	6a 00                	push   $0x0
c0022429:	68 9f 00 00 00       	push   $0x9f
c002242e:	e9 2c f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022433 <intra0_stub>:

STUB(a0, zero) STUB(a1, zero) STUB(a2, zero) STUB(a3, zero)
c0022433:	55                   	push   %ebp
c0022434:	6a 00                	push   $0x0
c0022436:	68 a0 00 00 00       	push   $0xa0
c002243b:	e9 1f f9 ff ff       	jmp    c0021d5f <intr_entry>

c0022440 <intra1_stub>:
c0022440:	55                   	push   %ebp
c0022441:	6a 00                	push   $0x0
c0022443:	68 a1 00 00 00       	push   $0xa1
c0022448:	e9 12 f9 ff ff       	jmp    c0021d5f <intr_entry>

c002244d <intra2_stub>:
c002244d:	55                   	push   %ebp
c002244e:	6a 00                	push   $0x0
c0022450:	68 a2 00 00 00       	push   $0xa2
c0022455:	e9 05 f9 ff ff       	jmp    c0021d5f <intr_entry>

c002245a <intra3_stub>:
c002245a:	55                   	push   %ebp
c002245b:	6a 00                	push   $0x0
c002245d:	68 a3 00 00 00       	push   $0xa3
c0022462:	e9 f8 f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022467 <intra4_stub>:
STUB(a4, zero) STUB(a5, zero) STUB(a6, zero) STUB(a7, zero)
c0022467:	55                   	push   %ebp
c0022468:	6a 00                	push   $0x0
c002246a:	68 a4 00 00 00       	push   $0xa4
c002246f:	e9 eb f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022474 <intra5_stub>:
c0022474:	55                   	push   %ebp
c0022475:	6a 00                	push   $0x0
c0022477:	68 a5 00 00 00       	push   $0xa5
c002247c:	e9 de f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022481 <intra6_stub>:
c0022481:	55                   	push   %ebp
c0022482:	6a 00                	push   $0x0
c0022484:	68 a6 00 00 00       	push   $0xa6
c0022489:	e9 d1 f8 ff ff       	jmp    c0021d5f <intr_entry>

c002248e <intra7_stub>:
c002248e:	55                   	push   %ebp
c002248f:	6a 00                	push   $0x0
c0022491:	68 a7 00 00 00       	push   $0xa7
c0022496:	e9 c4 f8 ff ff       	jmp    c0021d5f <intr_entry>

c002249b <intra8_stub>:
STUB(a8, zero) STUB(a9, zero) STUB(aa, zero) STUB(ab, zero)
c002249b:	55                   	push   %ebp
c002249c:	6a 00                	push   $0x0
c002249e:	68 a8 00 00 00       	push   $0xa8
c00224a3:	e9 b7 f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224a8 <intra9_stub>:
c00224a8:	55                   	push   %ebp
c00224a9:	6a 00                	push   $0x0
c00224ab:	68 a9 00 00 00       	push   $0xa9
c00224b0:	e9 aa f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224b5 <intraa_stub>:
c00224b5:	55                   	push   %ebp
c00224b6:	6a 00                	push   $0x0
c00224b8:	68 aa 00 00 00       	push   $0xaa
c00224bd:	e9 9d f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224c2 <intrab_stub>:
c00224c2:	55                   	push   %ebp
c00224c3:	6a 00                	push   $0x0
c00224c5:	68 ab 00 00 00       	push   $0xab
c00224ca:	e9 90 f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224cf <intrac_stub>:
STUB(ac, zero) STUB(ad, zero) STUB(ae, zero) STUB(af, zero)
c00224cf:	55                   	push   %ebp
c00224d0:	6a 00                	push   $0x0
c00224d2:	68 ac 00 00 00       	push   $0xac
c00224d7:	e9 83 f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224dc <intrad_stub>:
c00224dc:	55                   	push   %ebp
c00224dd:	6a 00                	push   $0x0
c00224df:	68 ad 00 00 00       	push   $0xad
c00224e4:	e9 76 f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224e9 <intrae_stub>:
c00224e9:	55                   	push   %ebp
c00224ea:	6a 00                	push   $0x0
c00224ec:	68 ae 00 00 00       	push   $0xae
c00224f1:	e9 69 f8 ff ff       	jmp    c0021d5f <intr_entry>

c00224f6 <intraf_stub>:
c00224f6:	55                   	push   %ebp
c00224f7:	6a 00                	push   $0x0
c00224f9:	68 af 00 00 00       	push   $0xaf
c00224fe:	e9 5c f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022503 <intrb0_stub>:

STUB(b0, zero) STUB(b1, zero) STUB(b2, zero) STUB(b3, zero)
c0022503:	55                   	push   %ebp
c0022504:	6a 00                	push   $0x0
c0022506:	68 b0 00 00 00       	push   $0xb0
c002250b:	e9 4f f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022510 <intrb1_stub>:
c0022510:	55                   	push   %ebp
c0022511:	6a 00                	push   $0x0
c0022513:	68 b1 00 00 00       	push   $0xb1
c0022518:	e9 42 f8 ff ff       	jmp    c0021d5f <intr_entry>

c002251d <intrb2_stub>:
c002251d:	55                   	push   %ebp
c002251e:	6a 00                	push   $0x0
c0022520:	68 b2 00 00 00       	push   $0xb2
c0022525:	e9 35 f8 ff ff       	jmp    c0021d5f <intr_entry>

c002252a <intrb3_stub>:
c002252a:	55                   	push   %ebp
c002252b:	6a 00                	push   $0x0
c002252d:	68 b3 00 00 00       	push   $0xb3
c0022532:	e9 28 f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022537 <intrb4_stub>:
STUB(b4, zero) STUB(b5, zero) STUB(b6, zero) STUB(b7, zero)
c0022537:	55                   	push   %ebp
c0022538:	6a 00                	push   $0x0
c002253a:	68 b4 00 00 00       	push   $0xb4
c002253f:	e9 1b f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022544 <intrb5_stub>:
c0022544:	55                   	push   %ebp
c0022545:	6a 00                	push   $0x0
c0022547:	68 b5 00 00 00       	push   $0xb5
c002254c:	e9 0e f8 ff ff       	jmp    c0021d5f <intr_entry>

c0022551 <intrb6_stub>:
c0022551:	55                   	push   %ebp
c0022552:	6a 00                	push   $0x0
c0022554:	68 b6 00 00 00       	push   $0xb6
c0022559:	e9 01 f8 ff ff       	jmp    c0021d5f <intr_entry>

c002255e <intrb7_stub>:
c002255e:	55                   	push   %ebp
c002255f:	6a 00                	push   $0x0
c0022561:	68 b7 00 00 00       	push   $0xb7
c0022566:	e9 f4 f7 ff ff       	jmp    c0021d5f <intr_entry>

c002256b <intrb8_stub>:
STUB(b8, zero) STUB(b9, zero) STUB(ba, zero) STUB(bb, zero)
c002256b:	55                   	push   %ebp
c002256c:	6a 00                	push   $0x0
c002256e:	68 b8 00 00 00       	push   $0xb8
c0022573:	e9 e7 f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022578 <intrb9_stub>:
c0022578:	55                   	push   %ebp
c0022579:	6a 00                	push   $0x0
c002257b:	68 b9 00 00 00       	push   $0xb9
c0022580:	e9 da f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022585 <intrba_stub>:
c0022585:	55                   	push   %ebp
c0022586:	6a 00                	push   $0x0
c0022588:	68 ba 00 00 00       	push   $0xba
c002258d:	e9 cd f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022592 <intrbb_stub>:
c0022592:	55                   	push   %ebp
c0022593:	6a 00                	push   $0x0
c0022595:	68 bb 00 00 00       	push   $0xbb
c002259a:	e9 c0 f7 ff ff       	jmp    c0021d5f <intr_entry>

c002259f <intrbc_stub>:
STUB(bc, zero) STUB(bd, zero) STUB(be, zero) STUB(bf, zero)
c002259f:	55                   	push   %ebp
c00225a0:	6a 00                	push   $0x0
c00225a2:	68 bc 00 00 00       	push   $0xbc
c00225a7:	e9 b3 f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225ac <intrbd_stub>:
c00225ac:	55                   	push   %ebp
c00225ad:	6a 00                	push   $0x0
c00225af:	68 bd 00 00 00       	push   $0xbd
c00225b4:	e9 a6 f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225b9 <intrbe_stub>:
c00225b9:	55                   	push   %ebp
c00225ba:	6a 00                	push   $0x0
c00225bc:	68 be 00 00 00       	push   $0xbe
c00225c1:	e9 99 f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225c6 <intrbf_stub>:
c00225c6:	55                   	push   %ebp
c00225c7:	6a 00                	push   $0x0
c00225c9:	68 bf 00 00 00       	push   $0xbf
c00225ce:	e9 8c f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225d3 <intrc0_stub>:

STUB(c0, zero) STUB(c1, zero) STUB(c2, zero) STUB(c3, zero)
c00225d3:	55                   	push   %ebp
c00225d4:	6a 00                	push   $0x0
c00225d6:	68 c0 00 00 00       	push   $0xc0
c00225db:	e9 7f f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225e0 <intrc1_stub>:
c00225e0:	55                   	push   %ebp
c00225e1:	6a 00                	push   $0x0
c00225e3:	68 c1 00 00 00       	push   $0xc1
c00225e8:	e9 72 f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225ed <intrc2_stub>:
c00225ed:	55                   	push   %ebp
c00225ee:	6a 00                	push   $0x0
c00225f0:	68 c2 00 00 00       	push   $0xc2
c00225f5:	e9 65 f7 ff ff       	jmp    c0021d5f <intr_entry>

c00225fa <intrc3_stub>:
c00225fa:	55                   	push   %ebp
c00225fb:	6a 00                	push   $0x0
c00225fd:	68 c3 00 00 00       	push   $0xc3
c0022602:	e9 58 f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022607 <intrc4_stub>:
STUB(c4, zero) STUB(c5, zero) STUB(c6, zero) STUB(c7, zero)
c0022607:	55                   	push   %ebp
c0022608:	6a 00                	push   $0x0
c002260a:	68 c4 00 00 00       	push   $0xc4
c002260f:	e9 4b f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022614 <intrc5_stub>:
c0022614:	55                   	push   %ebp
c0022615:	6a 00                	push   $0x0
c0022617:	68 c5 00 00 00       	push   $0xc5
c002261c:	e9 3e f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022621 <intrc6_stub>:
c0022621:	55                   	push   %ebp
c0022622:	6a 00                	push   $0x0
c0022624:	68 c6 00 00 00       	push   $0xc6
c0022629:	e9 31 f7 ff ff       	jmp    c0021d5f <intr_entry>

c002262e <intrc7_stub>:
c002262e:	55                   	push   %ebp
c002262f:	6a 00                	push   $0x0
c0022631:	68 c7 00 00 00       	push   $0xc7
c0022636:	e9 24 f7 ff ff       	jmp    c0021d5f <intr_entry>

c002263b <intrc8_stub>:
STUB(c8, zero) STUB(c9, zero) STUB(ca, zero) STUB(cb, zero)
c002263b:	55                   	push   %ebp
c002263c:	6a 00                	push   $0x0
c002263e:	68 c8 00 00 00       	push   $0xc8
c0022643:	e9 17 f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022648 <intrc9_stub>:
c0022648:	55                   	push   %ebp
c0022649:	6a 00                	push   $0x0
c002264b:	68 c9 00 00 00       	push   $0xc9
c0022650:	e9 0a f7 ff ff       	jmp    c0021d5f <intr_entry>

c0022655 <intrca_stub>:
c0022655:	55                   	push   %ebp
c0022656:	6a 00                	push   $0x0
c0022658:	68 ca 00 00 00       	push   $0xca
c002265d:	e9 fd f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022662 <intrcb_stub>:
c0022662:	55                   	push   %ebp
c0022663:	6a 00                	push   $0x0
c0022665:	68 cb 00 00 00       	push   $0xcb
c002266a:	e9 f0 f6 ff ff       	jmp    c0021d5f <intr_entry>

c002266f <intrcc_stub>:
STUB(cc, zero) STUB(cd, zero) STUB(ce, zero) STUB(cf, zero)
c002266f:	55                   	push   %ebp
c0022670:	6a 00                	push   $0x0
c0022672:	68 cc 00 00 00       	push   $0xcc
c0022677:	e9 e3 f6 ff ff       	jmp    c0021d5f <intr_entry>

c002267c <intrcd_stub>:
c002267c:	55                   	push   %ebp
c002267d:	6a 00                	push   $0x0
c002267f:	68 cd 00 00 00       	push   $0xcd
c0022684:	e9 d6 f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022689 <intrce_stub>:
c0022689:	55                   	push   %ebp
c002268a:	6a 00                	push   $0x0
c002268c:	68 ce 00 00 00       	push   $0xce
c0022691:	e9 c9 f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022696 <intrcf_stub>:
c0022696:	55                   	push   %ebp
c0022697:	6a 00                	push   $0x0
c0022699:	68 cf 00 00 00       	push   $0xcf
c002269e:	e9 bc f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226a3 <intrd0_stub>:

STUB(d0, zero) STUB(d1, zero) STUB(d2, zero) STUB(d3, zero)
c00226a3:	55                   	push   %ebp
c00226a4:	6a 00                	push   $0x0
c00226a6:	68 d0 00 00 00       	push   $0xd0
c00226ab:	e9 af f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226b0 <intrd1_stub>:
c00226b0:	55                   	push   %ebp
c00226b1:	6a 00                	push   $0x0
c00226b3:	68 d1 00 00 00       	push   $0xd1
c00226b8:	e9 a2 f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226bd <intrd2_stub>:
c00226bd:	55                   	push   %ebp
c00226be:	6a 00                	push   $0x0
c00226c0:	68 d2 00 00 00       	push   $0xd2
c00226c5:	e9 95 f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226ca <intrd3_stub>:
c00226ca:	55                   	push   %ebp
c00226cb:	6a 00                	push   $0x0
c00226cd:	68 d3 00 00 00       	push   $0xd3
c00226d2:	e9 88 f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226d7 <intrd4_stub>:
STUB(d4, zero) STUB(d5, zero) STUB(d6, zero) STUB(d7, zero)
c00226d7:	55                   	push   %ebp
c00226d8:	6a 00                	push   $0x0
c00226da:	68 d4 00 00 00       	push   $0xd4
c00226df:	e9 7b f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226e4 <intrd5_stub>:
c00226e4:	55                   	push   %ebp
c00226e5:	6a 00                	push   $0x0
c00226e7:	68 d5 00 00 00       	push   $0xd5
c00226ec:	e9 6e f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226f1 <intrd6_stub>:
c00226f1:	55                   	push   %ebp
c00226f2:	6a 00                	push   $0x0
c00226f4:	68 d6 00 00 00       	push   $0xd6
c00226f9:	e9 61 f6 ff ff       	jmp    c0021d5f <intr_entry>

c00226fe <intrd7_stub>:
c00226fe:	55                   	push   %ebp
c00226ff:	6a 00                	push   $0x0
c0022701:	68 d7 00 00 00       	push   $0xd7
c0022706:	e9 54 f6 ff ff       	jmp    c0021d5f <intr_entry>

c002270b <intrd8_stub>:
STUB(d8, zero) STUB(d9, zero) STUB(da, zero) STUB(db, zero)
c002270b:	55                   	push   %ebp
c002270c:	6a 00                	push   $0x0
c002270e:	68 d8 00 00 00       	push   $0xd8
c0022713:	e9 47 f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022718 <intrd9_stub>:
c0022718:	55                   	push   %ebp
c0022719:	6a 00                	push   $0x0
c002271b:	68 d9 00 00 00       	push   $0xd9
c0022720:	e9 3a f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022725 <intrda_stub>:
c0022725:	55                   	push   %ebp
c0022726:	6a 00                	push   $0x0
c0022728:	68 da 00 00 00       	push   $0xda
c002272d:	e9 2d f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022732 <intrdb_stub>:
c0022732:	55                   	push   %ebp
c0022733:	6a 00                	push   $0x0
c0022735:	68 db 00 00 00       	push   $0xdb
c002273a:	e9 20 f6 ff ff       	jmp    c0021d5f <intr_entry>

c002273f <intrdc_stub>:
STUB(dc, zero) STUB(dd, zero) STUB(de, zero) STUB(df, zero)
c002273f:	55                   	push   %ebp
c0022740:	6a 00                	push   $0x0
c0022742:	68 dc 00 00 00       	push   $0xdc
c0022747:	e9 13 f6 ff ff       	jmp    c0021d5f <intr_entry>

c002274c <intrdd_stub>:
c002274c:	55                   	push   %ebp
c002274d:	6a 00                	push   $0x0
c002274f:	68 dd 00 00 00       	push   $0xdd
c0022754:	e9 06 f6 ff ff       	jmp    c0021d5f <intr_entry>

c0022759 <intrde_stub>:
c0022759:	55                   	push   %ebp
c002275a:	6a 00                	push   $0x0
c002275c:	68 de 00 00 00       	push   $0xde
c0022761:	e9 f9 f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022766 <intrdf_stub>:
c0022766:	55                   	push   %ebp
c0022767:	6a 00                	push   $0x0
c0022769:	68 df 00 00 00       	push   $0xdf
c002276e:	e9 ec f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022773 <intre0_stub>:

STUB(e0, zero) STUB(e1, zero) STUB(e2, zero) STUB(e3, zero)
c0022773:	55                   	push   %ebp
c0022774:	6a 00                	push   $0x0
c0022776:	68 e0 00 00 00       	push   $0xe0
c002277b:	e9 df f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022780 <intre1_stub>:
c0022780:	55                   	push   %ebp
c0022781:	6a 00                	push   $0x0
c0022783:	68 e1 00 00 00       	push   $0xe1
c0022788:	e9 d2 f5 ff ff       	jmp    c0021d5f <intr_entry>

c002278d <intre2_stub>:
c002278d:	55                   	push   %ebp
c002278e:	6a 00                	push   $0x0
c0022790:	68 e2 00 00 00       	push   $0xe2
c0022795:	e9 c5 f5 ff ff       	jmp    c0021d5f <intr_entry>

c002279a <intre3_stub>:
c002279a:	55                   	push   %ebp
c002279b:	6a 00                	push   $0x0
c002279d:	68 e3 00 00 00       	push   $0xe3
c00227a2:	e9 b8 f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227a7 <intre4_stub>:
STUB(e4, zero) STUB(e5, zero) STUB(e6, zero) STUB(e7, zero)
c00227a7:	55                   	push   %ebp
c00227a8:	6a 00                	push   $0x0
c00227aa:	68 e4 00 00 00       	push   $0xe4
c00227af:	e9 ab f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227b4 <intre5_stub>:
c00227b4:	55                   	push   %ebp
c00227b5:	6a 00                	push   $0x0
c00227b7:	68 e5 00 00 00       	push   $0xe5
c00227bc:	e9 9e f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227c1 <intre6_stub>:
c00227c1:	55                   	push   %ebp
c00227c2:	6a 00                	push   $0x0
c00227c4:	68 e6 00 00 00       	push   $0xe6
c00227c9:	e9 91 f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227ce <intre7_stub>:
c00227ce:	55                   	push   %ebp
c00227cf:	6a 00                	push   $0x0
c00227d1:	68 e7 00 00 00       	push   $0xe7
c00227d6:	e9 84 f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227db <intre8_stub>:
STUB(e8, zero) STUB(e9, zero) STUB(ea, zero) STUB(eb, zero)
c00227db:	55                   	push   %ebp
c00227dc:	6a 00                	push   $0x0
c00227de:	68 e8 00 00 00       	push   $0xe8
c00227e3:	e9 77 f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227e8 <intre9_stub>:
c00227e8:	55                   	push   %ebp
c00227e9:	6a 00                	push   $0x0
c00227eb:	68 e9 00 00 00       	push   $0xe9
c00227f0:	e9 6a f5 ff ff       	jmp    c0021d5f <intr_entry>

c00227f5 <intrea_stub>:
c00227f5:	55                   	push   %ebp
c00227f6:	6a 00                	push   $0x0
c00227f8:	68 ea 00 00 00       	push   $0xea
c00227fd:	e9 5d f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022802 <intreb_stub>:
c0022802:	55                   	push   %ebp
c0022803:	6a 00                	push   $0x0
c0022805:	68 eb 00 00 00       	push   $0xeb
c002280a:	e9 50 f5 ff ff       	jmp    c0021d5f <intr_entry>

c002280f <intrec_stub>:
STUB(ec, zero) STUB(ed, zero) STUB(ee, zero) STUB(ef, zero)
c002280f:	55                   	push   %ebp
c0022810:	6a 00                	push   $0x0
c0022812:	68 ec 00 00 00       	push   $0xec
c0022817:	e9 43 f5 ff ff       	jmp    c0021d5f <intr_entry>

c002281c <intred_stub>:
c002281c:	55                   	push   %ebp
c002281d:	6a 00                	push   $0x0
c002281f:	68 ed 00 00 00       	push   $0xed
c0022824:	e9 36 f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022829 <intree_stub>:
c0022829:	55                   	push   %ebp
c002282a:	6a 00                	push   $0x0
c002282c:	68 ee 00 00 00       	push   $0xee
c0022831:	e9 29 f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022836 <intref_stub>:
c0022836:	55                   	push   %ebp
c0022837:	6a 00                	push   $0x0
c0022839:	68 ef 00 00 00       	push   $0xef
c002283e:	e9 1c f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022843 <intrf0_stub>:

STUB(f0, zero) STUB(f1, zero) STUB(f2, zero) STUB(f3, zero)
c0022843:	55                   	push   %ebp
c0022844:	6a 00                	push   $0x0
c0022846:	68 f0 00 00 00       	push   $0xf0
c002284b:	e9 0f f5 ff ff       	jmp    c0021d5f <intr_entry>

c0022850 <intrf1_stub>:
c0022850:	55                   	push   %ebp
c0022851:	6a 00                	push   $0x0
c0022853:	68 f1 00 00 00       	push   $0xf1
c0022858:	e9 02 f5 ff ff       	jmp    c0021d5f <intr_entry>

c002285d <intrf2_stub>:
c002285d:	55                   	push   %ebp
c002285e:	6a 00                	push   $0x0
c0022860:	68 f2 00 00 00       	push   $0xf2
c0022865:	e9 f5 f4 ff ff       	jmp    c0021d5f <intr_entry>

c002286a <intrf3_stub>:
c002286a:	55                   	push   %ebp
c002286b:	6a 00                	push   $0x0
c002286d:	68 f3 00 00 00       	push   $0xf3
c0022872:	e9 e8 f4 ff ff       	jmp    c0021d5f <intr_entry>

c0022877 <intrf4_stub>:
STUB(f4, zero) STUB(f5, zero) STUB(f6, zero) STUB(f7, zero)
c0022877:	55                   	push   %ebp
c0022878:	6a 00                	push   $0x0
c002287a:	68 f4 00 00 00       	push   $0xf4
c002287f:	e9 db f4 ff ff       	jmp    c0021d5f <intr_entry>

c0022884 <intrf5_stub>:
c0022884:	55                   	push   %ebp
c0022885:	6a 00                	push   $0x0
c0022887:	68 f5 00 00 00       	push   $0xf5
c002288c:	e9 ce f4 ff ff       	jmp    c0021d5f <intr_entry>

c0022891 <intrf6_stub>:
c0022891:	55                   	push   %ebp
c0022892:	6a 00                	push   $0x0
c0022894:	68 f6 00 00 00       	push   $0xf6
c0022899:	e9 c1 f4 ff ff       	jmp    c0021d5f <intr_entry>

c002289e <intrf7_stub>:
c002289e:	55                   	push   %ebp
c002289f:	6a 00                	push   $0x0
c00228a1:	68 f7 00 00 00       	push   $0xf7
c00228a6:	e9 b4 f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228ab <intrf8_stub>:
STUB(f8, zero) STUB(f9, zero) STUB(fa, zero) STUB(fb, zero)
c00228ab:	55                   	push   %ebp
c00228ac:	6a 00                	push   $0x0
c00228ae:	68 f8 00 00 00       	push   $0xf8
c00228b3:	e9 a7 f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228b8 <intrf9_stub>:
c00228b8:	55                   	push   %ebp
c00228b9:	6a 00                	push   $0x0
c00228bb:	68 f9 00 00 00       	push   $0xf9
c00228c0:	e9 9a f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228c5 <intrfa_stub>:
c00228c5:	55                   	push   %ebp
c00228c6:	6a 00                	push   $0x0
c00228c8:	68 fa 00 00 00       	push   $0xfa
c00228cd:	e9 8d f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228d2 <intrfb_stub>:
c00228d2:	55                   	push   %ebp
c00228d3:	6a 00                	push   $0x0
c00228d5:	68 fb 00 00 00       	push   $0xfb
c00228da:	e9 80 f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228df <intrfc_stub>:
STUB(fc, zero) STUB(fd, zero) STUB(fe, zero) STUB(ff, zero)
c00228df:	55                   	push   %ebp
c00228e0:	6a 00                	push   $0x0
c00228e2:	68 fc 00 00 00       	push   $0xfc
c00228e7:	e9 73 f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228ec <intrfd_stub>:
c00228ec:	55                   	push   %ebp
c00228ed:	6a 00                	push   $0x0
c00228ef:	68 fd 00 00 00       	push   $0xfd
c00228f4:	e9 66 f4 ff ff       	jmp    c0021d5f <intr_entry>

c00228f9 <intrfe_stub>:
c00228f9:	55                   	push   %ebp
c00228fa:	6a 00                	push   $0x0
c00228fc:	68 fe 00 00 00       	push   $0xfe
c0022901:	e9 59 f4 ff ff       	jmp    c0021d5f <intr_entry>

c0022906 <intrff_stub>:
c0022906:	55                   	push   %ebp
c0022907:	6a 00                	push   $0x0
c0022909:	68 ff 00 00 00       	push   $0xff
c002290e:	e9 4c f4 ff ff       	jmp    c0021d5f <intr_entry>

c0022913 <priority_compare>:
#include "threads/thread.h"

#define DEPTH_LIMIT 8

//used for comparing threads by donated_priority - for sorting & scheduling
static bool priority_compare(struct list_elem* a, struct list_elem* b, void* aux UNUSED){
c0022913:	55                   	push   %ebp
c0022914:	89 e5                	mov    %esp,%ebp
c0022916:	56                   	push   %esi
c0022917:	53                   	push   %ebx
  return list_entry(a, struct thread, elem)->donated_priority > list_entry(b, struct thread, elem)->donated_priority;
c0022918:	8b 45 08             	mov    0x8(%ebp),%eax
c002291b:	83 c0 04             	add    $0x4,%eax
c002291e:	83 e8 2c             	sub    $0x2c,%eax
c0022921:	8b 48 38             	mov    0x38(%eax),%ecx
c0022924:	8b 58 3c             	mov    0x3c(%eax),%ebx
c0022927:	8b 45 0c             	mov    0xc(%ebp),%eax
c002292a:	83 c0 04             	add    $0x4,%eax
c002292d:	83 e8 2c             	sub    $0x2c,%eax
c0022930:	8b 50 3c             	mov    0x3c(%eax),%edx
c0022933:	8b 40 38             	mov    0x38(%eax),%eax
c0022936:	be 01 00 00 00       	mov    $0x1,%esi
c002293b:	39 d3                	cmp    %edx,%ebx
c002293d:	7f 0d                	jg     c002294c <priority_compare+0x39>
c002293f:	39 d3                	cmp    %edx,%ebx
c0022941:	7c 04                	jl     c0022947 <priority_compare+0x34>
c0022943:	39 c1                	cmp    %eax,%ecx
c0022945:	77 05                	ja     c002294c <priority_compare+0x39>
c0022947:	be 00 00 00 00       	mov    $0x0,%esi
c002294c:	89 f0                	mov    %esi,%eax
}
c002294e:	5b                   	pop    %ebx
c002294f:	5e                   	pop    %esi
c0022950:	5d                   	pop    %ebp
c0022951:	c3                   	ret    

c0022952 <cond_compare>:

//used to compare elements in the condition waiters list by their associated donated_priority
static bool cond_compare(struct list_elem* a, struct list_elem* b, void* aux UNUSED){
c0022952:	55                   	push   %ebp
c0022953:	89 e5                	mov    %esp,%ebp
c0022955:	56                   	push   %esi
c0022956:	53                   	push   %ebx
  return list_entry(a, struct semaphore_elem, elem)->donated_priority > list_entry(b, struct semaphore_elem, elem)->donated_priority;
c0022957:	8b 45 08             	mov    0x8(%ebp),%eax
c002295a:	83 c0 04             	add    $0x4,%eax
c002295d:	83 e8 04             	sub    $0x4,%eax
c0022960:	8b 48 1c             	mov    0x1c(%eax),%ecx
c0022963:	8b 58 20             	mov    0x20(%eax),%ebx
c0022966:	8b 45 0c             	mov    0xc(%ebp),%eax
c0022969:	83 c0 04             	add    $0x4,%eax
c002296c:	83 e8 04             	sub    $0x4,%eax
c002296f:	8b 50 20             	mov    0x20(%eax),%edx
c0022972:	8b 40 1c             	mov    0x1c(%eax),%eax
c0022975:	be 01 00 00 00       	mov    $0x1,%esi
c002297a:	39 d3                	cmp    %edx,%ebx
c002297c:	77 0d                	ja     c002298b <cond_compare+0x39>
c002297e:	39 d3                	cmp    %edx,%ebx
c0022980:	72 04                	jb     c0022986 <cond_compare+0x34>
c0022982:	39 c1                	cmp    %eax,%ecx
c0022984:	77 05                	ja     c002298b <cond_compare+0x39>
c0022986:	be 00 00 00 00       	mov    $0x0,%esi
c002298b:	89 f0                	mov    %esi,%eax
}
c002298d:	5b                   	pop    %ebx
c002298e:	5e                   	pop    %esi
c002298f:	5d                   	pop    %ebp
c0022990:	c3                   	ret    

c0022991 <sema_init>:

   - up or "V": increment the value (and wake up one waiting
     thread, if any). */
void
sema_init (struct semaphore *sema, unsigned value) 
{
c0022991:	55                   	push   %ebp
c0022992:	89 e5                	mov    %esp,%ebp
c0022994:	83 ec 08             	sub    $0x8,%esp
  ASSERT (sema != NULL);
c0022997:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002299b:	75 1e                	jne    c00229bb <sema_init+0x2a>
c002299d:	83 ec 0c             	sub    $0xc,%esp
c00229a0:	68 4c f6 02 c0       	push   $0xc002f64c
c00229a5:	68 59 f6 02 c0       	push   $0xc002f659
c00229aa:	68 20 f7 02 c0       	push   $0xc002f720
c00229af:	6a 3b                	push   $0x3b
c00229b1:	68 70 f6 02 c0       	push   $0xc002f670
c00229b6:	e8 60 72 00 00       	call   c0029c1b <debug_panic>

  sema->value = value;
c00229bb:	8b 45 08             	mov    0x8(%ebp),%eax
c00229be:	8b 55 0c             	mov    0xc(%ebp),%edx
c00229c1:	89 10                	mov    %edx,(%eax)
  list_init (&sema->waiters);
c00229c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00229c6:	83 c0 04             	add    $0x4,%eax
c00229c9:	83 ec 0c             	sub    $0xc,%esp
c00229cc:	50                   	push   %eax
c00229cd:	e8 bc 74 00 00       	call   c0029e8e <list_init>
c00229d2:	83 c4 10             	add    $0x10,%esp
}
c00229d5:	90                   	nop
c00229d6:	c9                   	leave  
c00229d7:	c3                   	ret    

c00229d8 <sema_down>:
   interrupt handler.  This function may be called with
   interrupts disabled, but if it sleeps then the next scheduled
   thread will probably turn interrupts back on. */
void
sema_down (struct semaphore *sema) 
{
c00229d8:	55                   	push   %ebp
c00229d9:	89 e5                	mov    %esp,%ebp
c00229db:	83 ec 18             	sub    $0x18,%esp
  ASSERT (sema != NULL);
c00229de:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00229e2:	75 1e                	jne    c0022a02 <sema_down+0x2a>
c00229e4:	83 ec 0c             	sub    $0xc,%esp
c00229e7:	68 4c f6 02 c0       	push   $0xc002f64c
c00229ec:	68 59 f6 02 c0       	push   $0xc002f659
c00229f1:	68 2c f7 02 c0       	push   $0xc002f72c
c00229f6:	6a 4b                	push   $0x4b
c00229f8:	68 70 f6 02 c0       	push   $0xc002f670
c00229fd:	e8 19 72 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!intr_context ());
c0022a02:	e8 cf ed ff ff       	call   c00217d6 <intr_context>
c0022a07:	83 f0 01             	xor    $0x1,%eax
c0022a0a:	84 c0                	test   %al,%al
c0022a0c:	75 1e                	jne    c0022a2c <sema_down+0x54>
c0022a0e:	83 ec 0c             	sub    $0xc,%esp
c0022a11:	68 86 f6 02 c0       	push   $0xc002f686
c0022a16:	68 59 f6 02 c0       	push   $0xc002f659
c0022a1b:	68 2c f7 02 c0       	push   $0xc002f72c
c0022a20:	6a 4c                	push   $0x4c
c0022a22:	68 70 f6 02 c0       	push   $0xc002f670
c0022a27:	e8 ef 71 00 00       	call   c0029c1b <debug_panic>

  enum intr_level old_level;
  old_level = intr_disable ();
c0022a2c:	e8 d6 ea ff ff       	call   c0021507 <intr_disable>
c0022a31:	89 45 f4             	mov    %eax,-0xc(%ebp)

  while (sema->value == 0) 
c0022a34:	eb 20                	jmp    c0022a56 <sema_down+0x7e>
    {
      
      list_push_back (&sema->waiters, &thread_current ()->elem);
c0022a36:	e8 b1 e2 ff ff       	call   c0020cec <thread_current>
c0022a3b:	8d 50 28             	lea    0x28(%eax),%edx
c0022a3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a41:	83 c0 04             	add    $0x4,%eax
c0022a44:	83 ec 08             	sub    $0x8,%esp
c0022a47:	52                   	push   %edx
c0022a48:	50                   	push   %eax
c0022a49:	e8 20 78 00 00       	call   c002a26e <list_push_back>
c0022a4e:	83 c4 10             	add    $0x10,%esp
      thread_block ();
c0022a51:	e8 76 e1 ff ff       	call   c0020bcc <thread_block>
  ASSERT (!intr_context ());

  enum intr_level old_level;
  old_level = intr_disable ();

  while (sema->value == 0) 
c0022a56:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a59:	8b 00                	mov    (%eax),%eax
c0022a5b:	85 c0                	test   %eax,%eax
c0022a5d:	74 d7                	je     c0022a36 <sema_down+0x5e>
      
      list_push_back (&sema->waiters, &thread_current ()->elem);
      thread_block ();
    }

  sema->value--;
c0022a5f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a62:	8b 00                	mov    (%eax),%eax
c0022a64:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022a67:	8b 45 08             	mov    0x8(%ebp),%eax
c0022a6a:	89 10                	mov    %edx,(%eax)
  intr_set_level (old_level);
c0022a6c:	83 ec 0c             	sub    $0xc,%esp
c0022a6f:	ff 75 f4             	pushl  -0xc(%ebp)
c0022a72:	e8 38 ea ff ff       	call   c00214af <intr_set_level>
c0022a77:	83 c4 10             	add    $0x10,%esp
}
c0022a7a:	90                   	nop
c0022a7b:	c9                   	leave  
c0022a7c:	c3                   	ret    

c0022a7d <sema_try_down>:
   decremented, false otherwise.

   This function may be called from an interrupt handler. */
bool
sema_try_down (struct semaphore *sema) 
{
c0022a7d:	55                   	push   %ebp
c0022a7e:	89 e5                	mov    %esp,%ebp
c0022a80:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  bool success;

  ASSERT (sema != NULL);
c0022a83:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022a87:	75 1e                	jne    c0022aa7 <sema_try_down+0x2a>
c0022a89:	83 ec 0c             	sub    $0xc,%esp
c0022a8c:	68 4c f6 02 c0       	push   $0xc002f64c
c0022a91:	68 59 f6 02 c0       	push   $0xc002f659
c0022a96:	68 38 f7 02 c0       	push   $0xc002f738
c0022a9b:	6a 67                	push   $0x67
c0022a9d:	68 70 f6 02 c0       	push   $0xc002f670
c0022aa2:	e8 74 71 00 00       	call   c0029c1b <debug_panic>

  old_level = intr_disable ();
c0022aa7:	e8 5b ea ff ff       	call   c0021507 <intr_disable>
c0022aac:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (sema->value > 0) 
c0022aaf:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ab2:	8b 00                	mov    (%eax),%eax
c0022ab4:	85 c0                	test   %eax,%eax
c0022ab6:	74 13                	je     c0022acb <sema_try_down+0x4e>
    {
      sema->value--;
c0022ab8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022abb:	8b 00                	mov    (%eax),%eax
c0022abd:	8d 50 ff             	lea    -0x1(%eax),%edx
c0022ac0:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ac3:	89 10                	mov    %edx,(%eax)
      success = true; 
c0022ac5:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
c0022ac9:	eb 04                	jmp    c0022acf <sema_try_down+0x52>
    }
  else
    success = false;
c0022acb:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  intr_set_level (old_level);
c0022acf:	83 ec 0c             	sub    $0xc,%esp
c0022ad2:	ff 75 f0             	pushl  -0x10(%ebp)
c0022ad5:	e8 d5 e9 ff ff       	call   c00214af <intr_set_level>
c0022ada:	83 c4 10             	add    $0x10,%esp

  return success;
c0022add:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0022ae1:	c9                   	leave  
c0022ae2:	c3                   	ret    

c0022ae3 <sema_up>:
   and wakes up one thread of those waiting for SEMA, if any.

   This function may be called from an interrupt handler. */
void
sema_up (struct semaphore *sema) 
{
c0022ae3:	55                   	push   %ebp
c0022ae4:	89 e5                	mov    %esp,%ebp
c0022ae6:	56                   	push   %esi
c0022ae7:	53                   	push   %ebx
c0022ae8:	83 ec 10             	sub    $0x10,%esp
  ASSERT (sema != NULL);
c0022aeb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022aef:	75 1e                	jne    c0022b0f <sema_up+0x2c>
c0022af1:	83 ec 0c             	sub    $0xc,%esp
c0022af4:	68 4c f6 02 c0       	push   $0xc002f64c
c0022af9:	68 59 f6 02 c0       	push   $0xc002f659
c0022afe:	68 48 f7 02 c0       	push   $0xc002f748
c0022b03:	6a 7d                	push   $0x7d
c0022b05:	68 70 f6 02 c0       	push   $0xc002f670
c0022b0a:	e8 0c 71 00 00       	call   c0029c1b <debug_panic>
  enum intr_level old_level;
  old_level = intr_disable ();
c0022b0f:	e8 f3 e9 ff ff       	call   c0021507 <intr_disable>
c0022b14:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema->value++;
c0022b17:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b1a:	8b 00                	mov    (%eax),%eax
c0022b1c:	8d 50 01             	lea    0x1(%eax),%edx
c0022b1f:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b22:	89 10                	mov    %edx,(%eax)

  if (!list_empty (&sema->waiters)) {
c0022b24:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b27:	83 c0 04             	add    $0x4,%eax
c0022b2a:	83 ec 0c             	sub    $0xc,%esp
c0022b2d:	50                   	push   %eax
c0022b2e:	e8 e3 78 00 00       	call   c002a416 <list_empty>
c0022b33:	83 c4 10             	add    $0x10,%esp
c0022b36:	83 f0 01             	xor    $0x1,%eax
c0022b39:	84 c0                	test   %al,%al
c0022b3b:	74 67                	je     c0022ba4 <sema_up+0xc1>
    //make sure the thread with the highest priority is being woken up
    list_sort(&sema->waiters, (list_less_func*)&priority_compare, NULL);
c0022b3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b40:	83 c0 04             	add    $0x4,%eax
c0022b43:	83 ec 04             	sub    $0x4,%esp
c0022b46:	6a 00                	push   $0x0
c0022b48:	68 13 29 02 c0       	push   $0xc0022913
c0022b4d:	50                   	push   %eax
c0022b4e:	e8 7a 7c 00 00       	call   c002a7cd <list_sort>
c0022b53:	83 c4 10             	add    $0x10,%esp
    struct thread *t =  list_entry (list_pop_front (&sema->waiters),
c0022b56:	8b 45 08             	mov    0x8(%ebp),%eax
c0022b59:	83 c0 04             	add    $0x4,%eax
c0022b5c:	83 ec 0c             	sub    $0xc,%esp
c0022b5f:	50                   	push   %eax
c0022b60:	e8 88 77 00 00       	call   c002a2ed <list_pop_front>
c0022b65:	83 c4 10             	add    $0x10,%esp
c0022b68:	83 c0 04             	add    $0x4,%eax
c0022b6b:	83 e8 2c             	sub    $0x2c,%eax
c0022b6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                                struct thread, elem);
    thread_unblock (t);
c0022b71:	83 ec 0c             	sub    $0xc,%esp
c0022b74:	ff 75 f0             	pushl  -0x10(%ebp)
c0022b77:	e8 c1 e0 ff ff       	call   c0020c3d <thread_unblock>
c0022b7c:	83 c4 10             	add    $0x10,%esp

    // yield current thread if unblocked thread has higher priority
    if (t->donated_priority > thread_current ()->donated_priority) {
c0022b7f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022b82:	8b 58 38             	mov    0x38(%eax),%ebx
c0022b85:	8b 70 3c             	mov    0x3c(%eax),%esi
c0022b88:	e8 5f e1 ff ff       	call   c0020cec <thread_current>
c0022b8d:	8b 50 3c             	mov    0x3c(%eax),%edx
c0022b90:	8b 40 38             	mov    0x38(%eax),%eax
c0022b93:	39 d6                	cmp    %edx,%esi
c0022b95:	7c 0d                	jl     c0022ba4 <sema_up+0xc1>
c0022b97:	39 d6                	cmp    %edx,%esi
c0022b99:	7f 04                	jg     c0022b9f <sema_up+0xbc>
c0022b9b:	39 c3                	cmp    %eax,%ebx
c0022b9d:	76 05                	jbe    c0022ba4 <sema_up+0xc1>
      thread_yield();
c0022b9f:	e8 3e e2 ff ff       	call   c0020de2 <thread_yield>
    }
  } 
    
  intr_set_level (old_level);;
c0022ba4:	83 ec 0c             	sub    $0xc,%esp
c0022ba7:	ff 75 f4             	pushl  -0xc(%ebp)
c0022baa:	e8 00 e9 ff ff       	call   c00214af <intr_set_level>
c0022baf:	83 c4 10             	add    $0x10,%esp
}
c0022bb2:	90                   	nop
c0022bb3:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0022bb6:	5b                   	pop    %ebx
c0022bb7:	5e                   	pop    %esi
c0022bb8:	5d                   	pop    %ebp
c0022bb9:	c3                   	ret    

c0022bba <sema_self_test>:
/* Self-test for semaphores that makes control "ping-pong"
   between a pair of threads.  Insert calls to printf() to see
   what's going on. */
void
sema_self_test (void) 
{
c0022bba:	55                   	push   %ebp
c0022bbb:	89 e5                	mov    %esp,%ebp
c0022bbd:	83 ec 38             	sub    $0x38,%esp
  struct semaphore sema[2];
  int i;

  printf ("Testing semaphores...");
c0022bc0:	83 ec 0c             	sub    $0xc,%esp
c0022bc3:	68 97 f6 02 c0       	push   $0xc002f697
c0022bc8:	e8 1b 4c 00 00       	call   c00277e8 <printf>
c0022bcd:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[0], 0);
c0022bd0:	83 ec 08             	sub    $0x8,%esp
c0022bd3:	6a 00                	push   $0x0
c0022bd5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022bd8:	50                   	push   %eax
c0022bd9:	e8 b3 fd ff ff       	call   c0022991 <sema_init>
c0022bde:	83 c4 10             	add    $0x10,%esp
  sema_init (&sema[1], 0);
c0022be1:	83 ec 08             	sub    $0x8,%esp
c0022be4:	6a 00                	push   $0x0
c0022be6:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022be9:	83 c0 14             	add    $0x14,%eax
c0022bec:	50                   	push   %eax
c0022bed:	e8 9f fd ff ff       	call   c0022991 <sema_init>
c0022bf2:	83 c4 10             	add    $0x10,%esp
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
c0022bf5:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022bf8:	50                   	push   %eax
c0022bf9:	68 54 2c 02 c0       	push   $0xc0022c54
c0022bfe:	6a 1f                	push   $0x1f
c0022c00:	68 ad f6 02 c0       	push   $0xc002f6ad
c0022c05:	e8 9d de ff ff       	call   c0020aa7 <thread_create>
c0022c0a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c0022c0d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022c14:	eb 25                	jmp    c0022c3b <sema_self_test+0x81>
    {
      sema_up (&sema[0]);
c0022c16:	83 ec 0c             	sub    $0xc,%esp
c0022c19:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022c1c:	50                   	push   %eax
c0022c1d:	e8 c1 fe ff ff       	call   c0022ae3 <sema_up>
c0022c22:	83 c4 10             	add    $0x10,%esp
      sema_down (&sema[1]);
c0022c25:	83 ec 0c             	sub    $0xc,%esp
c0022c28:	8d 45 cc             	lea    -0x34(%ebp),%eax
c0022c2b:	83 c0 14             	add    $0x14,%eax
c0022c2e:	50                   	push   %eax
c0022c2f:	e8 a4 fd ff ff       	call   c00229d8 <sema_down>
c0022c34:	83 c4 10             	add    $0x10,%esp

  printf ("Testing semaphores...");
  sema_init (&sema[0], 0);
  sema_init (&sema[1], 0);
  thread_create ("sema-test", PRI_DEFAULT, sema_test_helper, &sema);
  for (i = 0; i < 10; i++) 
c0022c37:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022c3b:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022c3f:	7e d5                	jle    c0022c16 <sema_self_test+0x5c>
    {
      sema_up (&sema[0]);
      sema_down (&sema[1]);
    }
  printf ("done.\n");
c0022c41:	83 ec 0c             	sub    $0xc,%esp
c0022c44:	68 b7 f6 02 c0       	push   $0xc002f6b7
c0022c49:	e8 80 91 00 00       	call   c002bdce <puts>
c0022c4e:	83 c4 10             	add    $0x10,%esp
}
c0022c51:	90                   	nop
c0022c52:	c9                   	leave  
c0022c53:	c3                   	ret    

c0022c54 <sema_test_helper>:

/* Thread function used by sema_self_test(). */
static void
sema_test_helper (void *sema_) 
{
c0022c54:	55                   	push   %ebp
c0022c55:	89 e5                	mov    %esp,%ebp
c0022c57:	83 ec 18             	sub    $0x18,%esp
  struct semaphore *sema = sema_;
c0022c5a:	8b 45 08             	mov    0x8(%ebp),%eax
c0022c5d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  for (i = 0; i < 10; i++) 
c0022c60:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0022c67:	eb 24                	jmp    c0022c8d <sema_test_helper+0x39>
    {
      sema_down (&sema[0]);
c0022c69:	83 ec 0c             	sub    $0xc,%esp
c0022c6c:	ff 75 f0             	pushl  -0x10(%ebp)
c0022c6f:	e8 64 fd ff ff       	call   c00229d8 <sema_down>
c0022c74:	83 c4 10             	add    $0x10,%esp
      sema_up (&sema[1]);
c0022c77:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022c7a:	83 c0 14             	add    $0x14,%eax
c0022c7d:	83 ec 0c             	sub    $0xc,%esp
c0022c80:	50                   	push   %eax
c0022c81:	e8 5d fe ff ff       	call   c0022ae3 <sema_up>
c0022c86:	83 c4 10             	add    $0x10,%esp
sema_test_helper (void *sema_) 
{
  struct semaphore *sema = sema_;
  int i;

  for (i = 0; i < 10; i++) 
c0022c89:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0022c8d:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c0022c91:	7e d6                	jle    c0022c69 <sema_test_helper+0x15>
    {
      sema_down (&sema[0]);
      sema_up (&sema[1]);
    }
}
c0022c93:	90                   	nop
c0022c94:	c9                   	leave  
c0022c95:	c3                   	ret    

c0022c96 <lock_init>:
   acquire and release it.  When these restrictions prove
   onerous, it's a good sign that a semaphore should be used,
   instead of a lock. */
void
lock_init (struct lock *lock)
{
c0022c96:	55                   	push   %ebp
c0022c97:	89 e5                	mov    %esp,%ebp
c0022c99:	83 ec 08             	sub    $0x8,%esp
  ASSERT (lock != NULL);
c0022c9c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ca0:	75 21                	jne    c0022cc3 <lock_init+0x2d>
c0022ca2:	83 ec 0c             	sub    $0xc,%esp
c0022ca5:	68 bd f6 02 c0       	push   $0xc002f6bd
c0022caa:	68 59 f6 02 c0       	push   $0xc002f659
c0022caf:	68 50 f7 02 c0       	push   $0xc002f750
c0022cb4:	68 cb 00 00 00       	push   $0xcb
c0022cb9:	68 70 f6 02 c0       	push   $0xc002f670
c0022cbe:	e8 58 6f 00 00       	call   c0029c1b <debug_panic>

  lock->holder = NULL;
c0022cc3:	8b 45 08             	mov    0x8(%ebp),%eax
c0022cc6:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_init (&lock->semaphore, 1);
c0022ccc:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ccf:	83 c0 04             	add    $0x4,%eax
c0022cd2:	83 ec 08             	sub    $0x8,%esp
c0022cd5:	6a 01                	push   $0x1
c0022cd7:	50                   	push   %eax
c0022cd8:	e8 b4 fc ff ff       	call   c0022991 <sema_init>
c0022cdd:	83 c4 10             	add    $0x10,%esp
}
c0022ce0:	90                   	nop
c0022ce1:	c9                   	leave  
c0022ce2:	c3                   	ret    

c0022ce3 <lock_acquire>:
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */

void
lock_acquire (struct lock *lock)
{
c0022ce3:	55                   	push   %ebp
c0022ce4:	89 e5                	mov    %esp,%ebp
c0022ce6:	53                   	push   %ebx
c0022ce7:	83 ec 14             	sub    $0x14,%esp
  ASSERT (lock != NULL);
c0022cea:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022cee:	75 21                	jne    c0022d11 <lock_acquire+0x2e>
c0022cf0:	83 ec 0c             	sub    $0xc,%esp
c0022cf3:	68 bd f6 02 c0       	push   $0xc002f6bd
c0022cf8:	68 59 f6 02 c0       	push   $0xc002f659
c0022cfd:	68 5c f7 02 c0       	push   $0xc002f75c
c0022d02:	68 dd 00 00 00       	push   $0xdd
c0022d07:	68 70 f6 02 c0       	push   $0xc002f670
c0022d0c:	e8 0a 6f 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!intr_context ());
c0022d11:	e8 c0 ea ff ff       	call   c00217d6 <intr_context>
c0022d16:	83 f0 01             	xor    $0x1,%eax
c0022d19:	84 c0                	test   %al,%al
c0022d1b:	75 21                	jne    c0022d3e <lock_acquire+0x5b>
c0022d1d:	83 ec 0c             	sub    $0xc,%esp
c0022d20:	68 86 f6 02 c0       	push   $0xc002f686
c0022d25:	68 59 f6 02 c0       	push   $0xc002f659
c0022d2a:	68 5c f7 02 c0       	push   $0xc002f75c
c0022d2f:	68 de 00 00 00       	push   $0xde
c0022d34:	68 70 f6 02 c0       	push   $0xc002f670
c0022d39:	e8 dd 6e 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022d3e:	83 ec 0c             	sub    $0xc,%esp
c0022d41:	ff 75 08             	pushl  0x8(%ebp)
c0022d44:	e8 dc 03 00 00       	call   c0023125 <lock_held_by_current_thread>
c0022d49:	83 c4 10             	add    $0x10,%esp
c0022d4c:	83 f0 01             	xor    $0x1,%eax
c0022d4f:	84 c0                	test   %al,%al
c0022d51:	75 21                	jne    c0022d74 <lock_acquire+0x91>
c0022d53:	83 ec 0c             	sub    $0xc,%esp
c0022d56:	68 cc f6 02 c0       	push   $0xc002f6cc
c0022d5b:	68 59 f6 02 c0       	push   $0xc002f659
c0022d60:	68 5c f7 02 c0       	push   $0xc002f75c
c0022d65:	68 df 00 00 00       	push   $0xdf
c0022d6a:	68 70 f6 02 c0       	push   $0xc002f670
c0022d6f:	e8 a7 6e 00 00       	call   c0029c1b <debug_panic>

  enum intr_level old_level;
  old_level = intr_disable ();
c0022d74:	e8 8e e7 ff ff       	call   c0021507 <intr_disable>
c0022d79:	89 45 f4             	mov    %eax,-0xc(%ebp)
  //Helped by Schindler and Justin

  //if lock held
  //donate priority to lock holder if current thread's donated priority is greater and
  //check if nest donation is necessary
  if (lock->holder != NULL) {
c0022d7c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d7f:	8b 00                	mov    (%eax),%eax
c0022d81:	85 c0                	test   %eax,%eax
c0022d83:	74 53                	je     c0022dd8 <lock_acquire+0xf5>
    thread_current()->wait_on_lock = lock;
c0022d85:	e8 62 df ff ff       	call   c0020cec <thread_current>
c0022d8a:	89 c2                	mov    %eax,%edx
c0022d8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022d8f:	89 42 44             	mov    %eax,0x44(%edx)
    if (thread_current()->donated_priority > lock->holder->donated_priority) {
c0022d92:	e8 55 df ff ff       	call   c0020cec <thread_current>
c0022d97:	8b 48 38             	mov    0x38(%eax),%ecx
c0022d9a:	8b 58 3c             	mov    0x3c(%eax),%ebx
c0022d9d:	8b 45 08             	mov    0x8(%ebp),%eax
c0022da0:	8b 00                	mov    (%eax),%eax
c0022da2:	8b 50 3c             	mov    0x3c(%eax),%edx
c0022da5:	8b 40 38             	mov    0x38(%eax),%eax
c0022da8:	39 d3                	cmp    %edx,%ebx
c0022daa:	7c 2c                	jl     c0022dd8 <lock_acquire+0xf5>
c0022dac:	39 d3                	cmp    %edx,%ebx
c0022dae:	7f 04                	jg     c0022db4 <lock_acquire+0xd1>
c0022db0:	39 c1                	cmp    %eax,%ecx
c0022db2:	76 24                	jbe    c0022dd8 <lock_acquire+0xf5>
      lock->holder->donated_priority = thread_current()->donated_priority;
c0022db4:	8b 45 08             	mov    0x8(%ebp),%eax
c0022db7:	8b 18                	mov    (%eax),%ebx
c0022db9:	e8 2e df ff ff       	call   c0020cec <thread_current>
c0022dbe:	8b 50 3c             	mov    0x3c(%eax),%edx
c0022dc1:	8b 40 38             	mov    0x38(%eax),%eax
c0022dc4:	89 43 38             	mov    %eax,0x38(%ebx)
c0022dc7:	89 53 3c             	mov    %edx,0x3c(%ebx)
      lock->holder->has_donation = true;
c0022dca:	8b 45 08             	mov    0x8(%ebp),%eax
c0022dcd:	8b 00                	mov    (%eax),%eax
c0022dcf:	c6 40 40 01          	movb   $0x1,0x40(%eax)
      nest_donate();
c0022dd3:	e8 f2 02 00 00       	call   c00230ca <nest_donate>
    }
  }

  //attempt to acquire semaphore here, blocks if lock is held
  sema_down (&lock->semaphore);
c0022dd8:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ddb:	83 c0 04             	add    $0x4,%eax
c0022dde:	83 ec 0c             	sub    $0xc,%esp
c0022de1:	50                   	push   %eax
c0022de2:	e8 f1 fb ff ff       	call   c00229d8 <sema_down>
c0022de7:	83 c4 10             	add    $0x10,%esp
  
  //only reaches this code once lock is available
  //stores lock in threads locks_held list
  list_push_back(&thread_current()->locks_held, &lock->holding_elem);
c0022dea:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ded:	8d 58 18             	lea    0x18(%eax),%ebx
c0022df0:	e8 f7 de ff ff       	call   c0020cec <thread_current>
c0022df5:	83 c0 48             	add    $0x48,%eax
c0022df8:	83 ec 08             	sub    $0x8,%esp
c0022dfb:	53                   	push   %ebx
c0022dfc:	50                   	push   %eax
c0022dfd:	e8 6c 74 00 00       	call   c002a26e <list_push_back>
c0022e02:	83 c4 10             	add    $0x10,%esp
  lock->holder = thread_current ();
c0022e05:	e8 e2 de ff ff       	call   c0020cec <thread_current>
c0022e0a:	89 c2                	mov    %eax,%edx
c0022e0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e0f:	89 10                	mov    %edx,(%eax)
  //update the priority of thread after acquiring a new lock
  updatePriority(thread_current());
c0022e11:	e8 d6 de ff ff       	call   c0020cec <thread_current>
c0022e16:	83 ec 0c             	sub    $0xc,%esp
c0022e19:	50                   	push   %eax
c0022e1a:	e8 63 01 00 00       	call   c0022f82 <updatePriority>
c0022e1f:	83 c4 10             	add    $0x10,%esp


  intr_set_level (old_level); 
c0022e22:	83 ec 0c             	sub    $0xc,%esp
c0022e25:	ff 75 f4             	pushl  -0xc(%ebp)
c0022e28:	e8 82 e6 ff ff       	call   c00214af <intr_set_level>
c0022e2d:	83 c4 10             	add    $0x10,%esp

}
c0022e30:	90                   	nop
c0022e31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0022e34:	c9                   	leave  
c0022e35:	c3                   	ret    

c0022e36 <lock_try_acquire>:

   This function will not sleep, so it may be called within an
   interrupt handler. */
bool
lock_try_acquire (struct lock *lock)
{
c0022e36:	55                   	push   %ebp
c0022e37:	89 e5                	mov    %esp,%ebp
c0022e39:	83 ec 18             	sub    $0x18,%esp
  bool success;

  ASSERT (lock != NULL);
c0022e3c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022e40:	75 21                	jne    c0022e63 <lock_try_acquire+0x2d>
c0022e42:	83 ec 0c             	sub    $0xc,%esp
c0022e45:	68 bd f6 02 c0       	push   $0xc002f6bd
c0022e4a:	68 59 f6 02 c0       	push   $0xc002f659
c0022e4f:	68 6c f7 02 c0       	push   $0xc002f76c
c0022e54:	68 0c 01 00 00       	push   $0x10c
c0022e59:	68 70 f6 02 c0       	push   $0xc002f670
c0022e5e:	e8 b8 6d 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!lock_held_by_current_thread (lock));
c0022e63:	83 ec 0c             	sub    $0xc,%esp
c0022e66:	ff 75 08             	pushl  0x8(%ebp)
c0022e69:	e8 b7 02 00 00       	call   c0023125 <lock_held_by_current_thread>
c0022e6e:	83 c4 10             	add    $0x10,%esp
c0022e71:	83 f0 01             	xor    $0x1,%eax
c0022e74:	84 c0                	test   %al,%al
c0022e76:	75 21                	jne    c0022e99 <lock_try_acquire+0x63>
c0022e78:	83 ec 0c             	sub    $0xc,%esp
c0022e7b:	68 cc f6 02 c0       	push   $0xc002f6cc
c0022e80:	68 59 f6 02 c0       	push   $0xc002f659
c0022e85:	68 6c f7 02 c0       	push   $0xc002f76c
c0022e8a:	68 0d 01 00 00       	push   $0x10d
c0022e8f:	68 70 f6 02 c0       	push   $0xc002f670
c0022e94:	e8 82 6d 00 00       	call   c0029c1b <debug_panic>

  success = sema_try_down (&lock->semaphore);
c0022e99:	8b 45 08             	mov    0x8(%ebp),%eax
c0022e9c:	83 c0 04             	add    $0x4,%eax
c0022e9f:	83 ec 0c             	sub    $0xc,%esp
c0022ea2:	50                   	push   %eax
c0022ea3:	e8 d5 fb ff ff       	call   c0022a7d <sema_try_down>
c0022ea8:	83 c4 10             	add    $0x10,%esp
c0022eab:	88 45 f7             	mov    %al,-0x9(%ebp)
  if (success)
c0022eae:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
c0022eb2:	74 0c                	je     c0022ec0 <lock_try_acquire+0x8a>
    lock->holder = thread_current ();
c0022eb4:	e8 33 de ff ff       	call   c0020cec <thread_current>
c0022eb9:	89 c2                	mov    %eax,%edx
c0022ebb:	8b 45 08             	mov    0x8(%ebp),%eax
c0022ebe:	89 10                	mov    %edx,(%eax)
  return success;
c0022ec0:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0022ec4:	c9                   	leave  
c0022ec5:	c3                   	ret    

c0022ec6 <lock_release>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to release a lock within an interrupt
   handler. */
void
lock_release (struct lock *lock) 
{
c0022ec6:	55                   	push   %ebp
c0022ec7:	89 e5                	mov    %esp,%ebp
c0022ec9:	83 ec 18             	sub    $0x18,%esp
  ASSERT (lock != NULL);
c0022ecc:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0022ed0:	75 21                	jne    c0022ef3 <lock_release+0x2d>
c0022ed2:	83 ec 0c             	sub    $0xc,%esp
c0022ed5:	68 bd f6 02 c0       	push   $0xc002f6bd
c0022eda:	68 59 f6 02 c0       	push   $0xc002f659
c0022edf:	68 80 f7 02 c0       	push   $0xc002f780
c0022ee4:	68 1d 01 00 00       	push   $0x11d
c0022ee9:	68 70 f6 02 c0       	push   $0xc002f670
c0022eee:	e8 28 6d 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0022ef3:	83 ec 0c             	sub    $0xc,%esp
c0022ef6:	ff 75 08             	pushl  0x8(%ebp)
c0022ef9:	e8 27 02 00 00       	call   c0023125 <lock_held_by_current_thread>
c0022efe:	83 c4 10             	add    $0x10,%esp
c0022f01:	84 c0                	test   %al,%al
c0022f03:	75 21                	jne    c0022f26 <lock_release+0x60>
c0022f05:	83 ec 0c             	sub    $0xc,%esp
c0022f08:	68 f0 f6 02 c0       	push   $0xc002f6f0
c0022f0d:	68 59 f6 02 c0       	push   $0xc002f659
c0022f12:	68 80 f7 02 c0       	push   $0xc002f780
c0022f17:	68 1e 01 00 00       	push   $0x11e
c0022f1c:	68 70 f6 02 c0       	push   $0xc002f670
c0022f21:	e8 f5 6c 00 00       	call   c0029c1b <debug_panic>
  //Helped by Schindler and Justin

  //checks if the are any threads waiting on this thread to release the lock
  //if so, pop the highest priority waiting thread and set 'donated priority' to next highest
  enum intr_level old_level;
  old_level = intr_disable ();
c0022f26:	e8 dc e5 ff ff       	call   c0021507 <intr_disable>
c0022f2b:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock->holder = NULL;
c0022f2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f31:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  sema_up (&lock->semaphore);
c0022f37:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f3a:	83 c0 04             	add    $0x4,%eax
c0022f3d:	83 ec 0c             	sub    $0xc,%esp
c0022f40:	50                   	push   %eax
c0022f41:	e8 9d fb ff ff       	call   c0022ae3 <sema_up>
c0022f46:	83 c4 10             	add    $0x10,%esp
  
  //Remove lock from thread_current->locks_held
  list_remove(&lock->holding_elem);
c0022f49:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f4c:	83 c0 18             	add    $0x18,%eax
c0022f4f:	83 ec 0c             	sub    $0xc,%esp
c0022f52:	50                   	push   %eax
c0022f53:	e8 3c 73 00 00       	call   c002a294 <list_remove>
c0022f58:	83 c4 10             	add    $0x10,%esp
  //update thread's donated_priority now that it has released a lock
  updatePriority(thread_current());
c0022f5b:	e8 8c dd ff ff       	call   c0020cec <thread_current>
c0022f60:	83 ec 0c             	sub    $0xc,%esp
c0022f63:	50                   	push   %eax
c0022f64:	e8 19 00 00 00       	call   c0022f82 <updatePriority>
c0022f69:	83 c4 10             	add    $0x10,%esp
  

  intr_set_level(old_level);
c0022f6c:	83 ec 0c             	sub    $0xc,%esp
c0022f6f:	ff 75 f4             	pushl  -0xc(%ebp)
c0022f72:	e8 38 e5 ff ff       	call   c00214af <intr_set_level>
c0022f77:	83 c4 10             	add    $0x10,%esp

  //yield bc it may no longer be highest priority thread
  thread_yield();
c0022f7a:	e8 63 de ff ff       	call   c0020de2 <thread_yield>
}
c0022f7f:	90                   	nop
c0022f80:	c9                   	leave  
c0022f81:	c3                   	ret    

c0022f82 <updatePriority>:

// aqui codigo
void 
updatePriority(struct thread *t) {
c0022f82:	55                   	push   %ebp
c0022f83:	89 e5                	mov    %esp,%ebp
c0022f85:	83 ec 28             	sub    $0x28,%esp

  enum intr_level old_level;
  old_level = intr_disable ();
c0022f88:	e8 7a e5 ff ff       	call   c0021507 <intr_disable>
c0022f8d:	89 45 e8             	mov    %eax,-0x18(%ebp)

  t->has_donation = false;
c0022f90:	8b 45 08             	mov    0x8(%ebp),%eax
c0022f93:	c6 40 40 00          	movb   $0x0,0x40(%eax)
  uint64_t temp_priority = thread_current()->priority;
c0022f97:	e8 50 dd ff ff       	call   c0020cec <thread_current>
c0022f9c:	8b 40 1c             	mov    0x1c(%eax),%eax
c0022f9f:	99                   	cltd   
c0022fa0:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0022fa3:	89 55 f4             	mov    %edx,-0xc(%ebp)
  struct list_elem* iter = NULL;
c0022fa6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  //if no locks held, there will be no donation (should restore to original priority)
  if(list_empty(&t->locks_held)) {
c0022fad:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fb0:	83 c0 48             	add    $0x48,%eax
c0022fb3:	83 ec 0c             	sub    $0xc,%esp
c0022fb6:	50                   	push   %eax
c0022fb7:	e8 5a 74 00 00       	call   c002a416 <list_empty>
c0022fbc:	83 c4 10             	add    $0x10,%esp
c0022fbf:	84 c0                	test   %al,%al
c0022fc1:	74 14                	je     c0022fd7 <updatePriority+0x55>
    t->donated_priority = temp_priority;
c0022fc3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0022fc6:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0022fc9:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0022fcc:	89 41 38             	mov    %eax,0x38(%ecx)
c0022fcf:	89 51 3c             	mov    %edx,0x3c(%ecx)
c0022fd2:	e9 d3 00 00 00       	jmp    c00230aa <updatePriority+0x128>
  } else {
    //if locks held, iterate through them and find the highest priority waiting thread among them
    for (iter = list_begin(&t->locks_held); iter != list_end(&t->locks_held);
c0022fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0022fda:	83 c0 48             	add    $0x48,%eax
c0022fdd:	83 ec 0c             	sub    $0xc,%esp
c0022fe0:	50                   	push   %eax
c0022fe1:	e8 fd 6e 00 00       	call   c0029ee3 <list_begin>
c0022fe6:	83 c4 10             	add    $0x10,%esp
c0022fe9:	89 45 ec             	mov    %eax,-0x14(%ebp)
c0022fec:	e9 9e 00 00 00       	jmp    c002308f <updatePriority+0x10d>
          iter = list_next(iter)) 
    {
      struct lock* lk = list_entry(iter, struct lock, holding_elem);
c0022ff1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0022ff4:	83 c0 04             	add    $0x4,%eax
c0022ff7:	83 e8 1c             	sub    $0x1c,%eax
c0022ffa:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (list_size(&lk->semaphore.waiters) > 0) {
c0022ffd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023000:	83 c0 08             	add    $0x8,%eax
c0023003:	83 ec 0c             	sub    $0xc,%esp
c0023006:	50                   	push   %eax
c0023007:	e8 bd 73 00 00       	call   c002a3c9 <list_size>
c002300c:	83 c4 10             	add    $0x10,%esp
c002300f:	85 c0                	test   %eax,%eax
c0023011:	74 6b                	je     c002307e <updatePriority+0xfc>
        list_sort(&lk->semaphore.waiters, (list_less_func*)&priority_compare, NULL);
c0023013:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023016:	83 c0 08             	add    $0x8,%eax
c0023019:	83 ec 04             	sub    $0x4,%esp
c002301c:	6a 00                	push   $0x0
c002301e:	68 13 29 02 c0       	push   $0xc0022913
c0023023:	50                   	push   %eax
c0023024:	e8 a4 77 00 00       	call   c002a7cd <list_sort>
c0023029:	83 c4 10             	add    $0x10,%esp
        struct thread* max_priority_thread = list_entry(list_begin(&lk->semaphore.waiters), struct thread, elem);
c002302c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002302f:	83 c0 08             	add    $0x8,%eax
c0023032:	83 ec 0c             	sub    $0xc,%esp
c0023035:	50                   	push   %eax
c0023036:	e8 a8 6e 00 00       	call   c0029ee3 <list_begin>
c002303b:	83 c4 10             	add    $0x10,%esp
c002303e:	83 c0 04             	add    $0x4,%eax
c0023041:	83 e8 2c             	sub    $0x2c,%eax
c0023044:	89 45 e0             	mov    %eax,-0x20(%ebp)
        uint64_t lock_waiters_max = max_priority_thread->donated_priority;
c0023047:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002304a:	8b 50 3c             	mov    0x3c(%eax),%edx
c002304d:	8b 40 38             	mov    0x38(%eax),%eax
c0023050:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0023053:	89 55 dc             	mov    %edx,-0x24(%ebp)
        //if highest priority waiting thread is highest seen so far AND has higher priority than t->priority
        //update temp_priority
        if(lock_waiters_max > temp_priority) {
c0023056:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0023059:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002305c:	3b 55 f4             	cmp    -0xc(%ebp),%edx
c002305f:	72 1d                	jb     c002307e <updatePriority+0xfc>
c0023061:	3b 55 f4             	cmp    -0xc(%ebp),%edx
c0023064:	77 05                	ja     c002306b <updatePriority+0xe9>
c0023066:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023069:	76 13                	jbe    c002307e <updatePriority+0xfc>
            temp_priority = lock_waiters_max;
c002306b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002306e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0023071:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0023074:	89 55 f4             	mov    %edx,-0xc(%ebp)
            t->has_donation = true;
c0023077:	8b 45 08             	mov    0x8(%ebp),%eax
c002307a:	c6 40 40 01          	movb   $0x1,0x40(%eax)
  if(list_empty(&t->locks_held)) {
    t->donated_priority = temp_priority;
  } else {
    //if locks held, iterate through them and find the highest priority waiting thread among them
    for (iter = list_begin(&t->locks_held); iter != list_end(&t->locks_held);
          iter = list_next(iter)) 
c002307e:	83 ec 0c             	sub    $0xc,%esp
c0023081:	ff 75 ec             	pushl  -0x14(%ebp)
c0023084:	e8 8c 6e 00 00       	call   c0029f15 <list_next>
c0023089:	83 c4 10             	add    $0x10,%esp
c002308c:	89 45 ec             	mov    %eax,-0x14(%ebp)
  //if no locks held, there will be no donation (should restore to original priority)
  if(list_empty(&t->locks_held)) {
    t->donated_priority = temp_priority;
  } else {
    //if locks held, iterate through them and find the highest priority waiting thread among them
    for (iter = list_begin(&t->locks_held); iter != list_end(&t->locks_held);
c002308f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023092:	83 c0 48             	add    $0x48,%eax
c0023095:	83 ec 0c             	sub    $0xc,%esp
c0023098:	50                   	push   %eax
c0023099:	e8 c1 6e 00 00       	call   c0029f5f <list_end>
c002309e:	83 c4 10             	add    $0x10,%esp
c00230a1:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00230a4:	0f 85 47 ff ff ff    	jne    c0022ff1 <updatePriority+0x6f>

    }
  }

  //set donated_priority to highest priority waiter OR original priority if none
  t->donated_priority = temp_priority;
c00230aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230ad:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00230b0:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00230b3:	89 41 38             	mov    %eax,0x38(%ecx)
c00230b6:	89 51 3c             	mov    %edx,0x3c(%ecx)

  intr_set_level(old_level);  
c00230b9:	83 ec 0c             	sub    $0xc,%esp
c00230bc:	ff 75 e8             	pushl  -0x18(%ebp)
c00230bf:	e8 eb e3 ff ff       	call   c00214af <intr_set_level>
c00230c4:	83 c4 10             	add    $0x10,%esp
}
c00230c7:	90                   	nop
c00230c8:	c9                   	leave  
c00230c9:	c3                   	ret    

c00230ca <nest_donate>:

//for nest donation
void nest_donate() {
c00230ca:	55                   	push   %ebp
c00230cb:	89 e5                	mov    %esp,%ebp
c00230cd:	83 ec 18             	sub    $0x18,%esp
  struct thread *t = thread_current();
c00230d0:	e8 17 dc ff ff       	call   c0020cec <thread_current>
c00230d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  //the lock that the current thread is waiting on
  struct lock *l = t->wait_on_lock;
c00230d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00230db:	8b 40 44             	mov    0x44(%eax),%eax
c00230de:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int depth = 0;
c00230e1:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  //while there continues to be a thread-waiting_lock chain, iteratively traverse it and call updatePriority() on the threads in it
  while (t->wait_on_lock != NULL && l->holder != NULL && depth < DEPTH_LIMIT) {
c00230e8:	eb 1f                	jmp    c0023109 <nest_donate+0x3f>
    t = l->holder;
c00230ea:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00230ed:	8b 00                	mov    (%eax),%eax
c00230ef:	89 45 f4             	mov    %eax,-0xc(%ebp)
    updatePriority(t);
c00230f2:	83 ec 0c             	sub    $0xc,%esp
c00230f5:	ff 75 f4             	pushl  -0xc(%ebp)
c00230f8:	e8 85 fe ff ff       	call   c0022f82 <updatePriority>
c00230fd:	83 c4 10             	add    $0x10,%esp
    l = t->wait_on_lock;
c0023100:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023103:	8b 40 44             	mov    0x44(%eax),%eax
c0023106:	89 45 f0             	mov    %eax,-0x10(%ebp)
  //the lock that the current thread is waiting on
  struct lock *l = t->wait_on_lock;
  int depth = 0;

  //while there continues to be a thread-waiting_lock chain, iteratively traverse it and call updatePriority() on the threads in it
  while (t->wait_on_lock != NULL && l->holder != NULL && depth < DEPTH_LIMIT) {
c0023109:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002310c:	8b 40 44             	mov    0x44(%eax),%eax
c002310f:	85 c0                	test   %eax,%eax
c0023111:	74 0f                	je     c0023122 <nest_donate+0x58>
c0023113:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023116:	8b 00                	mov    (%eax),%eax
c0023118:	85 c0                	test   %eax,%eax
c002311a:	74 06                	je     c0023122 <nest_donate+0x58>
c002311c:	83 7d ec 07          	cmpl   $0x7,-0x14(%ebp)
c0023120:	7e c8                	jle    c00230ea <nest_donate+0x20>
    t = l->holder;
    updatePriority(t);
    l = t->wait_on_lock;
  }
}
c0023122:	90                   	nop
c0023123:	c9                   	leave  
c0023124:	c3                   	ret    

c0023125 <lock_held_by_current_thread>:
/* Returns true if the current thread holds LOCK, false
   otherwise.  (Note that testing whether some other thread holds
   a lock would be racy.) */
bool
lock_held_by_current_thread (const struct lock *lock) 
{
c0023125:	55                   	push   %ebp
c0023126:	89 e5                	mov    %esp,%ebp
c0023128:	53                   	push   %ebx
c0023129:	83 ec 04             	sub    $0x4,%esp
  ASSERT (lock != NULL);
c002312c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023130:	75 21                	jne    c0023153 <lock_held_by_current_thread+0x2e>
c0023132:	83 ec 0c             	sub    $0xc,%esp
c0023135:	68 bd f6 02 c0       	push   $0xc002f6bd
c002313a:	68 59 f6 02 c0       	push   $0xc002f659
c002313f:	68 90 f7 02 c0       	push   $0xc002f790
c0023144:	68 74 01 00 00       	push   $0x174
c0023149:	68 70 f6 02 c0       	push   $0xc002f670
c002314e:	e8 c8 6a 00 00       	call   c0029c1b <debug_panic>

  return lock->holder == thread_current ();
c0023153:	8b 45 08             	mov    0x8(%ebp),%eax
c0023156:	8b 18                	mov    (%eax),%ebx
c0023158:	e8 8f db ff ff       	call   c0020cec <thread_current>
c002315d:	39 c3                	cmp    %eax,%ebx
c002315f:	0f 94 c0             	sete   %al
}
c0023162:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023165:	c9                   	leave  
c0023166:	c3                   	ret    

c0023167 <cond_init>:
/* Initializes condition variable COND.  A condition variable
   allows one piece of code to signal a condition and cooperating
   code to receive the signal and act upon it. */
void
cond_init (struct condition *cond)
{
c0023167:	55                   	push   %ebp
c0023168:	89 e5                	mov    %esp,%ebp
c002316a:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c002316d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023171:	75 21                	jne    c0023194 <cond_init+0x2d>
c0023173:	83 ec 0c             	sub    $0xc,%esp
c0023176:	68 13 f7 02 c0       	push   $0xc002f713
c002317b:	68 59 f6 02 c0       	push   $0xc002f659
c0023180:	68 ac f7 02 c0       	push   $0xc002f7ac
c0023185:	68 81 01 00 00       	push   $0x181
c002318a:	68 70 f6 02 c0       	push   $0xc002f670
c002318f:	e8 87 6a 00 00       	call   c0029c1b <debug_panic>

  list_init (&cond->waiters);
c0023194:	8b 45 08             	mov    0x8(%ebp),%eax
c0023197:	83 ec 0c             	sub    $0xc,%esp
c002319a:	50                   	push   %eax
c002319b:	e8 ee 6c 00 00       	call   c0029e8e <list_init>
c00231a0:	83 c4 10             	add    $0x10,%esp
}
c00231a3:	90                   	nop
c00231a4:	c9                   	leave  
c00231a5:	c3                   	ret    

c00231a6 <cond_wait>:
   interrupt handler.  This function may be called with
   interrupts disabled, but interrupts will be turned back on if
   we need to sleep. */
void
cond_wait (struct condition *cond, struct lock *lock) 
{
c00231a6:	55                   	push   %ebp
c00231a7:	89 e5                	mov    %esp,%ebp
c00231a9:	83 ec 38             	sub    $0x38,%esp

  struct semaphore_elem waiter;

  ASSERT (cond != NULL);
c00231ac:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00231b0:	75 21                	jne    c00231d3 <cond_wait+0x2d>
c00231b2:	83 ec 0c             	sub    $0xc,%esp
c00231b5:	68 13 f7 02 c0       	push   $0xc002f713
c00231ba:	68 59 f6 02 c0       	push   $0xc002f659
c00231bf:	68 b8 f7 02 c0       	push   $0xc002f7b8
c00231c4:	68 a0 01 00 00       	push   $0x1a0
c00231c9:	68 70 f6 02 c0       	push   $0xc002f670
c00231ce:	e8 48 6a 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock != NULL);
c00231d3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00231d7:	75 21                	jne    c00231fa <cond_wait+0x54>
c00231d9:	83 ec 0c             	sub    $0xc,%esp
c00231dc:	68 bd f6 02 c0       	push   $0xc002f6bd
c00231e1:	68 59 f6 02 c0       	push   $0xc002f659
c00231e6:	68 b8 f7 02 c0       	push   $0xc002f7b8
c00231eb:	68 a1 01 00 00       	push   $0x1a1
c00231f0:	68 70 f6 02 c0       	push   $0xc002f670
c00231f5:	e8 21 6a 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!intr_context ());
c00231fa:	e8 d7 e5 ff ff       	call   c00217d6 <intr_context>
c00231ff:	83 f0 01             	xor    $0x1,%eax
c0023202:	84 c0                	test   %al,%al
c0023204:	75 21                	jne    c0023227 <cond_wait+0x81>
c0023206:	83 ec 0c             	sub    $0xc,%esp
c0023209:	68 86 f6 02 c0       	push   $0xc002f686
c002320e:	68 59 f6 02 c0       	push   $0xc002f659
c0023213:	68 b8 f7 02 c0       	push   $0xc002f7b8
c0023218:	68 a2 01 00 00       	push   $0x1a2
c002321d:	68 70 f6 02 c0       	push   $0xc002f670
c0023222:	e8 f4 69 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023227:	83 ec 0c             	sub    $0xc,%esp
c002322a:	ff 75 0c             	pushl  0xc(%ebp)
c002322d:	e8 f3 fe ff ff       	call   c0023125 <lock_held_by_current_thread>
c0023232:	83 c4 10             	add    $0x10,%esp
c0023235:	84 c0                	test   %al,%al
c0023237:	75 21                	jne    c002325a <cond_wait+0xb4>
c0023239:	83 ec 0c             	sub    $0xc,%esp
c002323c:	68 f0 f6 02 c0       	push   $0xc002f6f0
c0023241:	68 59 f6 02 c0       	push   $0xc002f659
c0023246:	68 b8 f7 02 c0       	push   $0xc002f7b8
c002324b:	68 a3 01 00 00       	push   $0x1a3
c0023250:	68 70 f6 02 c0       	push   $0xc002f670
c0023255:	e8 c1 69 00 00       	call   c0029c1b <debug_panic>
  

  sema_init (&waiter.semaphore, 0);
c002325a:	83 ec 08             	sub    $0x8,%esp
c002325d:	6a 00                	push   $0x0
c002325f:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c0023262:	83 c0 08             	add    $0x8,%eax
c0023265:	50                   	push   %eax
c0023266:	e8 26 f7 ff ff       	call   c0022991 <sema_init>
c002326b:	83 c4 10             	add    $0x10,%esp
  //almacenar thread donated priority a semaphore_elem - para fines de clasificar  aqui codigo
  waiter.donated_priority = thread_current()->donated_priority;
c002326e:	e8 79 da ff ff       	call   c0020cec <thread_current>
c0023273:	8b 50 3c             	mov    0x3c(%eax),%edx
c0023276:	8b 40 38             	mov    0x38(%eax),%eax
c0023279:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002327c:	89 55 f4             	mov    %edx,-0xc(%ebp)
  list_push_back (&cond->waiters, &waiter.elem);
c002327f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023282:	83 ec 08             	sub    $0x8,%esp
c0023285:	8d 55 d4             	lea    -0x2c(%ebp),%edx
c0023288:	52                   	push   %edx
c0023289:	50                   	push   %eax
c002328a:	e8 df 6f 00 00       	call   c002a26e <list_push_back>
c002328f:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c0023292:	83 ec 0c             	sub    $0xc,%esp
c0023295:	ff 75 0c             	pushl  0xc(%ebp)
c0023298:	e8 29 fc ff ff       	call   c0022ec6 <lock_release>
c002329d:	83 c4 10             	add    $0x10,%esp
  sema_down (&waiter.semaphore);
c00232a0:	83 ec 0c             	sub    $0xc,%esp
c00232a3:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c00232a6:	83 c0 08             	add    $0x8,%eax
c00232a9:	50                   	push   %eax
c00232aa:	e8 29 f7 ff ff       	call   c00229d8 <sema_down>
c00232af:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c00232b2:	83 ec 0c             	sub    $0xc,%esp
c00232b5:	ff 75 0c             	pushl  0xc(%ebp)
c00232b8:	e8 26 fa ff ff       	call   c0022ce3 <lock_acquire>
c00232bd:	83 c4 10             	add    $0x10,%esp
}
c00232c0:	90                   	nop
c00232c1:	c9                   	leave  
c00232c2:	c3                   	ret    

c00232c3 <cond_signal>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_signal (struct condition *cond, struct lock *lock UNUSED) 
{
c00232c3:	55                   	push   %ebp
c00232c4:	89 e5                	mov    %esp,%ebp
c00232c6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c00232c9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00232cd:	75 21                	jne    c00232f0 <cond_signal+0x2d>
c00232cf:	83 ec 0c             	sub    $0xc,%esp
c00232d2:	68 13 f7 02 c0       	push   $0xc002f713
c00232d7:	68 59 f6 02 c0       	push   $0xc002f659
c00232dc:	68 c4 f7 02 c0       	push   $0xc002f7c4
c00232e1:	68 b9 01 00 00       	push   $0x1b9
c00232e6:	68 70 f6 02 c0       	push   $0xc002f670
c00232eb:	e8 2b 69 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock != NULL);
c00232f0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00232f4:	75 21                	jne    c0023317 <cond_signal+0x54>
c00232f6:	83 ec 0c             	sub    $0xc,%esp
c00232f9:	68 bd f6 02 c0       	push   $0xc002f6bd
c00232fe:	68 59 f6 02 c0       	push   $0xc002f659
c0023303:	68 c4 f7 02 c0       	push   $0xc002f7c4
c0023308:	68 ba 01 00 00       	push   $0x1ba
c002330d:	68 70 f6 02 c0       	push   $0xc002f670
c0023312:	e8 04 69 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!intr_context ());
c0023317:	e8 ba e4 ff ff       	call   c00217d6 <intr_context>
c002331c:	83 f0 01             	xor    $0x1,%eax
c002331f:	84 c0                	test   %al,%al
c0023321:	75 21                	jne    c0023344 <cond_signal+0x81>
c0023323:	83 ec 0c             	sub    $0xc,%esp
c0023326:	68 86 f6 02 c0       	push   $0xc002f686
c002332b:	68 59 f6 02 c0       	push   $0xc002f659
c0023330:	68 c4 f7 02 c0       	push   $0xc002f7c4
c0023335:	68 bb 01 00 00       	push   $0x1bb
c002333a:	68 70 f6 02 c0       	push   $0xc002f670
c002333f:	e8 d7 68 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock_held_by_current_thread (lock));
c0023344:	83 ec 0c             	sub    $0xc,%esp
c0023347:	ff 75 0c             	pushl  0xc(%ebp)
c002334a:	e8 d6 fd ff ff       	call   c0023125 <lock_held_by_current_thread>
c002334f:	83 c4 10             	add    $0x10,%esp
c0023352:	84 c0                	test   %al,%al
c0023354:	75 21                	jne    c0023377 <cond_signal+0xb4>
c0023356:	83 ec 0c             	sub    $0xc,%esp
c0023359:	68 f0 f6 02 c0       	push   $0xc002f6f0
c002335e:	68 59 f6 02 c0       	push   $0xc002f659
c0023363:	68 c4 f7 02 c0       	push   $0xc002f7c4
c0023368:	68 bc 01 00 00       	push   $0x1bc
c002336d:	68 70 f6 02 c0       	push   $0xc002f670
c0023372:	e8 a4 68 00 00       	call   c0029c1b <debug_panic>

  if (!list_empty (&cond->waiters)){ 
c0023377:	8b 45 08             	mov    0x8(%ebp),%eax
c002337a:	83 ec 0c             	sub    $0xc,%esp
c002337d:	50                   	push   %eax
c002337e:	e8 93 70 00 00       	call   c002a416 <list_empty>
c0023383:	83 c4 10             	add    $0x10,%esp
c0023386:	83 f0 01             	xor    $0x1,%eax
c0023389:	84 c0                	test   %al,%al
c002338b:	74 3a                	je     c00233c7 <cond_signal+0x104>
    //ordenar semaphore_elems por sus prioridades asociadas, luego liberar el de mayor prioridad aqui codigo
    list_sort(&cond->waiters, (list_less_func*)&cond_compare, NULL);
c002338d:	8b 45 08             	mov    0x8(%ebp),%eax
c0023390:	83 ec 04             	sub    $0x4,%esp
c0023393:	6a 00                	push   $0x0
c0023395:	68 52 29 02 c0       	push   $0xc0022952
c002339a:	50                   	push   %eax
c002339b:	e8 2d 74 00 00       	call   c002a7cd <list_sort>
c00233a0:	83 c4 10             	add    $0x10,%esp
    sema_up (&list_entry (list_pop_front (&cond->waiters),
c00233a3:	8b 45 08             	mov    0x8(%ebp),%eax
c00233a6:	83 ec 0c             	sub    $0xc,%esp
c00233a9:	50                   	push   %eax
c00233aa:	e8 3e 6f 00 00       	call   c002a2ed <list_pop_front>
c00233af:	83 c4 10             	add    $0x10,%esp
c00233b2:	83 c0 04             	add    $0x4,%eax
c00233b5:	83 e8 04             	sub    $0x4,%eax
c00233b8:	83 c0 08             	add    $0x8,%eax
c00233bb:	83 ec 0c             	sub    $0xc,%esp
c00233be:	50                   	push   %eax
c00233bf:	e8 1f f7 ff ff       	call   c0022ae3 <sema_up>
c00233c4:	83 c4 10             	add    $0x10,%esp
                          struct semaphore_elem, elem)->semaphore);
  }
}
c00233c7:	90                   	nop
c00233c8:	c9                   	leave  
c00233c9:	c3                   	ret    

c00233ca <cond_broadcast>:
   An interrupt handler cannot acquire a lock, so it does not
   make sense to try to signal a condition variable within an
   interrupt handler. */
void
cond_broadcast (struct condition *cond, struct lock *lock) 
{
c00233ca:	55                   	push   %ebp
c00233cb:	89 e5                	mov    %esp,%ebp
c00233cd:	83 ec 08             	sub    $0x8,%esp
  ASSERT (cond != NULL);
c00233d0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00233d4:	75 21                	jne    c00233f7 <cond_broadcast+0x2d>
c00233d6:	83 ec 0c             	sub    $0xc,%esp
c00233d9:	68 13 f7 02 c0       	push   $0xc002f713
c00233de:	68 59 f6 02 c0       	push   $0xc002f659
c00233e3:	68 d0 f7 02 c0       	push   $0xc002f7d0
c00233e8:	68 cf 01 00 00       	push   $0x1cf
c00233ed:	68 70 f6 02 c0       	push   $0xc002f670
c00233f2:	e8 24 68 00 00       	call   c0029c1b <debug_panic>
  ASSERT (lock != NULL);
c00233f7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00233fb:	75 32                	jne    c002342f <cond_broadcast+0x65>
c00233fd:	83 ec 0c             	sub    $0xc,%esp
c0023400:	68 bd f6 02 c0       	push   $0xc002f6bd
c0023405:	68 59 f6 02 c0       	push   $0xc002f659
c002340a:	68 d0 f7 02 c0       	push   $0xc002f7d0
c002340f:	68 d0 01 00 00       	push   $0x1d0
c0023414:	68 70 f6 02 c0       	push   $0xc002f670
c0023419:	e8 fd 67 00 00       	call   c0029c1b <debug_panic>

  while (!list_empty (&cond->waiters))
    cond_signal (cond, lock);
c002341e:	83 ec 08             	sub    $0x8,%esp
c0023421:	ff 75 0c             	pushl  0xc(%ebp)
c0023424:	ff 75 08             	pushl  0x8(%ebp)
c0023427:	e8 97 fe ff ff       	call   c00232c3 <cond_signal>
c002342c:	83 c4 10             	add    $0x10,%esp
cond_broadcast (struct condition *cond, struct lock *lock) 
{
  ASSERT (cond != NULL);
  ASSERT (lock != NULL);

  while (!list_empty (&cond->waiters))
c002342f:	8b 45 08             	mov    0x8(%ebp),%eax
c0023432:	83 ec 0c             	sub    $0xc,%esp
c0023435:	50                   	push   %eax
c0023436:	e8 db 6f 00 00       	call   c002a416 <list_empty>
c002343b:	83 c4 10             	add    $0x10,%esp
c002343e:	83 f0 01             	xor    $0x1,%eax
c0023441:	84 c0                	test   %al,%al
c0023443:	75 d9                	jne    c002341e <cond_broadcast+0x54>
    cond_signal (cond, lock);
}
c0023445:	90                   	nop
c0023446:	c9                   	leave  
c0023447:	c3                   	ret    

c0023448 <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c0023448:	55                   	push   %ebp
c0023449:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c002344b:	8b 45 08             	mov    0x8(%ebp),%eax
c002344e:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c0023453:	5d                   	pop    %ebp
c0023454:	c3                   	ret    

c0023455 <pg_no>:

/* Virtual page number. */
static inline uintptr_t pg_no (const void *va) {
c0023455:	55                   	push   %ebp
c0023456:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va >> PGBITS;
c0023458:	8b 45 08             	mov    0x8(%ebp),%eax
c002345b:	c1 e8 0c             	shr    $0xc,%eax
}
c002345e:	5d                   	pop    %ebp
c002345f:	c3                   	ret    

c0023460 <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c0023460:	55                   	push   %ebp
c0023461:	89 e5                	mov    %esp,%ebp
c0023463:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0023466:	8b 45 08             	mov    0x8(%ebp),%eax
c0023469:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c002346e:	76 1e                	jbe    c002348e <ptov+0x2e>
c0023470:	83 ec 0c             	sub    $0xc,%esp
c0023473:	68 e0 f7 02 c0       	push   $0xc002f7e0
c0023478:	68 fb f7 02 c0       	push   $0xc002f7fb
c002347d:	68 18 f9 02 c0       	push   $0xc002f918
c0023482:	6a 4a                	push   $0x4a
c0023484:	68 12 f8 02 c0       	push   $0xc002f812
c0023489:	e8 8d 67 00 00       	call   c0029c1b <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c002348e:	8b 45 08             	mov    0x8(%ebp),%eax
c0023491:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0023496:	c9                   	leave  
c0023497:	c3                   	ret    

c0023498 <palloc_init>:

/* Initializes the page allocator.  At most USER_PAGE_LIMIT
   pages are put into the user pool. */
void
palloc_init (size_t user_page_limit)
{
c0023498:	55                   	push   %ebp
c0023499:	89 e5                	mov    %esp,%ebp
c002349b:	83 ec 28             	sub    $0x28,%esp
  /* Free memory starts at 1 MB and runs to the end of RAM. */
  uint8_t *free_start = ptov (1024 * 1024);
c002349e:	83 ec 0c             	sub    $0xc,%esp
c00234a1:	68 00 00 10 00       	push   $0x100000
c00234a6:	e8 b5 ff ff ff       	call   c0023460 <ptov>
c00234ab:	83 c4 10             	add    $0x10,%esp
c00234ae:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t *free_end = ptov (init_ram_pages * PGSIZE);
c00234b1:	a1 7e 01 02 c0       	mov    0xc002017e,%eax
c00234b6:	c1 e0 0c             	shl    $0xc,%eax
c00234b9:	83 ec 0c             	sub    $0xc,%esp
c00234bc:	50                   	push   %eax
c00234bd:	e8 9e ff ff ff       	call   c0023460 <ptov>
c00234c2:	83 c4 10             	add    $0x10,%esp
c00234c5:	89 45 ec             	mov    %eax,-0x14(%ebp)
  size_t free_pages = (free_end - free_start) / PGSIZE;
c00234c8:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00234cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00234ce:	29 c2                	sub    %eax,%edx
c00234d0:	89 d0                	mov    %edx,%eax
c00234d2:	8d 90 ff 0f 00 00    	lea    0xfff(%eax),%edx
c00234d8:	85 c0                	test   %eax,%eax
c00234da:	0f 48 c2             	cmovs  %edx,%eax
c00234dd:	c1 f8 0c             	sar    $0xc,%eax
c00234e0:	89 45 e8             	mov    %eax,-0x18(%ebp)
  size_t user_pages = free_pages / 2;
c00234e3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00234e6:	d1 e8                	shr    %eax
c00234e8:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t kernel_pages;
  if (user_pages > user_page_limit)
c00234eb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00234ee:	3b 45 08             	cmp    0x8(%ebp),%eax
c00234f1:	76 06                	jbe    c00234f9 <palloc_init+0x61>
    user_pages = user_page_limit;
c00234f3:	8b 45 08             	mov    0x8(%ebp),%eax
c00234f6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  kernel_pages = free_pages - user_pages;
c00234f9:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00234fc:	2b 45 f4             	sub    -0xc(%ebp),%eax
c00234ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Give half of memory to kernel, half to user. */
  init_pool (&kernel_pool, free_start, kernel_pages, "kernel pool");
c0023502:	68 28 f8 02 c0       	push   $0xc002f828
c0023507:	ff 75 e4             	pushl  -0x1c(%ebp)
c002350a:	ff 75 f0             	pushl  -0x10(%ebp)
c002350d:	68 c0 97 03 c0       	push   $0xc00397c0
c0023512:	e8 6e 02 00 00       	call   c0023785 <init_pool>
c0023517:	83 c4 10             	add    $0x10,%esp
  init_pool (&user_pool, free_start + kernel_pages * PGSIZE,
c002351a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002351d:	c1 e0 0c             	shl    $0xc,%eax
c0023520:	89 c2                	mov    %eax,%edx
c0023522:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023525:	01 d0                	add    %edx,%eax
c0023527:	68 34 f8 02 c0       	push   $0xc002f834
c002352c:	ff 75 f4             	pushl  -0xc(%ebp)
c002352f:	50                   	push   %eax
c0023530:	68 00 98 03 c0       	push   $0xc0039800
c0023535:	e8 4b 02 00 00       	call   c0023785 <init_pool>
c002353a:	83 c4 10             	add    $0x10,%esp
             user_pages, "user pool");
}
c002353d:	90                   	nop
c002353e:	c9                   	leave  
c002353f:	c3                   	ret    

c0023540 <palloc_get_multiple>:
   then the pages are filled with zeros.  If too few pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_multiple (enum palloc_flags flags, size_t page_cnt)
{
c0023540:	55                   	push   %ebp
c0023541:	89 e5                	mov    %esp,%ebp
c0023543:	83 ec 18             	sub    $0x18,%esp
  struct pool *pool = flags & PAL_USER ? &user_pool : &kernel_pool;
c0023546:	8b 45 08             	mov    0x8(%ebp),%eax
c0023549:	83 e0 04             	and    $0x4,%eax
c002354c:	85 c0                	test   %eax,%eax
c002354e:	74 07                	je     c0023557 <palloc_get_multiple+0x17>
c0023550:	b8 00 98 03 c0       	mov    $0xc0039800,%eax
c0023555:	eb 05                	jmp    c002355c <palloc_get_multiple+0x1c>
c0023557:	b8 c0 97 03 c0       	mov    $0xc00397c0,%eax
c002355c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  void *pages;
  size_t page_idx;

  if (page_cnt == 0)
c002355f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023563:	75 0a                	jne    c002356f <palloc_get_multiple+0x2f>
    return NULL;
c0023565:	b8 00 00 00 00       	mov    $0x0,%eax
c002356a:	e9 a3 00 00 00       	jmp    c0023612 <palloc_get_multiple+0xd2>

  lock_acquire (&pool->lock);
c002356f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023572:	83 ec 0c             	sub    $0xc,%esp
c0023575:	50                   	push   %eax
c0023576:	e8 68 f7 ff ff       	call   c0022ce3 <lock_acquire>
c002357b:	83 c4 10             	add    $0x10,%esp
  page_idx = bitmap_scan_and_flip (pool->used_map, 0, page_cnt, false);
c002357e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023581:	8b 40 20             	mov    0x20(%eax),%eax
c0023584:	6a 00                	push   $0x0
c0023586:	ff 75 0c             	pushl  0xc(%ebp)
c0023589:	6a 00                	push   $0x0
c002358b:	50                   	push   %eax
c002358c:	e8 b9 7d 00 00       	call   c002b34a <bitmap_scan_and_flip>
c0023591:	83 c4 10             	add    $0x10,%esp
c0023594:	89 45 ec             	mov    %eax,-0x14(%ebp)
  lock_release (&pool->lock);
c0023597:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002359a:	83 ec 0c             	sub    $0xc,%esp
c002359d:	50                   	push   %eax
c002359e:	e8 23 f9 ff ff       	call   c0022ec6 <lock_release>
c00235a3:	83 c4 10             	add    $0x10,%esp

  if (page_idx != BITMAP_ERROR)
c00235a6:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
c00235aa:	74 13                	je     c00235bf <palloc_get_multiple+0x7f>
    pages = pool->base + PGSIZE * page_idx;
c00235ac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00235af:	8b 40 24             	mov    0x24(%eax),%eax
c00235b2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00235b5:	c1 e2 0c             	shl    $0xc,%edx
c00235b8:	01 d0                	add    %edx,%eax
c00235ba:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00235bd:	eb 07                	jmp    c00235c6 <palloc_get_multiple+0x86>
  else
    pages = NULL;
c00235bf:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  if (pages != NULL) 
c00235c6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00235ca:	74 23                	je     c00235ef <palloc_get_multiple+0xaf>
    {
      if (flags & PAL_ZERO)
c00235cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00235cf:	83 e0 02             	and    $0x2,%eax
c00235d2:	85 c0                	test   %eax,%eax
c00235d4:	74 39                	je     c002360f <palloc_get_multiple+0xcf>
        memset (pages, 0, PGSIZE * page_cnt);
c00235d6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00235d9:	c1 e0 0c             	shl    $0xc,%eax
c00235dc:	83 ec 04             	sub    $0x4,%esp
c00235df:	50                   	push   %eax
c00235e0:	6a 00                	push   $0x0
c00235e2:	ff 75 f4             	pushl  -0xc(%ebp)
c00235e5:	e8 25 5a 00 00       	call   c002900f <memset>
c00235ea:	83 c4 10             	add    $0x10,%esp
c00235ed:	eb 20                	jmp    c002360f <palloc_get_multiple+0xcf>
    }
  else 
    {
      if (flags & PAL_ASSERT)
c00235ef:	8b 45 08             	mov    0x8(%ebp),%eax
c00235f2:	83 e0 01             	and    $0x1,%eax
c00235f5:	85 c0                	test   %eax,%eax
c00235f7:	74 16                	je     c002360f <palloc_get_multiple+0xcf>
        PANIC ("palloc_get: out of pages");
c00235f9:	68 3e f8 02 c0       	push   $0xc002f83e
c00235fe:	68 20 f9 02 c0       	push   $0xc002f920
c0023603:	6a 61                	push   $0x61
c0023605:	68 57 f8 02 c0       	push   $0xc002f857
c002360a:	e8 0c 66 00 00       	call   c0029c1b <debug_panic>
    }

  return pages;
c002360f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023612:	c9                   	leave  
c0023613:	c3                   	ret    

c0023614 <palloc_get_page>:
   then the page is filled with zeros.  If no pages are
   available, returns a null pointer, unless PAL_ASSERT is set in
   FLAGS, in which case the kernel panics. */
void *
palloc_get_page (enum palloc_flags flags) 
{
c0023614:	55                   	push   %ebp
c0023615:	89 e5                	mov    %esp,%ebp
c0023617:	83 ec 08             	sub    $0x8,%esp
  return palloc_get_multiple (flags, 1);
c002361a:	83 ec 08             	sub    $0x8,%esp
c002361d:	6a 01                	push   $0x1
c002361f:	ff 75 08             	pushl  0x8(%ebp)
c0023622:	e8 19 ff ff ff       	call   c0023540 <palloc_get_multiple>
c0023627:	83 c4 10             	add    $0x10,%esp
}
c002362a:	c9                   	leave  
c002362b:	c3                   	ret    

c002362c <palloc_free_multiple>:

/* Frees the PAGE_CNT pages starting at PAGES. */
void
palloc_free_multiple (void *pages, size_t page_cnt) 
{
c002362c:	55                   	push   %ebp
c002362d:	89 e5                	mov    %esp,%ebp
c002362f:	53                   	push   %ebx
c0023630:	83 ec 14             	sub    $0x14,%esp
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
c0023633:	ff 75 08             	pushl  0x8(%ebp)
c0023636:	e8 0d fe ff ff       	call   c0023448 <pg_ofs>
c002363b:	83 c4 04             	add    $0x4,%esp
c002363e:	85 c0                	test   %eax,%eax
c0023640:	74 1e                	je     c0023660 <palloc_free_multiple+0x34>
c0023642:	83 ec 0c             	sub    $0xc,%esp
c0023645:	68 6e f8 02 c0       	push   $0xc002f86e
c002364a:	68 fb f7 02 c0       	push   $0xc002f7fb
c002364f:	68 34 f9 02 c0       	push   $0xc002f934
c0023654:	6a 7b                	push   $0x7b
c0023656:	68 57 f8 02 c0       	push   $0xc002f857
c002365b:	e8 bb 65 00 00       	call   c0029c1b <debug_panic>
  if (pages == NULL || page_cnt == 0)
c0023660:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023664:	0f 84 fc 00 00 00    	je     c0023766 <palloc_free_multiple+0x13a>
c002366a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002366e:	0f 84 f2 00 00 00    	je     c0023766 <palloc_free_multiple+0x13a>
    return;

  if (page_from_pool (&kernel_pool, pages))
c0023674:	83 ec 08             	sub    $0x8,%esp
c0023677:	ff 75 08             	pushl  0x8(%ebp)
c002367a:	68 c0 97 03 c0       	push   $0xc00397c0
c002367f:	e8 a8 01 00 00       	call   c002382c <page_from_pool>
c0023684:	83 c4 10             	add    $0x10,%esp
c0023687:	84 c0                	test   %al,%al
c0023689:	74 09                	je     c0023694 <palloc_free_multiple+0x68>
    pool = &kernel_pool;
c002368b:	c7 45 f4 c0 97 03 c0 	movl   $0xc00397c0,-0xc(%ebp)
c0023692:	eb 39                	jmp    c00236cd <palloc_free_multiple+0xa1>
  else if (page_from_pool (&user_pool, pages))
c0023694:	83 ec 08             	sub    $0x8,%esp
c0023697:	ff 75 08             	pushl  0x8(%ebp)
c002369a:	68 00 98 03 c0       	push   $0xc0039800
c002369f:	e8 88 01 00 00       	call   c002382c <page_from_pool>
c00236a4:	83 c4 10             	add    $0x10,%esp
c00236a7:	84 c0                	test   %al,%al
c00236a9:	74 09                	je     c00236b4 <palloc_free_multiple+0x88>
    pool = &user_pool;
c00236ab:	c7 45 f4 00 98 03 c0 	movl   $0xc0039800,-0xc(%ebp)
c00236b2:	eb 19                	jmp    c00236cd <palloc_free_multiple+0xa1>
  else
    NOT_REACHED ();
c00236b4:	68 84 f8 02 c0       	push   $0xc002f884
c00236b9:	68 34 f9 02 c0       	push   $0xc002f934
c00236be:	68 84 00 00 00       	push   $0x84
c00236c3:	68 57 f8 02 c0       	push   $0xc002f857
c00236c8:	e8 4e 65 00 00       	call   c0029c1b <debug_panic>

  page_idx = pg_no (pages) - pg_no (pool->base);
c00236cd:	83 ec 0c             	sub    $0xc,%esp
c00236d0:	ff 75 08             	pushl  0x8(%ebp)
c00236d3:	e8 7d fd ff ff       	call   c0023455 <pg_no>
c00236d8:	83 c4 10             	add    $0x10,%esp
c00236db:	89 c3                	mov    %eax,%ebx
c00236dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00236e0:	8b 40 24             	mov    0x24(%eax),%eax
c00236e3:	83 ec 0c             	sub    $0xc,%esp
c00236e6:	50                   	push   %eax
c00236e7:	e8 69 fd ff ff       	call   c0023455 <pg_no>
c00236ec:	83 c4 10             	add    $0x10,%esp
c00236ef:	29 c3                	sub    %eax,%ebx
c00236f1:	89 d8                	mov    %ebx,%eax
c00236f3:	89 45 f0             	mov    %eax,-0x10(%ebp)

#ifndef NDEBUG
  memset (pages, 0xcc, PGSIZE * page_cnt);
c00236f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00236f9:	c1 e0 0c             	shl    $0xc,%eax
c00236fc:	83 ec 04             	sub    $0x4,%esp
c00236ff:	50                   	push   %eax
c0023700:	68 cc 00 00 00       	push   $0xcc
c0023705:	ff 75 08             	pushl  0x8(%ebp)
c0023708:	e8 02 59 00 00       	call   c002900f <memset>
c002370d:	83 c4 10             	add    $0x10,%esp
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
c0023710:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023713:	8b 40 20             	mov    0x20(%eax),%eax
c0023716:	83 ec 04             	sub    $0x4,%esp
c0023719:	ff 75 0c             	pushl  0xc(%ebp)
c002371c:	ff 75 f0             	pushl  -0x10(%ebp)
c002371f:	50                   	push   %eax
c0023720:	e8 43 7b 00 00       	call   c002b268 <bitmap_all>
c0023725:	83 c4 10             	add    $0x10,%esp
c0023728:	84 c0                	test   %al,%al
c002372a:	75 21                	jne    c002374d <palloc_free_multiple+0x121>
c002372c:	83 ec 0c             	sub    $0xc,%esp
c002372f:	68 a8 f8 02 c0       	push   $0xc002f8a8
c0023734:	68 fb f7 02 c0       	push   $0xc002f7fb
c0023739:	68 34 f9 02 c0       	push   $0xc002f934
c002373e:	68 8c 00 00 00       	push   $0x8c
c0023743:	68 57 f8 02 c0       	push   $0xc002f857
c0023748:	e8 ce 64 00 00       	call   c0029c1b <debug_panic>
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
c002374d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023750:	8b 40 20             	mov    0x20(%eax),%eax
c0023753:	6a 00                	push   $0x0
c0023755:	ff 75 0c             	pushl  0xc(%ebp)
c0023758:	ff 75 f0             	pushl  -0x10(%ebp)
c002375b:	50                   	push   %eax
c002375c:	e8 5c 78 00 00       	call   c002afbd <bitmap_set_multiple>
c0023761:	83 c4 10             	add    $0x10,%esp
c0023764:	eb 01                	jmp    c0023767 <palloc_free_multiple+0x13b>
  struct pool *pool;
  size_t page_idx;

  ASSERT (pg_ofs (pages) == 0);
  if (pages == NULL || page_cnt == 0)
    return;
c0023766:	90                   	nop
  memset (pages, 0xcc, PGSIZE * page_cnt);
#endif

  ASSERT (bitmap_all (pool->used_map, page_idx, page_cnt));
  bitmap_set_multiple (pool->used_map, page_idx, page_cnt, false);
}
c0023767:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002376a:	c9                   	leave  
c002376b:	c3                   	ret    

c002376c <palloc_free_page>:

/* Frees the page at PAGE. */
void
palloc_free_page (void *page) 
{
c002376c:	55                   	push   %ebp
c002376d:	89 e5                	mov    %esp,%ebp
c002376f:	83 ec 08             	sub    $0x8,%esp
  palloc_free_multiple (page, 1);
c0023772:	83 ec 08             	sub    $0x8,%esp
c0023775:	6a 01                	push   $0x1
c0023777:	ff 75 08             	pushl  0x8(%ebp)
c002377a:	e8 ad fe ff ff       	call   c002362c <palloc_free_multiple>
c002377f:	83 c4 10             	add    $0x10,%esp
}
c0023782:	90                   	nop
c0023783:	c9                   	leave  
c0023784:	c3                   	ret    

c0023785 <init_pool>:

/* Initializes pool P as starting at START and ending at END,
   naming it NAME for debugging purposes. */
static void
init_pool (struct pool *p, void *base, size_t page_cnt, const char *name) 
{
c0023785:	55                   	push   %ebp
c0023786:	89 e5                	mov    %esp,%ebp
c0023788:	83 ec 18             	sub    $0x18,%esp
  /* We'll put the pool's used_map at its base.
     Calculate the space needed for the bitmap
     and subtract it from the pool's size. */
  size_t bm_pages = DIV_ROUND_UP (bitmap_buf_size (page_cnt), PGSIZE);
c002378b:	83 ec 0c             	sub    $0xc,%esp
c002378e:	ff 75 10             	pushl  0x10(%ebp)
c0023791:	e8 bd 75 00 00       	call   c002ad53 <bitmap_buf_size>
c0023796:	83 c4 10             	add    $0x10,%esp
c0023799:	05 ff 0f 00 00       	add    $0xfff,%eax
c002379e:	c1 e8 0c             	shr    $0xc,%eax
c00237a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (bm_pages > page_cnt)
c00237a4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00237a7:	3b 45 10             	cmp    0x10(%ebp),%eax
c00237aa:	76 1f                	jbe    c00237cb <init_pool+0x46>
    PANIC ("Not enough memory in %s for bitmap.", name);
c00237ac:	83 ec 0c             	sub    $0xc,%esp
c00237af:	ff 75 14             	pushl  0x14(%ebp)
c00237b2:	68 d8 f8 02 c0       	push   $0xc002f8d8
c00237b7:	68 4c f9 02 c0       	push   $0xc002f94c
c00237bc:	68 a1 00 00 00       	push   $0xa1
c00237c1:	68 57 f8 02 c0       	push   $0xc002f857
c00237c6:	e8 50 64 00 00       	call   c0029c1b <debug_panic>
  page_cnt -= bm_pages;
c00237cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00237ce:	29 45 10             	sub    %eax,0x10(%ebp)

  printf ("%zu pages available in %s.\n", page_cnt, name);
c00237d1:	83 ec 04             	sub    $0x4,%esp
c00237d4:	ff 75 14             	pushl  0x14(%ebp)
c00237d7:	ff 75 10             	pushl  0x10(%ebp)
c00237da:	68 fc f8 02 c0       	push   $0xc002f8fc
c00237df:	e8 04 40 00 00       	call   c00277e8 <printf>
c00237e4:	83 c4 10             	add    $0x10,%esp

  /* Initialize the pool. */
  lock_init (&p->lock);
c00237e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00237ea:	83 ec 0c             	sub    $0xc,%esp
c00237ed:	50                   	push   %eax
c00237ee:	e8 a3 f4 ff ff       	call   c0022c96 <lock_init>
c00237f3:	83 c4 10             	add    $0x10,%esp
  p->used_map = bitmap_create_in_buf (page_cnt, base, bm_pages * PGSIZE);
c00237f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00237f9:	c1 e0 0c             	shl    $0xc,%eax
c00237fc:	83 ec 04             	sub    $0x4,%esp
c00237ff:	50                   	push   %eax
c0023800:	ff 75 0c             	pushl  0xc(%ebp)
c0023803:	ff 75 10             	pushl  0x10(%ebp)
c0023806:	e8 e2 74 00 00       	call   c002aced <bitmap_create_in_buf>
c002380b:	83 c4 10             	add    $0x10,%esp
c002380e:	89 c2                	mov    %eax,%edx
c0023810:	8b 45 08             	mov    0x8(%ebp),%eax
c0023813:	89 50 20             	mov    %edx,0x20(%eax)
  p->base = base + bm_pages * PGSIZE;
c0023816:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023819:	c1 e0 0c             	shl    $0xc,%eax
c002381c:	89 c2                	mov    %eax,%edx
c002381e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023821:	01 c2                	add    %eax,%edx
c0023823:	8b 45 08             	mov    0x8(%ebp),%eax
c0023826:	89 50 24             	mov    %edx,0x24(%eax)
}
c0023829:	90                   	nop
c002382a:	c9                   	leave  
c002382b:	c3                   	ret    

c002382c <page_from_pool>:

/* Returns true if PAGE was allocated from POOL,
   false otherwise. */
static bool
page_from_pool (const struct pool *pool, void *page) 
{
c002382c:	55                   	push   %ebp
c002382d:	89 e5                	mov    %esp,%ebp
c002382f:	83 ec 18             	sub    $0x18,%esp
  size_t page_no = pg_no (page);
c0023832:	ff 75 0c             	pushl  0xc(%ebp)
c0023835:	e8 1b fc ff ff       	call   c0023455 <pg_no>
c002383a:	83 c4 04             	add    $0x4,%esp
c002383d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t start_page = pg_no (pool->base);
c0023840:	8b 45 08             	mov    0x8(%ebp),%eax
c0023843:	8b 40 24             	mov    0x24(%eax),%eax
c0023846:	50                   	push   %eax
c0023847:	e8 09 fc ff ff       	call   c0023455 <pg_no>
c002384c:	83 c4 04             	add    $0x4,%esp
c002384f:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t end_page = start_page + bitmap_size (pool->used_map);
c0023852:	8b 45 08             	mov    0x8(%ebp),%eax
c0023855:	8b 40 20             	mov    0x20(%eax),%eax
c0023858:	83 ec 0c             	sub    $0xc,%esp
c002385b:	50                   	push   %eax
c002385c:	e8 34 75 00 00       	call   c002ad95 <bitmap_size>
c0023861:	83 c4 10             	add    $0x10,%esp
c0023864:	89 c2                	mov    %eax,%edx
c0023866:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023869:	01 d0                	add    %edx,%eax
c002386b:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return page_no >= start_page && page_no < end_page;
c002386e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023871:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023874:	72 0f                	jb     c0023885 <page_from_pool+0x59>
c0023876:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023879:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002387c:	73 07                	jae    c0023885 <page_from_pool+0x59>
c002387e:	b8 01 00 00 00       	mov    $0x1,%eax
c0023883:	eb 05                	jmp    c002388a <page_from_pool+0x5e>
c0023885:	b8 00 00 00 00       	mov    $0x0,%eax
c002388a:	83 e0 01             	and    $0x1,%eax
}
c002388d:	c9                   	leave  
c002388e:	c3                   	ret    

c002388f <pg_ofs>:
#define PGBITS  12                         /* Number of offset bits. */
#define PGSIZE  (1 << PGBITS)              /* Bytes in a page. */
#define PGMASK  BITMASK(PGSHIFT, PGBITS)   /* Page offset bits (0:12). */

/* Offset within a page. */
static inline unsigned pg_ofs (const void *va) {
c002388f:	55                   	push   %ebp
c0023890:	89 e5                	mov    %esp,%ebp
  return (uintptr_t) va & PGMASK;
c0023892:	8b 45 08             	mov    0x8(%ebp),%eax
c0023895:	25 ff 0f 00 00       	and    $0xfff,%eax
}
c002389a:	5d                   	pop    %ebp
c002389b:	c3                   	ret    

c002389c <pg_round_down>:
static inline void *pg_round_up (const void *va) {
  return (void *) (((uintptr_t) va + PGSIZE - 1) & ~PGMASK);
}

/* Round down to nearest page boundary. */
static inline void *pg_round_down (const void *va) {
c002389c:	55                   	push   %ebp
c002389d:	89 e5                	mov    %esp,%ebp
  return (void *) ((uintptr_t) va & ~PGMASK);
c002389f:	8b 45 08             	mov    0x8(%ebp),%eax
c00238a2:	25 00 f0 ff ff       	and    $0xfffff000,%eax
}
c00238a7:	5d                   	pop    %ebp
c00238a8:	c3                   	ret    

c00238a9 <malloc_init>:
static struct block *arena_to_block (struct arena *, size_t idx);

/* Initializes the malloc() descriptors. */
void
malloc_init (void) 
{
c00238a9:	55                   	push   %ebp
c00238aa:	89 e5                	mov    %esp,%ebp
c00238ac:	83 ec 18             	sub    $0x18,%esp
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c00238af:	c7 45 f4 10 00 00 00 	movl   $0x10,-0xc(%ebp)
c00238b6:	e9 96 00 00 00       	jmp    c0023951 <malloc_init+0xa8>
    {
      struct desc *d = &descs[desc_cnt++];
c00238bb:	a1 70 9a 03 c0       	mov    0xc0039a70,%eax
c00238c0:	8d 50 01             	lea    0x1(%eax),%edx
c00238c3:	89 15 70 9a 03 c0    	mov    %edx,0xc0039a70
c00238c9:	89 c2                	mov    %eax,%edx
c00238cb:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
c00238d2:	89 c2                	mov    %eax,%edx
c00238d4:	8d 04 d5 00 00 00 00 	lea    0x0(,%edx,8),%eax
c00238db:	29 d0                	sub    %edx,%eax
c00238dd:	05 40 98 03 c0       	add    $0xc0039840,%eax
c00238e2:	89 45 f0             	mov    %eax,-0x10(%ebp)
      ASSERT (desc_cnt <= sizeof descs / sizeof *descs);
c00238e5:	a1 70 9a 03 c0       	mov    0xc0039a70,%eax
c00238ea:	83 f8 0a             	cmp    $0xa,%eax
c00238ed:	76 1e                	jbe    c002390d <malloc_init+0x64>
c00238ef:	83 ec 0c             	sub    $0xc,%esp
c00238f2:	68 58 f9 02 c0       	push   $0xc002f958
c00238f7:	68 81 f9 02 c0       	push   $0xc002f981
c00238fc:	68 8c fa 02 c0       	push   $0xc002fa8c
c0023901:	6a 4f                	push   $0x4f
c0023903:	68 98 f9 02 c0       	push   $0xc002f998
c0023908:	e8 0e 63 00 00       	call   c0029c1b <debug_panic>
      d->block_size = block_size;
c002390d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023910:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023913:	89 10                	mov    %edx,(%eax)
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
c0023915:	b8 f4 0f 00 00       	mov    $0xff4,%eax
c002391a:	ba 00 00 00 00       	mov    $0x0,%edx
c002391f:	f7 75 f4             	divl   -0xc(%ebp)
c0023922:	89 c2                	mov    %eax,%edx
c0023924:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023927:	89 50 04             	mov    %edx,0x4(%eax)
      list_init (&d->free_list);
c002392a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002392d:	83 c0 08             	add    $0x8,%eax
c0023930:	83 ec 0c             	sub    $0xc,%esp
c0023933:	50                   	push   %eax
c0023934:	e8 55 65 00 00       	call   c0029e8e <list_init>
c0023939:	83 c4 10             	add    $0x10,%esp
      lock_init (&d->lock);
c002393c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002393f:	83 c0 18             	add    $0x18,%eax
c0023942:	83 ec 0c             	sub    $0xc,%esp
c0023945:	50                   	push   %eax
c0023946:	e8 4b f3 ff ff       	call   c0022c96 <lock_init>
c002394b:	83 c4 10             	add    $0x10,%esp
void
malloc_init (void) 
{
  size_t block_size;

  for (block_size = 16; block_size < PGSIZE / 2; block_size *= 2)
c002394e:	d1 65 f4             	shll   -0xc(%ebp)
c0023951:	81 7d f4 ff 07 00 00 	cmpl   $0x7ff,-0xc(%ebp)
c0023958:	0f 86 5d ff ff ff    	jbe    c00238bb <malloc_init+0x12>
      d->block_size = block_size;
      d->blocks_per_arena = (PGSIZE - sizeof (struct arena)) / block_size;
      list_init (&d->free_list);
      lock_init (&d->lock);
    }
}
c002395e:	90                   	nop
c002395f:	c9                   	leave  
c0023960:	c3                   	ret    

c0023961 <malloc>:

/* Obtains and returns a new block of at least SIZE bytes.
   Returns a null pointer if memory is not available. */
void *
malloc (size_t size) 
{
c0023961:	55                   	push   %ebp
c0023962:	89 e5                	mov    %esp,%ebp
c0023964:	83 ec 28             	sub    $0x28,%esp
  struct desc *d;
  struct block *b;
  struct arena *a;

  /* A null pointer satisfies a request for 0 bytes. */
  if (size == 0)
c0023967:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002396b:	75 0a                	jne    c0023977 <malloc+0x16>
    return NULL;
c002396d:	b8 00 00 00 00       	mov    $0x0,%eax
c0023972:	e9 ba 01 00 00       	jmp    c0023b31 <malloc+0x1d0>

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c0023977:	c7 45 f4 40 98 03 c0 	movl   $0xc0039840,-0xc(%ebp)
c002397e:	eb 0e                	jmp    c002398e <malloc+0x2d>
    if (d->block_size >= size)
c0023980:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023983:	8b 00                	mov    (%eax),%eax
c0023985:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023988:	73 23                	jae    c00239ad <malloc+0x4c>
  if (size == 0)
    return NULL;

  /* Find the smallest descriptor that satisfies a SIZE-byte
     request. */
  for (d = descs; d < descs + desc_cnt; d++)
c002398a:	83 45 f4 38          	addl   $0x38,-0xc(%ebp)
c002398e:	a1 70 9a 03 c0       	mov    0xc0039a70,%eax
c0023993:	c1 e0 03             	shl    $0x3,%eax
c0023996:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002399d:	29 c2                	sub    %eax,%edx
c002399f:	89 d0                	mov    %edx,%eax
c00239a1:	05 40 98 03 c0       	add    $0xc0039840,%eax
c00239a6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00239a9:	77 d5                	ja     c0023980 <malloc+0x1f>
c00239ab:	eb 01                	jmp    c00239ae <malloc+0x4d>
    if (d->block_size >= size)
      break;
c00239ad:	90                   	nop
  if (d == descs + desc_cnt) 
c00239ae:	a1 70 9a 03 c0       	mov    0xc0039a70,%eax
c00239b3:	c1 e0 03             	shl    $0x3,%eax
c00239b6:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c00239bd:	29 c2                	sub    %eax,%edx
c00239bf:	89 d0                	mov    %edx,%eax
c00239c1:	05 40 98 03 c0       	add    $0xc0039840,%eax
c00239c6:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00239c9:	75 58                	jne    c0023a23 <malloc+0xc2>
    {
      /* SIZE is too big for any descriptor.
         Allocate enough pages to hold SIZE plus an arena. */
      size_t page_cnt = DIV_ROUND_UP (size + sizeof *a, PGSIZE);
c00239cb:	8b 45 08             	mov    0x8(%ebp),%eax
c00239ce:	05 0b 10 00 00       	add    $0x100b,%eax
c00239d3:	c1 e8 0c             	shr    $0xc,%eax
c00239d6:	89 45 ec             	mov    %eax,-0x14(%ebp)
      a = palloc_get_multiple (0, page_cnt);
c00239d9:	83 ec 08             	sub    $0x8,%esp
c00239dc:	ff 75 ec             	pushl  -0x14(%ebp)
c00239df:	6a 00                	push   $0x0
c00239e1:	e8 5a fb ff ff       	call   c0023540 <palloc_get_multiple>
c00239e6:	83 c4 10             	add    $0x10,%esp
c00239e9:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL)
c00239ec:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c00239f0:	75 0a                	jne    c00239fc <malloc+0x9b>
        return NULL;
c00239f2:	b8 00 00 00 00       	mov    $0x0,%eax
c00239f7:	e9 35 01 00 00       	jmp    c0023b31 <malloc+0x1d0>

      /* Initialize the arena to indicate a big block of PAGE_CNT
         pages, and return it. */
      a->magic = ARENA_MAGIC;
c00239fc:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00239ff:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = NULL;
c0023a05:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a08:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      a->free_cnt = page_cnt;
c0023a0f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a12:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0023a15:	89 50 08             	mov    %edx,0x8(%eax)
      return a + 1;
c0023a18:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a1b:	83 c0 0c             	add    $0xc,%eax
c0023a1e:	e9 0e 01 00 00       	jmp    c0023b31 <malloc+0x1d0>
    }

  lock_acquire (&d->lock);
c0023a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a26:	83 c0 18             	add    $0x18,%eax
c0023a29:	83 ec 0c             	sub    $0xc,%esp
c0023a2c:	50                   	push   %eax
c0023a2d:	e8 b1 f2 ff ff       	call   c0022ce3 <lock_acquire>
c0023a32:	83 c4 10             	add    $0x10,%esp

  /* If the free list is empty, create a new arena. */
  if (list_empty (&d->free_list))
c0023a35:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a38:	83 c0 08             	add    $0x8,%eax
c0023a3b:	83 ec 0c             	sub    $0xc,%esp
c0023a3e:	50                   	push   %eax
c0023a3f:	e8 d2 69 00 00       	call   c002a416 <list_empty>
c0023a44:	83 c4 10             	add    $0x10,%esp
c0023a47:	84 c0                	test   %al,%al
c0023a49:	0f 84 92 00 00 00    	je     c0023ae1 <malloc+0x180>
    {
      size_t i;

      /* Allocate a page. */
      a = palloc_get_page (0);
c0023a4f:	83 ec 0c             	sub    $0xc,%esp
c0023a52:	6a 00                	push   $0x0
c0023a54:	e8 bb fb ff ff       	call   c0023614 <palloc_get_page>
c0023a59:	83 c4 10             	add    $0x10,%esp
c0023a5c:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (a == NULL) 
c0023a5f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023a63:	75 1c                	jne    c0023a81 <malloc+0x120>
        {
          lock_release (&d->lock);
c0023a65:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a68:	83 c0 18             	add    $0x18,%eax
c0023a6b:	83 ec 0c             	sub    $0xc,%esp
c0023a6e:	50                   	push   %eax
c0023a6f:	e8 52 f4 ff ff       	call   c0022ec6 <lock_release>
c0023a74:	83 c4 10             	add    $0x10,%esp
          return NULL; 
c0023a77:	b8 00 00 00 00       	mov    $0x0,%eax
c0023a7c:	e9 b0 00 00 00       	jmp    c0023b31 <malloc+0x1d0>
        }

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
c0023a81:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a84:	c7 00 ed 8e 54 9a    	movl   $0x9a548eed,(%eax)
      a->desc = d;
c0023a8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a8d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023a90:	89 50 04             	mov    %edx,0x4(%eax)
      a->free_cnt = d->blocks_per_arena;
c0023a93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023a96:	8b 50 04             	mov    0x4(%eax),%edx
c0023a99:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023a9c:	89 50 08             	mov    %edx,0x8(%eax)
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023a9f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0023aa6:	eb 2e                	jmp    c0023ad6 <malloc+0x175>
        {
          struct block *b = arena_to_block (a, i);
c0023aa8:	83 ec 08             	sub    $0x8,%esp
c0023aab:	ff 75 f0             	pushl  -0x10(%ebp)
c0023aae:	ff 75 e8             	pushl  -0x18(%ebp)
c0023ab1:	e8 ea 03 00 00       	call   c0023ea0 <arena_to_block>
c0023ab6:	83 c4 10             	add    $0x10,%esp
c0023ab9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          list_push_back (&d->free_list, &b->free_elem);
c0023abc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023abf:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0023ac2:	83 c2 08             	add    $0x8,%edx
c0023ac5:	83 ec 08             	sub    $0x8,%esp
c0023ac8:	50                   	push   %eax
c0023ac9:	52                   	push   %edx
c0023aca:	e8 9f 67 00 00       	call   c002a26e <list_push_back>
c0023acf:	83 c4 10             	add    $0x10,%esp

      /* Initialize arena and add its blocks to the free list. */
      a->magic = ARENA_MAGIC;
      a->desc = d;
      a->free_cnt = d->blocks_per_arena;
      for (i = 0; i < d->blocks_per_arena; i++) 
c0023ad2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0023ad6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ad9:	8b 40 04             	mov    0x4(%eax),%eax
c0023adc:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0023adf:	77 c7                	ja     c0023aa8 <malloc+0x147>
          list_push_back (&d->free_list, &b->free_elem);
        }
    }

  /* Get a block from free list and return it. */
  b = list_entry (list_pop_front (&d->free_list), struct block, free_elem);
c0023ae1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023ae4:	83 c0 08             	add    $0x8,%eax
c0023ae7:	83 ec 0c             	sub    $0xc,%esp
c0023aea:	50                   	push   %eax
c0023aeb:	e8 fd 67 00 00       	call   c002a2ed <list_pop_front>
c0023af0:	83 c4 10             	add    $0x10,%esp
c0023af3:	83 c0 04             	add    $0x4,%eax
c0023af6:	83 e8 04             	sub    $0x4,%eax
c0023af9:	89 45 e0             	mov    %eax,-0x20(%ebp)
  a = block_to_arena (b);
c0023afc:	83 ec 0c             	sub    $0xc,%esp
c0023aff:	ff 75 e0             	pushl  -0x20(%ebp)
c0023b02:	e8 9b 02 00 00       	call   c0023da2 <block_to_arena>
c0023b07:	83 c4 10             	add    $0x10,%esp
c0023b0a:	89 45 e8             	mov    %eax,-0x18(%ebp)
  a->free_cnt--;
c0023b0d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b10:	8b 40 08             	mov    0x8(%eax),%eax
c0023b13:	8d 50 ff             	lea    -0x1(%eax),%edx
c0023b16:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023b19:	89 50 08             	mov    %edx,0x8(%eax)
  lock_release (&d->lock);
c0023b1c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b1f:	83 c0 18             	add    $0x18,%eax
c0023b22:	83 ec 0c             	sub    $0xc,%esp
c0023b25:	50                   	push   %eax
c0023b26:	e8 9b f3 ff ff       	call   c0022ec6 <lock_release>
c0023b2b:	83 c4 10             	add    $0x10,%esp
  return b;
c0023b2e:	8b 45 e0             	mov    -0x20(%ebp),%eax
}
c0023b31:	c9                   	leave  
c0023b32:	c3                   	ret    

c0023b33 <calloc>:

/* Allocates and return A times B bytes initialized to zeroes.
   Returns a null pointer if memory is not available. */
void *
calloc (size_t a, size_t b) 
{
c0023b33:	55                   	push   %ebp
c0023b34:	89 e5                	mov    %esp,%ebp
c0023b36:	83 ec 18             	sub    $0x18,%esp
  void *p;
  size_t size;

  /* Calculate block size and make sure it fits in size_t. */
  size = a * b;
c0023b39:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b3c:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023b40:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (size < a || size < b)
c0023b43:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b46:	3b 45 08             	cmp    0x8(%ebp),%eax
c0023b49:	72 08                	jb     c0023b53 <calloc+0x20>
c0023b4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023b4e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023b51:	73 07                	jae    c0023b5a <calloc+0x27>
    return NULL;
c0023b53:	b8 00 00 00 00       	mov    $0x0,%eax
c0023b58:	eb 2d                	jmp    c0023b87 <calloc+0x54>

  /* Allocate and zero memory. */
  p = malloc (size);
c0023b5a:	83 ec 0c             	sub    $0xc,%esp
c0023b5d:	ff 75 f4             	pushl  -0xc(%ebp)
c0023b60:	e8 fc fd ff ff       	call   c0023961 <malloc>
c0023b65:	83 c4 10             	add    $0x10,%esp
c0023b68:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (p != NULL)
c0023b6b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0023b6f:	74 13                	je     c0023b84 <calloc+0x51>
    memset (p, 0, size);
c0023b71:	83 ec 04             	sub    $0x4,%esp
c0023b74:	ff 75 f4             	pushl  -0xc(%ebp)
c0023b77:	6a 00                	push   $0x0
c0023b79:	ff 75 f0             	pushl  -0x10(%ebp)
c0023b7c:	e8 8e 54 00 00       	call   c002900f <memset>
c0023b81:	83 c4 10             	add    $0x10,%esp

  return p;
c0023b84:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0023b87:	c9                   	leave  
c0023b88:	c3                   	ret    

c0023b89 <block_size>:

/* Returns the number of bytes allocated for BLOCK. */
static size_t
block_size (void *block) 
{
c0023b89:	55                   	push   %ebp
c0023b8a:	89 e5                	mov    %esp,%ebp
c0023b8c:	53                   	push   %ebx
c0023b8d:	83 ec 14             	sub    $0x14,%esp
  struct block *b = block;
c0023b90:	8b 45 08             	mov    0x8(%ebp),%eax
c0023b93:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct arena *a = block_to_arena (b);
c0023b96:	83 ec 0c             	sub    $0xc,%esp
c0023b99:	ff 75 f4             	pushl  -0xc(%ebp)
c0023b9c:	e8 01 02 00 00       	call   c0023da2 <block_to_arena>
c0023ba1:	83 c4 10             	add    $0x10,%esp
c0023ba4:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct desc *d = a->desc;
c0023ba7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023baa:	8b 40 04             	mov    0x4(%eax),%eax
c0023bad:	89 45 ec             	mov    %eax,-0x14(%ebp)

  return d != NULL ? d->block_size : PGSIZE * a->free_cnt - pg_ofs (block);
c0023bb0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c0023bb4:	74 07                	je     c0023bbd <block_size+0x34>
c0023bb6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023bb9:	8b 00                	mov    (%eax),%eax
c0023bbb:	eb 1d                	jmp    c0023bda <block_size+0x51>
c0023bbd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023bc0:	8b 40 08             	mov    0x8(%eax),%eax
c0023bc3:	c1 e0 0c             	shl    $0xc,%eax
c0023bc6:	89 c3                	mov    %eax,%ebx
c0023bc8:	83 ec 0c             	sub    $0xc,%esp
c0023bcb:	ff 75 08             	pushl  0x8(%ebp)
c0023bce:	e8 bc fc ff ff       	call   c002388f <pg_ofs>
c0023bd3:	83 c4 10             	add    $0x10,%esp
c0023bd6:	29 c3                	sub    %eax,%ebx
c0023bd8:	89 d8                	mov    %ebx,%eax
}
c0023bda:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0023bdd:	c9                   	leave  
c0023bde:	c3                   	ret    

c0023bdf <realloc>:
   null pointer.
   A call with null OLD_BLOCK is equivalent to malloc(NEW_SIZE).
   A call with zero NEW_SIZE is equivalent to free(OLD_BLOCK). */
void *
realloc (void *old_block, size_t new_size) 
{
c0023bdf:	55                   	push   %ebp
c0023be0:	89 e5                	mov    %esp,%ebp
c0023be2:	83 ec 18             	sub    $0x18,%esp
  if (new_size == 0) 
c0023be5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0023be9:	75 15                	jne    c0023c00 <realloc+0x21>
    {
      free (old_block);
c0023beb:	83 ec 0c             	sub    $0xc,%esp
c0023bee:	ff 75 08             	pushl  0x8(%ebp)
c0023bf1:	e8 6c 00 00 00       	call   c0023c62 <free>
c0023bf6:	83 c4 10             	add    $0x10,%esp
      return NULL;
c0023bf9:	b8 00 00 00 00       	mov    $0x0,%eax
c0023bfe:	eb 60                	jmp    c0023c60 <realloc+0x81>
    }
  else 
    {
      void *new_block = malloc (new_size);
c0023c00:	83 ec 0c             	sub    $0xc,%esp
c0023c03:	ff 75 0c             	pushl  0xc(%ebp)
c0023c06:	e8 56 fd ff ff       	call   c0023961 <malloc>
c0023c0b:	83 c4 10             	add    $0x10,%esp
c0023c0e:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (old_block != NULL && new_block != NULL)
c0023c11:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023c15:	74 46                	je     c0023c5d <realloc+0x7e>
c0023c17:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023c1b:	74 40                	je     c0023c5d <realloc+0x7e>
        {
          size_t old_size = block_size (old_block);
c0023c1d:	83 ec 0c             	sub    $0xc,%esp
c0023c20:	ff 75 08             	pushl  0x8(%ebp)
c0023c23:	e8 61 ff ff ff       	call   c0023b89 <block_size>
c0023c28:	83 c4 10             	add    $0x10,%esp
c0023c2b:	89 45 f0             	mov    %eax,-0x10(%ebp)
          size_t min_size = new_size < old_size ? new_size : old_size;
c0023c2e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023c31:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c0023c34:	0f 46 45 f0          	cmovbe -0x10(%ebp),%eax
c0023c38:	89 45 ec             	mov    %eax,-0x14(%ebp)
          memcpy (new_block, old_block, min_size);
c0023c3b:	83 ec 04             	sub    $0x4,%esp
c0023c3e:	ff 75 ec             	pushl  -0x14(%ebp)
c0023c41:	ff 75 08             	pushl  0x8(%ebp)
c0023c44:	ff 75 f4             	pushl  -0xc(%ebp)
c0023c47:	e8 bd 4d 00 00       	call   c0028a09 <memcpy>
c0023c4c:	83 c4 10             	add    $0x10,%esp
          free (old_block);
c0023c4f:	83 ec 0c             	sub    $0xc,%esp
c0023c52:	ff 75 08             	pushl  0x8(%ebp)
c0023c55:	e8 08 00 00 00       	call   c0023c62 <free>
c0023c5a:	83 c4 10             	add    $0x10,%esp
        }
      return new_block;
c0023c5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
    }
}
c0023c60:	c9                   	leave  
c0023c61:	c3                   	ret    

c0023c62 <free>:

/* Frees block P, which must have been previously allocated with
   malloc(), calloc(), or realloc(). */
void
free (void *p) 
{
c0023c62:	55                   	push   %ebp
c0023c63:	89 e5                	mov    %esp,%ebp
c0023c65:	83 ec 28             	sub    $0x28,%esp
  if (p != NULL)
c0023c68:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023c6c:	0f 84 2e 01 00 00    	je     c0023da0 <free+0x13e>
    {
      struct block *b = p;
c0023c72:	8b 45 08             	mov    0x8(%ebp),%eax
c0023c75:	89 45 f0             	mov    %eax,-0x10(%ebp)
      struct arena *a = block_to_arena (b);
c0023c78:	83 ec 0c             	sub    $0xc,%esp
c0023c7b:	ff 75 f0             	pushl  -0x10(%ebp)
c0023c7e:	e8 1f 01 00 00       	call   c0023da2 <block_to_arena>
c0023c83:	83 c4 10             	add    $0x10,%esp
c0023c86:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct desc *d = a->desc;
c0023c89:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023c8c:	8b 40 04             	mov    0x4(%eax),%eax
c0023c8f:	89 45 e8             	mov    %eax,-0x18(%ebp)
      
      if (d != NULL) 
c0023c92:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c0023c96:	0f 84 ee 00 00 00    	je     c0023d8a <free+0x128>
        {
          /* It's a normal block.  We handle it here. */

#ifndef NDEBUG
          /* Clear the block to help detect use-after-free bugs. */
          memset (b, 0xcc, d->block_size);
c0023c9c:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023c9f:	8b 00                	mov    (%eax),%eax
c0023ca1:	83 ec 04             	sub    $0x4,%esp
c0023ca4:	50                   	push   %eax
c0023ca5:	68 cc 00 00 00       	push   $0xcc
c0023caa:	ff 75 f0             	pushl  -0x10(%ebp)
c0023cad:	e8 5d 53 00 00       	call   c002900f <memset>
c0023cb2:	83 c4 10             	add    $0x10,%esp
#endif
  
          lock_acquire (&d->lock);
c0023cb5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023cb8:	83 c0 18             	add    $0x18,%eax
c0023cbb:	83 ec 0c             	sub    $0xc,%esp
c0023cbe:	50                   	push   %eax
c0023cbf:	e8 1f f0 ff ff       	call   c0022ce3 <lock_acquire>
c0023cc4:	83 c4 10             	add    $0x10,%esp

          /* Add block to free list. */
          list_push_front (&d->free_list, &b->free_elem);
c0023cc7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0023cca:	8b 55 e8             	mov    -0x18(%ebp),%edx
c0023ccd:	83 c2 08             	add    $0x8,%edx
c0023cd0:	83 ec 08             	sub    $0x8,%esp
c0023cd3:	50                   	push   %eax
c0023cd4:	52                   	push   %edx
c0023cd5:	e8 6e 65 00 00       	call   c002a248 <list_push_front>
c0023cda:	83 c4 10             	add    $0x10,%esp

          /* If the arena is now entirely unused, free it. */
          if (++a->free_cnt >= d->blocks_per_arena) 
c0023cdd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023ce0:	8b 40 08             	mov    0x8(%eax),%eax
c0023ce3:	8d 50 01             	lea    0x1(%eax),%edx
c0023ce6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023ce9:	89 50 08             	mov    %edx,0x8(%eax)
c0023cec:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023cef:	8b 50 08             	mov    0x8(%eax),%edx
c0023cf2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023cf5:	8b 40 04             	mov    0x4(%eax),%eax
c0023cf8:	39 c2                	cmp    %eax,%edx
c0023cfa:	72 7a                	jb     c0023d76 <free+0x114>
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
c0023cfc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023cff:	8b 50 08             	mov    0x8(%eax),%edx
c0023d02:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d05:	8b 40 04             	mov    0x4(%eax),%eax
c0023d08:	39 c2                	cmp    %eax,%edx
c0023d0a:	74 21                	je     c0023d2d <free+0xcb>
c0023d0c:	83 ec 0c             	sub    $0xc,%esp
c0023d0f:	68 b0 f9 02 c0       	push   $0xc002f9b0
c0023d14:	68 81 f9 02 c0       	push   $0xc002f981
c0023d19:	68 98 fa 02 c0       	push   $0xc002fa98
c0023d1e:	68 f6 00 00 00       	push   $0xf6
c0023d23:	68 98 f9 02 c0       	push   $0xc002f998
c0023d28:	e8 ee 5e 00 00       	call   c0029c1b <debug_panic>
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023d2d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0023d34:	eb 27                	jmp    c0023d5d <free+0xfb>
                {
                  struct block *b = arena_to_block (a, i);
c0023d36:	83 ec 08             	sub    $0x8,%esp
c0023d39:	ff 75 f4             	pushl  -0xc(%ebp)
c0023d3c:	ff 75 ec             	pushl  -0x14(%ebp)
c0023d3f:	e8 5c 01 00 00       	call   c0023ea0 <arena_to_block>
c0023d44:	83 c4 10             	add    $0x10,%esp
c0023d47:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                  list_remove (&b->free_elem);
c0023d4a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0023d4d:	83 ec 0c             	sub    $0xc,%esp
c0023d50:	50                   	push   %eax
c0023d51:	e8 3e 65 00 00       	call   c002a294 <list_remove>
c0023d56:	83 c4 10             	add    $0x10,%esp
          if (++a->free_cnt >= d->blocks_per_arena) 
            {
              size_t i;

              ASSERT (a->free_cnt == d->blocks_per_arena);
              for (i = 0; i < d->blocks_per_arena; i++) 
c0023d59:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0023d5d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d60:	8b 40 04             	mov    0x4(%eax),%eax
c0023d63:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0023d66:	77 ce                	ja     c0023d36 <free+0xd4>
                {
                  struct block *b = arena_to_block (a, i);
                  list_remove (&b->free_elem);
                }
              palloc_free_page (a);
c0023d68:	83 ec 0c             	sub    $0xc,%esp
c0023d6b:	ff 75 ec             	pushl  -0x14(%ebp)
c0023d6e:	e8 f9 f9 ff ff       	call   c002376c <palloc_free_page>
c0023d73:	83 c4 10             	add    $0x10,%esp
            }

          lock_release (&d->lock);
c0023d76:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0023d79:	83 c0 18             	add    $0x18,%eax
c0023d7c:	83 ec 0c             	sub    $0xc,%esp
c0023d7f:	50                   	push   %eax
c0023d80:	e8 41 f1 ff ff       	call   c0022ec6 <lock_release>
c0023d85:	83 c4 10             	add    $0x10,%esp
c0023d88:	eb 16                	jmp    c0023da0 <free+0x13e>
        }
      else
        {
          /* It's a big block.  Free its pages. */
          palloc_free_multiple (a, a->free_cnt);
c0023d8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0023d8d:	8b 40 08             	mov    0x8(%eax),%eax
c0023d90:	83 ec 08             	sub    $0x8,%esp
c0023d93:	50                   	push   %eax
c0023d94:	ff 75 ec             	pushl  -0x14(%ebp)
c0023d97:	e8 90 f8 ff ff       	call   c002362c <palloc_free_multiple>
c0023d9c:	83 c4 10             	add    $0x10,%esp
          return;
c0023d9f:	90                   	nop
        }
    }
}
c0023da0:	c9                   	leave  
c0023da1:	c3                   	ret    

c0023da2 <block_to_arena>:

/* Returns the arena that block B is inside. */
static struct arena *
block_to_arena (struct block *b)
{
c0023da2:	55                   	push   %ebp
c0023da3:	89 e5                	mov    %esp,%ebp
c0023da5:	83 ec 18             	sub    $0x18,%esp
  struct arena *a = pg_round_down (b);
c0023da8:	ff 75 08             	pushl  0x8(%ebp)
c0023dab:	e8 ec fa ff ff       	call   c002389c <pg_round_down>
c0023db0:	83 c4 04             	add    $0x4,%esp
c0023db3:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Check that the arena is valid. */
  ASSERT (a != NULL);
c0023db6:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0023dba:	75 21                	jne    c0023ddd <block_to_arena+0x3b>
c0023dbc:	83 ec 0c             	sub    $0xc,%esp
c0023dbf:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0023dc4:	68 81 f9 02 c0       	push   $0xc002f981
c0023dc9:	68 a0 fa 02 c0       	push   $0xc002faa0
c0023dce:	68 11 01 00 00       	push   $0x111
c0023dd3:	68 98 f9 02 c0       	push   $0xc002f998
c0023dd8:	e8 3e 5e 00 00       	call   c0029c1b <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023ddd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023de0:	8b 00                	mov    (%eax),%eax
c0023de2:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023de7:	74 21                	je     c0023e0a <block_to_arena+0x68>
c0023de9:	83 ec 0c             	sub    $0xc,%esp
c0023dec:	68 dd f9 02 c0       	push   $0xc002f9dd
c0023df1:	68 81 f9 02 c0       	push   $0xc002f981
c0023df6:	68 a0 fa 02 c0       	push   $0xc002faa0
c0023dfb:	68 12 01 00 00       	push   $0x112
c0023e00:	68 98 f9 02 c0       	push   $0xc002f998
c0023e05:	e8 11 5e 00 00       	call   c0029c1b <debug_panic>

  /* Check that the block is properly aligned for the arena. */
  ASSERT (a->desc == NULL
c0023e0a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e0d:	8b 40 04             	mov    0x4(%eax),%eax
c0023e10:	85 c0                	test   %eax,%eax
c0023e12:	74 49                	je     c0023e5d <block_to_arena+0xbb>
c0023e14:	83 ec 0c             	sub    $0xc,%esp
c0023e17:	ff 75 08             	pushl  0x8(%ebp)
c0023e1a:	e8 70 fa ff ff       	call   c002388f <pg_ofs>
c0023e1f:	83 c4 10             	add    $0x10,%esp
c0023e22:	8d 50 f4             	lea    -0xc(%eax),%edx
c0023e25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e28:	8b 40 04             	mov    0x4(%eax),%eax
c0023e2b:	8b 08                	mov    (%eax),%ecx
c0023e2d:	89 d0                	mov    %edx,%eax
c0023e2f:	ba 00 00 00 00       	mov    $0x0,%edx
c0023e34:	f7 f1                	div    %ecx
c0023e36:	89 d0                	mov    %edx,%eax
c0023e38:	85 c0                	test   %eax,%eax
c0023e3a:	74 21                	je     c0023e5d <block_to_arena+0xbb>
c0023e3c:	83 ec 0c             	sub    $0xc,%esp
c0023e3f:	68 f8 f9 02 c0       	push   $0xc002f9f8
c0023e44:	68 81 f9 02 c0       	push   $0xc002f981
c0023e49:	68 a0 fa 02 c0       	push   $0xc002faa0
c0023e4e:	68 16 01 00 00       	push   $0x116
c0023e53:	68 98 f9 02 c0       	push   $0xc002f998
c0023e58:	e8 be 5d 00 00       	call   c0029c1b <debug_panic>
          || (pg_ofs (b) - sizeof *a) % a->desc->block_size == 0);
  ASSERT (a->desc != NULL || pg_ofs (b) == sizeof *a);
c0023e5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0023e60:	8b 40 04             	mov    0x4(%eax),%eax
c0023e63:	85 c0                	test   %eax,%eax
c0023e65:	75 34                	jne    c0023e9b <block_to_arena+0xf9>
c0023e67:	83 ec 0c             	sub    $0xc,%esp
c0023e6a:	ff 75 08             	pushl  0x8(%ebp)
c0023e6d:	e8 1d fa ff ff       	call   c002388f <pg_ofs>
c0023e72:	83 c4 10             	add    $0x10,%esp
c0023e75:	83 f8 0c             	cmp    $0xc,%eax
c0023e78:	74 21                	je     c0023e9b <block_to_arena+0xf9>
c0023e7a:	83 ec 0c             	sub    $0xc,%esp
c0023e7d:	68 40 fa 02 c0       	push   $0xc002fa40
c0023e82:	68 81 f9 02 c0       	push   $0xc002f981
c0023e87:	68 a0 fa 02 c0       	push   $0xc002faa0
c0023e8c:	68 17 01 00 00       	push   $0x117
c0023e91:	68 98 f9 02 c0       	push   $0xc002f998
c0023e96:	e8 80 5d 00 00       	call   c0029c1b <debug_panic>

  return a;
c0023e9b:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0023e9e:	c9                   	leave  
c0023e9f:	c3                   	ret    

c0023ea0 <arena_to_block>:

/* Returns the (IDX - 1)'th block within arena A. */
static struct block *
arena_to_block (struct arena *a, size_t idx) 
{
c0023ea0:	55                   	push   %ebp
c0023ea1:	89 e5                	mov    %esp,%ebp
c0023ea3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c0023ea6:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023eaa:	75 21                	jne    c0023ecd <arena_to_block+0x2d>
c0023eac:	83 ec 0c             	sub    $0xc,%esp
c0023eaf:	68 d3 f9 02 c0       	push   $0xc002f9d3
c0023eb4:	68 81 f9 02 c0       	push   $0xc002f981
c0023eb9:	68 b0 fa 02 c0       	push   $0xc002fab0
c0023ebe:	68 20 01 00 00       	push   $0x120
c0023ec3:	68 98 f9 02 c0       	push   $0xc002f998
c0023ec8:	e8 4e 5d 00 00       	call   c0029c1b <debug_panic>
  ASSERT (a->magic == ARENA_MAGIC);
c0023ecd:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ed0:	8b 00                	mov    (%eax),%eax
c0023ed2:	3d ed 8e 54 9a       	cmp    $0x9a548eed,%eax
c0023ed7:	74 21                	je     c0023efa <arena_to_block+0x5a>
c0023ed9:	83 ec 0c             	sub    $0xc,%esp
c0023edc:	68 dd f9 02 c0       	push   $0xc002f9dd
c0023ee1:	68 81 f9 02 c0       	push   $0xc002f981
c0023ee6:	68 b0 fa 02 c0       	push   $0xc002fab0
c0023eeb:	68 21 01 00 00       	push   $0x121
c0023ef0:	68 98 f9 02 c0       	push   $0xc002f998
c0023ef5:	e8 21 5d 00 00       	call   c0029c1b <debug_panic>
  ASSERT (idx < a->desc->blocks_per_arena);
c0023efa:	8b 45 08             	mov    0x8(%ebp),%eax
c0023efd:	8b 40 04             	mov    0x4(%eax),%eax
c0023f00:	8b 40 04             	mov    0x4(%eax),%eax
c0023f03:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0023f06:	77 21                	ja     c0023f29 <arena_to_block+0x89>
c0023f08:	83 ec 0c             	sub    $0xc,%esp
c0023f0b:	68 6c fa 02 c0       	push   $0xc002fa6c
c0023f10:	68 81 f9 02 c0       	push   $0xc002f981
c0023f15:	68 b0 fa 02 c0       	push   $0xc002fab0
c0023f1a:	68 22 01 00 00       	push   $0x122
c0023f1f:	68 98 f9 02 c0       	push   $0xc002f998
c0023f24:	e8 f2 5c 00 00       	call   c0029c1b <debug_panic>
  return (struct block *) ((uint8_t *) a
                           + sizeof *a
                           + idx * a->desc->block_size);
c0023f29:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f2c:	8b 40 04             	mov    0x4(%eax),%eax
c0023f2f:	8b 00                	mov    (%eax),%eax
c0023f31:	0f af 45 0c          	imul   0xc(%ebp),%eax
c0023f35:	8d 50 0c             	lea    0xc(%eax),%edx
arena_to_block (struct arena *a, size_t idx) 
{
  ASSERT (a != NULL);
  ASSERT (a->magic == ARENA_MAGIC);
  ASSERT (idx < a->desc->blocks_per_arena);
  return (struct block *) ((uint8_t *) a
c0023f38:	8b 45 08             	mov    0x8(%ebp),%eax
c0023f3b:	01 d0                	add    %edx,%eax
                           + sizeof *a
                           + idx * a->desc->block_size);
}
c0023f3d:	c9                   	leave  
c0023f3e:	c3                   	ret    

c0023f3f <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0023f3f:	55                   	push   %ebp
c0023f40:	89 e5                	mov    %esp,%ebp
c0023f42:	83 ec 08             	sub    $0x8,%esp
c0023f45:	8b 55 08             	mov    0x8(%ebp),%edx
c0023f48:	8b 45 0c             	mov    0xc(%ebp),%eax
c0023f4b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0023f4f:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0023f52:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0023f56:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0023f5a:	ee                   	out    %al,(%dx)
}
c0023f5b:	90                   	nop
c0023f5c:	c9                   	leave  
c0023f5d:	c3                   	ret    

c0023f5e <pit_configure_channel>:
     - Other modes are less useful.

   FREQUENCY is the number of periods per second, in Hz. */
void
pit_configure_channel (int channel, int mode, int frequency)
{
c0023f5e:	55                   	push   %ebp
c0023f5f:	89 e5                	mov    %esp,%ebp
c0023f61:	83 ec 18             	sub    $0x18,%esp
  uint16_t count;
  enum intr_level old_level;

  ASSERT (channel == 0 || channel == 2);
c0023f64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0023f68:	74 24                	je     c0023f8e <pit_configure_channel+0x30>
c0023f6a:	83 7d 08 02          	cmpl   $0x2,0x8(%ebp)
c0023f6e:	74 1e                	je     c0023f8e <pit_configure_channel+0x30>
c0023f70:	83 ec 0c             	sub    $0xc,%esp
c0023f73:	68 c0 fa 02 c0       	push   $0xc002fac0
c0023f78:	68 dd fa 02 c0       	push   $0xc002fadd
c0023f7d:	68 20 fb 02 c0       	push   $0xc002fb20
c0023f82:	6a 33                	push   $0x33
c0023f84:	68 f4 fa 02 c0       	push   $0xc002faf4
c0023f89:	e8 8d 5c 00 00       	call   c0029c1b <debug_panic>
  ASSERT (mode == 2 || mode == 3);
c0023f8e:	83 7d 0c 02          	cmpl   $0x2,0xc(%ebp)
c0023f92:	74 24                	je     c0023fb8 <pit_configure_channel+0x5a>
c0023f94:	83 7d 0c 03          	cmpl   $0x3,0xc(%ebp)
c0023f98:	74 1e                	je     c0023fb8 <pit_configure_channel+0x5a>
c0023f9a:	83 ec 0c             	sub    $0xc,%esp
c0023f9d:	68 08 fb 02 c0       	push   $0xc002fb08
c0023fa2:	68 dd fa 02 c0       	push   $0xc002fadd
c0023fa7:	68 20 fb 02 c0       	push   $0xc002fb20
c0023fac:	6a 34                	push   $0x34
c0023fae:	68 f4 fa 02 c0       	push   $0xc002faf4
c0023fb3:	e8 63 5c 00 00       	call   c0029c1b <debug_panic>

  /* Convert FREQUENCY to a PIT counter value.  The PIT has a
     clock that runs at PIT_HZ cycles per second.  We must
     translate FREQUENCY into a number of these cycles. */
  if (frequency < 19)
c0023fb8:	83 7d 10 12          	cmpl   $0x12,0x10(%ebp)
c0023fbc:	7f 08                	jg     c0023fc6 <pit_configure_channel+0x68>
    {
      /* Frequency is too low: the quotient would overflow the
         16-bit counter.  Force it to 0, which the PIT treats as
         65536, the highest possible count.  This yields a 18.2
         Hz timer, approximately. */
      count = 0;
c0023fbe:	66 c7 45 f6 00 00    	movw   $0x0,-0xa(%ebp)
c0023fc4:	eb 2a                	jmp    c0023ff0 <pit_configure_channel+0x92>
    }
  else if (frequency > PIT_HZ)
c0023fc6:	81 7d 10 dc 34 12 00 	cmpl   $0x1234dc,0x10(%ebp)
c0023fcd:	7e 08                	jle    c0023fd7 <pit_configure_channel+0x79>
      /* Frequency is too high: the quotient would underflow to
         0, which the PIT would interpret as 65536.  A count of 1
         is illegal in mode 2, so we force it to 2, which yields
         a 596.590 kHz timer, approximately.  (This timer rate is
         probably too fast to be useful anyhow.) */
      count = 2;
c0023fcf:	66 c7 45 f6 02 00    	movw   $0x2,-0xa(%ebp)
c0023fd5:	eb 19                	jmp    c0023ff0 <pit_configure_channel+0x92>
    }
  else
    count = (PIT_HZ + frequency / 2) / frequency;
c0023fd7:	8b 45 10             	mov    0x10(%ebp),%eax
c0023fda:	89 c2                	mov    %eax,%edx
c0023fdc:	c1 ea 1f             	shr    $0x1f,%edx
c0023fdf:	01 d0                	add    %edx,%eax
c0023fe1:	d1 f8                	sar    %eax
c0023fe3:	05 dc 34 12 00       	add    $0x1234dc,%eax
c0023fe8:	99                   	cltd   
c0023fe9:	f7 7d 10             	idivl  0x10(%ebp)
c0023fec:	66 89 45 f6          	mov    %ax,-0xa(%ebp)

  /* Configure the PIT mode and load its counters. */
  old_level = intr_disable ();
c0023ff0:	e8 12 d5 ff ff       	call   c0021507 <intr_disable>
c0023ff5:	89 45 f0             	mov    %eax,-0x10(%ebp)
  outb (PIT_PORT_CONTROL, (channel << 6) | 0x30 | (mode << 1));
c0023ff8:	8b 45 08             	mov    0x8(%ebp),%eax
c0023ffb:	c1 e0 06             	shl    $0x6,%eax
c0023ffe:	83 c8 30             	or     $0x30,%eax
c0024001:	89 c2                	mov    %eax,%edx
c0024003:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024006:	01 c0                	add    %eax,%eax
c0024008:	09 d0                	or     %edx,%eax
c002400a:	0f b6 c0             	movzbl %al,%eax
c002400d:	83 ec 08             	sub    $0x8,%esp
c0024010:	50                   	push   %eax
c0024011:	6a 43                	push   $0x43
c0024013:	e8 27 ff ff ff       	call   c0023f3f <outb>
c0024018:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count);
c002401b:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c002401f:	0f b6 d0             	movzbl %al,%edx
c0024022:	8b 45 08             	mov    0x8(%ebp),%eax
c0024025:	83 c0 40             	add    $0x40,%eax
c0024028:	0f b7 c0             	movzwl %ax,%eax
c002402b:	83 ec 08             	sub    $0x8,%esp
c002402e:	52                   	push   %edx
c002402f:	50                   	push   %eax
c0024030:	e8 0a ff ff ff       	call   c0023f3f <outb>
c0024035:	83 c4 10             	add    $0x10,%esp
  outb (PIT_PORT_COUNTER (channel), count >> 8);
c0024038:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
c002403c:	66 c1 e8 08          	shr    $0x8,%ax
c0024040:	0f b6 d0             	movzbl %al,%edx
c0024043:	8b 45 08             	mov    0x8(%ebp),%eax
c0024046:	83 c0 40             	add    $0x40,%eax
c0024049:	0f b7 c0             	movzwl %ax,%eax
c002404c:	83 ec 08             	sub    $0x8,%esp
c002404f:	52                   	push   %edx
c0024050:	50                   	push   %eax
c0024051:	e8 e9 fe ff ff       	call   c0023f3f <outb>
c0024056:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0024059:	83 ec 0c             	sub    $0xc,%esp
c002405c:	ff 75 f0             	pushl  -0x10(%ebp)
c002405f:	e8 4b d4 ff ff       	call   c00214af <intr_set_level>
c0024064:	83 c4 10             	add    $0x10,%esp
}
c0024067:	90                   	nop
c0024068:	c9                   	leave  
c0024069:	c3                   	ret    

c002406a <sleep_comp>:

static intr_handler_func timer_interrupt;
static bool too_many_loops (unsigned loops);

//decide which thread should be woken up first aqio sergio
static bool sleep_comp(struct list_elem* a, struct list_elem* b, void* aux UNUSED) {
c002406a:	55                   	push   %ebp
c002406b:	89 e5                	mov    %esp,%ebp
c002406d:	56                   	push   %esi
c002406e:	53                   	push   %ebx
	return list_entry(a, struct thread, elem)->wake_time < list_entry(b, struct thread, elem)->wake_time; 
c002406f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024072:	83 c0 04             	add    $0x4,%eax
c0024075:	83 e8 2c             	sub    $0x2c,%eax
c0024078:	8b 48 30             	mov    0x30(%eax),%ecx
c002407b:	8b 58 34             	mov    0x34(%eax),%ebx
c002407e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024081:	83 c0 04             	add    $0x4,%eax
c0024084:	83 e8 2c             	sub    $0x2c,%eax
c0024087:	8b 50 34             	mov    0x34(%eax),%edx
c002408a:	8b 40 30             	mov    0x30(%eax),%eax
c002408d:	be 01 00 00 00       	mov    $0x1,%esi
c0024092:	39 d3                	cmp    %edx,%ebx
c0024094:	7c 0d                	jl     c00240a3 <sleep_comp+0x39>
c0024096:	39 d3                	cmp    %edx,%ebx
c0024098:	7f 04                	jg     c002409e <sleep_comp+0x34>
c002409a:	39 c1                	cmp    %eax,%ecx
c002409c:	72 05                	jb     c00240a3 <sleep_comp+0x39>
c002409e:	be 00 00 00 00       	mov    $0x0,%esi
c00240a3:	89 f0                	mov    %esi,%eax
}
c00240a5:	5b                   	pop    %ebx
c00240a6:	5e                   	pop    %esi
c00240a7:	5d                   	pop    %ebp
c00240a8:	c3                   	ret    

c00240a9 <timer_init>:

/* Sets up the timer to interrupt TIMER_FREQ times per second,
   and registers the corresponding interrupt. */
void
timer_init (void) 
{
c00240a9:	55                   	push   %ebp
c00240aa:	89 e5                	mov    %esp,%ebp
c00240ac:	83 ec 08             	sub    $0x8,%esp
  pit_configure_channel (0, 2, TIMER_FREQ);
c00240af:	83 ec 04             	sub    $0x4,%esp
c00240b2:	6a 64                	push   $0x64
c00240b4:	6a 02                	push   $0x2
c00240b6:	6a 00                	push   $0x0
c00240b8:	e8 a1 fe ff ff       	call   c0023f5e <pit_configure_channel>
c00240bd:	83 c4 10             	add    $0x10,%esp
  intr_register_ext (0x20, timer_interrupt, "8254 Timer");
c00240c0:	83 ec 04             	sub    $0x4,%esp
c00240c3:	68 38 fb 02 c0       	push   $0xc002fb38
c00240c8:	68 11 44 02 c0       	push   $0xc0024411
c00240cd:	6a 20                	push   $0x20
c00240cf:	e8 54 d6 ff ff       	call   c0021728 <intr_register_ext>
c00240d4:	83 c4 10             	add    $0x10,%esp
  list_init(&sleeping_thread_list);
c00240d7:	83 ec 0c             	sub    $0xc,%esp
c00240da:	68 a8 9e 03 c0       	push   $0xc0039ea8
c00240df:	e8 aa 5d 00 00       	call   c0029e8e <list_init>
c00240e4:	83 c4 10             	add    $0x10,%esp
}
c00240e7:	90                   	nop
c00240e8:	c9                   	leave  
c00240e9:	c3                   	ret    

c00240ea <timer_calibrate>:

/* Calibrates loops_per_tick, used to implement brief delays. */
void
timer_calibrate (void) 
{
c00240ea:	55                   	push   %ebp
c00240eb:	89 e5                	mov    %esp,%ebp
c00240ed:	53                   	push   %ebx
c00240ee:	83 ec 14             	sub    $0x14,%esp
  unsigned high_bit, test_bit;

  ASSERT (intr_get_level () == INTR_ON);
c00240f1:	e8 9c d3 ff ff       	call   c0021492 <intr_get_level>
c00240f6:	83 f8 01             	cmp    $0x1,%eax
c00240f9:	74 1e                	je     c0024119 <timer_calibrate+0x2f>
c00240fb:	83 ec 0c             	sub    $0xc,%esp
c00240fe:	68 43 fb 02 c0       	push   $0xc002fb43
c0024103:	68 60 fb 02 c0       	push   $0xc002fb60
c0024108:	68 f0 fb 02 c0       	push   $0xc002fbf0
c002410d:	6a 3b                	push   $0x3b
c002410f:	68 77 fb 02 c0       	push   $0xc002fb77
c0024114:	e8 02 5b 00 00       	call   c0029c1b <debug_panic>
  printf ("Calibrating timer...  ");
c0024119:	83 ec 0c             	sub    $0xc,%esp
c002411c:	68 8d fb 02 c0       	push   $0xc002fb8d
c0024121:	e8 c2 36 00 00       	call   c00277e8 <printf>
c0024126:	83 c4 10             	add    $0x10,%esp

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
c0024129:	c7 05 80 9a 03 c0 00 	movl   $0x400,0xc0039a80
c0024130:	04 00 00 
  while (!too_many_loops (loops_per_tick << 1)) 
c0024133:	eb 33                	jmp    c0024168 <timer_calibrate+0x7e>
    {
      loops_per_tick <<= 1;
c0024135:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c002413a:	01 c0                	add    %eax,%eax
c002413c:	a3 80 9a 03 c0       	mov    %eax,0xc0039a80
      ASSERT (loops_per_tick != 0);
c0024141:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c0024146:	85 c0                	test   %eax,%eax
c0024148:	75 1e                	jne    c0024168 <timer_calibrate+0x7e>
c002414a:	83 ec 0c             	sub    $0xc,%esp
c002414d:	68 a4 fb 02 c0       	push   $0xc002fba4
c0024152:	68 60 fb 02 c0       	push   $0xc002fb60
c0024157:	68 f0 fb 02 c0       	push   $0xc002fbf0
c002415c:	6a 44                	push   $0x44
c002415e:	68 77 fb 02 c0       	push   $0xc002fb77
c0024163:	e8 b3 5a 00 00       	call   c0029c1b <debug_panic>
  printf ("Calibrating timer...  ");

  /* Approximate loops_per_tick as the largest power-of-two
     still less than one timer tick. */
  loops_per_tick = 1u << 10;
  while (!too_many_loops (loops_per_tick << 1)) 
c0024168:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c002416d:	01 c0                	add    %eax,%eax
c002416f:	83 ec 0c             	sub    $0xc,%esp
c0024172:	50                   	push   %eax
c0024173:	e8 4f 03 00 00       	call   c00244c7 <too_many_loops>
c0024178:	83 c4 10             	add    $0x10,%esp
c002417b:	83 f0 01             	xor    $0x1,%eax
c002417e:	84 c0                	test   %al,%al
c0024180:	75 b3                	jne    c0024135 <timer_calibrate+0x4b>
      loops_per_tick <<= 1;
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
c0024182:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c0024187:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c002418a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002418d:	d1 e8                	shr    %eax
c002418f:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0024192:	eb 29                	jmp    c00241bd <timer_calibrate+0xd3>
    if (!too_many_loops (high_bit | test_bit))
c0024194:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024197:	0b 45 f4             	or     -0xc(%ebp),%eax
c002419a:	83 ec 0c             	sub    $0xc,%esp
c002419d:	50                   	push   %eax
c002419e:	e8 24 03 00 00       	call   c00244c7 <too_many_loops>
c00241a3:	83 c4 10             	add    $0x10,%esp
c00241a6:	83 f0 01             	xor    $0x1,%eax
c00241a9:	84 c0                	test   %al,%al
c00241ab:	74 0d                	je     c00241ba <timer_calibrate+0xd0>
      loops_per_tick |= test_bit;
c00241ad:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c00241b2:	0b 45 f4             	or     -0xc(%ebp),%eax
c00241b5:	a3 80 9a 03 c0       	mov    %eax,0xc0039a80
      ASSERT (loops_per_tick != 0);
    }

  /* Refine the next 8 bits of loops_per_tick. */
  high_bit = loops_per_tick;
  for (test_bit = high_bit >> 1; test_bit != high_bit >> 10; test_bit >>= 1)
c00241ba:	d1 6d f4             	shrl   -0xc(%ebp)
c00241bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00241c0:	c1 e8 0a             	shr    $0xa,%eax
c00241c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00241c6:	75 cc                	jne    c0024194 <timer_calibrate+0xaa>
    if (!too_many_loops (high_bit | test_bit))
      loops_per_tick |= test_bit;

  printf ("%'"PRIu64" loops/s.\n", (uint64_t) loops_per_tick * TIMER_FREQ);
c00241c8:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c00241cd:	ba 00 00 00 00       	mov    $0x0,%edx
c00241d2:	6b da 64             	imul   $0x64,%edx,%ebx
c00241d5:	6b c8 00             	imul   $0x0,%eax,%ecx
c00241d8:	01 d9                	add    %ebx,%ecx
c00241da:	bb 64 00 00 00       	mov    $0x64,%ebx
c00241df:	f7 e3                	mul    %ebx
c00241e1:	01 d1                	add    %edx,%ecx
c00241e3:	89 ca                	mov    %ecx,%edx
c00241e5:	83 ec 04             	sub    $0x4,%esp
c00241e8:	52                   	push   %edx
c00241e9:	50                   	push   %eax
c00241ea:	68 b8 fb 02 c0       	push   $0xc002fbb8
c00241ef:	e8 f4 35 00 00       	call   c00277e8 <printf>
c00241f4:	83 c4 10             	add    $0x10,%esp
}
c00241f7:	90                   	nop
c00241f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00241fb:	c9                   	leave  
c00241fc:	c3                   	ret    

c00241fd <timer_ticks>:

/* Returns the number of timer ticks since the OS booted. */
int64_t
timer_ticks (void) 
{
c00241fd:	55                   	push   %ebp
c00241fe:	89 e5                	mov    %esp,%ebp
c0024200:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0024203:	e8 ff d2 ff ff       	call   c0021507 <intr_disable>
c0024208:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t t = ticks;
c002420b:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c0024210:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c0024216:	89 45 e8             	mov    %eax,-0x18(%ebp)
c0024219:	89 55 ec             	mov    %edx,-0x14(%ebp)
  intr_set_level (old_level);
c002421c:	83 ec 0c             	sub    $0xc,%esp
c002421f:	ff 75 f4             	pushl  -0xc(%ebp)
c0024222:	e8 88 d2 ff ff       	call   c00214af <intr_set_level>
c0024227:	83 c4 10             	add    $0x10,%esp
  return t;
c002422a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002422d:	8b 55 ec             	mov    -0x14(%ebp),%edx
}
c0024230:	c9                   	leave  
c0024231:	c3                   	ret    

c0024232 <timer_elapsed>:

/* Returns the number of timer ticks elapsed since THEN, which
   should be a value once returned by timer_ticks(). */
int64_t
timer_elapsed (int64_t then) 
{
c0024232:	55                   	push   %ebp
c0024233:	89 e5                	mov    %esp,%ebp
c0024235:	83 ec 18             	sub    $0x18,%esp
c0024238:	8b 45 08             	mov    0x8(%ebp),%eax
c002423b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002423e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024241:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return timer_ticks () - then;
c0024244:	e8 b4 ff ff ff       	call   c00241fd <timer_ticks>
c0024249:	2b 45 f0             	sub    -0x10(%ebp),%eax
c002424c:	1b 55 f4             	sbb    -0xc(%ebp),%edx
}
c002424f:	c9                   	leave  
c0024250:	c3                   	ret    

c0024251 <timer_sleep>:

/* Sleeps for approximately TICKS timer ticks.  Interrupts must
   be turned on. */
void
timer_sleep (int64_t ticks) 
{
c0024251:	55                   	push   %ebp
c0024252:	89 e5                	mov    %esp,%ebp
c0024254:	57                   	push   %edi
c0024255:	56                   	push   %esi
c0024256:	53                   	push   %ebx
c0024257:	83 ec 2c             	sub    $0x2c,%esp
c002425a:	8b 45 08             	mov    0x8(%ebp),%eax
c002425d:	89 45 d0             	mov    %eax,-0x30(%ebp)
c0024260:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024263:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  while (timer_elapsed (start) < ticks) 
    thread_yield ();*/

  /* aqui sergio*/
  
  ASSERT (intr_get_level () == INTR_ON);
c0024266:	e8 27 d2 ff ff       	call   c0021492 <intr_get_level>
c002426b:	83 f8 01             	cmp    $0x1,%eax
c002426e:	74 1e                	je     c002428e <timer_sleep+0x3d>
c0024270:	83 ec 0c             	sub    $0xc,%esp
c0024273:	68 43 fb 02 c0       	push   $0xc002fb43
c0024278:	68 60 fb 02 c0       	push   $0xc002fb60
c002427d:	68 00 fc 02 c0       	push   $0xc002fc00
c0024282:	6a 6f                	push   $0x6f
c0024284:	68 77 fb 02 c0       	push   $0xc002fb77
c0024289:	e8 8d 59 00 00       	call   c0029c1b <debug_panic>

  //BLOCK INSTEAD OF BUSY WAIT

  //disable interrupts
  enum intr_level old_level; 
  old_level = intr_disable();
c002428e:	e8 74 d2 ff ff       	call   c0021507 <intr_disable>
c0024293:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  thread_current()->wake_time = ticks + timer_ticks();
c0024296:	e8 51 ca ff ff       	call   c0020cec <thread_current>
c002429b:	89 c3                	mov    %eax,%ebx
c002429d:	e8 5b ff ff ff       	call   c00241fd <timer_ticks>
c00242a2:	89 c6                	mov    %eax,%esi
c00242a4:	89 d7                	mov    %edx,%edi
c00242a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
c00242a9:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c00242ac:	01 f0                	add    %esi,%eax
c00242ae:	11 fa                	adc    %edi,%edx
c00242b0:	89 43 30             	mov    %eax,0x30(%ebx)
c00242b3:	89 53 34             	mov    %edx,0x34(%ebx)

  //put the thread on the ready queue
  list_insert_ordered(&sleeping_thread_list, &thread_current()->elem, (list_less_func*)&sleep_comp, NULL);
c00242b6:	e8 31 ca ff ff       	call   c0020cec <thread_current>
c00242bb:	83 c0 28             	add    $0x28,%eax
c00242be:	6a 00                	push   $0x0
c00242c0:	68 6a 40 02 c0       	push   $0xc002406a
c00242c5:	50                   	push   %eax
c00242c6:	68 a8 9e 03 c0       	push   $0xc0039ea8
c00242cb:	e8 66 66 00 00       	call   c002a936 <list_insert_ordered>
c00242d0:	83 c4 10             	add    $0x10,%esp
  //block i.e. go to sleep until unblock is called
  thread_block();
c00242d3:	e8 f4 c8 ff ff       	call   c0020bcc <thread_block>
  //re-enable interrupts
  intr_set_level(old_level);
c00242d8:	83 ec 0c             	sub    $0xc,%esp
c00242db:	ff 75 e4             	pushl  -0x1c(%ebp)
c00242de:	e8 cc d1 ff ff       	call   c00214af <intr_set_level>
c00242e3:	83 c4 10             	add    $0x10,%esp
}
c00242e6:	90                   	nop
c00242e7:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00242ea:	5b                   	pop    %ebx
c00242eb:	5e                   	pop    %esi
c00242ec:	5f                   	pop    %edi
c00242ed:	5d                   	pop    %ebp
c00242ee:	c3                   	ret    

c00242ef <timer_msleep>:

/* Sleeps for approximately MS milliseconds.  Interrupts must be
   turned on. */
void
timer_msleep (int64_t ms) 
{
c00242ef:	55                   	push   %ebp
c00242f0:	89 e5                	mov    %esp,%ebp
c00242f2:	83 ec 18             	sub    $0x18,%esp
c00242f5:	8b 45 08             	mov    0x8(%ebp),%eax
c00242f8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00242fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00242fe:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ms, 1000);
c0024301:	83 ec 04             	sub    $0x4,%esp
c0024304:	68 e8 03 00 00       	push   $0x3e8
c0024309:	ff 75 f4             	pushl  -0xc(%ebp)
c002430c:	ff 75 f0             	pushl  -0x10(%ebp)
c002430f:	e8 75 02 00 00       	call   c0024589 <real_time_sleep>
c0024314:	83 c4 10             	add    $0x10,%esp
}
c0024317:	90                   	nop
c0024318:	c9                   	leave  
c0024319:	c3                   	ret    

c002431a <timer_usleep>:

/* Sleeps for approximately US microseconds.  Interrupts must be
   turned on. */
void
timer_usleep (int64_t us) 
{
c002431a:	55                   	push   %ebp
c002431b:	89 e5                	mov    %esp,%ebp
c002431d:	83 ec 18             	sub    $0x18,%esp
c0024320:	8b 45 08             	mov    0x8(%ebp),%eax
c0024323:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024326:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024329:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (us, 1000 * 1000);
c002432c:	83 ec 04             	sub    $0x4,%esp
c002432f:	68 40 42 0f 00       	push   $0xf4240
c0024334:	ff 75 f4             	pushl  -0xc(%ebp)
c0024337:	ff 75 f0             	pushl  -0x10(%ebp)
c002433a:	e8 4a 02 00 00       	call   c0024589 <real_time_sleep>
c002433f:	83 c4 10             	add    $0x10,%esp
}
c0024342:	90                   	nop
c0024343:	c9                   	leave  
c0024344:	c3                   	ret    

c0024345 <timer_nsleep>:

/* Sleeps for approximately NS nanoseconds.  Interrupts must be
   turned on. */
void
timer_nsleep (int64_t ns) 
{
c0024345:	55                   	push   %ebp
c0024346:	89 e5                	mov    %esp,%ebp
c0024348:	83 ec 18             	sub    $0x18,%esp
c002434b:	8b 45 08             	mov    0x8(%ebp),%eax
c002434e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024351:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024354:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_sleep (ns, 1000 * 1000 * 1000);
c0024357:	83 ec 04             	sub    $0x4,%esp
c002435a:	68 00 ca 9a 3b       	push   $0x3b9aca00
c002435f:	ff 75 f4             	pushl  -0xc(%ebp)
c0024362:	ff 75 f0             	pushl  -0x10(%ebp)
c0024365:	e8 1f 02 00 00       	call   c0024589 <real_time_sleep>
c002436a:	83 c4 10             	add    $0x10,%esp
}
c002436d:	90                   	nop
c002436e:	c9                   	leave  
c002436f:	c3                   	ret    

c0024370 <timer_mdelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_msleep()
   instead if interrupts are enabled. */
void
timer_mdelay (int64_t ms) 
{
c0024370:	55                   	push   %ebp
c0024371:	89 e5                	mov    %esp,%ebp
c0024373:	83 ec 18             	sub    $0x18,%esp
c0024376:	8b 45 08             	mov    0x8(%ebp),%eax
c0024379:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002437c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002437f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ms, 1000);
c0024382:	83 ec 04             	sub    $0x4,%esp
c0024385:	68 e8 03 00 00       	push   $0x3e8
c002438a:	ff 75 f4             	pushl  -0xc(%ebp)
c002438d:	ff 75 f0             	pushl  -0x10(%ebp)
c0024390:	e8 a6 02 00 00       	call   c002463b <real_time_delay>
c0024395:	83 c4 10             	add    $0x10,%esp
}
c0024398:	90                   	nop
c0024399:	c9                   	leave  
c002439a:	c3                   	ret    

c002439b <timer_udelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_usleep()
   instead if interrupts are enabled. */
void
timer_udelay (int64_t us) 
{
c002439b:	55                   	push   %ebp
c002439c:	89 e5                	mov    %esp,%ebp
c002439e:	83 ec 18             	sub    $0x18,%esp
c00243a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00243a4:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00243a7:	8b 45 0c             	mov    0xc(%ebp),%eax
c00243aa:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (us, 1000 * 1000);
c00243ad:	83 ec 04             	sub    $0x4,%esp
c00243b0:	68 40 42 0f 00       	push   $0xf4240
c00243b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00243b8:	ff 75 f0             	pushl  -0x10(%ebp)
c00243bb:	e8 7b 02 00 00       	call   c002463b <real_time_delay>
c00243c0:	83 c4 10             	add    $0x10,%esp
}
c00243c3:	90                   	nop
c00243c4:	c9                   	leave  
c00243c5:	c3                   	ret    

c00243c6 <timer_ndelay>:
   interrupts off for the interval between timer ticks or longer
   will cause timer ticks to be lost.  Thus, use timer_nsleep()
   instead if interrupts are enabled.*/
void
timer_ndelay (int64_t ns) 
{
c00243c6:	55                   	push   %ebp
c00243c7:	89 e5                	mov    %esp,%ebp
c00243c9:	83 ec 18             	sub    $0x18,%esp
c00243cc:	8b 45 08             	mov    0x8(%ebp),%eax
c00243cf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00243d2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00243d5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  real_time_delay (ns, 1000 * 1000 * 1000);
c00243d8:	83 ec 04             	sub    $0x4,%esp
c00243db:	68 00 ca 9a 3b       	push   $0x3b9aca00
c00243e0:	ff 75 f4             	pushl  -0xc(%ebp)
c00243e3:	ff 75 f0             	pushl  -0x10(%ebp)
c00243e6:	e8 50 02 00 00       	call   c002463b <real_time_delay>
c00243eb:	83 c4 10             	add    $0x10,%esp
}
c00243ee:	90                   	nop
c00243ef:	c9                   	leave  
c00243f0:	c3                   	ret    

c00243f1 <timer_print_stats>:

/* Prints timer statistics. */
void
timer_print_stats (void) 
{
c00243f1:	55                   	push   %ebp
c00243f2:	89 e5                	mov    %esp,%ebp
c00243f4:	83 ec 08             	sub    $0x8,%esp
  printf ("Timer: %"PRId64" ticks\n", timer_ticks ());
c00243f7:	e8 01 fe ff ff       	call   c00241fd <timer_ticks>
c00243fc:	83 ec 04             	sub    $0x4,%esp
c00243ff:	52                   	push   %edx
c0024400:	50                   	push   %eax
c0024401:	68 c8 fb 02 c0       	push   $0xc002fbc8
c0024406:	e8 dd 33 00 00       	call   c00277e8 <printf>
c002440b:	83 c4 10             	add    $0x10,%esp
}
c002440e:	90                   	nop
c002440f:	c9                   	leave  
c0024410:	c3                   	ret    

c0024411 <timer_interrupt>:

/* Timer interrupt handler. */
static void
timer_interrupt (struct intr_frame *args UNUSED)
{
c0024411:	55                   	push   %ebp
c0024412:	89 e5                	mov    %esp,%ebp
c0024414:	53                   	push   %ebx
c0024415:	83 ec 14             	sub    $0x14,%esp
  ticks++;
c0024418:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c002441d:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c0024423:	83 c0 01             	add    $0x1,%eax
c0024426:	83 d2 00             	adc    $0x0,%edx
c0024429:	a3 78 9a 03 c0       	mov    %eax,0xc0039a78
c002442e:	89 15 7c 9a 03 c0    	mov    %edx,0xc0039a7c
  thread_tick ();
c0024434:	e8 b2 c5 ff ff       	call   c00209eb <thread_tick>

  //aqui sergio 

  struct list_elem* iter = list_begin(&sleeping_thread_list);
c0024439:	83 ec 0c             	sub    $0xc,%esp
c002443c:	68 a8 9e 03 c0       	push   $0xc0039ea8
c0024441:	e8 9d 5a 00 00       	call   c0029ee3 <list_begin>
c0024446:	83 c4 10             	add    $0x10,%esp
c0024449:	89 45 f4             	mov    %eax,-0xc(%ebp)

  //iterate through and wake sleeping threads until we reach the first thread whose wake time has not yet been reached
  while(iter != list_end(&sleeping_thread_list)) {
c002444c:	eb 5b                	jmp    c00244a9 <timer_interrupt+0x98>
    struct thread* t = list_entry(iter, struct thread, elem);
c002444e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024451:	83 c0 04             	add    $0x4,%eax
c0024454:	83 e8 2c             	sub    $0x2c,%eax
c0024457:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (t->wake_time <= ticks) {
c002445a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002445d:	8b 48 30             	mov    0x30(%eax),%ecx
c0024460:	8b 58 34             	mov    0x34(%eax),%ebx
c0024463:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c0024468:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c002446e:	39 d3                	cmp    %edx,%ebx
c0024470:	7f 4e                	jg     c00244c0 <timer_interrupt+0xaf>
c0024472:	39 d3                	cmp    %edx,%ebx
c0024474:	7c 04                	jl     c002447a <timer_interrupt+0x69>
c0024476:	39 c1                	cmp    %eax,%ecx
c0024478:	77 46                	ja     c00244c0 <timer_interrupt+0xaf>
      list_remove(iter);
c002447a:	83 ec 0c             	sub    $0xc,%esp
c002447d:	ff 75 f4             	pushl  -0xc(%ebp)
c0024480:	e8 0f 5e 00 00       	call   c002a294 <list_remove>
c0024485:	83 c4 10             	add    $0x10,%esp
      thread_unblock(t);
c0024488:	83 ec 0c             	sub    $0xc,%esp
c002448b:	ff 75 f0             	pushl  -0x10(%ebp)
c002448e:	e8 aa c7 ff ff       	call   c0020c3d <thread_unblock>
c0024493:	83 c4 10             	add    $0x10,%esp
      iter = list_begin(&sleeping_thread_list);
c0024496:	83 ec 0c             	sub    $0xc,%esp
c0024499:	68 a8 9e 03 c0       	push   $0xc0039ea8
c002449e:	e8 40 5a 00 00       	call   c0029ee3 <list_begin>
c00244a3:	83 c4 10             	add    $0x10,%esp
c00244a6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  //aqui sergio 

  struct list_elem* iter = list_begin(&sleeping_thread_list);

  //iterate through and wake sleeping threads until we reach the first thread whose wake time has not yet been reached
  while(iter != list_end(&sleeping_thread_list)) {
c00244a9:	83 ec 0c             	sub    $0xc,%esp
c00244ac:	68 a8 9e 03 c0       	push   $0xc0039ea8
c00244b1:	e8 a9 5a 00 00       	call   c0029f5f <list_end>
c00244b6:	83 c4 10             	add    $0x10,%esp
c00244b9:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00244bc:	75 90                	jne    c002444e <timer_interrupt+0x3d>
      iter = list_begin(&sleeping_thread_list);
    } else {
      break;
    }
  }
}
c00244be:	eb 01                	jmp    c00244c1 <timer_interrupt+0xb0>
    if (t->wake_time <= ticks) {
      list_remove(iter);
      thread_unblock(t);
      iter = list_begin(&sleeping_thread_list);
    } else {
      break;
c00244c0:	90                   	nop
    }
  }
}
c00244c1:	90                   	nop
c00244c2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00244c5:	c9                   	leave  
c00244c6:	c3                   	ret    

c00244c7 <too_many_loops>:

/* Returns true if LOOPS iterations waits for more than one timer
   tick, otherwise false. */
static bool
too_many_loops (unsigned loops) 
{
c00244c7:	55                   	push   %ebp
c00244c8:	89 e5                	mov    %esp,%ebp
c00244ca:	56                   	push   %esi
c00244cb:	53                   	push   %ebx
c00244cc:	83 ec 10             	sub    $0x10,%esp
  /* Wait for a timer tick. */
  int64_t start = ticks;
c00244cf:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c00244d4:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c00244da:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00244dd:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (ticks == start)
c00244e0:	eb 00                	jmp    c00244e2 <too_many_loops+0x1b>
c00244e2:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c00244e7:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c00244ed:	89 d1                	mov    %edx,%ecx
c00244ef:	33 4d f4             	xor    -0xc(%ebp),%ecx
c00244f2:	33 45 f0             	xor    -0x10(%ebp),%eax
c00244f5:	09 c8                	or     %ecx,%eax
c00244f7:	85 c0                	test   %eax,%eax
c00244f9:	74 e7                	je     c00244e2 <too_many_loops+0x1b>
    barrier ();

  /* Run LOOPS loops. */
  start = ticks;
c00244fb:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c0024500:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c0024506:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024509:	89 55 f4             	mov    %edx,-0xc(%ebp)
  busy_wait (loops);
c002450c:	8b 45 08             	mov    0x8(%ebp),%eax
c002450f:	ba 00 00 00 00       	mov    $0x0,%edx
c0024514:	83 ec 08             	sub    $0x8,%esp
c0024517:	52                   	push   %edx
c0024518:	50                   	push   %eax
c0024519:	e8 2c 00 00 00       	call   c002454a <busy_wait>
c002451e:	83 c4 10             	add    $0x10,%esp

  /* If the tick count changed, we iterated too long. */
  barrier ();
  return start != ticks;
c0024521:	a1 78 9a 03 c0       	mov    0xc0039a78,%eax
c0024526:	8b 15 7c 9a 03 c0    	mov    0xc0039a7c,%edx
c002452c:	89 c1                	mov    %eax,%ecx
c002452e:	33 4d f0             	xor    -0x10(%ebp),%ecx
c0024531:	89 cb                	mov    %ecx,%ebx
c0024533:	89 d0                	mov    %edx,%eax
c0024535:	33 45 f4             	xor    -0xc(%ebp),%eax
c0024538:	89 c6                	mov    %eax,%esi
c002453a:	89 d8                	mov    %ebx,%eax
c002453c:	09 f0                	or     %esi,%eax
c002453e:	85 c0                	test   %eax,%eax
c0024540:	0f 95 c0             	setne  %al
}
c0024543:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024546:	5b                   	pop    %ebx
c0024547:	5e                   	pop    %esi
c0024548:	5d                   	pop    %ebp
c0024549:	c3                   	ret    

c002454a <busy_wait>:
   affect timings, so that if this function was inlined
   differently in different places the results would be difficult
   to predict. */
static void NO_INLINE
busy_wait (int64_t loops) 
{
c002454a:	55                   	push   %ebp
c002454b:	89 e5                	mov    %esp,%ebp
c002454d:	53                   	push   %ebx
c002454e:	83 ec 0c             	sub    $0xc,%esp
c0024551:	8b 45 08             	mov    0x8(%ebp),%eax
c0024554:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024557:	8b 45 0c             	mov    0xc(%ebp),%eax
c002455a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (loops-- > 0)
c002455d:	eb 00                	jmp    c002455f <busy_wait+0x15>
c002455f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024562:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0024565:	89 c1                	mov    %eax,%ecx
c0024567:	89 d3                	mov    %edx,%ebx
c0024569:	83 c1 ff             	add    $0xffffffff,%ecx
c002456c:	83 d3 ff             	adc    $0xffffffff,%ebx
c002456f:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0024572:	89 5d f4             	mov    %ebx,-0xc(%ebp)
c0024575:	85 d2                	test   %edx,%edx
c0024577:	7f e6                	jg     c002455f <busy_wait+0x15>
c0024579:	85 d2                	test   %edx,%edx
c002457b:	78 05                	js     c0024582 <busy_wait+0x38>
c002457d:	83 f8 00             	cmp    $0x0,%eax
c0024580:	77 dd                	ja     c002455f <busy_wait+0x15>
    barrier ();
}
c0024582:	90                   	nop
c0024583:	83 c4 0c             	add    $0xc,%esp
c0024586:	5b                   	pop    %ebx
c0024587:	5d                   	pop    %ebp
c0024588:	c3                   	ret    

c0024589 <real_time_sleep>:

/* Sleep for approximately NUM/DENOM seconds. */
static void
real_time_sleep (int64_t num, int32_t denom) 
{
c0024589:	55                   	push   %ebp
c002458a:	89 e5                	mov    %esp,%ebp
c002458c:	53                   	push   %ebx
c002458d:	83 ec 24             	sub    $0x24,%esp
c0024590:	8b 45 08             	mov    0x8(%ebp),%eax
c0024593:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0024596:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024599:	89 45 e4             	mov    %eax,-0x1c(%ebp)
          
        (NUM / DENOM) s          
     ---------------------- = NUM * TIMER_FREQ / DENOM ticks. 
     1 s / TIMER_FREQ ticks
  */
  int64_t ticks = num * TIMER_FREQ / denom;
c002459c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002459f:	6b d0 64             	imul   $0x64,%eax,%edx
c00245a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00245a5:	6b c0 00             	imul   $0x0,%eax,%eax
c00245a8:	8d 0c 02             	lea    (%edx,%eax,1),%ecx
c00245ab:	b8 64 00 00 00       	mov    $0x64,%eax
c00245b0:	f7 65 e0             	mull   -0x20(%ebp)
c00245b3:	01 d1                	add    %edx,%ecx
c00245b5:	89 ca                	mov    %ecx,%edx
c00245b7:	8b 4d 10             	mov    0x10(%ebp),%ecx
c00245ba:	89 cb                	mov    %ecx,%ebx
c00245bc:	c1 fb 1f             	sar    $0x1f,%ebx
c00245bf:	53                   	push   %ebx
c00245c0:	51                   	push   %ecx
c00245c1:	52                   	push   %edx
c00245c2:	50                   	push   %eax
c00245c3:	e8 2d 50 00 00       	call   c00295f5 <__divdi3>
c00245c8:	83 c4 10             	add    $0x10,%esp
c00245cb:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00245ce:	89 55 f4             	mov    %edx,-0xc(%ebp)

  ASSERT (intr_get_level () == INTR_ON);
c00245d1:	e8 bc ce ff ff       	call   c0021492 <intr_get_level>
c00245d6:	83 f8 01             	cmp    $0x1,%eax
c00245d9:	74 21                	je     c00245fc <real_time_sleep+0x73>
c00245db:	83 ec 0c             	sub    $0xc,%esp
c00245de:	68 43 fb 02 c0       	push   $0xc002fb43
c00245e3:	68 60 fb 02 c0       	push   $0xc002fb60
c00245e8:	68 0c fc 02 c0       	push   $0xc002fc0c
c00245ed:	68 0b 01 00 00       	push   $0x10b
c00245f2:	68 77 fb 02 c0       	push   $0xc002fb77
c00245f7:	e8 1f 56 00 00       	call   c0029c1b <debug_panic>
  if (ticks > 0)
c00245fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024600:	78 1f                	js     c0024621 <real_time_sleep+0x98>
c0024602:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0024606:	7f 06                	jg     c002460e <real_time_sleep+0x85>
c0024608:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002460c:	76 13                	jbe    c0024621 <real_time_sleep+0x98>
    {
      /* We're waiting for at least one full timer tick.  Use
         timer_sleep() because it will yield the CPU to other
         processes. */                
      timer_sleep (ticks); 
c002460e:	83 ec 08             	sub    $0x8,%esp
c0024611:	ff 75 f4             	pushl  -0xc(%ebp)
c0024614:	ff 75 f0             	pushl  -0x10(%ebp)
c0024617:	e8 35 fc ff ff       	call   c0024251 <timer_sleep>
c002461c:	83 c4 10             	add    $0x10,%esp
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
    }
}
c002461f:	eb 14                	jmp    c0024635 <real_time_sleep+0xac>
    }
  else 
    {
      /* Otherwise, use a busy-wait loop for more accurate
         sub-tick timing. */
      real_time_delay (num, denom); 
c0024621:	83 ec 04             	sub    $0x4,%esp
c0024624:	ff 75 10             	pushl  0x10(%ebp)
c0024627:	ff 75 e4             	pushl  -0x1c(%ebp)
c002462a:	ff 75 e0             	pushl  -0x20(%ebp)
c002462d:	e8 09 00 00 00       	call   c002463b <real_time_delay>
c0024632:	83 c4 10             	add    $0x10,%esp
    }
}
c0024635:	90                   	nop
c0024636:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024639:	c9                   	leave  
c002463a:	c3                   	ret    

c002463b <real_time_delay>:

/* Busy-wait for approximately NUM/DENOM seconds. */
static void
real_time_delay (int64_t num, int32_t denom)
{
c002463b:	55                   	push   %ebp
c002463c:	89 e5                	mov    %esp,%ebp
c002463e:	56                   	push   %esi
c002463f:	53                   	push   %ebx
c0024640:	83 ec 10             	sub    $0x10,%esp
c0024643:	8b 45 08             	mov    0x8(%ebp),%eax
c0024646:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0024649:	8b 45 0c             	mov    0xc(%ebp),%eax
c002464c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  /* Scale the numerator and denominator down by 1000 to avoid
     the possibility of overflow. */
  ASSERT (denom % 1000 == 0);
c002464f:	8b 4d 10             	mov    0x10(%ebp),%ecx
c0024652:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c0024657:	89 c8                	mov    %ecx,%eax
c0024659:	f7 ea                	imul   %edx
c002465b:	c1 fa 06             	sar    $0x6,%edx
c002465e:	89 c8                	mov    %ecx,%eax
c0024660:	c1 f8 1f             	sar    $0x1f,%eax
c0024663:	29 c2                	sub    %eax,%edx
c0024665:	89 d0                	mov    %edx,%eax
c0024667:	69 c0 e8 03 00 00    	imul   $0x3e8,%eax,%eax
c002466d:	29 c1                	sub    %eax,%ecx
c002466f:	89 c8                	mov    %ecx,%eax
c0024671:	85 c0                	test   %eax,%eax
c0024673:	74 21                	je     c0024696 <real_time_delay+0x5b>
c0024675:	83 ec 0c             	sub    $0xc,%esp
c0024678:	68 db fb 02 c0       	push   $0xc002fbdb
c002467d:	68 60 fb 02 c0       	push   $0xc002fb60
c0024682:	68 1c fc 02 c0       	push   $0xc002fc1c
c0024687:	68 21 01 00 00       	push   $0x121
c002468c:	68 77 fb 02 c0       	push   $0xc002fb77
c0024691:	e8 85 55 00 00       	call   c0029c1b <debug_panic>
  busy_wait (loops_per_tick * num / 1000 * TIMER_FREQ / (denom / 1000)); 
c0024696:	a1 80 9a 03 c0       	mov    0xc0039a80,%eax
c002469b:	ba 00 00 00 00       	mov    $0x0,%edx
c00246a0:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c00246a3:	89 cb                	mov    %ecx,%ebx
c00246a5:	0f af da             	imul   %edx,%ebx
c00246a8:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c00246ab:	0f af c8             	imul   %eax,%ecx
c00246ae:	01 d9                	add    %ebx,%ecx
c00246b0:	f7 65 f0             	mull   -0x10(%ebp)
c00246b3:	01 d1                	add    %edx,%ecx
c00246b5:	89 ca                	mov    %ecx,%edx
c00246b7:	6a 00                	push   $0x0
c00246b9:	68 e8 03 00 00       	push   $0x3e8
c00246be:	52                   	push   %edx
c00246bf:	50                   	push   %eax
c00246c0:	e8 30 4f 00 00       	call   c00295f5 <__divdi3>
c00246c5:	83 c4 10             	add    $0x10,%esp
c00246c8:	6b da 64             	imul   $0x64,%edx,%ebx
c00246cb:	6b c8 00             	imul   $0x0,%eax,%ecx
c00246ce:	8d 34 0b             	lea    (%ebx,%ecx,1),%esi
c00246d1:	b9 64 00 00 00       	mov    $0x64,%ecx
c00246d6:	f7 e1                	mul    %ecx
c00246d8:	89 c1                	mov    %eax,%ecx
c00246da:	89 d3                	mov    %edx,%ebx
c00246dc:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
c00246df:	89 c3                	mov    %eax,%ebx
c00246e1:	8b 75 10             	mov    0x10(%ebp),%esi
c00246e4:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
c00246e9:	89 f0                	mov    %esi,%eax
c00246eb:	f7 ea                	imul   %edx
c00246ed:	c1 fa 06             	sar    $0x6,%edx
c00246f0:	89 f0                	mov    %esi,%eax
c00246f2:	c1 f8 1f             	sar    $0x1f,%eax
c00246f5:	29 c2                	sub    %eax,%edx
c00246f7:	89 d0                	mov    %edx,%eax
c00246f9:	99                   	cltd   
c00246fa:	52                   	push   %edx
c00246fb:	50                   	push   %eax
c00246fc:	53                   	push   %ebx
c00246fd:	51                   	push   %ecx
c00246fe:	e8 f2 4e 00 00       	call   c00295f5 <__divdi3>
c0024703:	83 c4 10             	add    $0x10,%esp
c0024706:	83 ec 08             	sub    $0x8,%esp
c0024709:	52                   	push   %edx
c002470a:	50                   	push   %eax
c002470b:	e8 3a fe ff ff       	call   c002454a <busy_wait>
c0024710:	83 c4 10             	add    $0x10,%esp
}
c0024713:	90                   	nop
c0024714:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0024717:	5b                   	pop    %ebx
c0024718:	5e                   	pop    %esi
c0024719:	5d                   	pop    %ebp
c002471a:	c3                   	ret    

c002471b <isupper>:
#ifndef __LIB_CTYPE_H
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
c002471b:	55                   	push   %ebp
c002471c:	89 e5                	mov    %esp,%ebp
c002471e:	83 7d 08 40          	cmpl   $0x40,0x8(%ebp)
c0024722:	7e 0d                	jle    c0024731 <isupper+0x16>
c0024724:	83 7d 08 5a          	cmpl   $0x5a,0x8(%ebp)
c0024728:	7f 07                	jg     c0024731 <isupper+0x16>
c002472a:	b8 01 00 00 00       	mov    $0x1,%eax
c002472f:	eb 05                	jmp    c0024736 <isupper+0x1b>
c0024731:	b8 00 00 00 00       	mov    $0x0,%eax
c0024736:	5d                   	pop    %ebp
c0024737:	c3                   	ret    

c0024738 <tolower>:
static inline int isascii (int c) { return c >= 0 && c < 128; }
static inline int ispunct (int c) {
  return isprint (c) && !isalnum (c) && !isspace (c);
}

static inline int tolower (int c) { return isupper (c) ? c - 'A' + 'a' : c; }
c0024738:	55                   	push   %ebp
c0024739:	89 e5                	mov    %esp,%ebp
c002473b:	ff 75 08             	pushl  0x8(%ebp)
c002473e:	e8 d8 ff ff ff       	call   c002471b <isupper>
c0024743:	83 c4 04             	add    $0x4,%esp
c0024746:	85 c0                	test   %eax,%eax
c0024748:	74 08                	je     c0024752 <tolower+0x1a>
c002474a:	8b 45 08             	mov    0x8(%ebp),%eax
c002474d:	83 c0 20             	add    $0x20,%eax
c0024750:	eb 03                	jmp    c0024755 <tolower+0x1d>
c0024752:	8b 45 08             	mov    0x8(%ebp),%eax
c0024755:	c9                   	leave  
c0024756:	c3                   	ret    

c0024757 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0024757:	55                   	push   %ebp
c0024758:	89 e5                	mov    %esp,%ebp
c002475a:	83 ec 14             	sub    $0x14,%esp
c002475d:	8b 45 08             	mov    0x8(%ebp),%eax
c0024760:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024764:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0024768:	89 c2                	mov    %eax,%edx
c002476a:	ec                   	in     (%dx),%al
c002476b:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c002476e:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024772:	c9                   	leave  
c0024773:	c3                   	ret    

c0024774 <kbd_init>:
static intr_handler_func keyboard_interrupt;

/* Initializes the keyboard. */
void
kbd_init (void) 
{
c0024774:	55                   	push   %ebp
c0024775:	89 e5                	mov    %esp,%ebp
c0024777:	83 ec 08             	sub    $0x8,%esp
  intr_register_ext (0x21, keyboard_interrupt, "8042 Keyboard");
c002477a:	83 ec 04             	sub    $0x4,%esp
c002477d:	68 40 fc 02 c0       	push   $0xc002fc40
c0024782:	68 ba 47 02 c0       	push   $0xc00247ba
c0024787:	6a 21                	push   $0x21
c0024789:	e8 9a cf ff ff       	call   c0021728 <intr_register_ext>
c002478e:	83 c4 10             	add    $0x10,%esp
}
c0024791:	90                   	nop
c0024792:	c9                   	leave  
c0024793:	c3                   	ret    

c0024794 <kbd_print_stats>:

/* Prints keyboard statistics. */
void
kbd_print_stats (void) 
{
c0024794:	55                   	push   %ebp
c0024795:	89 e5                	mov    %esp,%ebp
c0024797:	83 ec 08             	sub    $0x8,%esp
  printf ("Keyboard: %lld keys pressed\n", key_cnt);
c002479a:	a1 90 9a 03 c0       	mov    0xc0039a90,%eax
c002479f:	8b 15 94 9a 03 c0    	mov    0xc0039a94,%edx
c00247a5:	83 ec 04             	sub    $0x4,%esp
c00247a8:	52                   	push   %edx
c00247a9:	50                   	push   %eax
c00247aa:	68 4e fc 02 c0       	push   $0xc002fc4e
c00247af:	e8 34 30 00 00       	call   c00277e8 <printf>
c00247b4:	83 c4 10             	add    $0x10,%esp
}
c00247b7:	90                   	nop
c00247b8:	c9                   	leave  
c00247b9:	c3                   	ret    

c00247ba <keyboard_interrupt>:

static bool map_key (const struct keymap[], unsigned scancode, uint8_t *);

static void
keyboard_interrupt (struct intr_frame *args UNUSED) 
{
c00247ba:	55                   	push   %ebp
c00247bb:	89 e5                	mov    %esp,%ebp
c00247bd:	53                   	push   %ebx
c00247be:	83 ec 14             	sub    $0x14,%esp
  /* Status of shift keys. */
  bool shift = left_shift || right_shift;
c00247c1:	0f b6 05 88 9a 03 c0 	movzbl 0xc0039a88,%eax
c00247c8:	84 c0                	test   %al,%al
c00247ca:	75 0b                	jne    c00247d7 <keyboard_interrupt+0x1d>
c00247cc:	0f b6 05 89 9a 03 c0 	movzbl 0xc0039a89,%eax
c00247d3:	84 c0                	test   %al,%al
c00247d5:	74 07                	je     c00247de <keyboard_interrupt+0x24>
c00247d7:	b8 01 00 00 00       	mov    $0x1,%eax
c00247dc:	eb 05                	jmp    c00247e3 <keyboard_interrupt+0x29>
c00247de:	b8 00 00 00 00       	mov    $0x0,%eax
c00247e3:	88 45 ef             	mov    %al,-0x11(%ebp)
c00247e6:	80 65 ef 01          	andb   $0x1,-0x11(%ebp)
  bool alt = left_alt || right_alt;
c00247ea:	0f b6 05 8a 9a 03 c0 	movzbl 0xc0039a8a,%eax
c00247f1:	84 c0                	test   %al,%al
c00247f3:	75 0b                	jne    c0024800 <keyboard_interrupt+0x46>
c00247f5:	0f b6 05 8b 9a 03 c0 	movzbl 0xc0039a8b,%eax
c00247fc:	84 c0                	test   %al,%al
c00247fe:	74 07                	je     c0024807 <keyboard_interrupt+0x4d>
c0024800:	b8 01 00 00 00       	mov    $0x1,%eax
c0024805:	eb 05                	jmp    c002480c <keyboard_interrupt+0x52>
c0024807:	b8 00 00 00 00       	mov    $0x0,%eax
c002480c:	88 45 ee             	mov    %al,-0x12(%ebp)
c002480f:	80 65 ee 01          	andb   $0x1,-0x12(%ebp)
  bool ctrl = left_ctrl || right_ctrl;
c0024813:	0f b6 05 8c 9a 03 c0 	movzbl 0xc0039a8c,%eax
c002481a:	84 c0                	test   %al,%al
c002481c:	75 0b                	jne    c0024829 <keyboard_interrupt+0x6f>
c002481e:	0f b6 05 8d 9a 03 c0 	movzbl 0xc0039a8d,%eax
c0024825:	84 c0                	test   %al,%al
c0024827:	74 07                	je     c0024830 <keyboard_interrupt+0x76>
c0024829:	b8 01 00 00 00       	mov    $0x1,%eax
c002482e:	eb 05                	jmp    c0024835 <keyboard_interrupt+0x7b>
c0024830:	b8 00 00 00 00       	mov    $0x0,%eax
c0024835:	88 45 ed             	mov    %al,-0x13(%ebp)
c0024838:	80 65 ed 01          	andb   $0x1,-0x13(%ebp)

  /* Character that corresponds to `code'. */
  uint8_t c;

  /* Read scancode, including second byte if prefix code. */
  code = inb (DATA_REG);
c002483c:	6a 60                	push   $0x60
c002483e:	e8 14 ff ff ff       	call   c0024757 <inb>
c0024843:	83 c4 04             	add    $0x4,%esp
c0024846:	0f b6 c0             	movzbl %al,%eax
c0024849:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (code == 0xe0)
c002484c:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%ebp)
c0024853:	75 1a                	jne    c002486f <keyboard_interrupt+0xb5>
    code = (code << 8) | inb (DATA_REG);
c0024855:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024858:	c1 e0 08             	shl    $0x8,%eax
c002485b:	89 c3                	mov    %eax,%ebx
c002485d:	6a 60                	push   $0x60
c002485f:	e8 f3 fe ff ff       	call   c0024757 <inb>
c0024864:	83 c4 04             	add    $0x4,%esp
c0024867:	0f b6 c0             	movzbl %al,%eax
c002486a:	09 d8                	or     %ebx,%eax
c002486c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Bit 0x80 distinguishes key press from key release
     (even if there's a prefix). */
  release = (code & 0x80) != 0;
c002486f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0024872:	25 80 00 00 00       	and    $0x80,%eax
c0024877:	85 c0                	test   %eax,%eax
c0024879:	0f 95 c0             	setne  %al
c002487c:	88 45 ec             	mov    %al,-0x14(%ebp)
  code &= ~0x80u;
c002487f:	81 65 f4 7f ff ff ff 	andl   $0xffffff7f,-0xc(%ebp)

  /* Interpret key. */
  if (code == 0x3a) 
c0024886:	83 7d f4 3a          	cmpl   $0x3a,-0xc(%ebp)
c002488a:	75 31                	jne    c00248bd <keyboard_interrupt+0x103>
    {
      /* Caps Lock. */
      if (!release)
c002488c:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c0024890:	83 f0 01             	xor    $0x1,%eax
c0024893:	84 c0                	test   %al,%al
c0024895:	0f 84 84 01 00 00    	je     c0024a1f <keyboard_interrupt+0x265>
        caps_lock = !caps_lock;
c002489b:	0f b6 05 8e 9a 03 c0 	movzbl 0xc0039a8e,%eax
c00248a2:	0f b6 c0             	movzbl %al,%eax
c00248a5:	85 c0                	test   %eax,%eax
c00248a7:	0f 95 c0             	setne  %al
c00248aa:	83 f0 01             	xor    $0x1,%eax
c00248ad:	0f b6 c0             	movzbl %al,%eax
c00248b0:	83 e0 01             	and    $0x1,%eax
c00248b3:	a2 8e 9a 03 c0       	mov    %al,0xc0039a8e
          {
            *key->state_var = !release;
            break;
          }
    }
}
c00248b8:	e9 62 01 00 00       	jmp    c0024a1f <keyboard_interrupt+0x265>
    {
      /* Caps Lock. */
      if (!release)
        caps_lock = !caps_lock;
    }
  else if (map_key (invariant_keymap, code, &c)
c00248bd:	83 ec 04             	sub    $0x4,%esp
c00248c0:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00248c3:	50                   	push   %eax
c00248c4:	ff 75 f4             	pushl  -0xc(%ebp)
c00248c7:	68 a0 fc 02 c0       	push   $0xc002fca0
c00248cc:	e8 54 01 00 00       	call   c0024a25 <map_key>
c00248d1:	83 c4 10             	add    $0x10,%esp
c00248d4:	84 c0                	test   %al,%al
c00248d6:	75 4f                	jne    c0024927 <keyboard_interrupt+0x16d>
           || (!shift && map_key (unshifted_keymap, code, &c))
c00248d8:	0f b6 45 ef          	movzbl -0x11(%ebp),%eax
c00248dc:	83 f0 01             	xor    $0x1,%eax
c00248df:	84 c0                	test   %al,%al
c00248e1:	74 1b                	je     c00248fe <keyboard_interrupt+0x144>
c00248e3:	83 ec 04             	sub    $0x4,%esp
c00248e6:	8d 45 eb             	lea    -0x15(%ebp),%eax
c00248e9:	50                   	push   %eax
c00248ea:	ff 75 f4             	pushl  -0xc(%ebp)
c00248ed:	68 20 fd 02 c0       	push   $0xc002fd20
c00248f2:	e8 2e 01 00 00       	call   c0024a25 <map_key>
c00248f7:	83 c4 10             	add    $0x10,%esp
c00248fa:	84 c0                	test   %al,%al
c00248fc:	75 29                	jne    c0024927 <keyboard_interrupt+0x16d>
           || (shift && map_key (shifted_keymap, code, &c)))
c00248fe:	80 7d ef 00          	cmpb   $0x0,-0x11(%ebp)
c0024902:	0f 84 d8 00 00 00    	je     c00249e0 <keyboard_interrupt+0x226>
c0024908:	83 ec 04             	sub    $0x4,%esp
c002490b:	8d 45 eb             	lea    -0x15(%ebp),%eax
c002490e:	50                   	push   %eax
c002490f:	ff 75 f4             	pushl  -0xc(%ebp)
c0024912:	68 80 fd 02 c0       	push   $0xc002fd80
c0024917:	e8 09 01 00 00       	call   c0024a25 <map_key>
c002491c:	83 c4 10             	add    $0x10,%esp
c002491f:	84 c0                	test   %al,%al
c0024921:	0f 84 b9 00 00 00    	je     c00249e0 <keyboard_interrupt+0x226>
    {
      /* Ordinary character. */
      if (!release) 
c0024927:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c002492b:	83 f0 01             	xor    $0x1,%eax
c002492e:	84 c0                	test   %al,%al
c0024930:	0f 84 e8 00 00 00    	je     c0024a1e <keyboard_interrupt+0x264>
        {
          /* Reboot if Ctrl+Alt+Del pressed. */
          if (c == 0177 && ctrl && alt)
c0024936:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002493a:	3c 7f                	cmp    $0x7f,%al
c002493c:	75 11                	jne    c002494f <keyboard_interrupt+0x195>
c002493e:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024942:	74 0b                	je     c002494f <keyboard_interrupt+0x195>
c0024944:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024948:	74 05                	je     c002494f <keyboard_interrupt+0x195>
            shutdown_reboot ();
c002494a:	e8 03 29 00 00       	call   c0027252 <shutdown_reboot>

          /* Handle Ctrl, Shift.
             Note that Ctrl overrides Shift. */
          if (ctrl && c >= 0x40 && c < 0x60) 
c002494f:	80 7d ed 00          	cmpb   $0x0,-0x13(%ebp)
c0024953:	74 1c                	je     c0024971 <keyboard_interrupt+0x1b7>
c0024955:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024959:	3c 3f                	cmp    $0x3f,%al
c002495b:	76 14                	jbe    c0024971 <keyboard_interrupt+0x1b7>
c002495d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024961:	3c 5f                	cmp    $0x5f,%al
c0024963:	77 0c                	ja     c0024971 <keyboard_interrupt+0x1b7>
            {
              /* A is 0x41, Ctrl+A is 0x01, etc. */
              c -= 0x40; 
c0024965:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024969:	83 e8 40             	sub    $0x40,%eax
c002496c:	88 45 eb             	mov    %al,-0x15(%ebp)
c002496f:	eb 22                	jmp    c0024993 <keyboard_interrupt+0x1d9>
            }
          else if (shift == caps_lock)
c0024971:	0f b6 05 8e 9a 03 c0 	movzbl 0xc0039a8e,%eax
c0024978:	38 45 ef             	cmp    %al,-0x11(%ebp)
c002497b:	75 16                	jne    c0024993 <keyboard_interrupt+0x1d9>
            c = tolower (c);
c002497d:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0024981:	0f b6 c0             	movzbl %al,%eax
c0024984:	83 ec 0c             	sub    $0xc,%esp
c0024987:	50                   	push   %eax
c0024988:	e8 ab fd ff ff       	call   c0024738 <tolower>
c002498d:	83 c4 10             	add    $0x10,%esp
c0024990:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Handle Alt by setting the high bit.
             This 0x80 is unrelated to the one used to
             distinguish key press from key release. */
          if (alt)
c0024993:	80 7d ee 00          	cmpb   $0x0,-0x12(%ebp)
c0024997:	74 0a                	je     c00249a3 <keyboard_interrupt+0x1e9>
            c += 0x80;
c0024999:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002499d:	83 c0 80             	add    $0xffffff80,%eax
c00249a0:	88 45 eb             	mov    %al,-0x15(%ebp)

          /* Append to keyboard buffer. */
          if (!input_full ())
c00249a3:	e8 92 21 00 00       	call   c0026b3a <input_full>
c00249a8:	83 f0 01             	xor    $0x1,%eax
c00249ab:	84 c0                	test   %al,%al
c00249ad:	74 6f                	je     c0024a1e <keyboard_interrupt+0x264>
            {
              key_cnt++;
c00249af:	a1 90 9a 03 c0       	mov    0xc0039a90,%eax
c00249b4:	8b 15 94 9a 03 c0    	mov    0xc0039a94,%edx
c00249ba:	83 c0 01             	add    $0x1,%eax
c00249bd:	83 d2 00             	adc    $0x0,%edx
c00249c0:	a3 90 9a 03 c0       	mov    %eax,0xc0039a90
c00249c5:	89 15 94 9a 03 c0    	mov    %edx,0xc0039a94
              input_putc (c);
c00249cb:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c00249cf:	0f b6 c0             	movzbl %al,%eax
c00249d2:	83 ec 0c             	sub    $0xc,%esp
c00249d5:	50                   	push   %eax
c00249d6:	e8 a0 20 00 00       	call   c0026a7b <input_putc>
c00249db:	83 c4 10             	add    $0x10,%esp
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c00249de:	eb 3e                	jmp    c0024a1e <keyboard_interrupt+0x264>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c00249e0:	c7 45 f0 c0 fd 02 c0 	movl   $0xc002fdc0,-0x10(%ebp)
c00249e7:	eb 2a                	jmp    c0024a13 <keyboard_interrupt+0x259>
        if (key->scancode == code)
c00249e9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00249ec:	8b 00                	mov    (%eax),%eax
c00249ee:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00249f1:	75 1c                	jne    c0024a0f <keyboard_interrupt+0x255>
          {
            *key->state_var = !release;
c00249f3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00249f6:	8b 50 04             	mov    0x4(%eax),%edx
c00249f9:	0f b6 45 ec          	movzbl -0x14(%ebp),%eax
c00249fd:	85 c0                	test   %eax,%eax
c00249ff:	0f 95 c0             	setne  %al
c0024a02:	83 f0 01             	xor    $0x1,%eax
c0024a05:	0f b6 c0             	movzbl %al,%eax
c0024a08:	83 e0 01             	and    $0x1,%eax
c0024a0b:	88 02                	mov    %al,(%edx)
            break;
c0024a0d:	eb 10                	jmp    c0024a1f <keyboard_interrupt+0x265>
        };
  
      const struct shift_key *key;

      /* Scan the table. */
      for (key = shift_keys; key->scancode != 0; key++) 
c0024a0f:	83 45 f0 08          	addl   $0x8,-0x10(%ebp)
c0024a13:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0024a16:	8b 00                	mov    (%eax),%eax
c0024a18:	85 c0                	test   %eax,%eax
c0024a1a:	75 cd                	jne    c00249e9 <keyboard_interrupt+0x22f>
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024a1c:	eb 01                	jmp    c0024a1f <keyboard_interrupt+0x265>
  else if (map_key (invariant_keymap, code, &c)
           || (!shift && map_key (unshifted_keymap, code, &c))
           || (shift && map_key (shifted_keymap, code, &c)))
    {
      /* Ordinary character. */
      if (!release) 
c0024a1e:	90                   	nop
          {
            *key->state_var = !release;
            break;
          }
    }
}
c0024a1f:	90                   	nop
c0024a20:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024a23:	c9                   	leave  
c0024a24:	c3                   	ret    

c0024a25 <map_key>:
   If found, sets *C to the corresponding character and returns
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
c0024a25:	55                   	push   %ebp
c0024a26:	89 e5                	mov    %esp,%ebp
c0024a28:	53                   	push   %ebx
c0024a29:	83 ec 04             	sub    $0x4,%esp
  for (; k->first_scancode != 0; k++)
c0024a2c:	eb 5d                	jmp    c0024a8b <map_key+0x66>
    if (scancode >= k->first_scancode
c0024a2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a31:	0f b6 00             	movzbl (%eax),%eax
c0024a34:	0f b6 c0             	movzbl %al,%eax
c0024a37:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024a3a:	77 4b                	ja     c0024a87 <map_key+0x62>
        && scancode < k->first_scancode + strlen (k->chars)) 
c0024a3c:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a3f:	0f b6 00             	movzbl (%eax),%eax
c0024a42:	0f b6 d8             	movzbl %al,%ebx
c0024a45:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a48:	8b 40 04             	mov    0x4(%eax),%eax
c0024a4b:	83 ec 0c             	sub    $0xc,%esp
c0024a4e:	50                   	push   %eax
c0024a4f:	e8 14 46 00 00       	call   c0029068 <strlen>
c0024a54:	83 c4 10             	add    $0x10,%esp
c0024a57:	01 d8                	add    %ebx,%eax
c0024a59:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0024a5c:	76 29                	jbe    c0024a87 <map_key+0x62>
      {
        *c = k->chars[scancode - k->first_scancode];
c0024a5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a61:	8b 50 04             	mov    0x4(%eax),%edx
c0024a64:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a67:	0f b6 00             	movzbl (%eax),%eax
c0024a6a:	0f b6 c0             	movzbl %al,%eax
c0024a6d:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0024a70:	29 c1                	sub    %eax,%ecx
c0024a72:	89 c8                	mov    %ecx,%eax
c0024a74:	01 d0                	add    %edx,%eax
c0024a76:	0f b6 00             	movzbl (%eax),%eax
c0024a79:	89 c2                	mov    %eax,%edx
c0024a7b:	8b 45 10             	mov    0x10(%ebp),%eax
c0024a7e:	88 10                	mov    %dl,(%eax)
        return true; 
c0024a80:	b8 01 00 00 00       	mov    $0x1,%eax
c0024a85:	eb 13                	jmp    c0024a9a <map_key+0x75>
   true.
   If not found, returns false and C is ignored. */
static bool
map_key (const struct keymap k[], unsigned scancode, uint8_t *c) 
{
  for (; k->first_scancode != 0; k++)
c0024a87:	83 45 08 08          	addl   $0x8,0x8(%ebp)
c0024a8b:	8b 45 08             	mov    0x8(%ebp),%eax
c0024a8e:	0f b6 00             	movzbl (%eax),%eax
c0024a91:	84 c0                	test   %al,%al
c0024a93:	75 99                	jne    c0024a2e <map_key+0x9>
      {
        *c = k->chars[scancode - k->first_scancode];
        return true; 
      }

  return false;
c0024a95:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0024a9a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0024a9d:	c9                   	leave  
c0024a9e:	c3                   	ret    

c0024a9f <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0024a9f:	55                   	push   %ebp
c0024aa0:	89 e5                	mov    %esp,%ebp
c0024aa2:	83 ec 14             	sub    $0x14,%esp
c0024aa5:	8b 45 08             	mov    0x8(%ebp),%eax
c0024aa8:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024aac:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0024ab0:	89 c2                	mov    %eax,%edx
c0024ab2:	ec                   	in     (%dx),%al
c0024ab3:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024ab6:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024aba:	c9                   	leave  
c0024abb:	c3                   	ret    

c0024abc <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0024abc:	55                   	push   %ebp
c0024abd:	89 e5                	mov    %esp,%ebp
c0024abf:	83 ec 08             	sub    $0x8,%esp
c0024ac2:	8b 55 08             	mov    0x8(%ebp),%edx
c0024ac5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024ac8:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024acc:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024acf:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0024ad3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024ad7:	ee                   	out    %al,(%dx)
}
c0024ad8:	90                   	nop
c0024ad9:	c9                   	leave  
c0024ada:	c3                   	ret    

c0024adb <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c0024adb:	55                   	push   %ebp
c0024adc:	89 e5                	mov    %esp,%ebp
c0024ade:	83 ec 08             	sub    $0x8,%esp
c0024ae1:	8b 55 08             	mov    0x8(%ebp),%edx
c0024ae4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024ae7:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024aeb:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0024aef:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0024af3:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024af7:	66 ef                	out    %ax,(%dx)
}
c0024af9:	90                   	nop
c0024afa:	c9                   	leave  
c0024afb:	c3                   	ret    

c0024afc <ptov>:

/* Returns kernel virtual address at which physical address PADDR
   is mapped. */
static inline void *
ptov (uintptr_t paddr)
{
c0024afc:	55                   	push   %ebp
c0024afd:	89 e5                	mov    %esp,%ebp
c0024aff:	83 ec 08             	sub    $0x8,%esp
  ASSERT ((void *) paddr < PHYS_BASE);
c0024b02:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b05:	3d ff ff ff bf       	cmp    $0xbfffffff,%eax
c0024b0a:	76 1e                	jbe    c0024b2a <ptov+0x2e>
c0024b0c:	83 ec 0c             	sub    $0xc,%esp
c0024b0f:	68 f8 fd 02 c0       	push   $0xc002fdf8
c0024b14:	68 13 fe 02 c0       	push   $0xc002fe13
c0024b19:	68 5c fe 02 c0       	push   $0xc002fe5c
c0024b1e:	6a 4a                	push   $0x4a
c0024b20:	68 2a fe 02 c0       	push   $0xc002fe2a
c0024b25:	e8 f1 50 00 00       	call   c0029c1b <debug_panic>

  return (void *) (paddr + PHYS_BASE);
c0024b2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b2d:	2d 00 00 00 40       	sub    $0x40000000,%eax
}
c0024b32:	c9                   	leave  
c0024b33:	c3                   	ret    

c0024b34 <init>:
static void find_cursor (size_t *x, size_t *y);

/* Initializes the VGA text display. */
static void
init (void)
{
c0024b34:	55                   	push   %ebp
c0024b35:	89 e5                	mov    %esp,%ebp
c0024b37:	83 ec 08             	sub    $0x8,%esp
  /* Already initialized? */
  static bool inited;
  if (!inited)
c0024b3a:	0f b6 05 a4 9a 03 c0 	movzbl 0xc0039aa4,%eax
c0024b41:	83 f0 01             	xor    $0x1,%eax
c0024b44:	84 c0                	test   %al,%al
c0024b46:	74 31                	je     c0024b79 <init+0x45>
    {
      fb = ptov (0xb8000);
c0024b48:	83 ec 0c             	sub    $0xc,%esp
c0024b4b:	68 00 80 0b 00       	push   $0xb8000
c0024b50:	e8 a7 ff ff ff       	call   c0024afc <ptov>
c0024b55:	83 c4 10             	add    $0x10,%esp
c0024b58:	a3 a0 9a 03 c0       	mov    %eax,0xc0039aa0
      find_cursor (&cx, &cy);
c0024b5d:	83 ec 08             	sub    $0x8,%esp
c0024b60:	68 9c 9a 03 c0       	push   $0xc0039a9c
c0024b65:	68 98 9a 03 c0       	push   $0xc0039a98
c0024b6a:	e8 9a 02 00 00       	call   c0024e09 <find_cursor>
c0024b6f:	83 c4 10             	add    $0x10,%esp
      inited = true; 
c0024b72:	c6 05 a4 9a 03 c0 01 	movb   $0x1,0xc0039aa4
    }
}
c0024b79:	90                   	nop
c0024b7a:	c9                   	leave  
c0024b7b:	c3                   	ret    

c0024b7c <vga_putc>:

/* Writes C to the VGA text display, interpreting control
   characters in the conventional ways.  */
void
vga_putc (int c)
{
c0024b7c:	55                   	push   %ebp
c0024b7d:	89 e5                	mov    %esp,%ebp
c0024b7f:	83 ec 18             	sub    $0x18,%esp
  /* Disable interrupts to lock out interrupt handlers
     that might write to the console. */
  enum intr_level old_level = intr_disable ();
c0024b82:	e8 80 c9 ff ff       	call   c0021507 <intr_disable>
c0024b87:	89 45 f4             	mov    %eax,-0xc(%ebp)

  init ();
c0024b8a:	e8 a5 ff ff ff       	call   c0024b34 <init>
  
  switch (c) 
c0024b8f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024b92:	83 e8 07             	sub    $0x7,%eax
c0024b95:	83 f8 06             	cmp    $0x6,%eax
c0024b98:	0f 87 90 00 00 00    	ja     c0024c2e <vga_putc+0xb2>
c0024b9e:	8b 04 85 40 fe 02 c0 	mov    -0x3ffd01c0(,%eax,4),%eax
c0024ba5:	ff e0                	jmp    *%eax
    {
    case '\n':
      newline ();
c0024ba7:	e8 9e 01 00 00       	call   c0024d4a <newline>
      break;
c0024bac:	e9 e9 00 00 00       	jmp    c0024c9a <vga_putc+0x11e>

    case '\f':
      cls ();
c0024bb1:	e8 fa 00 00 00       	call   c0024cb0 <cls>
      break;
c0024bb6:	e9 df 00 00 00       	jmp    c0024c9a <vga_putc+0x11e>

    case '\b':
      if (cx > 0)
c0024bbb:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024bc0:	85 c0                	test   %eax,%eax
c0024bc2:	0f 84 cb 00 00 00    	je     c0024c93 <vga_putc+0x117>
        cx--;
c0024bc8:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024bcd:	83 e8 01             	sub    $0x1,%eax
c0024bd0:	a3 98 9a 03 c0       	mov    %eax,0xc0039a98
      break;
c0024bd5:	e9 b9 00 00 00       	jmp    c0024c93 <vga_putc+0x117>
      
    case '\r':
      cx = 0;
c0024bda:	c7 05 98 9a 03 c0 00 	movl   $0x0,0xc0039a98
c0024be1:	00 00 00 
      break;
c0024be4:	e9 b1 00 00 00       	jmp    c0024c9a <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
c0024be9:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024bee:	83 c0 08             	add    $0x8,%eax
c0024bf1:	c1 e8 03             	shr    $0x3,%eax
c0024bf4:	c1 e0 03             	shl    $0x3,%eax
c0024bf7:	a3 98 9a 03 c0       	mov    %eax,0xc0039a98
      if (cx >= COL_CNT)
c0024bfc:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024c01:	83 f8 4f             	cmp    $0x4f,%eax
c0024c04:	0f 86 8c 00 00 00    	jbe    c0024c96 <vga_putc+0x11a>
        newline ();
c0024c0a:	e8 3b 01 00 00       	call   c0024d4a <newline>
      break;
c0024c0f:	e9 82 00 00 00       	jmp    c0024c96 <vga_putc+0x11a>

    case '\a':
      intr_set_level (old_level);
c0024c14:	83 ec 0c             	sub    $0xc,%esp
c0024c17:	ff 75 f4             	pushl  -0xc(%ebp)
c0024c1a:	e8 90 c8 ff ff       	call   c00214af <intr_set_level>
c0024c1f:	83 c4 10             	add    $0x10,%esp
      speaker_beep ();
c0024c22:	e8 52 28 00 00       	call   c0027479 <speaker_beep>
      intr_disable ();
c0024c27:	e8 db c8 ff ff       	call   c0021507 <intr_disable>
      break;
c0024c2c:	eb 6c                	jmp    c0024c9a <vga_putc+0x11e>
      
    default:
      fb[cy][cx][0] = c;
c0024c2e:	8b 0d a0 9a 03 c0    	mov    0xc0039aa0,%ecx
c0024c34:	8b 15 9c 9a 03 c0    	mov    0xc0039a9c,%edx
c0024c3a:	89 d0                	mov    %edx,%eax
c0024c3c:	c1 e0 02             	shl    $0x2,%eax
c0024c3f:	01 d0                	add    %edx,%eax
c0024c41:	c1 e0 05             	shl    $0x5,%eax
c0024c44:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024c47:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024c4c:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0024c4f:	88 0c 42             	mov    %cl,(%edx,%eax,2)
      fb[cy][cx][1] = GRAY_ON_BLACK;
c0024c52:	8b 0d a0 9a 03 c0    	mov    0xc0039aa0,%ecx
c0024c58:	8b 15 9c 9a 03 c0    	mov    0xc0039a9c,%edx
c0024c5e:	89 d0                	mov    %edx,%eax
c0024c60:	c1 e0 02             	shl    $0x2,%eax
c0024c63:	01 d0                	add    %edx,%eax
c0024c65:	c1 e0 05             	shl    $0x5,%eax
c0024c68:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024c6b:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024c70:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
      if (++cx >= COL_CNT)
c0024c75:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024c7a:	83 c0 01             	add    $0x1,%eax
c0024c7d:	a3 98 9a 03 c0       	mov    %eax,0xc0039a98
c0024c82:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024c87:	83 f8 4f             	cmp    $0x4f,%eax
c0024c8a:	76 0d                	jbe    c0024c99 <vga_putc+0x11d>
        newline ();
c0024c8c:	e8 b9 00 00 00       	call   c0024d4a <newline>
      break;
c0024c91:	eb 06                	jmp    c0024c99 <vga_putc+0x11d>
      break;

    case '\b':
      if (cx > 0)
        cx--;
      break;
c0024c93:	90                   	nop
c0024c94:	eb 04                	jmp    c0024c9a <vga_putc+0x11e>

    case '\t':
      cx = ROUND_UP (cx + 1, 8);
      if (cx >= COL_CNT)
        newline ();
      break;
c0024c96:	90                   	nop
c0024c97:	eb 01                	jmp    c0024c9a <vga_putc+0x11e>
    default:
      fb[cy][cx][0] = c;
      fb[cy][cx][1] = GRAY_ON_BLACK;
      if (++cx >= COL_CNT)
        newline ();
      break;
c0024c99:	90                   	nop
    }

  /* Update cursor position. */
  move_cursor ();
c0024c9a:	e8 0e 01 00 00       	call   c0024dad <move_cursor>

  intr_set_level (old_level);
c0024c9f:	83 ec 0c             	sub    $0xc,%esp
c0024ca2:	ff 75 f4             	pushl  -0xc(%ebp)
c0024ca5:	e8 05 c8 ff ff       	call   c00214af <intr_set_level>
c0024caa:	83 c4 10             	add    $0x10,%esp
}
c0024cad:	90                   	nop
c0024cae:	c9                   	leave  
c0024caf:	c3                   	ret    

c0024cb0 <cls>:

/* Clears the screen and moves the cursor to the upper left. */
static void
cls (void)
{
c0024cb0:	55                   	push   %ebp
c0024cb1:	89 e5                	mov    %esp,%ebp
c0024cb3:	83 ec 18             	sub    $0x18,%esp
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024cb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0024cbd:	eb 12                	jmp    c0024cd1 <cls+0x21>
    clear_row (y);
c0024cbf:	83 ec 0c             	sub    $0xc,%esp
c0024cc2:	ff 75 f4             	pushl  -0xc(%ebp)
c0024cc5:	e8 29 00 00 00       	call   c0024cf3 <clear_row>
c0024cca:	83 c4 10             	add    $0x10,%esp
static void
cls (void)
{
  size_t y;

  for (y = 0; y < ROW_CNT; y++)
c0024ccd:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0024cd1:	83 7d f4 18          	cmpl   $0x18,-0xc(%ebp)
c0024cd5:	76 e8                	jbe    c0024cbf <cls+0xf>
    clear_row (y);

  cx = cy = 0;
c0024cd7:	c7 05 9c 9a 03 c0 00 	movl   $0x0,0xc0039a9c
c0024cde:	00 00 00 
c0024ce1:	a1 9c 9a 03 c0       	mov    0xc0039a9c,%eax
c0024ce6:	a3 98 9a 03 c0       	mov    %eax,0xc0039a98
  move_cursor ();
c0024ceb:	e8 bd 00 00 00       	call   c0024dad <move_cursor>
}
c0024cf0:	90                   	nop
c0024cf1:	c9                   	leave  
c0024cf2:	c3                   	ret    

c0024cf3 <clear_row>:

/* Clears row Y to spaces. */
static void
clear_row (size_t y) 
{
c0024cf3:	55                   	push   %ebp
c0024cf4:	89 e5                	mov    %esp,%ebp
c0024cf6:	83 ec 10             	sub    $0x10,%esp
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0024cf9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0024d00:	eb 3f                	jmp    c0024d41 <clear_row+0x4e>
    {
      fb[y][x][0] = ' ';
c0024d02:	8b 0d a0 9a 03 c0    	mov    0xc0039aa0,%ecx
c0024d08:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d0b:	89 d0                	mov    %edx,%eax
c0024d0d:	c1 e0 02             	shl    $0x2,%eax
c0024d10:	01 d0                	add    %edx,%eax
c0024d12:	c1 e0 05             	shl    $0x5,%eax
c0024d15:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024d18:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024d1b:	c6 04 42 20          	movb   $0x20,(%edx,%eax,2)
      fb[y][x][1] = GRAY_ON_BLACK;
c0024d1f:	8b 0d a0 9a 03 c0    	mov    0xc0039aa0,%ecx
c0024d25:	8b 55 08             	mov    0x8(%ebp),%edx
c0024d28:	89 d0                	mov    %edx,%eax
c0024d2a:	c1 e0 02             	shl    $0x2,%eax
c0024d2d:	01 d0                	add    %edx,%eax
c0024d2f:	c1 e0 05             	shl    $0x5,%eax
c0024d32:	8d 14 01             	lea    (%ecx,%eax,1),%edx
c0024d35:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0024d38:	c6 44 42 01 07       	movb   $0x7,0x1(%edx,%eax,2)
static void
clear_row (size_t y) 
{
  size_t x;

  for (x = 0; x < COL_CNT; x++)
c0024d3d:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0024d41:	83 7d fc 4f          	cmpl   $0x4f,-0x4(%ebp)
c0024d45:	76 bb                	jbe    c0024d02 <clear_row+0xf>
    {
      fb[y][x][0] = ' ';
      fb[y][x][1] = GRAY_ON_BLACK;
    }
}
c0024d47:	90                   	nop
c0024d48:	c9                   	leave  
c0024d49:	c3                   	ret    

c0024d4a <newline>:
/* Advances the cursor to the first column in the next line on
   the screen.  If the cursor is already on the last line on the
   screen, scrolls the screen upward one line. */
static void
newline (void)
{
c0024d4a:	55                   	push   %ebp
c0024d4b:	89 e5                	mov    %esp,%ebp
c0024d4d:	83 ec 08             	sub    $0x8,%esp
  cx = 0;
c0024d50:	c7 05 98 9a 03 c0 00 	movl   $0x0,0xc0039a98
c0024d57:	00 00 00 
  cy++;
c0024d5a:	a1 9c 9a 03 c0       	mov    0xc0039a9c,%eax
c0024d5f:	83 c0 01             	add    $0x1,%eax
c0024d62:	a3 9c 9a 03 c0       	mov    %eax,0xc0039a9c
  if (cy >= ROW_CNT)
c0024d67:	a1 9c 9a 03 c0       	mov    0xc0039a9c,%eax
c0024d6c:	83 f8 18             	cmp    $0x18,%eax
c0024d6f:	76 39                	jbe    c0024daa <newline+0x60>
    {
      cy = ROW_CNT - 1;
c0024d71:	c7 05 9c 9a 03 c0 18 	movl   $0x18,0xc0039a9c
c0024d78:	00 00 00 
      memmove (&fb[0], &fb[1], sizeof fb[0] * (ROW_CNT - 1));
c0024d7b:	a1 a0 9a 03 c0       	mov    0xc0039aa0,%eax
c0024d80:	8d 90 a0 00 00 00    	lea    0xa0(%eax),%edx
c0024d86:	a1 a0 9a 03 c0       	mov    0xc0039aa0,%eax
c0024d8b:	83 ec 04             	sub    $0x4,%esp
c0024d8e:	68 00 0f 00 00       	push   $0xf00
c0024d93:	52                   	push   %edx
c0024d94:	50                   	push   %eax
c0024d95:	e8 fe 3c 00 00       	call   c0028a98 <memmove>
c0024d9a:	83 c4 10             	add    $0x10,%esp
      clear_row (ROW_CNT - 1);
c0024d9d:	83 ec 0c             	sub    $0xc,%esp
c0024da0:	6a 18                	push   $0x18
c0024da2:	e8 4c ff ff ff       	call   c0024cf3 <clear_row>
c0024da7:	83 c4 10             	add    $0x10,%esp
    }
}
c0024daa:	90                   	nop
c0024dab:	c9                   	leave  
c0024dac:	c3                   	ret    

c0024dad <move_cursor>:

/* Moves the hardware cursor to (cx,cy). */
static void
move_cursor (void) 
{
c0024dad:	55                   	push   %ebp
c0024dae:	89 e5                	mov    %esp,%ebp
c0024db0:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp = cx + COL_CNT * cy;
c0024db3:	a1 9c 9a 03 c0       	mov    0xc0039a9c,%eax
c0024db8:	89 c2                	mov    %eax,%edx
c0024dba:	89 d0                	mov    %edx,%eax
c0024dbc:	c1 e0 02             	shl    $0x2,%eax
c0024dbf:	01 d0                	add    %edx,%eax
c0024dc1:	c1 e0 04             	shl    $0x4,%eax
c0024dc4:	89 c2                	mov    %eax,%edx
c0024dc6:	a1 98 9a 03 c0       	mov    0xc0039a98,%eax
c0024dcb:	01 d0                	add    %edx,%eax
c0024dcd:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
  outw (0x3d4, 0x0e | (cp & 0xff00));
c0024dd1:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024dd5:	b0 00                	mov    $0x0,%al
c0024dd7:	83 c8 0e             	or     $0xe,%eax
c0024dda:	0f b7 c0             	movzwl %ax,%eax
c0024ddd:	50                   	push   %eax
c0024dde:	68 d4 03 00 00       	push   $0x3d4
c0024de3:	e8 f3 fc ff ff       	call   c0024adb <outw>
c0024de8:	83 c4 08             	add    $0x8,%esp
  outw (0x3d4, 0x0f | (cp << 8));
c0024deb:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024def:	c1 e0 08             	shl    $0x8,%eax
c0024df2:	83 c8 0f             	or     $0xf,%eax
c0024df5:	0f b7 c0             	movzwl %ax,%eax
c0024df8:	50                   	push   %eax
c0024df9:	68 d4 03 00 00       	push   $0x3d4
c0024dfe:	e8 d8 fc ff ff       	call   c0024adb <outw>
c0024e03:	83 c4 08             	add    $0x8,%esp
}
c0024e06:	90                   	nop
c0024e07:	c9                   	leave  
c0024e08:	c3                   	ret    

c0024e09 <find_cursor>:

/* Reads the current hardware cursor position into (*X,*Y). */
static void
find_cursor (size_t *x, size_t *y) 
{
c0024e09:	55                   	push   %ebp
c0024e0a:	89 e5                	mov    %esp,%ebp
c0024e0c:	83 ec 10             	sub    $0x10,%esp
  /* See [FREEVGA] under "Manipulating the Text-mode Cursor". */
  uint16_t cp;

  outb (0x3d4, 0x0e);
c0024e0f:	6a 0e                	push   $0xe
c0024e11:	68 d4 03 00 00       	push   $0x3d4
c0024e16:	e8 a1 fc ff ff       	call   c0024abc <outb>
c0024e1b:	83 c4 08             	add    $0x8,%esp
  cp = inb (0x3d5) << 8;
c0024e1e:	68 d5 03 00 00       	push   $0x3d5
c0024e23:	e8 77 fc ff ff       	call   c0024a9f <inb>
c0024e28:	83 c4 04             	add    $0x4,%esp
c0024e2b:	0f b6 c0             	movzbl %al,%eax
c0024e2e:	c1 e0 08             	shl    $0x8,%eax
c0024e31:	66 89 45 fe          	mov    %ax,-0x2(%ebp)

  outb (0x3d4, 0x0f);
c0024e35:	6a 0f                	push   $0xf
c0024e37:	68 d4 03 00 00       	push   $0x3d4
c0024e3c:	e8 7b fc ff ff       	call   c0024abc <outb>
c0024e41:	83 c4 08             	add    $0x8,%esp
  cp |= inb (0x3d5);
c0024e44:	68 d5 03 00 00       	push   $0x3d5
c0024e49:	e8 51 fc ff ff       	call   c0024a9f <inb>
c0024e4e:	83 c4 04             	add    $0x4,%esp
c0024e51:	0f b6 c0             	movzbl %al,%eax
c0024e54:	66 09 45 fe          	or     %ax,-0x2(%ebp)

  *x = cp % COL_CNT;
c0024e58:	0f b7 4d fe          	movzwl -0x2(%ebp),%ecx
c0024e5c:	0f b7 c1             	movzwl %cx,%eax
c0024e5f:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0024e65:	c1 e8 10             	shr    $0x10,%eax
c0024e68:	89 c2                	mov    %eax,%edx
c0024e6a:	66 c1 ea 06          	shr    $0x6,%dx
c0024e6e:	89 d0                	mov    %edx,%eax
c0024e70:	c1 e0 02             	shl    $0x2,%eax
c0024e73:	01 d0                	add    %edx,%eax
c0024e75:	c1 e0 04             	shl    $0x4,%eax
c0024e78:	29 c1                	sub    %eax,%ecx
c0024e7a:	89 ca                	mov    %ecx,%edx
c0024e7c:	0f b7 d2             	movzwl %dx,%edx
c0024e7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0024e82:	89 10                	mov    %edx,(%eax)
  *y = cp / COL_CNT;
c0024e84:	0f b7 45 fe          	movzwl -0x2(%ebp),%eax
c0024e88:	0f b7 c0             	movzwl %ax,%eax
c0024e8b:	69 c0 cd cc 00 00    	imul   $0xcccd,%eax,%eax
c0024e91:	c1 e8 10             	shr    $0x10,%eax
c0024e94:	66 c1 e8 06          	shr    $0x6,%ax
c0024e98:	0f b7 d0             	movzwl %ax,%edx
c0024e9b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024e9e:	89 10                	mov    %edx,(%eax)
}
c0024ea0:	90                   	nop
c0024ea1:	c9                   	leave  
c0024ea2:	c3                   	ret    

c0024ea3 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0024ea3:	55                   	push   %ebp
c0024ea4:	89 e5                	mov    %esp,%ebp
c0024ea6:	83 ec 14             	sub    $0x14,%esp
c0024ea9:	8b 45 08             	mov    0x8(%ebp),%eax
c0024eac:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0024eb0:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0024eb4:	89 c2                	mov    %eax,%edx
c0024eb6:	ec                   	in     (%dx),%al
c0024eb7:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0024eba:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0024ebe:	c9                   	leave  
c0024ebf:	c3                   	ret    

c0024ec0 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0024ec0:	55                   	push   %ebp
c0024ec1:	89 e5                	mov    %esp,%ebp
c0024ec3:	83 ec 08             	sub    $0x8,%esp
c0024ec6:	8b 55 08             	mov    0x8(%ebp),%edx
c0024ec9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0024ecc:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0024ed0:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0024ed3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0024ed7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0024edb:	ee                   	out    %al,(%dx)
}
c0024edc:	90                   	nop
c0024edd:	c9                   	leave  
c0024ede:	c3                   	ret    

c0024edf <init_poll>:
   Polling mode busy-waits for the serial port to become free
   before writing to it.  It's slow, but until interrupts have
   been initialized it's all we can do. */
static void
init_poll (void) 
{
c0024edf:	55                   	push   %ebp
c0024ee0:	89 e5                	mov    %esp,%ebp
c0024ee2:	83 ec 08             	sub    $0x8,%esp
  ASSERT (mode == UNINIT);
c0024ee5:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0024eea:	85 c0                	test   %eax,%eax
c0024eec:	74 1e                	je     c0024f0c <init_poll+0x2d>
c0024eee:	83 ec 0c             	sub    $0xc,%esp
c0024ef1:	68 64 fe 02 c0       	push   $0xc002fe64
c0024ef6:	68 73 fe 02 c0       	push   $0xc002fe73
c0024efb:	68 f0 fe 02 c0       	push   $0xc002fef0
c0024f00:	6a 45                	push   $0x45
c0024f02:	68 8a fe 02 c0       	push   $0xc002fe8a
c0024f07:	e8 0f 4d 00 00       	call   c0029c1b <debug_panic>
  outb (IER_REG, 0);                    /* Turn off all interrupts. */
c0024f0c:	83 ec 08             	sub    $0x8,%esp
c0024f0f:	6a 00                	push   $0x0
c0024f11:	68 f9 03 00 00       	push   $0x3f9
c0024f16:	e8 a5 ff ff ff       	call   c0024ec0 <outb>
c0024f1b:	83 c4 10             	add    $0x10,%esp
  outb (FCR_REG, 0);                    /* Disable FIFO. */
c0024f1e:	83 ec 08             	sub    $0x8,%esp
c0024f21:	6a 00                	push   $0x0
c0024f23:	68 fa 03 00 00       	push   $0x3fa
c0024f28:	e8 93 ff ff ff       	call   c0024ec0 <outb>
c0024f2d:	83 c4 10             	add    $0x10,%esp
  set_serial (9600);                    /* 9.6 kbps, N-8-1. */
c0024f30:	83 ec 0c             	sub    $0xc,%esp
c0024f33:	68 80 25 00 00       	push   $0x2580
c0024f38:	e8 e8 01 00 00       	call   c0025125 <set_serial>
c0024f3d:	83 c4 10             	add    $0x10,%esp
  outb (MCR_REG, MCR_OUT2);             /* Required to enable interrupts. */
c0024f40:	83 ec 08             	sub    $0x8,%esp
c0024f43:	6a 08                	push   $0x8
c0024f45:	68 fc 03 00 00       	push   $0x3fc
c0024f4a:	e8 71 ff ff ff       	call   c0024ec0 <outb>
c0024f4f:	83 c4 10             	add    $0x10,%esp
  intq_init (&txq);
c0024f52:	83 ec 0c             	sub    $0xc,%esp
c0024f55:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0024f5a:	e8 1a 1c 00 00       	call   c0026b79 <intq_init>
c0024f5f:	83 c4 10             	add    $0x10,%esp
  mode = POLL;
c0024f62:	c7 05 c0 9a 03 c0 01 	movl   $0x1,0xc0039ac0
c0024f69:	00 00 00 
} 
c0024f6c:	90                   	nop
c0024f6d:	c9                   	leave  
c0024f6e:	c3                   	ret    

c0024f6f <serial_init_queue>:
/* Initializes the serial port device for queued interrupt-driven
   I/O.  With interrupt-driven I/O we don't waste CPU time
   waiting for the serial device to become ready. */
void
serial_init_queue (void) 
{
c0024f6f:	55                   	push   %ebp
c0024f70:	89 e5                	mov    %esp,%ebp
c0024f72:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;

  if (mode == UNINIT)
c0024f75:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0024f7a:	85 c0                	test   %eax,%eax
c0024f7c:	75 05                	jne    c0024f83 <serial_init_queue+0x14>
    init_poll ();
c0024f7e:	e8 5c ff ff ff       	call   c0024edf <init_poll>
  ASSERT (mode == POLL);
c0024f83:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0024f88:	83 f8 01             	cmp    $0x1,%eax
c0024f8b:	74 1e                	je     c0024fab <serial_init_queue+0x3c>
c0024f8d:	83 ec 0c             	sub    $0xc,%esp
c0024f90:	68 a1 fe 02 c0       	push   $0xc002fea1
c0024f95:	68 73 fe 02 c0       	push   $0xc002fe73
c0024f9a:	68 fc fe 02 c0       	push   $0xc002fefc
c0024f9f:	6a 58                	push   $0x58
c0024fa1:	68 8a fe 02 c0       	push   $0xc002fe8a
c0024fa6:	e8 70 4c 00 00       	call   c0029c1b <debug_panic>

  intr_register_ext (0x20 + 4, serial_interrupt, "serial");
c0024fab:	83 ec 04             	sub    $0x4,%esp
c0024fae:	68 ae fe 02 c0       	push   $0xc002feae
c0024fb3:	68 ae 52 02 c0       	push   $0xc00252ae
c0024fb8:	6a 24                	push   $0x24
c0024fba:	e8 69 c7 ff ff       	call   c0021728 <intr_register_ext>
c0024fbf:	83 c4 10             	add    $0x10,%esp
  mode = QUEUE;
c0024fc2:	c7 05 c0 9a 03 c0 02 	movl   $0x2,0xc0039ac0
c0024fc9:	00 00 00 
  old_level = intr_disable ();
c0024fcc:	e8 36 c5 ff ff       	call   c0021507 <intr_disable>
c0024fd1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  write_ier ();
c0024fd4:	e8 f5 01 00 00       	call   c00251ce <write_ier>
  intr_set_level (old_level);
c0024fd9:	83 ec 0c             	sub    $0xc,%esp
c0024fdc:	ff 75 f4             	pushl  -0xc(%ebp)
c0024fdf:	e8 cb c4 ff ff       	call   c00214af <intr_set_level>
c0024fe4:	83 c4 10             	add    $0x10,%esp
}
c0024fe7:	90                   	nop
c0024fe8:	c9                   	leave  
c0024fe9:	c3                   	ret    

c0024fea <serial_putc>:

/* Sends BYTE to the serial port. */
void
serial_putc (uint8_t byte) 
{
c0024fea:	55                   	push   %ebp
c0024feb:	89 e5                	mov    %esp,%ebp
c0024fed:	83 ec 28             	sub    $0x28,%esp
c0024ff0:	8b 45 08             	mov    0x8(%ebp),%eax
c0024ff3:	88 45 e4             	mov    %al,-0x1c(%ebp)
  enum intr_level old_level = intr_disable ();
c0024ff6:	e8 0c c5 ff ff       	call   c0021507 <intr_disable>
c0024ffb:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (mode != QUEUE)
c0024ffe:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0025003:	83 f8 02             	cmp    $0x2,%eax
c0025006:	74 20                	je     c0025028 <serial_putc+0x3e>
    {
      /* If we're not set up for interrupt-driven I/O yet,
         use dumb polling to transmit a byte. */
      if (mode == UNINIT)
c0025008:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c002500d:	85 c0                	test   %eax,%eax
c002500f:	75 05                	jne    c0025016 <serial_putc+0x2c>
        init_poll ();
c0025011:	e8 c9 fe ff ff       	call   c0024edf <init_poll>
      putc_poll (byte); 
c0025016:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002501a:	83 ec 0c             	sub    $0xc,%esp
c002501d:	50                   	push   %eax
c002501e:	e8 22 02 00 00       	call   c0025245 <putc_poll>
c0025023:	83 c4 10             	add    $0x10,%esp
c0025026:	eb 53                	jmp    c002507b <serial_putc+0x91>
    }
  else 
    {
      /* Otherwise, queue a byte and update the interrupt enable
         register. */
      if (old_level == INTR_OFF && intq_full (&txq)) 
c0025028:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002502c:	75 33                	jne    c0025061 <serial_putc+0x77>
c002502e:	83 ec 0c             	sub    $0xc,%esp
c0025031:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0025036:	e8 c2 1b 00 00       	call   c0026bfd <intq_full>
c002503b:	83 c4 10             	add    $0x10,%esp
c002503e:	84 c0                	test   %al,%al
c0025040:	74 1f                	je     c0025061 <serial_putc+0x77>
          /* Interrupts are off and the transmit queue is full.
             If we wanted to wait for the queue to empty,
             we'd have to reenable interrupts.
             That's impolite, so we'll send a character via
             polling instead. */
          putc_poll (intq_getc (&txq)); 
c0025042:	83 ec 0c             	sub    $0xc,%esp
c0025045:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002504a:	e8 fc 1b 00 00       	call   c0026c4b <intq_getc>
c002504f:	83 c4 10             	add    $0x10,%esp
c0025052:	0f b6 c0             	movzbl %al,%eax
c0025055:	83 ec 0c             	sub    $0xc,%esp
c0025058:	50                   	push   %eax
c0025059:	e8 e7 01 00 00       	call   c0025245 <putc_poll>
c002505e:	83 c4 10             	add    $0x10,%esp
        }

      intq_putc (&txq, byte); 
c0025061:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c0025065:	83 ec 08             	sub    $0x8,%esp
c0025068:	50                   	push   %eax
c0025069:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002506e:	e8 ba 1c 00 00       	call   c0026d2d <intq_putc>
c0025073:	83 c4 10             	add    $0x10,%esp
      write_ier ();
c0025076:	e8 53 01 00 00       	call   c00251ce <write_ier>
    }
  
  intr_set_level (old_level);
c002507b:	83 ec 0c             	sub    $0xc,%esp
c002507e:	ff 75 f4             	pushl  -0xc(%ebp)
c0025081:	e8 29 c4 ff ff       	call   c00214af <intr_set_level>
c0025086:	83 c4 10             	add    $0x10,%esp
}
c0025089:	90                   	nop
c002508a:	c9                   	leave  
c002508b:	c3                   	ret    

c002508c <serial_flush>:

/* Flushes anything in the serial buffer out the port in polling
   mode. */
void
serial_flush (void) 
{
c002508c:	55                   	push   %ebp
c002508d:	89 e5                	mov    %esp,%ebp
c002508f:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c0025092:	e8 70 c4 ff ff       	call   c0021507 <intr_disable>
c0025097:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (!intq_empty (&txq))
c002509a:	eb 1f                	jmp    c00250bb <serial_flush+0x2f>
    putc_poll (intq_getc (&txq));
c002509c:	83 ec 0c             	sub    $0xc,%esp
c002509f:	68 e0 9a 03 c0       	push   $0xc0039ae0
c00250a4:	e8 a2 1b 00 00       	call   c0026c4b <intq_getc>
c00250a9:	83 c4 10             	add    $0x10,%esp
c00250ac:	0f b6 c0             	movzbl %al,%eax
c00250af:	83 ec 0c             	sub    $0xc,%esp
c00250b2:	50                   	push   %eax
c00250b3:	e8 8d 01 00 00       	call   c0025245 <putc_poll>
c00250b8:	83 c4 10             	add    $0x10,%esp
   mode. */
void
serial_flush (void) 
{
  enum intr_level old_level = intr_disable ();
  while (!intq_empty (&txq))
c00250bb:	83 ec 0c             	sub    $0xc,%esp
c00250be:	68 e0 9a 03 c0       	push   $0xc0039ae0
c00250c3:	e8 f5 1a 00 00       	call   c0026bbd <intq_empty>
c00250c8:	83 c4 10             	add    $0x10,%esp
c00250cb:	83 f0 01             	xor    $0x1,%eax
c00250ce:	84 c0                	test   %al,%al
c00250d0:	75 ca                	jne    c002509c <serial_flush+0x10>
    putc_poll (intq_getc (&txq));
  intr_set_level (old_level);
c00250d2:	83 ec 0c             	sub    $0xc,%esp
c00250d5:	ff 75 f4             	pushl  -0xc(%ebp)
c00250d8:	e8 d2 c3 ff ff       	call   c00214af <intr_set_level>
c00250dd:	83 c4 10             	add    $0x10,%esp
}
c00250e0:	90                   	nop
c00250e1:	c9                   	leave  
c00250e2:	c3                   	ret    

c00250e3 <serial_notify>:
   whether we should block receive interrupts.
   Called by the input buffer routines when characters are added
   to or removed from the buffer. */
void
serial_notify (void) 
{
c00250e3:	55                   	push   %ebp
c00250e4:	89 e5                	mov    %esp,%ebp
c00250e6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c00250e9:	e8 a4 c3 ff ff       	call   c0021492 <intr_get_level>
c00250ee:	85 c0                	test   %eax,%eax
c00250f0:	74 21                	je     c0025113 <serial_notify+0x30>
c00250f2:	83 ec 0c             	sub    $0xc,%esp
c00250f5:	68 b5 fe 02 c0       	push   $0xc002feb5
c00250fa:	68 73 fe 02 c0       	push   $0xc002fe73
c00250ff:	68 10 ff 02 c0       	push   $0xc002ff10
c0025104:	68 96 00 00 00       	push   $0x96
c0025109:	68 8a fe 02 c0       	push   $0xc002fe8a
c002510e:	e8 08 4b 00 00       	call   c0029c1b <debug_panic>
  if (mode == QUEUE)
c0025113:	a1 c0 9a 03 c0       	mov    0xc0039ac0,%eax
c0025118:	83 f8 02             	cmp    $0x2,%eax
c002511b:	75 05                	jne    c0025122 <serial_notify+0x3f>
    write_ier ();
c002511d:	e8 ac 00 00 00       	call   c00251ce <write_ier>
}
c0025122:	90                   	nop
c0025123:	c9                   	leave  
c0025124:	c3                   	ret    

c0025125 <set_serial>:

/* Configures the serial port for BPS bits per second. */
static void
set_serial (int bps)
{
c0025125:	55                   	push   %ebp
c0025126:	89 e5                	mov    %esp,%ebp
c0025128:	83 ec 18             	sub    $0x18,%esp
  int base_rate = 1843200 / 16;         /* Base rate of 16550A, in Hz. */
c002512b:	c7 45 f4 00 c2 01 00 	movl   $0x1c200,-0xc(%ebp)
  uint16_t divisor = base_rate / bps;   /* Clock rate divisor. */
c0025132:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025135:	99                   	cltd   
c0025136:	f7 7d 08             	idivl  0x8(%ebp)
c0025139:	66 89 45 f2          	mov    %ax,-0xe(%ebp)

  ASSERT (bps >= 300 && bps <= 115200);
c002513d:	81 7d 08 2b 01 00 00 	cmpl   $0x12b,0x8(%ebp)
c0025144:	7e 09                	jle    c002514f <set_serial+0x2a>
c0025146:	81 7d 08 00 c2 01 00 	cmpl   $0x1c200,0x8(%ebp)
c002514d:	7e 21                	jle    c0025170 <set_serial+0x4b>
c002514f:	83 ec 0c             	sub    $0xc,%esp
c0025152:	68 d3 fe 02 c0       	push   $0xc002fed3
c0025157:	68 73 fe 02 c0       	push   $0xc002fe73
c002515c:	68 20 ff 02 c0       	push   $0xc002ff20
c0025161:	68 a2 00 00 00       	push   $0xa2
c0025166:	68 8a fe 02 c0       	push   $0xc002fe8a
c002516b:	e8 ab 4a 00 00       	call   c0029c1b <debug_panic>

  /* Enable DLAB. */
  outb (LCR_REG, LCR_N81 | LCR_DLAB);
c0025170:	83 ec 08             	sub    $0x8,%esp
c0025173:	68 83 00 00 00       	push   $0x83
c0025178:	68 fb 03 00 00       	push   $0x3fb
c002517d:	e8 3e fd ff ff       	call   c0024ec0 <outb>
c0025182:	83 c4 10             	add    $0x10,%esp

  /* Set data rate. */
  outb (LS_REG, divisor & 0xff);
c0025185:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c0025189:	0f b6 c0             	movzbl %al,%eax
c002518c:	83 ec 08             	sub    $0x8,%esp
c002518f:	50                   	push   %eax
c0025190:	68 f8 03 00 00       	push   $0x3f8
c0025195:	e8 26 fd ff ff       	call   c0024ec0 <outb>
c002519a:	83 c4 10             	add    $0x10,%esp
  outb (MS_REG, divisor >> 8);
c002519d:	0f b7 45 f2          	movzwl -0xe(%ebp),%eax
c00251a1:	66 c1 e8 08          	shr    $0x8,%ax
c00251a5:	0f b6 c0             	movzbl %al,%eax
c00251a8:	83 ec 08             	sub    $0x8,%esp
c00251ab:	50                   	push   %eax
c00251ac:	68 f9 03 00 00       	push   $0x3f9
c00251b1:	e8 0a fd ff ff       	call   c0024ec0 <outb>
c00251b6:	83 c4 10             	add    $0x10,%esp
  
  /* Reset DLAB. */
  outb (LCR_REG, LCR_N81);
c00251b9:	83 ec 08             	sub    $0x8,%esp
c00251bc:	6a 03                	push   $0x3
c00251be:	68 fb 03 00 00       	push   $0x3fb
c00251c3:	e8 f8 fc ff ff       	call   c0024ec0 <outb>
c00251c8:	83 c4 10             	add    $0x10,%esp
}
c00251cb:	90                   	nop
c00251cc:	c9                   	leave  
c00251cd:	c3                   	ret    

c00251ce <write_ier>:

/* Update interrupt enable register. */
static void
write_ier (void) 
{
c00251ce:	55                   	push   %ebp
c00251cf:	89 e5                	mov    %esp,%ebp
c00251d1:	83 ec 18             	sub    $0x18,%esp
  uint8_t ier = 0;
c00251d4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

  ASSERT (intr_get_level () == INTR_OFF);
c00251d8:	e8 b5 c2 ff ff       	call   c0021492 <intr_get_level>
c00251dd:	85 c0                	test   %eax,%eax
c00251df:	74 21                	je     c0025202 <write_ier+0x34>
c00251e1:	83 ec 0c             	sub    $0xc,%esp
c00251e4:	68 b5 fe 02 c0       	push   $0xc002feb5
c00251e9:	68 73 fe 02 c0       	push   $0xc002fe73
c00251ee:	68 2c ff 02 c0       	push   $0xc002ff2c
c00251f3:	68 b5 00 00 00       	push   $0xb5
c00251f8:	68 8a fe 02 c0       	push   $0xc002fe8a
c00251fd:	e8 19 4a 00 00       	call   c0029c1b <debug_panic>

  /* Enable transmit interrupt if we have any characters to
     transmit. */
  if (!intq_empty (&txq))
c0025202:	83 ec 0c             	sub    $0xc,%esp
c0025205:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002520a:	e8 ae 19 00 00       	call   c0026bbd <intq_empty>
c002520f:	83 c4 10             	add    $0x10,%esp
c0025212:	83 f0 01             	xor    $0x1,%eax
c0025215:	84 c0                	test   %al,%al
c0025217:	74 04                	je     c002521d <write_ier+0x4f>
    ier |= IER_XMIT;
c0025219:	80 4d f7 02          	orb    $0x2,-0x9(%ebp)

  /* Enable receive interrupt if we have room to store any
     characters we receive. */
  if (!input_full ())
c002521d:	e8 18 19 00 00       	call   c0026b3a <input_full>
c0025222:	83 f0 01             	xor    $0x1,%eax
c0025225:	84 c0                	test   %al,%al
c0025227:	74 04                	je     c002522d <write_ier+0x5f>
    ier |= IER_RECV;
c0025229:	80 4d f7 01          	orb    $0x1,-0x9(%ebp)
  
  outb (IER_REG, ier);
c002522d:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c0025231:	83 ec 08             	sub    $0x8,%esp
c0025234:	50                   	push   %eax
c0025235:	68 f9 03 00 00       	push   $0x3f9
c002523a:	e8 81 fc ff ff       	call   c0024ec0 <outb>
c002523f:	83 c4 10             	add    $0x10,%esp
}
c0025242:	90                   	nop
c0025243:	c9                   	leave  
c0025244:	c3                   	ret    

c0025245 <putc_poll>:

/* Polls the serial port until it's ready,
   and then transmits BYTE. */
static void
putc_poll (uint8_t byte) 
{
c0025245:	55                   	push   %ebp
c0025246:	89 e5                	mov    %esp,%ebp
c0025248:	83 ec 18             	sub    $0x18,%esp
c002524b:	8b 45 08             	mov    0x8(%ebp),%eax
c002524e:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0025251:	e8 3c c2 ff ff       	call   c0021492 <intr_get_level>
c0025256:	85 c0                	test   %eax,%eax
c0025258:	74 22                	je     c002527c <putc_poll+0x37>
c002525a:	83 ec 0c             	sub    $0xc,%esp
c002525d:	68 b5 fe 02 c0       	push   $0xc002feb5
c0025262:	68 73 fe 02 c0       	push   $0xc002fe73
c0025267:	68 38 ff 02 c0       	push   $0xc002ff38
c002526c:	68 c9 00 00 00       	push   $0xc9
c0025271:	68 8a fe 02 c0       	push   $0xc002fe8a
c0025276:	e8 a0 49 00 00       	call   c0029c1b <debug_panic>

  while ((inb (LSR_REG) & LSR_THRE) == 0)
    continue;
c002527b:	90                   	nop
static void
putc_poll (uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);

  while ((inb (LSR_REG) & LSR_THRE) == 0)
c002527c:	83 ec 0c             	sub    $0xc,%esp
c002527f:	68 fd 03 00 00       	push   $0x3fd
c0025284:	e8 1a fc ff ff       	call   c0024ea3 <inb>
c0025289:	83 c4 10             	add    $0x10,%esp
c002528c:	0f b6 c0             	movzbl %al,%eax
c002528f:	83 e0 20             	and    $0x20,%eax
c0025292:	85 c0                	test   %eax,%eax
c0025294:	74 e5                	je     c002527b <putc_poll+0x36>
    continue;
  outb (THR_REG, byte);
c0025296:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002529a:	83 ec 08             	sub    $0x8,%esp
c002529d:	50                   	push   %eax
c002529e:	68 f8 03 00 00       	push   $0x3f8
c00252a3:	e8 18 fc ff ff       	call   c0024ec0 <outb>
c00252a8:	83 c4 10             	add    $0x10,%esp
}
c00252ab:	90                   	nop
c00252ac:	c9                   	leave  
c00252ad:	c3                   	ret    

c00252ae <serial_interrupt>:

/* Serial interrupt handler. */
static void
serial_interrupt (struct intr_frame *f UNUSED) 
{
c00252ae:	55                   	push   %ebp
c00252af:	89 e5                	mov    %esp,%ebp
c00252b1:	83 ec 08             	sub    $0x8,%esp
  /* Inquire about interrupt in UART.  Without this, we can
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);
c00252b4:	68 fa 03 00 00       	push   $0x3fa
c00252b9:	e8 e5 fb ff ff       	call   c0024ea3 <inb>
c00252be:	83 c4 04             	add    $0x4,%esp

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00252c1:	eb 1c                	jmp    c00252df <serial_interrupt+0x31>
    input_putc (inb (RBR_REG));
c00252c3:	68 f8 03 00 00       	push   $0x3f8
c00252c8:	e8 d6 fb ff ff       	call   c0024ea3 <inb>
c00252cd:	83 c4 04             	add    $0x4,%esp
c00252d0:	0f b6 c0             	movzbl %al,%eax
c00252d3:	83 ec 0c             	sub    $0xc,%esp
c00252d6:	50                   	push   %eax
c00252d7:	e8 9f 17 00 00       	call   c0026a7b <input_putc>
c00252dc:	83 c4 10             	add    $0x10,%esp
     occasionally miss an interrupt running under QEMU. */
  inb (IIR_REG);

  /* As long as we have room to receive a byte, and the hardware
     has a byte for us, receive a byte.  */
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
c00252df:	e8 56 18 00 00       	call   c0026b3a <input_full>
c00252e4:	83 f0 01             	xor    $0x1,%eax
c00252e7:	84 c0                	test   %al,%al
c00252e9:	74 40                	je     c002532b <serial_interrupt+0x7d>
c00252eb:	83 ec 0c             	sub    $0xc,%esp
c00252ee:	68 fd 03 00 00       	push   $0x3fd
c00252f3:	e8 ab fb ff ff       	call   c0024ea3 <inb>
c00252f8:	83 c4 10             	add    $0x10,%esp
c00252fb:	0f b6 c0             	movzbl %al,%eax
c00252fe:	83 e0 01             	and    $0x1,%eax
c0025301:	85 c0                	test   %eax,%eax
c0025303:	75 be                	jne    c00252c3 <serial_interrupt+0x15>
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c0025305:	eb 24                	jmp    c002532b <serial_interrupt+0x7d>
    outb (THR_REG, intq_getc (&txq));
c0025307:	83 ec 0c             	sub    $0xc,%esp
c002530a:	68 e0 9a 03 c0       	push   $0xc0039ae0
c002530f:	e8 37 19 00 00       	call   c0026c4b <intq_getc>
c0025314:	83 c4 10             	add    $0x10,%esp
c0025317:	0f b6 c0             	movzbl %al,%eax
c002531a:	83 ec 08             	sub    $0x8,%esp
c002531d:	50                   	push   %eax
c002531e:	68 f8 03 00 00       	push   $0x3f8
c0025323:	e8 98 fb ff ff       	call   c0024ec0 <outb>
c0025328:	83 c4 10             	add    $0x10,%esp
  while (!input_full () && (inb (LSR_REG) & LSR_DR) != 0)
    input_putc (inb (RBR_REG));

  /* As long as we have a byte to transmit, and the hardware is
     ready to accept a byte for transmission, transmit a byte. */
  while (!intq_empty (&txq) && (inb (LSR_REG) & LSR_THRE) != 0) 
c002532b:	83 ec 0c             	sub    $0xc,%esp
c002532e:	68 e0 9a 03 c0       	push   $0xc0039ae0
c0025333:	e8 85 18 00 00       	call   c0026bbd <intq_empty>
c0025338:	83 c4 10             	add    $0x10,%esp
c002533b:	83 f0 01             	xor    $0x1,%eax
c002533e:	84 c0                	test   %al,%al
c0025340:	74 1a                	je     c002535c <serial_interrupt+0xae>
c0025342:	83 ec 0c             	sub    $0xc,%esp
c0025345:	68 fd 03 00 00       	push   $0x3fd
c002534a:	e8 54 fb ff ff       	call   c0024ea3 <inb>
c002534f:	83 c4 10             	add    $0x10,%esp
c0025352:	0f b6 c0             	movzbl %al,%eax
c0025355:	83 e0 20             	and    $0x20,%eax
c0025358:	85 c0                	test   %eax,%eax
c002535a:	75 ab                	jne    c0025307 <serial_interrupt+0x59>
    outb (THR_REG, intq_getc (&txq));

  /* Update interrupt enable register based on queue status. */
  write_ier ();
c002535c:	e8 6d fe ff ff       	call   c00251ce <write_ier>
}
c0025361:	90                   	nop
c0025362:	c9                   	leave  
c0025363:	c3                   	ret    

c0025364 <block_type_name>:

/* Returns a human-readable name for the given block device
   TYPE. */
const char *
block_type_name (enum block_type type)
{
c0025364:	55                   	push   %ebp
c0025365:	89 e5                	mov    %esp,%ebp
c0025367:	83 ec 08             	sub    $0x8,%esp
      "swap",
      "raw",
      "foreign",
    };

  ASSERT (type < BLOCK_CNT);
c002536a:	83 7d 08 05          	cmpl   $0x5,0x8(%ebp)
c002536e:	76 1e                	jbe    c002538e <block_type_name+0x2a>
c0025370:	83 ec 0c             	sub    $0xc,%esp
c0025373:	68 44 ff 02 c0       	push   $0xc002ff44
c0025378:	68 55 ff 02 c0       	push   $0xc002ff55
c002537d:	68 5c 00 03 c0       	push   $0xc003005c
c0025382:	6a 2f                	push   $0x2f
c0025384:	68 6c ff 02 c0       	push   $0xc002ff6c
c0025389:	e8 8d 48 00 00       	call   c0029c1b <debug_panic>
  return block_type_names[type];
c002538e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025391:	8b 04 85 7c 7d 03 c0 	mov    -0x3ffc8284(,%eax,4),%eax
}
c0025398:	c9                   	leave  
c0025399:	c3                   	ret    

c002539a <block_get_role>:

/* Returns the block device fulfilling the given ROLE, or a null
   pointer if no block device has been assigned that role. */
struct block *
block_get_role (enum block_type role)
{
c002539a:	55                   	push   %ebp
c002539b:	89 e5                	mov    %esp,%ebp
c002539d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c00253a0:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00253a4:	76 1e                	jbe    c00253c4 <block_get_role+0x2a>
c00253a6:	83 ec 0c             	sub    $0xc,%esp
c00253a9:	68 82 ff 02 c0       	push   $0xc002ff82
c00253ae:	68 55 ff 02 c0       	push   $0xc002ff55
c00253b3:	68 94 00 03 c0       	push   $0xc0030094
c00253b8:	6a 38                	push   $0x38
c00253ba:	68 6c ff 02 c0       	push   $0xc002ff6c
c00253bf:	e8 57 48 00 00       	call   c0029c1b <debug_panic>
  return block_by_role[role];
c00253c4:	8b 45 08             	mov    0x8(%ebp),%eax
c00253c7:	8b 04 85 50 9b 03 c0 	mov    -0x3ffc64b0(,%eax,4),%eax
}
c00253ce:	c9                   	leave  
c00253cf:	c3                   	ret    

c00253d0 <block_set_role>:

/* Assigns BLOCK the given ROLE. */
void
block_set_role (enum block_type role, struct block *block)
{
c00253d0:	55                   	push   %ebp
c00253d1:	89 e5                	mov    %esp,%ebp
c00253d3:	83 ec 08             	sub    $0x8,%esp
  ASSERT (role < BLOCK_ROLE_CNT);
c00253d6:	83 7d 08 03          	cmpl   $0x3,0x8(%ebp)
c00253da:	76 1e                	jbe    c00253fa <block_set_role+0x2a>
c00253dc:	83 ec 0c             	sub    $0xc,%esp
c00253df:	68 82 ff 02 c0       	push   $0xc002ff82
c00253e4:	68 55 ff 02 c0       	push   $0xc002ff55
c00253e9:	68 a4 00 03 c0       	push   $0xc00300a4
c00253ee:	6a 40                	push   $0x40
c00253f0:	68 6c ff 02 c0       	push   $0xc002ff6c
c00253f5:	e8 21 48 00 00       	call   c0029c1b <debug_panic>
  block_by_role[role] = block;
c00253fa:	8b 45 08             	mov    0x8(%ebp),%eax
c00253fd:	8b 55 0c             	mov    0xc(%ebp),%edx
c0025400:	89 14 85 50 9b 03 c0 	mov    %edx,-0x3ffc64b0(,%eax,4)
}
c0025407:	90                   	nop
c0025408:	c9                   	leave  
c0025409:	c3                   	ret    

c002540a <block_first>:

/* Returns the first block device in kernel probe order, or a
   null pointer if no block devices are registered. */
struct block *
block_first (void)
{
c002540a:	55                   	push   %ebp
c002540b:	89 e5                	mov    %esp,%ebp
c002540d:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_begin (&all_blocks));
c0025410:	83 ec 0c             	sub    $0xc,%esp
c0025413:	68 6c 7d 03 c0       	push   $0xc0037d6c
c0025418:	e8 c6 4a 00 00       	call   c0029ee3 <list_begin>
c002541d:	83 c4 10             	add    $0x10,%esp
c0025420:	83 ec 0c             	sub    $0xc,%esp
c0025423:	50                   	push   %eax
c0025424:	e8 6d 03 00 00       	call   c0025796 <list_elem_to_block>
c0025429:	83 c4 10             	add    $0x10,%esp
}
c002542c:	c9                   	leave  
c002542d:	c3                   	ret    

c002542e <block_next>:

/* Returns the block device following BLOCK in kernel probe
   order, or a null pointer if BLOCK is the last block device. */
struct block *
block_next (struct block *block)
{
c002542e:	55                   	push   %ebp
c002542f:	89 e5                	mov    %esp,%ebp
c0025431:	83 ec 08             	sub    $0x8,%esp
  return list_elem_to_block (list_next (&block->list_elem));
c0025434:	8b 45 08             	mov    0x8(%ebp),%eax
c0025437:	83 ec 0c             	sub    $0xc,%esp
c002543a:	50                   	push   %eax
c002543b:	e8 d5 4a 00 00       	call   c0029f15 <list_next>
c0025440:	83 c4 10             	add    $0x10,%esp
c0025443:	83 ec 0c             	sub    $0xc,%esp
c0025446:	50                   	push   %eax
c0025447:	e8 4a 03 00 00       	call   c0025796 <list_elem_to_block>
c002544c:	83 c4 10             	add    $0x10,%esp
}
c002544f:	c9                   	leave  
c0025450:	c3                   	ret    

c0025451 <block_get_by_name>:

/* Returns the block device with the given NAME, or a null
   pointer if no block device has that name. */
struct block *
block_get_by_name (const char *name)
{
c0025451:	55                   	push   %ebp
c0025452:	89 e5                	mov    %esp,%ebp
c0025454:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c0025457:	83 ec 0c             	sub    $0xc,%esp
c002545a:	68 6c 7d 03 c0       	push   $0xc0037d6c
c002545f:	e8 7f 4a 00 00       	call   c0029ee3 <list_begin>
c0025464:	83 c4 10             	add    $0x10,%esp
c0025467:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002546a:	eb 3b                	jmp    c00254a7 <block_get_by_name+0x56>
       e = list_next (e))
    {
      struct block *block = list_entry (e, struct block, list_elem);
c002546c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002546f:	83 c0 04             	add    $0x4,%eax
c0025472:	83 e8 04             	sub    $0x4,%eax
c0025475:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!strcmp (name, block->name))
c0025478:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002547b:	83 c0 08             	add    $0x8,%eax
c002547e:	83 ec 08             	sub    $0x8,%esp
c0025481:	50                   	push   %eax
c0025482:	ff 75 08             	pushl  0x8(%ebp)
c0025485:	e8 87 37 00 00       	call   c0028c11 <strcmp>
c002548a:	83 c4 10             	add    $0x10,%esp
c002548d:	85 c0                	test   %eax,%eax
c002548f:	75 05                	jne    c0025496 <block_get_by_name+0x45>
        return block;
c0025491:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025494:	eb 2b                	jmp    c00254c1 <block_get_by_name+0x70>
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
       e = list_next (e))
c0025496:	83 ec 0c             	sub    $0xc,%esp
c0025499:	ff 75 f4             	pushl  -0xc(%ebp)
c002549c:	e8 74 4a 00 00       	call   c0029f15 <list_next>
c00254a1:	83 c4 10             	add    $0x10,%esp
c00254a4:	89 45 f4             	mov    %eax,-0xc(%ebp)
struct block *
block_get_by_name (const char *name)
{
  struct list_elem *e;

  for (e = list_begin (&all_blocks); e != list_end (&all_blocks);
c00254a7:	83 ec 0c             	sub    $0xc,%esp
c00254aa:	68 6c 7d 03 c0       	push   $0xc0037d6c
c00254af:	e8 ab 4a 00 00       	call   c0029f5f <list_end>
c00254b4:	83 c4 10             	add    $0x10,%esp
c00254b7:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c00254ba:	75 b0                	jne    c002546c <block_get_by_name+0x1b>
      struct block *block = list_entry (e, struct block, list_elem);
      if (!strcmp (name, block->name))
        return block;
    }

  return NULL;
c00254bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00254c1:	c9                   	leave  
c00254c2:	c3                   	ret    

c00254c3 <check_sector>:

/* Verifies that SECTOR is a valid offset within BLOCK.
   Panics if not. */
static void
check_sector (struct block *block, block_sector_t sector)
{
c00254c3:	55                   	push   %ebp
c00254c4:	89 e5                	mov    %esp,%ebp
c00254c6:	53                   	push   %ebx
c00254c7:	83 ec 04             	sub    $0x4,%esp
  if (sector >= block->size)
c00254ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00254cd:	8b 40 1c             	mov    0x1c(%eax),%eax
c00254d0:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00254d3:	77 32                	ja     c0025507 <check_sector+0x44>
    {
      /* We do not use ASSERT because we want to panic here
         regardless of whether NDEBUG is defined. */
      PANIC ("Access past end of device %s (sector=%"PRDSNu", "
c00254d5:	8b 45 08             	mov    0x8(%ebp),%eax
c00254d8:	8b 58 1c             	mov    0x1c(%eax),%ebx
c00254db:	83 ec 0c             	sub    $0xc,%esp
c00254de:	ff 75 08             	pushl  0x8(%ebp)
c00254e1:	e8 fd 00 00 00       	call   c00255e3 <block_name>
c00254e6:	83 c4 10             	add    $0x10,%esp
c00254e9:	83 ec 04             	sub    $0x4,%esp
c00254ec:	53                   	push   %ebx
c00254ed:	ff 75 0c             	pushl  0xc(%ebp)
c00254f0:	50                   	push   %eax
c00254f1:	68 98 ff 02 c0       	push   $0xc002ff98
c00254f6:	68 b4 00 03 c0       	push   $0xc00300b4
c00254fb:	6a 70                	push   $0x70
c00254fd:	68 6c ff 02 c0       	push   $0xc002ff6c
c0025502:	e8 14 47 00 00       	call   c0029c1b <debug_panic>
             "size=%"PRDSNu")\n", block_name (block), sector, block->size);
    }
}
c0025507:	90                   	nop
c0025508:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002550b:	c9                   	leave  
c002550c:	c3                   	ret    

c002550d <block_read>:
   have room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_read (struct block *block, block_sector_t sector, void *buffer)
{
c002550d:	55                   	push   %ebp
c002550e:	89 e5                	mov    %esp,%ebp
c0025510:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025513:	83 ec 08             	sub    $0x8,%esp
c0025516:	ff 75 0c             	pushl  0xc(%ebp)
c0025519:	ff 75 08             	pushl  0x8(%ebp)
c002551c:	e8 a2 ff ff ff       	call   c00254c3 <check_sector>
c0025521:	83 c4 10             	add    $0x10,%esp
  block->ops->read (block->aux, sector, buffer);
c0025524:	8b 45 08             	mov    0x8(%ebp),%eax
c0025527:	8b 40 20             	mov    0x20(%eax),%eax
c002552a:	8b 00                	mov    (%eax),%eax
c002552c:	8b 55 08             	mov    0x8(%ebp),%edx
c002552f:	8b 52 24             	mov    0x24(%edx),%edx
c0025532:	83 ec 04             	sub    $0x4,%esp
c0025535:	ff 75 10             	pushl  0x10(%ebp)
c0025538:	ff 75 0c             	pushl  0xc(%ebp)
c002553b:	52                   	push   %edx
c002553c:	ff d0                	call   *%eax
c002553e:	83 c4 10             	add    $0x10,%esp
  block->read_cnt++;
c0025541:	8b 45 08             	mov    0x8(%ebp),%eax
c0025544:	8b 50 2c             	mov    0x2c(%eax),%edx
c0025547:	8b 40 28             	mov    0x28(%eax),%eax
c002554a:	83 c0 01             	add    $0x1,%eax
c002554d:	83 d2 00             	adc    $0x0,%edx
c0025550:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0025553:	89 41 28             	mov    %eax,0x28(%ecx)
c0025556:	89 51 2c             	mov    %edx,0x2c(%ecx)
}
c0025559:	90                   	nop
c002555a:	c9                   	leave  
c002555b:	c3                   	ret    

c002555c <block_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to block devices, so external
   per-block device locking is unneeded. */
void
block_write (struct block *block, block_sector_t sector, const void *buffer)
{
c002555c:	55                   	push   %ebp
c002555d:	89 e5                	mov    %esp,%ebp
c002555f:	83 ec 08             	sub    $0x8,%esp
  check_sector (block, sector);
c0025562:	83 ec 08             	sub    $0x8,%esp
c0025565:	ff 75 0c             	pushl  0xc(%ebp)
c0025568:	ff 75 08             	pushl  0x8(%ebp)
c002556b:	e8 53 ff ff ff       	call   c00254c3 <check_sector>
c0025570:	83 c4 10             	add    $0x10,%esp
  ASSERT (block->type != BLOCK_FOREIGN);
c0025573:	8b 45 08             	mov    0x8(%ebp),%eax
c0025576:	8b 40 18             	mov    0x18(%eax),%eax
c0025579:	83 f8 05             	cmp    $0x5,%eax
c002557c:	75 21                	jne    c002559f <block_write+0x43>
c002557e:	83 ec 0c             	sub    $0xc,%esp
c0025581:	68 cb ff 02 c0       	push   $0xc002ffcb
c0025586:	68 55 ff 02 c0       	push   $0xc002ff55
c002558b:	68 c4 00 03 c0       	push   $0xc00300c4
c0025590:	68 89 00 00 00       	push   $0x89
c0025595:	68 6c ff 02 c0       	push   $0xc002ff6c
c002559a:	e8 7c 46 00 00       	call   c0029c1b <debug_panic>
  block->ops->write (block->aux, sector, buffer);
c002559f:	8b 45 08             	mov    0x8(%ebp),%eax
c00255a2:	8b 40 20             	mov    0x20(%eax),%eax
c00255a5:	8b 40 04             	mov    0x4(%eax),%eax
c00255a8:	8b 55 08             	mov    0x8(%ebp),%edx
c00255ab:	8b 52 24             	mov    0x24(%edx),%edx
c00255ae:	83 ec 04             	sub    $0x4,%esp
c00255b1:	ff 75 10             	pushl  0x10(%ebp)
c00255b4:	ff 75 0c             	pushl  0xc(%ebp)
c00255b7:	52                   	push   %edx
c00255b8:	ff d0                	call   *%eax
c00255ba:	83 c4 10             	add    $0x10,%esp
  block->write_cnt++;
c00255bd:	8b 45 08             	mov    0x8(%ebp),%eax
c00255c0:	8b 50 34             	mov    0x34(%eax),%edx
c00255c3:	8b 40 30             	mov    0x30(%eax),%eax
c00255c6:	83 c0 01             	add    $0x1,%eax
c00255c9:	83 d2 00             	adc    $0x0,%edx
c00255cc:	8b 4d 08             	mov    0x8(%ebp),%ecx
c00255cf:	89 41 30             	mov    %eax,0x30(%ecx)
c00255d2:	89 51 34             	mov    %edx,0x34(%ecx)
}
c00255d5:	90                   	nop
c00255d6:	c9                   	leave  
c00255d7:	c3                   	ret    

c00255d8 <block_size>:

/* Returns the number of sectors in BLOCK. */
block_sector_t
block_size (struct block *block)
{
c00255d8:	55                   	push   %ebp
c00255d9:	89 e5                	mov    %esp,%ebp
  return block->size;
c00255db:	8b 45 08             	mov    0x8(%ebp),%eax
c00255de:	8b 40 1c             	mov    0x1c(%eax),%eax
}
c00255e1:	5d                   	pop    %ebp
c00255e2:	c3                   	ret    

c00255e3 <block_name>:

/* Returns BLOCK's name (e.g. "hda"). */
const char *
block_name (struct block *block)
{
c00255e3:	55                   	push   %ebp
c00255e4:	89 e5                	mov    %esp,%ebp
  return block->name;
c00255e6:	8b 45 08             	mov    0x8(%ebp),%eax
c00255e9:	83 c0 08             	add    $0x8,%eax
}
c00255ec:	5d                   	pop    %ebp
c00255ed:	c3                   	ret    

c00255ee <block_type>:

/* Returns BLOCK's type. */
enum block_type
block_type (struct block *block)
{
c00255ee:	55                   	push   %ebp
c00255ef:	89 e5                	mov    %esp,%ebp
  return block->type;
c00255f1:	8b 45 08             	mov    0x8(%ebp),%eax
c00255f4:	8b 40 18             	mov    0x18(%eax),%eax
}
c00255f7:	5d                   	pop    %ebp
c00255f8:	c3                   	ret    

c00255f9 <block_print_stats>:

/* Prints statistics for each block device used for a Pintos role. */
void
block_print_stats (void)
{
c00255f9:	55                   	push   %ebp
c00255fa:	89 e5                	mov    %esp,%ebp
c00255fc:	56                   	push   %esi
c00255fd:	53                   	push   %ebx
c00255fe:	83 ec 20             	sub    $0x20,%esp
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025601:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025608:	eb 63                	jmp    c002566d <block_print_stats+0x74>
    {
      struct block *block = block_by_role[i];
c002560a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002560d:	8b 04 85 50 9b 03 c0 	mov    -0x3ffc64b0(,%eax,4),%eax
c0025614:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (block != NULL)
c0025617:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002561b:	74 4c                	je     c0025669 <block_print_stats+0x70>
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c002561d:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025620:	8b 50 34             	mov    0x34(%eax),%edx
c0025623:	8b 40 30             	mov    0x30(%eax),%eax
c0025626:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0025629:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c002562c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002562f:	8b 58 28             	mov    0x28(%eax),%ebx
c0025632:	8b 70 2c             	mov    0x2c(%eax),%esi
c0025635:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025638:	8b 40 18             	mov    0x18(%eax),%eax
c002563b:	83 ec 0c             	sub    $0xc,%esp
c002563e:	50                   	push   %eax
c002563f:	e8 20 fd ff ff       	call   c0025364 <block_type_name>
c0025644:	83 c4 10             	add    $0x10,%esp
c0025647:	89 c2                	mov    %eax,%edx
                  block->name, block_type_name (block->type),
c0025649:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002564c:	83 c0 08             	add    $0x8,%eax
  for (i = 0; i < BLOCK_ROLE_CNT; i++)
    {
      struct block *block = block_by_role[i];
      if (block != NULL)
        {
          printf ("%s (%s): %llu reads, %llu writes\n",
c002564f:	83 ec 04             	sub    $0x4,%esp
c0025652:	ff 75 e4             	pushl  -0x1c(%ebp)
c0025655:	ff 75 e0             	pushl  -0x20(%ebp)
c0025658:	56                   	push   %esi
c0025659:	53                   	push   %ebx
c002565a:	52                   	push   %edx
c002565b:	50                   	push   %eax
c002565c:	68 e8 ff 02 c0       	push   $0xc002ffe8
c0025661:	e8 82 21 00 00       	call   c00277e8 <printf>
c0025666:	83 c4 20             	add    $0x20,%esp
void
block_print_stats (void)
{
  int i;

  for (i = 0; i < BLOCK_ROLE_CNT; i++)
c0025669:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002566d:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025671:	7e 97                	jle    c002560a <block_print_stats+0x11>
          printf ("%s (%s): %llu reads, %llu writes\n",
                  block->name, block_type_name (block->type),
                  block->read_cnt, block->write_cnt);
        }
    }
}
c0025673:	90                   	nop
c0025674:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025677:	5b                   	pop    %ebx
c0025678:	5e                   	pop    %esi
c0025679:	5d                   	pop    %ebp
c002567a:	c3                   	ret    

c002567b <block_register>:
   will be passed AUX in each function call. */
struct block *
block_register (const char *name, enum block_type type,
                const char *extra_info, block_sector_t size,
                const struct block_operations *ops, void *aux)
{
c002567b:	55                   	push   %ebp
c002567c:	89 e5                	mov    %esp,%ebp
c002567e:	83 ec 18             	sub    $0x18,%esp
  struct block *block = malloc (sizeof *block);
c0025681:	83 ec 0c             	sub    $0xc,%esp
c0025684:	6a 38                	push   $0x38
c0025686:	e8 d6 e2 ff ff       	call   c0023961 <malloc>
c002568b:	83 c4 10             	add    $0x10,%esp
c002568e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (block == NULL)
c0025691:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0025695:	75 19                	jne    c00256b0 <block_register+0x35>
    PANIC ("Failed to allocate memory for block device descriptor");
c0025697:	68 0c 00 03 c0       	push   $0xc003000c
c002569c:	68 d0 00 03 c0       	push   $0xc00300d0
c00256a1:	68 c1 00 00 00       	push   $0xc1
c00256a6:	68 6c ff 02 c0       	push   $0xc002ff6c
c00256ab:	e8 6b 45 00 00       	call   c0029c1b <debug_panic>

  list_push_back (&all_blocks, &block->list_elem);
c00256b0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256b3:	83 ec 08             	sub    $0x8,%esp
c00256b6:	50                   	push   %eax
c00256b7:	68 6c 7d 03 c0       	push   $0xc0037d6c
c00256bc:	e8 ad 4b 00 00       	call   c002a26e <list_push_back>
c00256c1:	83 c4 10             	add    $0x10,%esp
  strlcpy (block->name, name, sizeof block->name);
c00256c4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256c7:	83 c0 08             	add    $0x8,%eax
c00256ca:	83 ec 04             	sub    $0x4,%esp
c00256cd:	6a 10                	push   $0x10
c00256cf:	ff 75 08             	pushl  0x8(%ebp)
c00256d2:	50                   	push   %eax
c00256d3:	e8 0e 3a 00 00       	call   c00290e6 <strlcpy>
c00256d8:	83 c4 10             	add    $0x10,%esp
  block->type = type;
c00256db:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256de:	8b 55 0c             	mov    0xc(%ebp),%edx
c00256e1:	89 50 18             	mov    %edx,0x18(%eax)
  block->size = size;
c00256e4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256e7:	8b 55 14             	mov    0x14(%ebp),%edx
c00256ea:	89 50 1c             	mov    %edx,0x1c(%eax)
  block->ops = ops;
c00256ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256f0:	8b 55 18             	mov    0x18(%ebp),%edx
c00256f3:	89 50 20             	mov    %edx,0x20(%eax)
  block->aux = aux;
c00256f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00256f9:	8b 55 1c             	mov    0x1c(%ebp),%edx
c00256fc:	89 50 24             	mov    %edx,0x24(%eax)
  block->read_cnt = 0;
c00256ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025702:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
c0025709:	c7 40 2c 00 00 00 00 	movl   $0x0,0x2c(%eax)
  block->write_cnt = 0;
c0025710:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025713:	c7 40 30 00 00 00 00 	movl   $0x0,0x30(%eax)
c002571a:	c7 40 34 00 00 00 00 	movl   $0x0,0x34(%eax)

  printf ("%s: %'"PRDSNu" sectors (", block->name, block->size);
c0025721:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025724:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025727:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002572a:	83 c2 08             	add    $0x8,%edx
c002572d:	83 ec 04             	sub    $0x4,%esp
c0025730:	50                   	push   %eax
c0025731:	52                   	push   %edx
c0025732:	68 42 00 03 c0       	push   $0xc0030042
c0025737:	e8 ac 20 00 00       	call   c00277e8 <printf>
c002573c:	83 c4 10             	add    $0x10,%esp
  print_human_readable_size ((uint64_t) block->size * BLOCK_SECTOR_SIZE);
c002573f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025742:	8b 40 1c             	mov    0x1c(%eax),%eax
c0025745:	ba 00 00 00 00       	mov    $0x0,%edx
c002574a:	0f a4 c2 09          	shld   $0x9,%eax,%edx
c002574e:	c1 e0 09             	shl    $0x9,%eax
c0025751:	83 ec 08             	sub    $0x8,%esp
c0025754:	52                   	push   %edx
c0025755:	50                   	push   %eax
c0025756:	e8 b2 2d 00 00       	call   c002850d <print_human_readable_size>
c002575b:	83 c4 10             	add    $0x10,%esp
  printf (")");
c002575e:	83 ec 0c             	sub    $0xc,%esp
c0025761:	6a 29                	push   $0x29
c0025763:	e8 ee 66 00 00       	call   c002be56 <putchar>
c0025768:	83 c4 10             	add    $0x10,%esp
  if (extra_info != NULL)
c002576b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002576f:	74 13                	je     c0025784 <block_register+0x109>
    printf (", %s", extra_info);
c0025771:	83 ec 08             	sub    $0x8,%esp
c0025774:	ff 75 10             	pushl  0x10(%ebp)
c0025777:	68 54 00 03 c0       	push   $0xc0030054
c002577c:	e8 67 20 00 00       	call   c00277e8 <printf>
c0025781:	83 c4 10             	add    $0x10,%esp
  printf ("\n");
c0025784:	83 ec 0c             	sub    $0xc,%esp
c0025787:	6a 0a                	push   $0xa
c0025789:	e8 c8 66 00 00       	call   c002be56 <putchar>
c002578e:	83 c4 10             	add    $0x10,%esp

  return block;
c0025791:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0025794:	c9                   	leave  
c0025795:	c3                   	ret    

c0025796 <list_elem_to_block>:

/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
c0025796:	55                   	push   %ebp
c0025797:	89 e5                	mov    %esp,%ebp
c0025799:	83 ec 08             	sub    $0x8,%esp
  return (list_elem != list_end (&all_blocks)
c002579c:	83 ec 0c             	sub    $0xc,%esp
c002579f:	68 6c 7d 03 c0       	push   $0xc0037d6c
c00257a4:	e8 b6 47 00 00       	call   c0029f5f <list_end>
c00257a9:	83 c4 10             	add    $0x10,%esp
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00257ac:	3b 45 08             	cmp    0x8(%ebp),%eax
c00257af:	74 0b                	je     c00257bc <list_elem_to_block+0x26>
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
          ? list_entry (list_elem, struct block, list_elem)
c00257b1:	8b 45 08             	mov    0x8(%ebp),%eax
c00257b4:	83 c0 04             	add    $0x4,%eax
          : NULL);
c00257b7:	83 e8 04             	sub    $0x4,%eax
/* Returns the block device corresponding to LIST_ELEM, or a null
   pointer if LIST_ELEM is the list end of all_blocks. */
static struct block *
list_elem_to_block (struct list_elem *list_elem)
{
  return (list_elem != list_end (&all_blocks)
c00257ba:	eb 05                	jmp    c00257c1 <list_elem_to_block+0x2b>
          ? list_entry (list_elem, struct block, list_elem)
          : NULL);
c00257bc:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00257c1:	c9                   	leave  
c00257c2:	c3                   	ret    

c00257c3 <partition_scan>:
static const char *partition_type_name (uint8_t);

/* Scans BLOCK for partitions of interest to Pintos. */
void
partition_scan (struct block *block)
{
c00257c3:	55                   	push   %ebp
c00257c4:	89 e5                	mov    %esp,%ebp
c00257c6:	83 ec 18             	sub    $0x18,%esp
  int part_nr = 0;
c00257c9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  read_partition_table (block, 0, 0, &part_nr);
c00257d0:	8d 45 f4             	lea    -0xc(%ebp),%eax
c00257d3:	50                   	push   %eax
c00257d4:	6a 00                	push   $0x0
c00257d6:	6a 00                	push   $0x0
c00257d8:	ff 75 08             	pushl  0x8(%ebp)
c00257db:	e8 2c 00 00 00       	call   c002580c <read_partition_table>
c00257e0:	83 c4 10             	add    $0x10,%esp
  if (part_nr == 0)
c00257e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00257e6:	85 c0                	test   %eax,%eax
c00257e8:	75 1f                	jne    c0025809 <partition_scan+0x46>
    printf ("%s: Device contains no partitions\n", block_name (block));
c00257ea:	83 ec 0c             	sub    $0xc,%esp
c00257ed:	ff 75 08             	pushl  0x8(%ebp)
c00257f0:	e8 ee fd ff ff       	call   c00255e3 <block_name>
c00257f5:	83 c4 10             	add    $0x10,%esp
c00257f8:	83 ec 08             	sub    $0x8,%esp
c00257fb:	50                   	push   %eax
c00257fc:	68 e0 00 03 c0       	push   $0xc00300e0
c0025801:	e8 e2 1f 00 00       	call   c00277e8 <printf>
c0025806:	83 c4 10             	add    $0x10,%esp
}
c0025809:	90                   	nop
c002580a:	c9                   	leave  
c002580b:	c3                   	ret    

c002580c <read_partition_table>:
   partitions are found. */
static void
read_partition_table (struct block *block, block_sector_t sector,
                      block_sector_t primary_extended_sector,
                      int *part_nr)
{
c002580c:	55                   	push   %ebp
c002580d:	89 e5                	mov    %esp,%ebp
c002580f:	53                   	push   %ebx
c0025810:	83 ec 14             	sub    $0x14,%esp

  struct partition_table *pt;
  size_t i;

  /* Check SECTOR validity. */
  if (sector >= block_size (block))
c0025813:	83 ec 0c             	sub    $0xc,%esp
c0025816:	ff 75 08             	pushl  0x8(%ebp)
c0025819:	e8 ba fd ff ff       	call   c00255d8 <block_size>
c002581e:	83 c4 10             	add    $0x10,%esp
c0025821:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0025824:	77 27                	ja     c002584d <read_partition_table+0x41>
    {
      printf ("%s: Partition table at sector %"PRDSNu" past end of device.\n",
c0025826:	83 ec 0c             	sub    $0xc,%esp
c0025829:	ff 75 08             	pushl  0x8(%ebp)
c002582c:	e8 b2 fd ff ff       	call   c00255e3 <block_name>
c0025831:	83 c4 10             	add    $0x10,%esp
c0025834:	83 ec 04             	sub    $0x4,%esp
c0025837:	ff 75 0c             	pushl  0xc(%ebp)
c002583a:	50                   	push   %eax
c002583b:	68 04 01 03 c0       	push   $0xc0030104
c0025840:	e8 a3 1f 00 00       	call   c00277e8 <printf>
c0025845:	83 c4 10             	add    $0x10,%esp
              block_name (block), sector);
      return;
c0025848:	e9 d9 01 00 00       	jmp    c0025a26 <read_partition_table+0x21a>
    }

  /* Read sector. */
  ASSERT (sizeof *pt == BLOCK_SECTOR_SIZE);
  pt = malloc (sizeof *pt);
c002584d:	83 ec 0c             	sub    $0xc,%esp
c0025850:	68 00 02 00 00       	push   $0x200
c0025855:	e8 07 e1 ff ff       	call   c0023961 <malloc>
c002585a:	83 c4 10             	add    $0x10,%esp
c002585d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (pt == NULL)
c0025860:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025864:	75 16                	jne    c002587c <read_partition_table+0x70>
    PANIC ("Failed to allocate memory for partition table.");
c0025866:	68 3c 01 03 c0       	push   $0xc003013c
c002586b:	68 c4 02 03 c0       	push   $0xc00302c4
c0025870:	6a 5a                	push   $0x5a
c0025872:	68 6b 01 03 c0       	push   $0xc003016b
c0025877:	e8 9f 43 00 00       	call   c0029c1b <debug_panic>
  block_read (block, 0, pt);
c002587c:	83 ec 04             	sub    $0x4,%esp
c002587f:	ff 75 f0             	pushl  -0x10(%ebp)
c0025882:	6a 00                	push   $0x0
c0025884:	ff 75 08             	pushl  0x8(%ebp)
c0025887:	e8 81 fc ff ff       	call   c002550d <block_read>
c002588c:	83 c4 10             	add    $0x10,%esp

  /* Check signature. */
  if (pt->signature != 0xaa55)
c002588f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025892:	0f b7 80 fe 01 00 00 	movzwl 0x1fe(%eax),%eax
c0025899:	66 3d 55 aa          	cmp    $0xaa55,%ax
c002589d:	74 5c                	je     c00258fb <read_partition_table+0xef>
    {
      if (primary_extended_sector == 0)
c002589f:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00258a3:	75 21                	jne    c00258c6 <read_partition_table+0xba>
        printf ("%s: Invalid partition table signature\n", block_name (block));
c00258a5:	83 ec 0c             	sub    $0xc,%esp
c00258a8:	ff 75 08             	pushl  0x8(%ebp)
c00258ab:	e8 33 fd ff ff       	call   c00255e3 <block_name>
c00258b0:	83 c4 10             	add    $0x10,%esp
c00258b3:	83 ec 08             	sub    $0x8,%esp
c00258b6:	50                   	push   %eax
c00258b7:	68 88 01 03 c0       	push   $0xc0030188
c00258bc:	e8 27 1f 00 00       	call   c00277e8 <printf>
c00258c1:	83 c4 10             	add    $0x10,%esp
c00258c4:	eb 22                	jmp    c00258e8 <read_partition_table+0xdc>
      else
        printf ("%s: Invalid extended partition table in sector %"PRDSNu"\n",
c00258c6:	83 ec 0c             	sub    $0xc,%esp
c00258c9:	ff 75 08             	pushl  0x8(%ebp)
c00258cc:	e8 12 fd ff ff       	call   c00255e3 <block_name>
c00258d1:	83 c4 10             	add    $0x10,%esp
c00258d4:	83 ec 04             	sub    $0x4,%esp
c00258d7:	ff 75 0c             	pushl  0xc(%ebp)
c00258da:	50                   	push   %eax
c00258db:	68 b0 01 03 c0       	push   $0xc00301b0
c00258e0:	e8 03 1f 00 00       	call   c00277e8 <printf>
c00258e5:	83 c4 10             	add    $0x10,%esp
                block_name (block), sector);
      free (pt);
c00258e8:	83 ec 0c             	sub    $0xc,%esp
c00258eb:	ff 75 f0             	pushl  -0x10(%ebp)
c00258ee:	e8 6f e3 ff ff       	call   c0023c62 <free>
c00258f3:	83 c4 10             	add    $0x10,%esp
      return;
c00258f6:	e9 2b 01 00 00       	jmp    c0025a26 <read_partition_table+0x21a>
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c00258fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025902:	e9 07 01 00 00       	jmp    c0025a0e <read_partition_table+0x202>
    {
      struct partition_table_entry *e = &pt->partitions[i];
c0025907:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002590a:	83 c0 1b             	add    $0x1b,%eax
c002590d:	c1 e0 04             	shl    $0x4,%eax
c0025910:	89 c2                	mov    %eax,%edx
c0025912:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025915:	01 d0                	add    %edx,%eax
c0025917:	83 c0 0e             	add    $0xe,%eax
c002591a:	89 45 ec             	mov    %eax,-0x14(%ebp)

      if (e->size == 0 || e->type == 0)
c002591d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025920:	8b 40 0c             	mov    0xc(%eax),%eax
c0025923:	85 c0                	test   %eax,%eax
c0025925:	0f 84 df 00 00 00    	je     c0025a0a <read_partition_table+0x1fe>
c002592b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002592e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025932:	84 c0                	test   %al,%al
c0025934:	0f 84 d0 00 00 00    	je     c0025a0a <read_partition_table+0x1fe>
        {
          /* Ignore empty partition. */
        }
      else if (e->type == 0x05       /* Extended partition. */
c002593a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002593d:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025941:	3c 05                	cmp    $0x5,%al
c0025943:	74 21                	je     c0025966 <read_partition_table+0x15a>
               || e->type == 0x0f    /* Windows 98 extended partition. */
c0025945:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025948:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c002594c:	3c 0f                	cmp    $0xf,%al
c002594e:	74 16                	je     c0025966 <read_partition_table+0x15a>
               || e->type == 0x85    /* Linux extended partition. */
c0025950:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025953:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025957:	3c 85                	cmp    $0x85,%al
c0025959:	74 0b                	je     c0025966 <read_partition_table+0x15a>
               || e->type == 0xc5)   /* DR-DOS extended partition. */
c002595b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002595e:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c0025962:	3c c5                	cmp    $0xc5,%al
c0025964:	75 65                	jne    c00259cb <read_partition_table+0x1bf>
        {
          printf ("%s: Extended partition in sector %"PRDSNu"\n",
c0025966:	83 ec 0c             	sub    $0xc,%esp
c0025969:	ff 75 08             	pushl  0x8(%ebp)
c002596c:	e8 72 fc ff ff       	call   c00255e3 <block_name>
c0025971:	83 c4 10             	add    $0x10,%esp
c0025974:	83 ec 04             	sub    $0x4,%esp
c0025977:	ff 75 0c             	pushl  0xc(%ebp)
c002597a:	50                   	push   %eax
c002597b:	68 e4 01 03 c0       	push   $0xc00301e4
c0025980:	e8 63 1e 00 00       	call   c00277e8 <printf>
c0025985:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c0025988:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002598c:	75 1e                	jne    c00259ac <read_partition_table+0x1a0>
            read_partition_table (block, e->offset, e->offset, part_nr);
c002598e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025991:	8b 50 08             	mov    0x8(%eax),%edx
c0025994:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025997:	8b 40 08             	mov    0x8(%eax),%eax
c002599a:	ff 75 14             	pushl  0x14(%ebp)
c002599d:	52                   	push   %edx
c002599e:	50                   	push   %eax
c002599f:	ff 75 08             	pushl  0x8(%ebp)
c00259a2:	e8 65 fe ff ff       	call   c002580c <read_partition_table>
c00259a7:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c00259aa:	eb 5e                	jmp    c0025a0a <read_partition_table+0x1fe>
            read_partition_table (block, e->offset, e->offset, part_nr);
          else
            read_partition_table (block, e->offset + primary_extended_sector,
c00259ac:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259af:	8b 50 08             	mov    0x8(%eax),%edx
c00259b2:	8b 45 10             	mov    0x10(%ebp),%eax
c00259b5:	01 d0                	add    %edx,%eax
c00259b7:	ff 75 14             	pushl  0x14(%ebp)
c00259ba:	ff 75 10             	pushl  0x10(%ebp)
c00259bd:	50                   	push   %eax
c00259be:	ff 75 08             	pushl  0x8(%ebp)
c00259c1:	e8 46 fe ff ff       	call   c002580c <read_partition_table>
c00259c6:	83 c4 10             	add    $0x10,%esp
             the device's primary partition table in sector 0, then
             the offset is an absolute sector number.  Otherwise,
             no matter how deep the partition table we're reading
             is nested, the offset is relative to the start of
             the extended partition that the MBR points to. */
          if (sector == 0)
c00259c9:	eb 3f                	jmp    c0025a0a <read_partition_table+0x1fe>
            read_partition_table (block, e->offset + primary_extended_sector,
                                  primary_extended_sector, part_nr);
        }
      else
        {
          ++*part_nr;
c00259cb:	8b 45 14             	mov    0x14(%ebp),%eax
c00259ce:	8b 00                	mov    (%eax),%eax
c00259d0:	8d 50 01             	lea    0x1(%eax),%edx
c00259d3:	8b 45 14             	mov    0x14(%ebp),%eax
c00259d6:	89 10                	mov    %edx,(%eax)

          found_partition (block, e->type, e->offset + sector,
c00259d8:	8b 45 14             	mov    0x14(%ebp),%eax
c00259db:	8b 08                	mov    (%eax),%ecx
c00259dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259e0:	8b 50 0c             	mov    0xc(%eax),%edx
c00259e3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259e6:	8b 58 08             	mov    0x8(%eax),%ebx
c00259e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00259ec:	01 c3                	add    %eax,%ebx
c00259ee:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00259f1:	0f b6 40 04          	movzbl 0x4(%eax),%eax
c00259f5:	0f b6 c0             	movzbl %al,%eax
c00259f8:	83 ec 0c             	sub    $0xc,%esp
c00259fb:	51                   	push   %ecx
c00259fc:	52                   	push   %edx
c00259fd:	53                   	push   %ebx
c00259fe:	50                   	push   %eax
c00259ff:	ff 75 08             	pushl  0x8(%ebp)
c0025a02:	e8 24 00 00 00       	call   c0025a2b <found_partition>
c0025a07:	83 c4 20             	add    $0x20,%esp
      free (pt);
      return;
    }

  /* Parse partitions. */
  for (i = 0; i < sizeof pt->partitions / sizeof *pt->partitions; i++)
c0025a0a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025a0e:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c0025a12:	0f 86 ef fe ff ff    	jbe    c0025907 <read_partition_table+0xfb>
          found_partition (block, e->type, e->offset + sector,
                           e->size, *part_nr);
        }
    }

  free (pt);
c0025a18:	83 ec 0c             	sub    $0xc,%esp
c0025a1b:	ff 75 f0             	pushl  -0x10(%ebp)
c0025a1e:	e8 3f e2 ff ff       	call   c0023c62 <free>
c0025a23:	83 c4 10             	add    $0x10,%esp
}
c0025a26:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0025a29:	c9                   	leave  
c0025a2a:	c3                   	ret    

c0025a2b <found_partition>:
   if so then add it to the proper element of partitions[]. */
static void
found_partition (struct block *block, uint8_t part_type,
                 block_sector_t start, block_sector_t size,
                 int part_nr)
{
c0025a2b:	55                   	push   %ebp
c0025a2c:	89 e5                	mov    %esp,%ebp
c0025a2e:	56                   	push   %esi
c0025a2f:	53                   	push   %ebx
c0025a30:	81 ec b0 00 00 00    	sub    $0xb0,%esp
c0025a36:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025a39:	88 85 54 ff ff ff    	mov    %al,-0xac(%ebp)
  if (start >= block_size (block))
c0025a3f:	83 ec 0c             	sub    $0xc,%esp
c0025a42:	ff 75 08             	pushl  0x8(%ebp)
c0025a45:	e8 8e fb ff ff       	call   c00255d8 <block_size>
c0025a4a:	83 c4 10             	add    $0x10,%esp
c0025a4d:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025a50:	77 27                	ja     c0025a79 <found_partition+0x4e>
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
c0025a52:	83 ec 0c             	sub    $0xc,%esp
c0025a55:	ff 75 08             	pushl  0x8(%ebp)
c0025a58:	e8 86 fb ff ff       	call   c00255e3 <block_name>
c0025a5d:	83 c4 10             	add    $0x10,%esp
c0025a60:	ff 75 10             	pushl  0x10(%ebp)
c0025a63:	ff 75 18             	pushl  0x18(%ebp)
c0025a66:	50                   	push   %eax
c0025a67:	68 0c 02 03 c0       	push   $0xc003020c
c0025a6c:	e8 77 1d 00 00       	call   c00277e8 <printf>
c0025a71:	83 c4 10             	add    $0x10,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025a74:	e9 76 01 00 00       	jmp    c0025bef <found_partition+0x1c4>
                 int part_nr)
{
  if (start >= block_size (block))
    printf ("%s%d: Partition starts past end of device (sector %"PRDSNu")\n",
            block_name (block), part_nr, start);
  else if (start + size < start || start + size > block_size (block))
c0025a79:	8b 55 10             	mov    0x10(%ebp),%edx
c0025a7c:	8b 45 14             	mov    0x14(%ebp),%eax
c0025a7f:	01 d0                	add    %edx,%eax
c0025a81:	3b 45 10             	cmp    0x10(%ebp),%eax
c0025a84:	72 1b                	jb     c0025aa1 <found_partition+0x76>
c0025a86:	8b 55 10             	mov    0x10(%ebp),%edx
c0025a89:	8b 45 14             	mov    0x14(%ebp),%eax
c0025a8c:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025a8f:	83 ec 0c             	sub    $0xc,%esp
c0025a92:	ff 75 08             	pushl  0x8(%ebp)
c0025a95:	e8 3e fb ff ff       	call   c00255d8 <block_size>
c0025a9a:	83 c4 10             	add    $0x10,%esp
c0025a9d:	39 c3                	cmp    %eax,%ebx
c0025a9f:	76 42                	jbe    c0025ae3 <found_partition+0xb8>
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
c0025aa1:	83 ec 0c             	sub    $0xc,%esp
c0025aa4:	ff 75 08             	pushl  0x8(%ebp)
c0025aa7:	e8 2c fb ff ff       	call   c00255d8 <block_size>
c0025aac:	83 c4 10             	add    $0x10,%esp
c0025aaf:	89 c6                	mov    %eax,%esi
c0025ab1:	8b 55 10             	mov    0x10(%ebp),%edx
c0025ab4:	8b 45 14             	mov    0x14(%ebp),%eax
c0025ab7:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
c0025aba:	83 ec 0c             	sub    $0xc,%esp
c0025abd:	ff 75 08             	pushl  0x8(%ebp)
c0025ac0:	e8 1e fb ff ff       	call   c00255e3 <block_name>
c0025ac5:	83 c4 10             	add    $0x10,%esp
c0025ac8:	83 ec 0c             	sub    $0xc,%esp
c0025acb:	56                   	push   %esi
c0025acc:	53                   	push   %ebx
c0025acd:	ff 75 18             	pushl  0x18(%ebp)
c0025ad0:	50                   	push   %eax
c0025ad1:	68 44 02 03 c0       	push   $0xc0030244
c0025ad6:	e8 0d 1d 00 00       	call   c00277e8 <printf>
c0025adb:	83 c4 20             	add    $0x20,%esp
      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
    }
}
c0025ade:	e9 0c 01 00 00       	jmp    c0025bef <found_partition+0x1c4>
  else if (start + size < start || start + size > block_size (block))
    printf ("%s%d: Partition end (%"PRDSNu") past end of device (%"PRDSNu")\n",
            block_name (block), part_nr, start + size, block_size (block));
  else
    {
      enum block_type type = (part_type == 0x20 ? BLOCK_KERNEL
c0025ae3:	80 bd 54 ff ff ff 20 	cmpb   $0x20,-0xac(%ebp)
c0025aea:	74 37                	je     c0025b23 <found_partition+0xf8>
c0025aec:	80 bd 54 ff ff ff 21 	cmpb   $0x21,-0xac(%ebp)
c0025af3:	74 27                	je     c0025b1c <found_partition+0xf1>
c0025af5:	80 bd 54 ff ff ff 22 	cmpb   $0x22,-0xac(%ebp)
c0025afc:	74 17                	je     c0025b15 <found_partition+0xea>
c0025afe:	80 bd 54 ff ff ff 23 	cmpb   $0x23,-0xac(%ebp)
c0025b05:	75 07                	jne    c0025b0e <found_partition+0xe3>
c0025b07:	b8 03 00 00 00       	mov    $0x3,%eax
c0025b0c:	eb 1a                	jmp    c0025b28 <found_partition+0xfd>
c0025b0e:	b8 05 00 00 00       	mov    $0x5,%eax
c0025b13:	eb 13                	jmp    c0025b28 <found_partition+0xfd>
c0025b15:	b8 02 00 00 00       	mov    $0x2,%eax
c0025b1a:	eb 0c                	jmp    c0025b28 <found_partition+0xfd>
c0025b1c:	b8 01 00 00 00       	mov    $0x1,%eax
c0025b21:	eb 05                	jmp    c0025b28 <found_partition+0xfd>
c0025b23:	b8 00 00 00 00       	mov    $0x0,%eax
c0025b28:	89 45 f4             	mov    %eax,-0xc(%ebp)
                              : BLOCK_FOREIGN);
      struct partition *p;
      char extra_info[128];
      char name[16];

      p = malloc (sizeof *p);
c0025b2b:	83 ec 0c             	sub    $0xc,%esp
c0025b2e:	6a 08                	push   $0x8
c0025b30:	e8 2c de ff ff       	call   c0023961 <malloc>
c0025b35:	83 c4 10             	add    $0x10,%esp
c0025b38:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (p == NULL)
c0025b3b:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0025b3f:	75 19                	jne    c0025b5a <found_partition+0x12f>
        PANIC ("Failed to allocate memory for partition descriptor");
c0025b41:	68 78 02 03 c0       	push   $0xc0030278
c0025b46:	68 dc 02 03 c0       	push   $0xc00302dc
c0025b4b:	68 b1 00 00 00       	push   $0xb1
c0025b50:	68 6b 01 03 c0       	push   $0xc003016b
c0025b55:	e8 c1 40 00 00       	call   c0029c1b <debug_panic>
      p->block = block;
c0025b5a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025b5d:	8b 55 08             	mov    0x8(%ebp),%edx
c0025b60:	89 10                	mov    %edx,(%eax)
      p->start = start;
c0025b62:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025b65:	8b 55 10             	mov    0x10(%ebp),%edx
c0025b68:	89 50 04             	mov    %edx,0x4(%eax)

      snprintf (name, sizeof name, "%s%d", block_name (block), part_nr);
c0025b6b:	83 ec 0c             	sub    $0xc,%esp
c0025b6e:	ff 75 08             	pushl  0x8(%ebp)
c0025b71:	e8 6d fa ff ff       	call   c00255e3 <block_name>
c0025b76:	83 c4 10             	add    $0x10,%esp
c0025b79:	83 ec 0c             	sub    $0xc,%esp
c0025b7c:	ff 75 18             	pushl  0x18(%ebp)
c0025b7f:	50                   	push   %eax
c0025b80:	68 ab 02 03 c0       	push   $0xc00302ab
c0025b85:	6a 10                	push   $0x10
c0025b87:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025b8a:	50                   	push   %eax
c0025b8b:	e8 2f 1c 00 00       	call   c00277bf <snprintf>
c0025b90:	83 c4 20             	add    $0x20,%esp
      snprintf (extra_info, sizeof extra_info, "%s (%02x)",
c0025b93:	0f b6 9d 54 ff ff ff 	movzbl -0xac(%ebp),%ebx
c0025b9a:	0f b6 85 54 ff ff ff 	movzbl -0xac(%ebp),%eax
c0025ba1:	83 ec 0c             	sub    $0xc,%esp
c0025ba4:	50                   	push   %eax
c0025ba5:	e8 4d 00 00 00       	call   c0025bf7 <partition_type_name>
c0025baa:	83 c4 10             	add    $0x10,%esp
c0025bad:	83 ec 0c             	sub    $0xc,%esp
c0025bb0:	53                   	push   %ebx
c0025bb1:	50                   	push   %eax
c0025bb2:	68 b0 02 03 c0       	push   $0xc00302b0
c0025bb7:	68 80 00 00 00       	push   $0x80
c0025bbc:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025bc2:	50                   	push   %eax
c0025bc3:	e8 f7 1b 00 00       	call   c00277bf <snprintf>
c0025bc8:	83 c4 20             	add    $0x20,%esp
                partition_type_name (part_type), part_type);
      block_register (name, type, extra_info, size, &partition_operations, p);
c0025bcb:	83 ec 08             	sub    $0x8,%esp
c0025bce:	ff 75 f0             	pushl  -0x10(%ebp)
c0025bd1:	68 a0 7d 03 c0       	push   $0xc0037da0
c0025bd6:	ff 75 14             	pushl  0x14(%ebp)
c0025bd9:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
c0025bdf:	50                   	push   %eax
c0025be0:	ff 75 f4             	pushl  -0xc(%ebp)
c0025be3:	8d 45 e0             	lea    -0x20(%ebp),%eax
c0025be6:	50                   	push   %eax
c0025be7:	e8 8f fa ff ff       	call   c002567b <block_register>
c0025bec:	83 c4 20             	add    $0x20,%esp
    }
}
c0025bef:	90                   	nop
c0025bf0:	8d 65 f8             	lea    -0x8(%ebp),%esp
c0025bf3:	5b                   	pop    %ebx
c0025bf4:	5e                   	pop    %esi
c0025bf5:	5d                   	pop    %ebp
c0025bf6:	c3                   	ret    

c0025bf7 <partition_type_name>:

/* Returns a human-readable name for the given partition TYPE. */
static const char *
partition_type_name (uint8_t type)
{
c0025bf7:	55                   	push   %ebp
c0025bf8:	89 e5                	mov    %esp,%ebp
c0025bfa:	83 ec 04             	sub    $0x4,%esp
c0025bfd:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c00:	88 45 fc             	mov    %al,-0x4(%ebp)
      [0xfd] = "Linux raid autodetect",
      [0xfe] = "LANstep",
      [0xff] = "BBT",
    };

  return type_names[type] != NULL ? type_names[type] : "Unknown";
c0025c03:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025c07:	8b 04 85 c0 7d 03 c0 	mov    -0x3ffc8240(,%eax,4),%eax
c0025c0e:	85 c0                	test   %eax,%eax
c0025c10:	74 0d                	je     c0025c1f <partition_type_name+0x28>
c0025c12:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0025c16:	8b 04 85 c0 7d 03 c0 	mov    -0x3ffc8240(,%eax,4),%eax
c0025c1d:	eb 05                	jmp    c0025c24 <partition_type_name+0x2d>
c0025c1f:	b8 ba 02 03 c0       	mov    $0xc00302ba,%eax
}
c0025c24:	c9                   	leave  
c0025c25:	c3                   	ret    

c0025c26 <partition_read>:

/* Reads sector SECTOR from partition P into BUFFER, which must
   have room for BLOCK_SECTOR_SIZE bytes. */
static void
partition_read (void *p_, block_sector_t sector, void *buffer)
{
c0025c26:	55                   	push   %ebp
c0025c27:	89 e5                	mov    %esp,%ebp
c0025c29:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025c2c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c2f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_read (p->block, p->start + sector, buffer);
c0025c32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c35:	8b 50 04             	mov    0x4(%eax),%edx
c0025c38:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025c3b:	01 c2                	add    %eax,%edx
c0025c3d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c40:	8b 00                	mov    (%eax),%eax
c0025c42:	83 ec 04             	sub    $0x4,%esp
c0025c45:	ff 75 10             	pushl  0x10(%ebp)
c0025c48:	52                   	push   %edx
c0025c49:	50                   	push   %eax
c0025c4a:	e8 be f8 ff ff       	call   c002550d <block_read>
c0025c4f:	83 c4 10             	add    $0x10,%esp
}
c0025c52:	90                   	nop
c0025c53:	c9                   	leave  
c0025c54:	c3                   	ret    

c0025c55 <partition_write>:
/* Write sector SECTOR to partition P from BUFFER, which must
   contain BLOCK_SECTOR_SIZE bytes.  Returns after the block has
   acknowledged receiving the data. */
static void
partition_write (void *p_, block_sector_t sector, const void *buffer)
{
c0025c55:	55                   	push   %ebp
c0025c56:	89 e5                	mov    %esp,%ebp
c0025c58:	83 ec 18             	sub    $0x18,%esp
  struct partition *p = p_;
c0025c5b:	8b 45 08             	mov    0x8(%ebp),%eax
c0025c5e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_write (p->block, p->start + sector, buffer);
c0025c61:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c64:	8b 50 04             	mov    0x4(%eax),%edx
c0025c67:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025c6a:	01 c2                	add    %eax,%edx
c0025c6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025c6f:	8b 00                	mov    (%eax),%eax
c0025c71:	83 ec 04             	sub    $0x4,%esp
c0025c74:	ff 75 10             	pushl  0x10(%ebp)
c0025c77:	52                   	push   %edx
c0025c78:	50                   	push   %eax
c0025c79:	e8 de f8 ff ff       	call   c002555c <block_write>
c0025c7e:	83 c4 10             	add    $0x10,%esp
}
c0025c81:	90                   	nop
c0025c82:	c9                   	leave  
c0025c83:	c3                   	ret    

c0025c84 <isspace>:
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c0025c84:	55                   	push   %ebp
c0025c85:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c0025c87:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c0025c8b:	74 1e                	je     c0025cab <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c0025c8d:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c0025c91:	74 18                	je     c0025cab <isspace+0x27>
c0025c93:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c0025c97:	74 12                	je     c0025cab <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c0025c99:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c0025c9d:	74 0c                	je     c0025cab <isspace+0x27>
c0025c9f:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c0025ca3:	74 06                	je     c0025cab <isspace+0x27>
c0025ca5:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c0025ca9:	75 07                	jne    c0025cb2 <isspace+0x2e>
c0025cab:	b8 01 00 00 00       	mov    $0x1,%eax
c0025cb0:	eb 05                	jmp    c0025cb7 <isspace+0x33>
c0025cb2:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0025cb7:	5d                   	pop    %ebp
c0025cb8:	c3                   	ret    

c0025cb9 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0025cb9:	55                   	push   %ebp
c0025cba:	89 e5                	mov    %esp,%ebp
c0025cbc:	83 ec 14             	sub    $0x14,%esp
c0025cbf:	8b 45 08             	mov    0x8(%ebp),%eax
c0025cc2:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0025cc6:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0025cca:	89 c2                	mov    %eax,%edx
c0025ccc:	ec                   	in     (%dx),%al
c0025ccd:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0025cd0:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0025cd4:	c9                   	leave  
c0025cd5:	c3                   	ret    

c0025cd6 <insw>:

/* Reads CNT 16-bit (halfword) units from PORT, one after
   another, and stores them into the buffer starting at ADDR. */
static inline void
insw (uint16_t port, void *addr, size_t cnt)
{
c0025cd6:	55                   	push   %ebp
c0025cd7:	89 e5                	mov    %esp,%ebp
c0025cd9:	57                   	push   %edi
c0025cda:	53                   	push   %ebx
c0025cdb:	83 ec 04             	sub    $0x4,%esp
c0025cde:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ce1:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2a] "INS". */
  asm volatile ("rep insw" : "+D" (addr), "+c" (cnt) : "d" (port) : "memory");
c0025ce5:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0025ce9:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025cec:	8b 45 10             	mov    0x10(%ebp),%eax
c0025cef:	89 cb                	mov    %ecx,%ebx
c0025cf1:	89 df                	mov    %ebx,%edi
c0025cf3:	89 c1                	mov    %eax,%ecx
c0025cf5:	66 f3 6d             	rep insw (%dx),%es:(%edi)
c0025cf8:	89 c8                	mov    %ecx,%eax
c0025cfa:	89 fb                	mov    %edi,%ebx
c0025cfc:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025cff:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025d02:	90                   	nop
c0025d03:	83 c4 04             	add    $0x4,%esp
c0025d06:	5b                   	pop    %ebx
c0025d07:	5f                   	pop    %edi
c0025d08:	5d                   	pop    %ebp
c0025d09:	c3                   	ret    

c0025d0a <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0025d0a:	55                   	push   %ebp
c0025d0b:	89 e5                	mov    %esp,%ebp
c0025d0d:	83 ec 08             	sub    $0x8,%esp
c0025d10:	8b 55 08             	mov    0x8(%ebp),%edx
c0025d13:	8b 45 0c             	mov    0xc(%ebp),%eax
c0025d16:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0025d1a:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0025d1d:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0025d21:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0025d25:	ee                   	out    %al,(%dx)
}
c0025d26:	90                   	nop
c0025d27:	c9                   	leave  
c0025d28:	c3                   	ret    

c0025d29 <outsw>:

/* Writes to PORT each 16-bit unit (halfword) of data in the
   CNT-halfword buffer starting at ADDR. */
static inline void
outsw (uint16_t port, const void *addr, size_t cnt)
{
c0025d29:	55                   	push   %ebp
c0025d2a:	89 e5                	mov    %esp,%ebp
c0025d2c:	56                   	push   %esi
c0025d2d:	53                   	push   %ebx
c0025d2e:	83 ec 04             	sub    $0x4,%esp
c0025d31:	8b 45 08             	mov    0x8(%ebp),%eax
c0025d34:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
  /* See [IA32-v2b] "OUTS". */
  asm volatile ("rep outsw" : "+S" (addr), "+c" (cnt) : "d" (port));
c0025d38:	0f b7 55 f4          	movzwl -0xc(%ebp),%edx
c0025d3c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0025d3f:	8b 45 10             	mov    0x10(%ebp),%eax
c0025d42:	89 cb                	mov    %ecx,%ebx
c0025d44:	89 de                	mov    %ebx,%esi
c0025d46:	89 c1                	mov    %eax,%ecx
c0025d48:	66 f3 6f             	rep outsw %ds:(%esi),(%dx)
c0025d4b:	89 c8                	mov    %ecx,%eax
c0025d4d:	89 f3                	mov    %esi,%ebx
c0025d4f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
c0025d52:	89 45 10             	mov    %eax,0x10(%ebp)
}
c0025d55:	90                   	nop
c0025d56:	83 c4 04             	add    $0x4,%esp
c0025d59:	5b                   	pop    %ebx
c0025d5a:	5e                   	pop    %esi
c0025d5b:	5d                   	pop    %ebp
c0025d5c:	c3                   	ret    

c0025d5d <ide_init>:
static void interrupt_handler (struct intr_frame *);

/* Initialize the disk subsystem and detect disks. */
void
ide_init (void) 
{
c0025d5d:	55                   	push   %ebp
c0025d5e:	89 e5                	mov    %esp,%ebp
c0025d60:	83 ec 18             	sub    $0x18,%esp
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025d63:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025d6a:	e9 ae 01 00 00       	jmp    c0025f1d <ide_init+0x1c0>
    {
      struct channel *c = &channels[chan_no];
c0025d6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d72:	6b c0 6c             	imul   $0x6c,%eax,%eax
c0025d75:	05 60 9b 03 c0       	add    $0xc0039b60,%eax
c0025d7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
      int dev_no;

      /* Initialize channel. */
      snprintf (c->name, sizeof c->name, "ide%zu", chan_no);
c0025d7d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025d80:	ff 75 f4             	pushl  -0xc(%ebp)
c0025d83:	68 b0 07 03 c0       	push   $0xc00307b0
c0025d88:	6a 08                	push   $0x8
c0025d8a:	50                   	push   %eax
c0025d8b:	e8 2f 1a 00 00       	call   c00277bf <snprintf>
c0025d90:	83 c4 10             	add    $0x10,%esp
      switch (chan_no) 
c0025d93:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025d96:	85 c0                	test   %eax,%eax
c0025d98:	74 07                	je     c0025da1 <ide_init+0x44>
c0025d9a:	83 f8 01             	cmp    $0x1,%eax
c0025d9d:	74 14                	je     c0025db3 <ide_init+0x56>
c0025d9f:	eb 24                	jmp    c0025dc5 <ide_init+0x68>
        {
        case 0:
          c->reg_base = 0x1f0;
c0025da1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025da4:	66 c7 40 08 f0 01    	movw   $0x1f0,0x8(%eax)
          c->irq = 14 + 0x20;
c0025daa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dad:	c6 40 0a 2e          	movb   $0x2e,0xa(%eax)
          break;
c0025db1:	eb 28                	jmp    c0025ddb <ide_init+0x7e>
        case 1:
          c->reg_base = 0x170;
c0025db3:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025db6:	66 c7 40 08 70 01    	movw   $0x170,0x8(%eax)
          c->irq = 15 + 0x20;
c0025dbc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dbf:	c6 40 0a 2f          	movb   $0x2f,0xa(%eax)
          break;
c0025dc3:	eb 16                	jmp    c0025ddb <ide_init+0x7e>
        default:
          NOT_REACHED ();
c0025dc5:	68 b8 07 03 c0       	push   $0xc00307b8
c0025dca:	68 0c 09 03 c0       	push   $0xc003090c
c0025dcf:	6a 7c                	push   $0x7c
c0025dd1:	68 da 07 03 c0       	push   $0xc00307da
c0025dd6:	e8 40 3e 00 00       	call   c0029c1b <debug_panic>
        }
      lock_init (&c->lock);
c0025ddb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025dde:	83 c0 0c             	add    $0xc,%eax
c0025de1:	83 ec 0c             	sub    $0xc,%esp
c0025de4:	50                   	push   %eax
c0025de5:	e8 ac ce ff ff       	call   c0022c96 <lock_init>
c0025dea:	83 c4 10             	add    $0x10,%esp
      c->expecting_interrupt = false;
c0025ded:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025df0:	c6 40 2c 00          	movb   $0x0,0x2c(%eax)
      sema_init (&c->completion_wait, 0);
c0025df4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025df7:	83 c0 30             	add    $0x30,%eax
c0025dfa:	83 ec 08             	sub    $0x8,%esp
c0025dfd:	6a 00                	push   $0x0
c0025dff:	50                   	push   %eax
c0025e00:	e8 8c cb ff ff       	call   c0022991 <sema_init>
c0025e05:	83 c4 10             	add    $0x10,%esp
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025e08:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025e0f:	eb 5a                	jmp    c0025e6b <ide_init+0x10e>
        {
          struct ata_disk *d = &c->devices[dev_no];
c0025e11:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025e14:	89 d0                	mov    %edx,%eax
c0025e16:	c1 e0 02             	shl    $0x2,%eax
c0025e19:	01 d0                	add    %edx,%eax
c0025e1b:	c1 e0 02             	shl    $0x2,%eax
c0025e1e:	8d 50 40             	lea    0x40(%eax),%edx
c0025e21:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025e24:	01 d0                	add    %edx,%eax
c0025e26:	83 c0 04             	add    $0x4,%eax
c0025e29:	89 45 e8             	mov    %eax,-0x18(%ebp)
          snprintf (d->name, sizeof d->name,
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
c0025e2c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0025e2f:	8d 14 00             	lea    (%eax,%eax,1),%edx
c0025e32:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0025e35:	01 d0                	add    %edx,%eax
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        {
          struct ata_disk *d = &c->devices[dev_no];
          snprintf (d->name, sizeof d->name,
c0025e37:	8d 50 61             	lea    0x61(%eax),%edx
c0025e3a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e3d:	52                   	push   %edx
c0025e3e:	68 ee 07 03 c0       	push   $0xc00307ee
c0025e43:	6a 08                	push   $0x8
c0025e45:	50                   	push   %eax
c0025e46:	e8 74 19 00 00       	call   c00277bf <snprintf>
c0025e4b:	83 c4 10             	add    $0x10,%esp
                    "hd%c", 'a' + chan_no * 2 + dev_no); 
          d->channel = c;
c0025e4e:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e51:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025e54:	89 50 08             	mov    %edx,0x8(%eax)
          d->dev_no = dev_no;
c0025e57:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e5a:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025e5d:	89 50 0c             	mov    %edx,0xc(%eax)
          d->is_ata = false;
c0025e60:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0025e63:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      lock_init (&c->lock);
      c->expecting_interrupt = false;
      sema_init (&c->completion_wait, 0);
 
      /* Initialize devices. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025e67:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025e6b:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025e6f:	7e a0                	jle    c0025e11 <ide_init+0xb4>
          d->dev_no = dev_no;
          d->is_ata = false;
        }

      /* Register interrupt handler. */
      intr_register_ext (c->irq, interrupt_handler, c->name);
c0025e71:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0025e74:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025e77:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c0025e7b:	0f b6 c0             	movzbl %al,%eax
c0025e7e:	83 ec 04             	sub    $0x4,%esp
c0025e81:	52                   	push   %edx
c0025e82:	68 cb 69 02 c0       	push   $0xc00269cb
c0025e87:	50                   	push   %eax
c0025e88:	e8 9b b8 ff ff       	call   c0021728 <intr_register_ext>
c0025e8d:	83 c4 10             	add    $0x10,%esp

      /* Reset hardware. */
      reset_channel (c);
c0025e90:	83 ec 0c             	sub    $0xc,%esp
c0025e93:	ff 75 ec             	pushl  -0x14(%ebp)
c0025e96:	e8 8f 00 00 00       	call   c0025f2a <reset_channel>
c0025e9b:	83 c4 10             	add    $0x10,%esp

      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
c0025e9e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025ea1:	83 c0 44             	add    $0x44,%eax
c0025ea4:	83 ec 0c             	sub    $0xc,%esp
c0025ea7:	50                   	push   %eax
c0025ea8:	e8 09 03 00 00       	call   c00261b6 <check_device_type>
c0025ead:	83 c4 10             	add    $0x10,%esp
c0025eb0:	84 c0                	test   %al,%al
c0025eb2:	74 12                	je     c0025ec6 <ide_init+0x169>
        check_device_type (&c->devices[1]);
c0025eb4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025eb7:	83 c0 58             	add    $0x58,%eax
c0025eba:	83 ec 0c             	sub    $0xc,%esp
c0025ebd:	50                   	push   %eax
c0025ebe:	e8 f3 02 00 00       	call   c00261b6 <check_device_type>
c0025ec3:	83 c4 10             	add    $0x10,%esp

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025ec6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0025ecd:	eb 44                	jmp    c0025f13 <ide_init+0x1b6>
        if (c->devices[dev_no].is_ata)
c0025ecf:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0025ed2:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025ed5:	89 d0                	mov    %edx,%eax
c0025ed7:	c1 e0 02             	shl    $0x2,%eax
c0025eda:	01 d0                	add    %edx,%eax
c0025edc:	c1 e0 02             	shl    $0x2,%eax
c0025edf:	01 c8                	add    %ecx,%eax
c0025ee1:	83 c0 54             	add    $0x54,%eax
c0025ee4:	0f b6 00             	movzbl (%eax),%eax
c0025ee7:	84 c0                	test   %al,%al
c0025ee9:	74 24                	je     c0025f0f <ide_init+0x1b2>
          identify_ata_device (&c->devices[dev_no]);
c0025eeb:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0025eee:	89 d0                	mov    %edx,%eax
c0025ef0:	c1 e0 02             	shl    $0x2,%eax
c0025ef3:	01 d0                	add    %edx,%eax
c0025ef5:	c1 e0 02             	shl    $0x2,%eax
c0025ef8:	8d 50 40             	lea    0x40(%eax),%edx
c0025efb:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0025efe:	01 d0                	add    %edx,%eax
c0025f00:	83 c0 04             	add    $0x4,%eax
c0025f03:	83 ec 0c             	sub    $0xc,%esp
c0025f06:	50                   	push   %eax
c0025f07:	e8 a5 03 00 00       	call   c00262b1 <identify_ata_device>
c0025f0c:	83 c4 10             	add    $0x10,%esp
      /* Distinguish ATA hard disks from other devices. */
      if (check_device_type (&c->devices[0]))
        check_device_type (&c->devices[1]);

      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
c0025f0f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0025f13:	83 7d f0 01          	cmpl   $0x1,-0x10(%ebp)
c0025f17:	7e b6                	jle    c0025ecf <ide_init+0x172>
void
ide_init (void) 
{
  size_t chan_no;

  for (chan_no = 0; chan_no < CHANNEL_CNT; chan_no++)
c0025f19:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0025f1d:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0025f21:	0f 86 48 fe ff ff    	jbe    c0025d6f <ide_init+0x12>
      /* Read hard disk identity information. */
      for (dev_no = 0; dev_no < 2; dev_no++)
        if (c->devices[dev_no].is_ata)
          identify_ata_device (&c->devices[dev_no]);
    }
}
c0025f27:	90                   	nop
c0025f28:	c9                   	leave  
c0025f29:	c3                   	ret    

c0025f2a <reset_channel>:

/* Resets an ATA channel and waits for any devices present on it
   to finish the reset. */
static void
reset_channel (struct channel *c) 
{
c0025f2a:	55                   	push   %ebp
c0025f2b:	89 e5                	mov    %esp,%ebp
c0025f2d:	83 ec 18             	sub    $0x18,%esp
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0025f30:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0025f37:	e9 2b 01 00 00       	jmp    c0026067 <reset_channel+0x13d>
    {
      struct ata_disk *d = &c->devices[dev_no];
c0025f3c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0025f3f:	89 d0                	mov    %edx,%eax
c0025f41:	c1 e0 02             	shl    $0x2,%eax
c0025f44:	01 d0                	add    %edx,%eax
c0025f46:	c1 e0 02             	shl    $0x2,%eax
c0025f49:	8d 50 40             	lea    0x40(%eax),%edx
c0025f4c:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f4f:	01 d0                	add    %edx,%eax
c0025f51:	83 c0 04             	add    $0x4,%eax
c0025f54:	89 45 ec             	mov    %eax,-0x14(%ebp)

      select_device (d);
c0025f57:	83 ec 0c             	sub    $0xc,%esp
c0025f5a:	ff 75 ec             	pushl  -0x14(%ebp)
c0025f5d:	e8 cd 09 00 00       	call   c002692f <select_device>
c0025f62:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025f65:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f68:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025f6c:	83 c0 02             	add    $0x2,%eax
c0025f6f:	0f b7 c0             	movzwl %ax,%eax
c0025f72:	83 ec 08             	sub    $0x8,%esp
c0025f75:	6a 55                	push   $0x55
c0025f77:	50                   	push   %eax
c0025f78:	e8 8d fd ff ff       	call   c0025d0a <outb>
c0025f7d:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025f80:	8b 45 08             	mov    0x8(%ebp),%eax
c0025f83:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025f87:	83 c0 03             	add    $0x3,%eax
c0025f8a:	0f b7 c0             	movzwl %ax,%eax
c0025f8d:	83 ec 08             	sub    $0x8,%esp
c0025f90:	68 aa 00 00 00       	push   $0xaa
c0025f95:	50                   	push   %eax
c0025f96:	e8 6f fd ff ff       	call   c0025d0a <outb>
c0025f9b:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0xaa);
c0025f9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fa1:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025fa5:	83 c0 02             	add    $0x2,%eax
c0025fa8:	0f b7 c0             	movzwl %ax,%eax
c0025fab:	83 ec 08             	sub    $0x8,%esp
c0025fae:	68 aa 00 00 00       	push   $0xaa
c0025fb3:	50                   	push   %eax
c0025fb4:	e8 51 fd ff ff       	call   c0025d0a <outb>
c0025fb9:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0x55);
c0025fbc:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fbf:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025fc3:	83 c0 03             	add    $0x3,%eax
c0025fc6:	0f b7 c0             	movzwl %ax,%eax
c0025fc9:	83 ec 08             	sub    $0x8,%esp
c0025fcc:	6a 55                	push   $0x55
c0025fce:	50                   	push   %eax
c0025fcf:	e8 36 fd ff ff       	call   c0025d0a <outb>
c0025fd4:	83 c4 10             	add    $0x10,%esp

      outb (reg_nsect (c), 0x55);
c0025fd7:	8b 45 08             	mov    0x8(%ebp),%eax
c0025fda:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025fde:	83 c0 02             	add    $0x2,%eax
c0025fe1:	0f b7 c0             	movzwl %ax,%eax
c0025fe4:	83 ec 08             	sub    $0x8,%esp
c0025fe7:	6a 55                	push   $0x55
c0025fe9:	50                   	push   %eax
c0025fea:	e8 1b fd ff ff       	call   c0025d0a <outb>
c0025fef:	83 c4 10             	add    $0x10,%esp
      outb (reg_lbal (c), 0xaa);
c0025ff2:	8b 45 08             	mov    0x8(%ebp),%eax
c0025ff5:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0025ff9:	83 c0 03             	add    $0x3,%eax
c0025ffc:	0f b7 c0             	movzwl %ax,%eax
c0025fff:	83 ec 08             	sub    $0x8,%esp
c0026002:	68 aa 00 00 00       	push   $0xaa
c0026007:	50                   	push   %eax
c0026008:	e8 fd fc ff ff       	call   c0025d0a <outb>
c002600d:	83 c4 10             	add    $0x10,%esp

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0026010:	8b 45 08             	mov    0x8(%ebp),%eax
c0026013:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026017:	83 c0 02             	add    $0x2,%eax
c002601a:	0f b7 c0             	movzwl %ax,%eax
c002601d:	83 ec 0c             	sub    $0xc,%esp
c0026020:	50                   	push   %eax
c0026021:	e8 93 fc ff ff       	call   c0025cb9 <inb>
c0026026:	83 c4 10             	add    $0x10,%esp
                         && inb (reg_lbal (c)) == 0xaa);
c0026029:	3c 55                	cmp    $0x55,%al
c002602b:	75 24                	jne    c0026051 <reset_channel+0x127>
c002602d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026030:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026034:	83 c0 03             	add    $0x3,%eax
c0026037:	0f b7 c0             	movzwl %ax,%eax
c002603a:	83 ec 0c             	sub    $0xc,%esp
c002603d:	50                   	push   %eax
c002603e:	e8 76 fc ff ff       	call   c0025cb9 <inb>
c0026043:	83 c4 10             	add    $0x10,%esp
c0026046:	3c aa                	cmp    $0xaa,%al
c0026048:	75 07                	jne    c0026051 <reset_channel+0x127>
c002604a:	b8 01 00 00 00       	mov    $0x1,%eax
c002604f:	eb 05                	jmp    c0026056 <reset_channel+0x12c>
c0026051:	b8 00 00 00 00       	mov    $0x0,%eax
c0026056:	83 e0 01             	and    $0x1,%eax
      outb (reg_lbal (c), 0x55);

      outb (reg_nsect (c), 0x55);
      outb (reg_lbal (c), 0xaa);

      present[dev_no] = (inb (reg_nsect (c)) == 0x55
c0026059:	8d 4d ea             	lea    -0x16(%ebp),%ecx
c002605c:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002605f:	01 ca                	add    %ecx,%edx
c0026061:	88 02                	mov    %al,(%edx)
  bool present[2];
  int dev_no;

  /* The ATA reset sequence depends on which devices are present,
     so we start by detecting device presence. */
  for (dev_no = 0; dev_no < 2; dev_no++)
c0026063:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026067:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002606b:	0f 8e cb fe ff ff    	jle    c0025f3c <reset_channel+0x12>
                         && inb (reg_lbal (c)) == 0xaa);
    }

  /* Issue soft reset sequence, which selects device 0 as a side effect.
     Also enable interrupts. */
  outb (reg_ctl (c), 0);
c0026071:	8b 45 08             	mov    0x8(%ebp),%eax
c0026074:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026078:	66 05 06 02          	add    $0x206,%ax
c002607c:	0f b7 c0             	movzwl %ax,%eax
c002607f:	83 ec 08             	sub    $0x8,%esp
c0026082:	6a 00                	push   $0x0
c0026084:	50                   	push   %eax
c0026085:	e8 80 fc ff ff       	call   c0025d0a <outb>
c002608a:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c002608d:	83 ec 08             	sub    $0x8,%esp
c0026090:	6a 00                	push   $0x0
c0026092:	6a 0a                	push   $0xa
c0026094:	e8 81 e2 ff ff       	call   c002431a <timer_usleep>
c0026099:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), CTL_SRST);
c002609c:	8b 45 08             	mov    0x8(%ebp),%eax
c002609f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00260a3:	66 05 06 02          	add    $0x206,%ax
c00260a7:	0f b7 c0             	movzwl %ax,%eax
c00260aa:	83 ec 08             	sub    $0x8,%esp
c00260ad:	6a 04                	push   $0x4
c00260af:	50                   	push   %eax
c00260b0:	e8 55 fc ff ff       	call   c0025d0a <outb>
c00260b5:	83 c4 10             	add    $0x10,%esp
  timer_usleep (10);
c00260b8:	83 ec 08             	sub    $0x8,%esp
c00260bb:	6a 00                	push   $0x0
c00260bd:	6a 0a                	push   $0xa
c00260bf:	e8 56 e2 ff ff       	call   c002431a <timer_usleep>
c00260c4:	83 c4 10             	add    $0x10,%esp
  outb (reg_ctl (c), 0);
c00260c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00260ca:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00260ce:	66 05 06 02          	add    $0x206,%ax
c00260d2:	0f b7 c0             	movzwl %ax,%eax
c00260d5:	83 ec 08             	sub    $0x8,%esp
c00260d8:	6a 00                	push   $0x0
c00260da:	50                   	push   %eax
c00260db:	e8 2a fc ff ff       	call   c0025d0a <outb>
c00260e0:	83 c4 10             	add    $0x10,%esp

  timer_msleep (150);
c00260e3:	83 ec 08             	sub    $0x8,%esp
c00260e6:	6a 00                	push   $0x0
c00260e8:	68 96 00 00 00       	push   $0x96
c00260ed:	e8 fd e1 ff ff       	call   c00242ef <timer_msleep>
c00260f2:	83 c4 10             	add    $0x10,%esp

  /* Wait for device 0 to clear BSY. */
  if (present[0]) 
c00260f5:	0f b6 45 ea          	movzbl -0x16(%ebp),%eax
c00260f9:	84 c0                	test   %al,%al
c00260fb:	74 24                	je     c0026121 <reset_channel+0x1f7>
    {
      select_device (&c->devices[0]);
c00260fd:	8b 45 08             	mov    0x8(%ebp),%eax
c0026100:	83 c0 44             	add    $0x44,%eax
c0026103:	83 ec 0c             	sub    $0xc,%esp
c0026106:	50                   	push   %eax
c0026107:	e8 23 08 00 00       	call   c002692f <select_device>
c002610c:	83 c4 10             	add    $0x10,%esp
      wait_while_busy (&c->devices[0]); 
c002610f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026112:	83 c0 44             	add    $0x44,%eax
c0026115:	83 ec 0c             	sub    $0xc,%esp
c0026118:	50                   	push   %eax
c0026119:	e8 44 07 00 00       	call   c0026862 <wait_while_busy>
c002611e:	83 c4 10             	add    $0x10,%esp
    }

  /* Wait for device 1 to clear BSY. */
  if (present[1])
c0026121:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c0026125:	84 c0                	test   %al,%al
c0026127:	0f 84 86 00 00 00    	je     c00261b3 <reset_channel+0x289>
    {
      int i;

      select_device (&c->devices[1]);
c002612d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026130:	83 c0 58             	add    $0x58,%eax
c0026133:	83 ec 0c             	sub    $0xc,%esp
c0026136:	50                   	push   %eax
c0026137:	e8 f3 07 00 00       	call   c002692f <select_device>
c002613c:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < 3000; i++) 
c002613f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0026146:	eb 4d                	jmp    c0026195 <reset_channel+0x26b>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
c0026148:	8b 45 08             	mov    0x8(%ebp),%eax
c002614b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002614f:	83 c0 02             	add    $0x2,%eax
c0026152:	0f b7 c0             	movzwl %ax,%eax
c0026155:	83 ec 0c             	sub    $0xc,%esp
c0026158:	50                   	push   %eax
c0026159:	e8 5b fb ff ff       	call   c0025cb9 <inb>
c002615e:	83 c4 10             	add    $0x10,%esp
c0026161:	3c 01                	cmp    $0x1,%al
c0026163:	75 1d                	jne    c0026182 <reset_channel+0x258>
c0026165:	8b 45 08             	mov    0x8(%ebp),%eax
c0026168:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002616c:	83 c0 03             	add    $0x3,%eax
c002616f:	0f b7 c0             	movzwl %ax,%eax
c0026172:	83 ec 0c             	sub    $0xc,%esp
c0026175:	50                   	push   %eax
c0026176:	e8 3e fb ff ff       	call   c0025cb9 <inb>
c002617b:	83 c4 10             	add    $0x10,%esp
c002617e:	3c 01                	cmp    $0x1,%al
c0026180:	74 1e                	je     c00261a0 <reset_channel+0x276>
            break;
          timer_msleep (10);
c0026182:	83 ec 08             	sub    $0x8,%esp
c0026185:	6a 00                	push   $0x0
c0026187:	6a 0a                	push   $0xa
c0026189:	e8 61 e1 ff ff       	call   c00242ef <timer_msleep>
c002618e:	83 c4 10             	add    $0x10,%esp
  if (present[1])
    {
      int i;

      select_device (&c->devices[1]);
      for (i = 0; i < 3000; i++) 
c0026191:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0026195:	81 7d f0 b7 0b 00 00 	cmpl   $0xbb7,-0x10(%ebp)
c002619c:	7e aa                	jle    c0026148 <reset_channel+0x21e>
c002619e:	eb 01                	jmp    c00261a1 <reset_channel+0x277>
        {
          if (inb (reg_nsect (c)) == 1 && inb (reg_lbal (c)) == 1)
            break;
c00261a0:	90                   	nop
          timer_msleep (10);
        }
      wait_while_busy (&c->devices[1]);
c00261a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00261a4:	83 c0 58             	add    $0x58,%eax
c00261a7:	83 ec 0c             	sub    $0xc,%esp
c00261aa:	50                   	push   %eax
c00261ab:	e8 b2 06 00 00       	call   c0026862 <wait_while_busy>
c00261b0:	83 c4 10             	add    $0x10,%esp
    }
}
c00261b3:	90                   	nop
c00261b4:	c9                   	leave  
c00261b5:	c3                   	ret    

c00261b6 <check_device_type>:
   if it's possible that a slave (device 1) exists on this
   channel.  If D is device 1 (slave), the return value is not
   meaningful. */
static bool
check_device_type (struct ata_disk *d) 
{
c00261b6:	55                   	push   %ebp
c00261b7:	89 e5                	mov    %esp,%ebp
c00261b9:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c00261bc:	8b 45 08             	mov    0x8(%ebp),%eax
c00261bf:	8b 40 08             	mov    0x8(%eax),%eax
c00261c2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  uint8_t error, lbam, lbah, status;

  select_device (d);
c00261c5:	83 ec 0c             	sub    $0xc,%esp
c00261c8:	ff 75 08             	pushl  0x8(%ebp)
c00261cb:	e8 5f 07 00 00       	call   c002692f <select_device>
c00261d0:	83 c4 10             	add    $0x10,%esp

  error = inb (reg_error (c));
c00261d3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261d6:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261da:	83 c0 01             	add    $0x1,%eax
c00261dd:	0f b7 c0             	movzwl %ax,%eax
c00261e0:	83 ec 0c             	sub    $0xc,%esp
c00261e3:	50                   	push   %eax
c00261e4:	e8 d0 fa ff ff       	call   c0025cb9 <inb>
c00261e9:	83 c4 10             	add    $0x10,%esp
c00261ec:	88 45 f3             	mov    %al,-0xd(%ebp)
  lbam = inb (reg_lbam (c));
c00261ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00261f2:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00261f6:	83 c0 04             	add    $0x4,%eax
c00261f9:	0f b7 c0             	movzwl %ax,%eax
c00261fc:	83 ec 0c             	sub    $0xc,%esp
c00261ff:	50                   	push   %eax
c0026200:	e8 b4 fa ff ff       	call   c0025cb9 <inb>
c0026205:	83 c4 10             	add    $0x10,%esp
c0026208:	88 45 f2             	mov    %al,-0xe(%ebp)
  lbah = inb (reg_lbah (c));
c002620b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002620e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026212:	83 c0 05             	add    $0x5,%eax
c0026215:	0f b7 c0             	movzwl %ax,%eax
c0026218:	83 ec 0c             	sub    $0xc,%esp
c002621b:	50                   	push   %eax
c002621c:	e8 98 fa ff ff       	call   c0025cb9 <inb>
c0026221:	83 c4 10             	add    $0x10,%esp
c0026224:	88 45 f1             	mov    %al,-0xf(%ebp)
  status = inb (reg_status (c));
c0026227:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002622a:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002622e:	83 c0 07             	add    $0x7,%eax
c0026231:	0f b7 c0             	movzwl %ax,%eax
c0026234:	83 ec 0c             	sub    $0xc,%esp
c0026237:	50                   	push   %eax
c0026238:	e8 7c fa ff ff       	call   c0025cb9 <inb>
c002623d:	83 c4 10             	add    $0x10,%esp
c0026240:	88 45 f0             	mov    %al,-0x10(%ebp)

  if ((error != 1 && (error != 0x81 || d->dev_no == 1))
c0026243:	80 7d f3 01          	cmpb   $0x1,-0xd(%ebp)
c0026247:	74 11                	je     c002625a <check_device_type+0xa4>
c0026249:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c002624d:	75 1e                	jne    c002626d <check_device_type+0xb7>
c002624f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026252:	8b 40 0c             	mov    0xc(%eax),%eax
c0026255:	83 f8 01             	cmp    $0x1,%eax
c0026258:	74 13                	je     c002626d <check_device_type+0xb7>
      || (status & STA_DRDY) == 0
c002625a:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c002625e:	83 e0 40             	and    $0x40,%eax
c0026261:	85 c0                	test   %eax,%eax
c0026263:	74 08                	je     c002626d <check_device_type+0xb7>
      || (status & STA_BSY) != 0)
c0026265:	0f b6 45 f0          	movzbl -0x10(%ebp),%eax
c0026269:	84 c0                	test   %al,%al
c002626b:	79 10                	jns    c002627d <check_device_type+0xc7>
    {
      d->is_ata = false;
c002626d:	8b 45 08             	mov    0x8(%ebp),%eax
c0026270:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return error != 0x81;      
c0026274:	80 7d f3 81          	cmpb   $0x81,-0xd(%ebp)
c0026278:	0f 95 c0             	setne  %al
c002627b:	eb 32                	jmp    c00262af <check_device_type+0xf9>
    }
  else 
    {
      d->is_ata = (lbam == 0 && lbah == 0) || (lbam == 0x3c && lbah == 0xc3);
c002627d:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
c0026281:	75 06                	jne    c0026289 <check_device_type+0xd3>
c0026283:	80 7d f1 00          	cmpb   $0x0,-0xf(%ebp)
c0026287:	74 0c                	je     c0026295 <check_device_type+0xdf>
c0026289:	80 7d f2 3c          	cmpb   $0x3c,-0xe(%ebp)
c002628d:	75 0d                	jne    c002629c <check_device_type+0xe6>
c002628f:	80 7d f1 c3          	cmpb   $0xc3,-0xf(%ebp)
c0026293:	75 07                	jne    c002629c <check_device_type+0xe6>
c0026295:	b8 01 00 00 00       	mov    $0x1,%eax
c002629a:	eb 05                	jmp    c00262a1 <check_device_type+0xeb>
c002629c:	b8 00 00 00 00       	mov    $0x0,%eax
c00262a1:	83 e0 01             	and    $0x1,%eax
c00262a4:	8b 55 08             	mov    0x8(%ebp),%edx
c00262a7:	88 42 10             	mov    %al,0x10(%edx)
      return true; 
c00262aa:	b8 01 00 00 00       	mov    $0x1,%eax
    }
}
c00262af:	c9                   	leave  
c00262b0:	c3                   	ret    

c00262b1 <identify_ata_device>:
/* Sends an IDENTIFY DEVICE command to disk D and reads the
   response.  Registers the disk with the block device
   layer. */
static void
identify_ata_device (struct ata_disk *d) 
{
c00262b1:	55                   	push   %ebp
c00262b2:	89 e5                	mov    %esp,%ebp
c00262b4:	81 ec a8 02 00 00    	sub    $0x2a8,%esp
  struct channel *c = d->channel;
c00262ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00262bd:	8b 40 08             	mov    0x8(%eax),%eax
c00262c0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  block_sector_t capacity;
  char *model, *serial;
  char extra_info[128];
  struct block *block;

  ASSERT (d->is_ata);
c00262c3:	8b 45 08             	mov    0x8(%ebp),%eax
c00262c6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
c00262ca:	84 c0                	test   %al,%al
c00262cc:	75 21                	jne    c00262ef <identify_ata_device+0x3e>
c00262ce:	83 ec 0c             	sub    $0xc,%esp
c00262d1:	68 f3 07 03 c0       	push   $0xc00307f3
c00262d6:	68 fd 07 03 c0       	push   $0xc00307fd
c00262db:	68 18 09 03 c0       	push   $0xc0030918
c00262e0:	68 0d 01 00 00       	push   $0x10d
c00262e5:	68 da 07 03 c0       	push   $0xc00307da
c00262ea:	e8 2c 39 00 00       	call   c0029c1b <debug_panic>

  /* Send the IDENTIFY DEVICE command, wait for an interrupt
     indicating the device's response is ready, and read the data
     into our buffer. */
  select_device_wait (d);
c00262ef:	83 ec 0c             	sub    $0xc,%esp
c00262f2:	ff 75 08             	pushl  0x8(%ebp)
c00262f5:	e8 9e 06 00 00       	call   c0026998 <select_device_wait>
c00262fa:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_IDENTIFY_DEVICE);
c00262fd:	83 ec 08             	sub    $0x8,%esp
c0026300:	68 ec 00 00 00       	push   $0xec
c0026305:	ff 75 f4             	pushl  -0xc(%ebp)
c0026308:	e8 4b 04 00 00       	call   c0026758 <issue_pio_command>
c002630d:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026310:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026313:	83 c0 30             	add    $0x30,%eax
c0026316:	83 ec 0c             	sub    $0xc,%esp
c0026319:	50                   	push   %eax
c002631a:	e8 b9 c6 ff ff       	call   c00229d8 <sema_down>
c002631f:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c0026322:	83 ec 0c             	sub    $0xc,%esp
c0026325:	ff 75 08             	pushl  0x8(%ebp)
c0026328:	e8 35 05 00 00       	call   c0026862 <wait_while_busy>
c002632d:	83 c4 10             	add    $0x10,%esp
c0026330:	83 f0 01             	xor    $0x1,%eax
c0026333:	84 c0                	test   %al,%al
c0026335:	74 0c                	je     c0026343 <identify_ata_device+0x92>
    {
      d->is_ata = false;
c0026337:	8b 45 08             	mov    0x8(%ebp),%eax
c002633a:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c002633e:	e9 fb 00 00 00       	jmp    c002643e <identify_ata_device+0x18d>
    }
  input_sector (c, id);
c0026343:	83 ec 08             	sub    $0x8,%esp
c0026346:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002634c:	50                   	push   %eax
c002634d:	ff 75 f4             	pushl  -0xc(%ebp)
c0026350:	e8 62 04 00 00       	call   c00267b7 <input_sector>
c0026355:	83 c4 10             	add    $0x10,%esp

  /* Calculate capacity.
     Read model name and serial number. */
  capacity = *(uint32_t *) &id[60 * 2];
c0026358:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002635e:	83 c0 78             	add    $0x78,%eax
c0026361:	8b 00                	mov    (%eax),%eax
c0026363:	89 45 f0             	mov    %eax,-0x10(%ebp)
  model = descramble_ata_string (&id[10 * 2], 20);
c0026366:	83 ec 08             	sub    $0x8,%esp
c0026369:	6a 14                	push   $0x14
c002636b:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c0026371:	83 c0 14             	add    $0x14,%eax
c0026374:	50                   	push   %eax
c0026375:	e8 c6 00 00 00       	call   c0026440 <descramble_ata_string>
c002637a:	83 c4 10             	add    $0x10,%esp
c002637d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  serial = descramble_ata_string (&id[27 * 2], 40);
c0026380:	83 ec 08             	sub    $0x8,%esp
c0026383:	6a 28                	push   $0x28
c0026385:	8d 85 e4 fd ff ff    	lea    -0x21c(%ebp),%eax
c002638b:	83 c0 36             	add    $0x36,%eax
c002638e:	50                   	push   %eax
c002638f:	e8 ac 00 00 00       	call   c0026440 <descramble_ata_string>
c0026394:	83 c4 10             	add    $0x10,%esp
c0026397:	89 45 e8             	mov    %eax,-0x18(%ebp)
  snprintf (extra_info, sizeof extra_info,
c002639a:	83 ec 0c             	sub    $0xc,%esp
c002639d:	ff 75 e8             	pushl  -0x18(%ebp)
c00263a0:	ff 75 ec             	pushl  -0x14(%ebp)
c00263a3:	68 14 08 03 c0       	push   $0xc0030814
c00263a8:	68 80 00 00 00       	push   $0x80
c00263ad:	8d 85 64 fd ff ff    	lea    -0x29c(%ebp),%eax
c00263b3:	50                   	push   %eax
c00263b4:	e8 06 14 00 00       	call   c00277bf <snprintf>
c00263b9:	83 c4 20             	add    $0x20,%esp
  /* Disable access to IDE disks over 1 GB, which are likely
     physical IDE disks rather than virtual ones.  If we don't
     allow access to those, we're less likely to scribble on
     someone's important data.  You can disable this check by
     hand if you really want to do so. */
  if (capacity >= 1024 * 1024 * 1024 / BLOCK_SECTOR_SIZE)
c00263bc:	81 7d f0 ff ff 1f 00 	cmpl   $0x1fffff,-0x10(%ebp)
c00263c3:	76 45                	jbe    c002640a <identify_ata_device+0x159>
    {
      printf ("%s: ignoring ", d->name);
c00263c5:	8b 45 08             	mov    0x8(%ebp),%eax
c00263c8:	83 ec 08             	sub    $0x8,%esp
c00263cb:	50                   	push   %eax
c00263cc:	68 2c 08 03 c0       	push   $0xc003082c
c00263d1:	e8 12 14 00 00       	call   c00277e8 <printf>
c00263d6:	83 c4 10             	add    $0x10,%esp
      print_human_readable_size (capacity * 512);
c00263d9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00263dc:	c1 e0 09             	shl    $0x9,%eax
c00263df:	ba 00 00 00 00       	mov    $0x0,%edx
c00263e4:	83 ec 08             	sub    $0x8,%esp
c00263e7:	52                   	push   %edx
c00263e8:	50                   	push   %eax
c00263e9:	e8 1f 21 00 00       	call   c002850d <print_human_readable_size>
c00263ee:	83 c4 10             	add    $0x10,%esp
      printf ("disk for safety\n");
c00263f1:	83 ec 0c             	sub    $0xc,%esp
c00263f4:	68 3a 08 03 c0       	push   $0xc003083a
c00263f9:	e8 d0 59 00 00       	call   c002bdce <puts>
c00263fe:	83 c4 10             	add    $0x10,%esp
      d->is_ata = false;
c0026401:	8b 45 08             	mov    0x8(%ebp),%eax
c0026404:	c6 40 10 00          	movb   $0x0,0x10(%eax)
      return;
c0026408:	eb 34                	jmp    c002643e <identify_ata_device+0x18d>
    }

  /* Register. */
  block = block_register (d->name, BLOCK_RAW, extra_info, capacity,
c002640a:	8b 45 08             	mov    0x8(%ebp),%eax
c002640d:	83 ec 08             	sub    $0x8,%esp
c0026410:	ff 75 08             	pushl  0x8(%ebp)
c0026413:	68 c0 81 03 c0       	push   $0xc00381c0
c0026418:	ff 75 f0             	pushl  -0x10(%ebp)
c002641b:	8d 95 64 fd ff ff    	lea    -0x29c(%ebp),%edx
c0026421:	52                   	push   %edx
c0026422:	6a 04                	push   $0x4
c0026424:	50                   	push   %eax
c0026425:	e8 51 f2 ff ff       	call   c002567b <block_register>
c002642a:	83 c4 20             	add    $0x20,%esp
c002642d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
                          &ide_operations, d);
  partition_scan (block);
c0026430:	83 ec 0c             	sub    $0xc,%esp
c0026433:	ff 75 e4             	pushl  -0x1c(%ebp)
c0026436:	e8 88 f3 ff ff       	call   c00257c3 <partition_scan>
c002643b:	83 c4 10             	add    $0x10,%esp
}
c002643e:	c9                   	leave  
c002643f:	c3                   	ret    

c0026440 <descramble_ata_string>:
/* Translates STRING, which consists of SIZE bytes in a funky
   format, into a null-terminated string in-place.  Drops
   trailing whitespace and null bytes.  Returns STRING.  */
static char *
descramble_ata_string (char *string, int size) 
{
c0026440:	55                   	push   %ebp
c0026441:	89 e5                	mov    %esp,%ebp
c0026443:	83 ec 10             	sub    $0x10,%esp
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0026446:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002644d:	eb 3b                	jmp    c002648a <descramble_ata_string+0x4a>
    {
      char tmp = string[i];
c002644f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026452:	8b 45 08             	mov    0x8(%ebp),%eax
c0026455:	01 d0                	add    %edx,%eax
c0026457:	0f b6 00             	movzbl (%eax),%eax
c002645a:	88 45 fb             	mov    %al,-0x5(%ebp)
      string[i] = string[i + 1];
c002645d:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0026460:	8b 45 08             	mov    0x8(%ebp),%eax
c0026463:	01 c2                	add    %eax,%edx
c0026465:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026468:	8d 48 01             	lea    0x1(%eax),%ecx
c002646b:	8b 45 08             	mov    0x8(%ebp),%eax
c002646e:	01 c8                	add    %ecx,%eax
c0026470:	0f b6 00             	movzbl (%eax),%eax
c0026473:	88 02                	mov    %al,(%edx)
      string[i + 1] = tmp;
c0026475:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0026478:	8d 50 01             	lea    0x1(%eax),%edx
c002647b:	8b 45 08             	mov    0x8(%ebp),%eax
c002647e:	01 c2                	add    %eax,%edx
c0026480:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c0026484:	88 02                	mov    %al,(%edx)
descramble_ata_string (char *string, int size) 
{
  int i;

  /* Swap all pairs of bytes. */
  for (i = 0; i + 1 < size; i += 2)
c0026486:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
c002648a:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002648d:	83 c0 01             	add    $0x1,%eax
c0026490:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026493:	7c ba                	jl     c002644f <descramble_ata_string+0xf>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c0026495:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c0026499:	eb 2d                	jmp    c00264c8 <descramble_ata_string+0x88>
    {
      int c = string[size - 1];
c002649b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002649e:	8d 50 ff             	lea    -0x1(%eax),%edx
c00264a1:	8b 45 08             	mov    0x8(%ebp),%eax
c00264a4:	01 d0                	add    %edx,%eax
c00264a6:	0f b6 00             	movzbl (%eax),%eax
c00264a9:	0f be c0             	movsbl %al,%eax
c00264ac:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (c != '\0' && !isspace (c))
c00264af:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c00264b3:	74 0f                	je     c00264c4 <descramble_ata_string+0x84>
c00264b5:	ff 75 f4             	pushl  -0xc(%ebp)
c00264b8:	e8 c7 f7 ff ff       	call   c0025c84 <isspace>
c00264bd:	83 c4 04             	add    $0x4,%esp
c00264c0:	85 c0                	test   %eax,%eax
c00264c2:	74 0c                	je     c00264d0 <descramble_ata_string+0x90>
      string[i] = string[i + 1];
      string[i + 1] = tmp;
    }

  /* Find the last non-white, non-null character. */
  for (size--; size > 0; size--)
c00264c4:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
c00264c8:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00264cc:	7f cd                	jg     c002649b <descramble_ata_string+0x5b>
c00264ce:	eb 01                	jmp    c00264d1 <descramble_ata_string+0x91>
    {
      int c = string[size - 1];
      if (c != '\0' && !isspace (c))
        break; 
c00264d0:	90                   	nop
    }
  string[size] = '\0';
c00264d1:	8b 55 0c             	mov    0xc(%ebp),%edx
c00264d4:	8b 45 08             	mov    0x8(%ebp),%eax
c00264d7:	01 d0                	add    %edx,%eax
c00264d9:	c6 00 00             	movb   $0x0,(%eax)

  return string;
c00264dc:	8b 45 08             	mov    0x8(%ebp),%eax
}
c00264df:	c9                   	leave  
c00264e0:	c3                   	ret    

c00264e1 <ide_read>:
   room for BLOCK_SECTOR_SIZE bytes.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_read (void *d_, block_sector_t sec_no, void *buffer)
{
c00264e1:	55                   	push   %ebp
c00264e2:	89 e5                	mov    %esp,%ebp
c00264e4:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c00264e7:	8b 45 08             	mov    0x8(%ebp),%eax
c00264ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c00264ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00264f0:	8b 40 08             	mov    0x8(%eax),%eax
c00264f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c00264f6:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00264f9:	83 c0 0c             	add    $0xc,%eax
c00264fc:	83 ec 0c             	sub    $0xc,%esp
c00264ff:	50                   	push   %eax
c0026500:	e8 de c7 ff ff       	call   c0022ce3 <lock_acquire>
c0026505:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c0026508:	83 ec 08             	sub    $0x8,%esp
c002650b:	ff 75 0c             	pushl  0xc(%ebp)
c002650e:	ff 75 f4             	pushl  -0xc(%ebp)
c0026511:	e8 3b 01 00 00       	call   c0026651 <select_sector>
c0026516:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_READ_SECTOR_RETRY);
c0026519:	83 ec 08             	sub    $0x8,%esp
c002651c:	6a 20                	push   $0x20
c002651e:	ff 75 f0             	pushl  -0x10(%ebp)
c0026521:	e8 32 02 00 00       	call   c0026758 <issue_pio_command>
c0026526:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c0026529:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002652c:	83 c0 30             	add    $0x30,%eax
c002652f:	83 ec 0c             	sub    $0xc,%esp
c0026532:	50                   	push   %eax
c0026533:	e8 a0 c4 ff ff       	call   c00229d8 <sema_down>
c0026538:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c002653b:	83 ec 0c             	sub    $0xc,%esp
c002653e:	ff 75 f4             	pushl  -0xc(%ebp)
c0026541:	e8 1c 03 00 00       	call   c0026862 <wait_while_busy>
c0026546:	83 c4 10             	add    $0x10,%esp
c0026549:	83 f0 01             	xor    $0x1,%eax
c002654c:	84 c0                	test   %al,%al
c002654e:	74 23                	je     c0026573 <ide_read+0x92>
    PANIC ("%s: disk read failed, sector=%"PRDSNu, d->name, sec_no);
c0026550:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026553:	83 ec 08             	sub    $0x8,%esp
c0026556:	ff 75 0c             	pushl  0xc(%ebp)
c0026559:	50                   	push   %eax
c002655a:	68 4c 08 03 c0       	push   $0xc003084c
c002655f:	68 2c 09 03 c0       	push   $0xc003092c
c0026564:	68 62 01 00 00       	push   $0x162
c0026569:	68 da 07 03 c0       	push   $0xc00307da
c002656e:	e8 a8 36 00 00       	call   c0029c1b <debug_panic>
  input_sector (c, buffer);
c0026573:	83 ec 08             	sub    $0x8,%esp
c0026576:	ff 75 10             	pushl  0x10(%ebp)
c0026579:	ff 75 f0             	pushl  -0x10(%ebp)
c002657c:	e8 36 02 00 00       	call   c00267b7 <input_sector>
c0026581:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c0026584:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026587:	83 c0 0c             	add    $0xc,%eax
c002658a:	83 ec 0c             	sub    $0xc,%esp
c002658d:	50                   	push   %eax
c002658e:	e8 33 c9 ff ff       	call   c0022ec6 <lock_release>
c0026593:	83 c4 10             	add    $0x10,%esp
}
c0026596:	90                   	nop
c0026597:	c9                   	leave  
c0026598:	c3                   	ret    

c0026599 <ide_write>:
   acknowledged receiving the data.
   Internally synchronizes accesses to disks, so external
   per-disk locking is unneeded. */
static void
ide_write (void *d_, block_sector_t sec_no, const void *buffer)
{
c0026599:	55                   	push   %ebp
c002659a:	89 e5                	mov    %esp,%ebp
c002659c:	83 ec 18             	sub    $0x18,%esp
  struct ata_disk *d = d_;
c002659f:	8b 45 08             	mov    0x8(%ebp),%eax
c00265a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct channel *c = d->channel;
c00265a5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265a8:	8b 40 08             	mov    0x8(%eax),%eax
c00265ab:	89 45 f0             	mov    %eax,-0x10(%ebp)
  lock_acquire (&c->lock);
c00265ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00265b1:	83 c0 0c             	add    $0xc,%eax
c00265b4:	83 ec 0c             	sub    $0xc,%esp
c00265b7:	50                   	push   %eax
c00265b8:	e8 26 c7 ff ff       	call   c0022ce3 <lock_acquire>
c00265bd:	83 c4 10             	add    $0x10,%esp
  select_sector (d, sec_no);
c00265c0:	83 ec 08             	sub    $0x8,%esp
c00265c3:	ff 75 0c             	pushl  0xc(%ebp)
c00265c6:	ff 75 f4             	pushl  -0xc(%ebp)
c00265c9:	e8 83 00 00 00       	call   c0026651 <select_sector>
c00265ce:	83 c4 10             	add    $0x10,%esp
  issue_pio_command (c, CMD_WRITE_SECTOR_RETRY);
c00265d1:	83 ec 08             	sub    $0x8,%esp
c00265d4:	6a 30                	push   $0x30
c00265d6:	ff 75 f0             	pushl  -0x10(%ebp)
c00265d9:	e8 7a 01 00 00       	call   c0026758 <issue_pio_command>
c00265de:	83 c4 10             	add    $0x10,%esp
  if (!wait_while_busy (d))
c00265e1:	83 ec 0c             	sub    $0xc,%esp
c00265e4:	ff 75 f4             	pushl  -0xc(%ebp)
c00265e7:	e8 76 02 00 00       	call   c0026862 <wait_while_busy>
c00265ec:	83 c4 10             	add    $0x10,%esp
c00265ef:	83 f0 01             	xor    $0x1,%eax
c00265f2:	84 c0                	test   %al,%al
c00265f4:	74 23                	je     c0026619 <ide_write+0x80>
    PANIC ("%s: disk write failed, sector=%"PRDSNu, d->name, sec_no);
c00265f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00265f9:	83 ec 08             	sub    $0x8,%esp
c00265fc:	ff 75 0c             	pushl  0xc(%ebp)
c00265ff:	50                   	push   %eax
c0026600:	68 6c 08 03 c0       	push   $0xc003086c
c0026605:	68 38 09 03 c0       	push   $0xc0030938
c002660a:	68 75 01 00 00       	push   $0x175
c002660f:	68 da 07 03 c0       	push   $0xc00307da
c0026614:	e8 02 36 00 00       	call   c0029c1b <debug_panic>
  output_sector (c, buffer);
c0026619:	83 ec 08             	sub    $0x8,%esp
c002661c:	ff 75 10             	pushl  0x10(%ebp)
c002661f:	ff 75 f0             	pushl  -0x10(%ebp)
c0026622:	e8 b1 01 00 00       	call   c00267d8 <output_sector>
c0026627:	83 c4 10             	add    $0x10,%esp
  sema_down (&c->completion_wait);
c002662a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002662d:	83 c0 30             	add    $0x30,%eax
c0026630:	83 ec 0c             	sub    $0xc,%esp
c0026633:	50                   	push   %eax
c0026634:	e8 9f c3 ff ff       	call   c00229d8 <sema_down>
c0026639:	83 c4 10             	add    $0x10,%esp
  lock_release (&c->lock);
c002663c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002663f:	83 c0 0c             	add    $0xc,%eax
c0026642:	83 ec 0c             	sub    $0xc,%esp
c0026645:	50                   	push   %eax
c0026646:	e8 7b c8 ff ff       	call   c0022ec6 <lock_release>
c002664b:	83 c4 10             	add    $0x10,%esp
}
c002664e:	90                   	nop
c002664f:	c9                   	leave  
c0026650:	c3                   	ret    

c0026651 <select_sector>:
/* Selects device D, waiting for it to become ready, and then
   writes SEC_NO to the disk's sector selection registers.  (We
   use LBA mode.) */
static void
select_sector (struct ata_disk *d, block_sector_t sec_no)
{
c0026651:	55                   	push   %ebp
c0026652:	89 e5                	mov    %esp,%ebp
c0026654:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026657:	8b 45 08             	mov    0x8(%ebp),%eax
c002665a:	8b 40 08             	mov    0x8(%eax),%eax
c002665d:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sec_no < (1UL << 28));
c0026660:	81 7d 0c ff ff ff 0f 	cmpl   $0xfffffff,0xc(%ebp)
c0026667:	76 21                	jbe    c002668a <select_sector+0x39>
c0026669:	83 ec 0c             	sub    $0xc,%esp
c002666c:	68 8d 08 03 c0       	push   $0xc003088d
c0026671:	68 fd 07 03 c0       	push   $0xc00307fd
c0026676:	68 44 09 03 c0       	push   $0xc0030944
c002667b:	68 89 01 00 00       	push   $0x189
c0026680:	68 da 07 03 c0       	push   $0xc00307da
c0026685:	e8 91 35 00 00       	call   c0029c1b <debug_panic>
  
  select_device_wait (d);
c002668a:	83 ec 0c             	sub    $0xc,%esp
c002668d:	ff 75 08             	pushl  0x8(%ebp)
c0026690:	e8 03 03 00 00       	call   c0026998 <select_device_wait>
c0026695:	83 c4 10             	add    $0x10,%esp
  outb (reg_nsect (c), 1);
c0026698:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002669b:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002669f:	83 c0 02             	add    $0x2,%eax
c00266a2:	0f b7 c0             	movzwl %ax,%eax
c00266a5:	83 ec 08             	sub    $0x8,%esp
c00266a8:	6a 01                	push   $0x1
c00266aa:	50                   	push   %eax
c00266ab:	e8 5a f6 ff ff       	call   c0025d0a <outb>
c00266b0:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbal (c), sec_no);
c00266b3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266b6:	0f b6 d0             	movzbl %al,%edx
c00266b9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00266bc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00266c0:	83 c0 03             	add    $0x3,%eax
c00266c3:	0f b7 c0             	movzwl %ax,%eax
c00266c6:	83 ec 08             	sub    $0x8,%esp
c00266c9:	52                   	push   %edx
c00266ca:	50                   	push   %eax
c00266cb:	e8 3a f6 ff ff       	call   c0025d0a <outb>
c00266d0:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbam (c), sec_no >> 8);
c00266d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266d6:	c1 e8 08             	shr    $0x8,%eax
c00266d9:	0f b6 d0             	movzbl %al,%edx
c00266dc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00266df:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00266e3:	83 c0 04             	add    $0x4,%eax
c00266e6:	0f b7 c0             	movzwl %ax,%eax
c00266e9:	83 ec 08             	sub    $0x8,%esp
c00266ec:	52                   	push   %edx
c00266ed:	50                   	push   %eax
c00266ee:	e8 17 f6 ff ff       	call   c0025d0a <outb>
c00266f3:	83 c4 10             	add    $0x10,%esp
  outb (reg_lbah (c), (sec_no >> 16));
c00266f6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00266f9:	c1 e8 10             	shr    $0x10,%eax
c00266fc:	0f b6 d0             	movzbl %al,%edx
c00266ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026702:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026706:	83 c0 05             	add    $0x5,%eax
c0026709:	0f b7 c0             	movzwl %ax,%eax
c002670c:	83 ec 08             	sub    $0x8,%esp
c002670f:	52                   	push   %edx
c0026710:	50                   	push   %eax
c0026711:	e8 f4 f5 ff ff       	call   c0025d0a <outb>
c0026716:	83 c4 10             	add    $0x10,%esp
  outb (reg_device (c),
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026719:	8b 45 08             	mov    0x8(%ebp),%eax
c002671c:	8b 40 0c             	mov    0xc(%eax),%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c002671f:	83 f8 01             	cmp    $0x1,%eax
c0026722:	75 07                	jne    c002672b <select_sector+0xda>
c0026724:	ba f0 ff ff ff       	mov    $0xfffffff0,%edx
c0026729:	eb 05                	jmp    c0026730 <select_sector+0xdf>
c002672b:	ba e0 ff ff ff       	mov    $0xffffffe0,%edx
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
c0026730:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026733:	c1 e8 18             	shr    $0x18,%eax
  select_device_wait (d);
  outb (reg_nsect (c), 1);
  outb (reg_lbal (c), sec_no);
  outb (reg_lbam (c), sec_no >> 8);
  outb (reg_lbah (c), (sec_no >> 16));
  outb (reg_device (c),
c0026736:	09 d0                	or     %edx,%eax
c0026738:	0f b6 d0             	movzbl %al,%edx
c002673b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002673e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026742:	83 c0 06             	add    $0x6,%eax
c0026745:	0f b7 c0             	movzwl %ax,%eax
c0026748:	83 ec 08             	sub    $0x8,%esp
c002674b:	52                   	push   %edx
c002674c:	50                   	push   %eax
c002674d:	e8 b8 f5 ff ff       	call   c0025d0a <outb>
c0026752:	83 c4 10             	add    $0x10,%esp
        DEV_MBS | DEV_LBA | (d->dev_no == 1 ? DEV_DEV : 0) | (sec_no >> 24));
}
c0026755:	90                   	nop
c0026756:	c9                   	leave  
c0026757:	c3                   	ret    

c0026758 <issue_pio_command>:

/* Writes COMMAND to channel C and prepares for receiving a
   completion interrupt. */
static void
issue_pio_command (struct channel *c, uint8_t command) 
{
c0026758:	55                   	push   %ebp
c0026759:	89 e5                	mov    %esp,%ebp
c002675b:	83 ec 18             	sub    $0x18,%esp
c002675e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026761:	88 45 f4             	mov    %al,-0xc(%ebp)
  /* Interrupts must be enabled or our semaphore will never be
     up'd by the completion handler. */
  ASSERT (intr_get_level () == INTR_ON);
c0026764:	e8 29 ad ff ff       	call   c0021492 <intr_get_level>
c0026769:	83 f8 01             	cmp    $0x1,%eax
c002676c:	74 21                	je     c002678f <issue_pio_command+0x37>
c002676e:	83 ec 0c             	sub    $0xc,%esp
c0026771:	68 a2 08 03 c0       	push   $0xc00308a2
c0026776:	68 fd 07 03 c0       	push   $0xc00307fd
c002677b:	68 54 09 03 c0       	push   $0xc0030954
c0026780:	68 9b 01 00 00       	push   $0x19b
c0026785:	68 da 07 03 c0       	push   $0xc00307da
c002678a:	e8 8c 34 00 00       	call   c0029c1b <debug_panic>

  c->expecting_interrupt = true;
c002678f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026792:	c6 40 2c 01          	movb   $0x1,0x2c(%eax)
  outb (reg_command (c), command);
c0026796:	0f b6 55 f4          	movzbl -0xc(%ebp),%edx
c002679a:	8b 45 08             	mov    0x8(%ebp),%eax
c002679d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00267a1:	83 c0 07             	add    $0x7,%eax
c00267a4:	0f b7 c0             	movzwl %ax,%eax
c00267a7:	83 ec 08             	sub    $0x8,%esp
c00267aa:	52                   	push   %edx
c00267ab:	50                   	push   %eax
c00267ac:	e8 59 f5 ff ff       	call   c0025d0a <outb>
c00267b1:	83 c4 10             	add    $0x10,%esp
}
c00267b4:	90                   	nop
c00267b5:	c9                   	leave  
c00267b6:	c3                   	ret    

c00267b7 <input_sector>:

/* Reads a sector from channel C's data register in PIO mode into
   SECTOR, which must have room for BLOCK_SECTOR_SIZE bytes. */
static void
input_sector (struct channel *c, void *sector) 
{
c00267b7:	55                   	push   %ebp
c00267b8:	89 e5                	mov    %esp,%ebp
  insw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c00267ba:	8b 45 08             	mov    0x8(%ebp),%eax
c00267bd:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00267c1:	0f b7 c0             	movzwl %ax,%eax
c00267c4:	68 00 01 00 00       	push   $0x100
c00267c9:	ff 75 0c             	pushl  0xc(%ebp)
c00267cc:	50                   	push   %eax
c00267cd:	e8 04 f5 ff ff       	call   c0025cd6 <insw>
c00267d2:	83 c4 0c             	add    $0xc,%esp
}
c00267d5:	90                   	nop
c00267d6:	c9                   	leave  
c00267d7:	c3                   	ret    

c00267d8 <output_sector>:

/* Writes SECTOR to channel C's data register in PIO mode.
   SECTOR must contain BLOCK_SECTOR_SIZE bytes. */
static void
output_sector (struct channel *c, const void *sector) 
{
c00267d8:	55                   	push   %ebp
c00267d9:	89 e5                	mov    %esp,%ebp
  outsw (reg_data (c), sector, BLOCK_SECTOR_SIZE / 2);
c00267db:	8b 45 08             	mov    0x8(%ebp),%eax
c00267de:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00267e2:	0f b7 c0             	movzwl %ax,%eax
c00267e5:	68 00 01 00 00       	push   $0x100
c00267ea:	ff 75 0c             	pushl  0xc(%ebp)
c00267ed:	50                   	push   %eax
c00267ee:	e8 36 f5 ff ff       	call   c0025d29 <outsw>
c00267f3:	83 c4 0c             	add    $0xc,%esp
}
c00267f6:	90                   	nop
c00267f7:	c9                   	leave  
c00267f8:	c3                   	ret    

c00267f9 <wait_until_idle>:

   As a side effect, reading the status register clears any
   pending interrupt. */
static void
wait_until_idle (const struct ata_disk *d) 
{
c00267f9:	55                   	push   %ebp
c00267fa:	89 e5                	mov    %esp,%ebp
c00267fc:	83 ec 18             	sub    $0x18,%esp
  int i;

  for (i = 0; i < 1000; i++) 
c00267ff:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026806:	eb 38                	jmp    c0026840 <wait_until_idle+0x47>
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
c0026808:	8b 45 08             	mov    0x8(%ebp),%eax
c002680b:	8b 40 08             	mov    0x8(%eax),%eax
c002680e:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026812:	83 c0 07             	add    $0x7,%eax
c0026815:	0f b7 c0             	movzwl %ax,%eax
c0026818:	50                   	push   %eax
c0026819:	e8 9b f4 ff ff       	call   c0025cb9 <inb>
c002681e:	83 c4 04             	add    $0x4,%esp
c0026821:	0f b6 c0             	movzbl %al,%eax
c0026824:	25 88 00 00 00       	and    $0x88,%eax
c0026829:	85 c0                	test   %eax,%eax
c002682b:	74 32                	je     c002685f <wait_until_idle+0x66>
        return;
      timer_usleep (10);
c002682d:	83 ec 08             	sub    $0x8,%esp
c0026830:	6a 00                	push   $0x0
c0026832:	6a 0a                	push   $0xa
c0026834:	e8 e1 da ff ff       	call   c002431a <timer_usleep>
c0026839:	83 c4 10             	add    $0x10,%esp
static void
wait_until_idle (const struct ata_disk *d) 
{
  int i;

  for (i = 0; i < 1000; i++) 
c002683c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0026840:	81 7d f4 e7 03 00 00 	cmpl   $0x3e7,-0xc(%ebp)
c0026847:	7e bf                	jle    c0026808 <wait_until_idle+0xf>
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
c0026849:	8b 45 08             	mov    0x8(%ebp),%eax
c002684c:	83 ec 08             	sub    $0x8,%esp
c002684f:	50                   	push   %eax
c0026850:	68 bf 08 03 c0       	push   $0xc00308bf
c0026855:	e8 8e 0f 00 00       	call   c00277e8 <printf>
c002685a:	83 c4 10             	add    $0x10,%esp
c002685d:	eb 01                	jmp    c0026860 <wait_until_idle+0x67>
  int i;

  for (i = 0; i < 1000; i++) 
    {
      if ((inb (reg_status (d->channel)) & (STA_BSY | STA_DRQ)) == 0)
        return;
c002685f:	90                   	nop
      timer_usleep (10);
    }

  printf ("%s: idle timeout\n", d->name);
}
c0026860:	c9                   	leave  
c0026861:	c3                   	ret    

c0026862 <wait_while_busy>:
   and then return the status of the DRQ bit.
   The ATA standards say that a disk may take as long as that to
   complete its reset. */
static bool
wait_while_busy (const struct ata_disk *d) 
{
c0026862:	55                   	push   %ebp
c0026863:	89 e5                	mov    %esp,%ebp
c0026865:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026868:	8b 45 08             	mov    0x8(%ebp),%eax
c002686b:	8b 40 08             	mov    0x8(%eax),%eax
c002686e:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < 3000; i++)
c0026871:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0026878:	e9 8e 00 00 00       	jmp    c002690b <wait_while_busy+0xa9>
    {
      if (i == 700)
c002687d:	81 7d f4 bc 02 00 00 	cmpl   $0x2bc,-0xc(%ebp)
c0026884:	75 14                	jne    c002689a <wait_while_busy+0x38>
        printf ("%s: busy, waiting...", d->name);
c0026886:	8b 45 08             	mov    0x8(%ebp),%eax
c0026889:	83 ec 08             	sub    $0x8,%esp
c002688c:	50                   	push   %eax
c002688d:	68 d1 08 03 c0       	push   $0xc00308d1
c0026892:	e8 51 0f 00 00       	call   c00277e8 <printf>
c0026897:	83 c4 10             	add    $0x10,%esp
      if (!(inb (reg_alt_status (c)) & STA_BSY)) 
c002689a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002689d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00268a1:	66 05 06 02          	add    $0x206,%ax
c00268a5:	0f b7 c0             	movzwl %ax,%eax
c00268a8:	83 ec 0c             	sub    $0xc,%esp
c00268ab:	50                   	push   %eax
c00268ac:	e8 08 f4 ff ff       	call   c0025cb9 <inb>
c00268b1:	83 c4 10             	add    $0x10,%esp
c00268b4:	84 c0                	test   %al,%al
c00268b6:	78 40                	js     c00268f8 <wait_while_busy+0x96>
        {
          if (i >= 700)
c00268b8:	81 7d f4 bb 02 00 00 	cmpl   $0x2bb,-0xc(%ebp)
c00268bf:	7e 10                	jle    c00268d1 <wait_while_busy+0x6f>
            printf ("ok\n");
c00268c1:	83 ec 0c             	sub    $0xc,%esp
c00268c4:	68 e6 08 03 c0       	push   $0xc00308e6
c00268c9:	e8 00 55 00 00       	call   c002bdce <puts>
c00268ce:	83 c4 10             	add    $0x10,%esp
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
c00268d1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00268d4:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c00268d8:	66 05 06 02          	add    $0x206,%ax
c00268dc:	0f b7 c0             	movzwl %ax,%eax
c00268df:	83 ec 0c             	sub    $0xc,%esp
c00268e2:	50                   	push   %eax
c00268e3:	e8 d1 f3 ff ff       	call   c0025cb9 <inb>
c00268e8:	83 c4 10             	add    $0x10,%esp
c00268eb:	0f b6 c0             	movzbl %al,%eax
c00268ee:	83 e0 08             	and    $0x8,%eax
c00268f1:	85 c0                	test   %eax,%eax
c00268f3:	0f 95 c0             	setne  %al
c00268f6:	eb 35                	jmp    c002692d <wait_while_busy+0xcb>
        }
      timer_msleep (10);
c00268f8:	83 ec 08             	sub    $0x8,%esp
c00268fb:	6a 00                	push   $0x0
c00268fd:	6a 0a                	push   $0xa
c00268ff:	e8 eb d9 ff ff       	call   c00242ef <timer_msleep>
c0026904:	83 c4 10             	add    $0x10,%esp
wait_while_busy (const struct ata_disk *d) 
{
  struct channel *c = d->channel;
  int i;
  
  for (i = 0; i < 3000; i++)
c0026907:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002690b:	81 7d f4 b7 0b 00 00 	cmpl   $0xbb7,-0xc(%ebp)
c0026912:	0f 8e 65 ff ff ff    	jle    c002687d <wait_while_busy+0x1b>
          return (inb (reg_alt_status (c)) & STA_DRQ) != 0;
        }
      timer_msleep (10);
    }

  printf ("failed\n");
c0026918:	83 ec 0c             	sub    $0xc,%esp
c002691b:	68 e9 08 03 c0       	push   $0xc00308e9
c0026920:	e8 a9 54 00 00       	call   c002bdce <puts>
c0026925:	83 c4 10             	add    $0x10,%esp
  return false;
c0026928:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002692d:	c9                   	leave  
c002692e:	c3                   	ret    

c002692f <select_device>:

/* Program D's channel so that D is now the selected disk. */
static void
select_device (const struct ata_disk *d)
{
c002692f:	55                   	push   %ebp
c0026930:	89 e5                	mov    %esp,%ebp
c0026932:	83 ec 18             	sub    $0x18,%esp
  struct channel *c = d->channel;
c0026935:	8b 45 08             	mov    0x8(%ebp),%eax
c0026938:	8b 40 08             	mov    0x8(%eax),%eax
c002693b:	89 45 f0             	mov    %eax,-0x10(%ebp)
  uint8_t dev = DEV_MBS;
c002693e:	c6 45 f7 a0          	movb   $0xa0,-0x9(%ebp)
  if (d->dev_no == 1)
c0026942:	8b 45 08             	mov    0x8(%ebp),%eax
c0026945:	8b 40 0c             	mov    0xc(%eax),%eax
c0026948:	83 f8 01             	cmp    $0x1,%eax
c002694b:	75 04                	jne    c0026951 <select_device+0x22>
    dev |= DEV_DEV;
c002694d:	80 4d f7 10          	orb    $0x10,-0x9(%ebp)
  outb (reg_device (c), dev);
c0026951:	0f b6 55 f7          	movzbl -0x9(%ebp),%edx
c0026955:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0026958:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c002695c:	83 c0 06             	add    $0x6,%eax
c002695f:	0f b7 c0             	movzwl %ax,%eax
c0026962:	52                   	push   %edx
c0026963:	50                   	push   %eax
c0026964:	e8 a1 f3 ff ff       	call   c0025d0a <outb>
c0026969:	83 c4 08             	add    $0x8,%esp
  inb (reg_alt_status (c));
c002696c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002696f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026973:	66 05 06 02          	add    $0x206,%ax
c0026977:	0f b7 c0             	movzwl %ax,%eax
c002697a:	50                   	push   %eax
c002697b:	e8 39 f3 ff ff       	call   c0025cb9 <inb>
c0026980:	83 c4 04             	add    $0x4,%esp
  timer_nsleep (400);
c0026983:	83 ec 08             	sub    $0x8,%esp
c0026986:	6a 00                	push   $0x0
c0026988:	68 90 01 00 00       	push   $0x190
c002698d:	e8 b3 d9 ff ff       	call   c0024345 <timer_nsleep>
c0026992:	83 c4 10             	add    $0x10,%esp
}
c0026995:	90                   	nop
c0026996:	c9                   	leave  
c0026997:	c3                   	ret    

c0026998 <select_device_wait>:

/* Select disk D in its channel, as select_device(), but wait for
   the channel to become idle before and after. */
static void
select_device_wait (const struct ata_disk *d) 
{
c0026998:	55                   	push   %ebp
c0026999:	89 e5                	mov    %esp,%ebp
c002699b:	83 ec 08             	sub    $0x8,%esp
  wait_until_idle (d);
c002699e:	83 ec 0c             	sub    $0xc,%esp
c00269a1:	ff 75 08             	pushl  0x8(%ebp)
c00269a4:	e8 50 fe ff ff       	call   c00267f9 <wait_until_idle>
c00269a9:	83 c4 10             	add    $0x10,%esp
  select_device (d);
c00269ac:	83 ec 0c             	sub    $0xc,%esp
c00269af:	ff 75 08             	pushl  0x8(%ebp)
c00269b2:	e8 78 ff ff ff       	call   c002692f <select_device>
c00269b7:	83 c4 10             	add    $0x10,%esp
  wait_until_idle (d);
c00269ba:	83 ec 0c             	sub    $0xc,%esp
c00269bd:	ff 75 08             	pushl  0x8(%ebp)
c00269c0:	e8 34 fe ff ff       	call   c00267f9 <wait_until_idle>
c00269c5:	83 c4 10             	add    $0x10,%esp
}
c00269c8:	90                   	nop
c00269c9:	c9                   	leave  
c00269ca:	c3                   	ret    

c00269cb <interrupt_handler>:

/* ATA interrupt handler. */
static void
interrupt_handler (struct intr_frame *f) 
{
c00269cb:	55                   	push   %ebp
c00269cc:	89 e5                	mov    %esp,%ebp
c00269ce:	83 ec 18             	sub    $0x18,%esp
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c00269d1:	c7 45 f4 60 9b 03 c0 	movl   $0xc0039b60,-0xc(%ebp)
c00269d8:	eb 63                	jmp    c0026a3d <interrupt_handler+0x72>
    if (f->vec_no == c->irq)
c00269da:	8b 45 08             	mov    0x8(%ebp),%eax
c00269dd:	8b 50 30             	mov    0x30(%eax),%edx
c00269e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269e3:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
c00269e7:	0f b6 c0             	movzbl %al,%eax
c00269ea:	39 c2                	cmp    %eax,%edx
c00269ec:	75 4b                	jne    c0026a39 <interrupt_handler+0x6e>
      {
        if (c->expecting_interrupt) 
c00269ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269f1:	0f b6 40 2c          	movzbl 0x2c(%eax),%eax
c00269f5:	84 c0                	test   %al,%al
c00269f7:	74 2a                	je     c0026a23 <interrupt_handler+0x58>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
c00269f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00269fc:	0f b7 40 08          	movzwl 0x8(%eax),%eax
c0026a00:	83 c0 07             	add    $0x7,%eax
c0026a03:	0f b7 c0             	movzwl %ax,%eax
c0026a06:	50                   	push   %eax
c0026a07:	e8 ad f2 ff ff       	call   c0025cb9 <inb>
c0026a0c:	83 c4 04             	add    $0x4,%esp
            sema_up (&c->completion_wait);      /* Wake up waiter. */
c0026a0f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a12:	83 c0 30             	add    $0x30,%eax
c0026a15:	83 ec 0c             	sub    $0xc,%esp
c0026a18:	50                   	push   %eax
c0026a19:	e8 c5 c0 ff ff       	call   c0022ae3 <sema_up>
c0026a1e:	83 c4 10             	add    $0x10,%esp
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
c0026a21:	eb 3d                	jmp    c0026a60 <interrupt_handler+0x95>
          {
            inb (reg_status (c));               /* Acknowledge interrupt. */
            sema_up (&c->completion_wait);      /* Wake up waiter. */
          }
        else
          printf ("%s: unexpected interrupt\n", c->name);
c0026a23:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0026a26:	83 ec 08             	sub    $0x8,%esp
c0026a29:	50                   	push   %eax
c0026a2a:	68 f0 08 03 c0       	push   $0xc00308f0
c0026a2f:	e8 b4 0d 00 00       	call   c00277e8 <printf>
c0026a34:	83 c4 10             	add    $0x10,%esp
        return;
c0026a37:	eb 27                	jmp    c0026a60 <interrupt_handler+0x95>
static void
interrupt_handler (struct intr_frame *f) 
{
  struct channel *c;

  for (c = channels; c < channels + CHANNEL_CNT; c++)
c0026a39:	83 45 f4 6c          	addl   $0x6c,-0xc(%ebp)
c0026a3d:	b8 38 9c 03 c0       	mov    $0xc0039c38,%eax
c0026a42:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c0026a45:	72 93                	jb     c00269da <interrupt_handler+0xf>
        else
          printf ("%s: unexpected interrupt\n", c->name);
        return;
      }

  NOT_REACHED ();
c0026a47:	68 b8 07 03 c0       	push   $0xc00307b8
c0026a4c:	68 68 09 03 c0       	push   $0xc0030968
c0026a51:	68 0c 02 00 00       	push   $0x20c
c0026a56:	68 da 07 03 c0       	push   $0xc00307da
c0026a5b:	e8 bb 31 00 00       	call   c0029c1b <debug_panic>
}
c0026a60:	c9                   	leave  
c0026a61:	c3                   	ret    

c0026a62 <input_init>:
static struct intq buffer;

/* Initializes the input buffer. */
void
input_init (void) 
{
c0026a62:	55                   	push   %ebp
c0026a63:	89 e5                	mov    %esp,%ebp
c0026a65:	83 ec 08             	sub    $0x8,%esp
  intq_init (&buffer);
c0026a68:	83 ec 0c             	sub    $0xc,%esp
c0026a6b:	68 40 9c 03 c0       	push   $0xc0039c40
c0026a70:	e8 04 01 00 00       	call   c0026b79 <intq_init>
c0026a75:	83 c4 10             	add    $0x10,%esp
}
c0026a78:	90                   	nop
c0026a79:	c9                   	leave  
c0026a7a:	c3                   	ret    

c0026a7b <input_putc>:

/* Adds a key to the input buffer.
   Interrupts must be off and the buffer must not be full. */
void
input_putc (uint8_t key) 
{
c0026a7b:	55                   	push   %ebp
c0026a7c:	89 e5                	mov    %esp,%ebp
c0026a7e:	83 ec 18             	sub    $0x18,%esp
c0026a81:	8b 45 08             	mov    0x8(%ebp),%eax
c0026a84:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026a87:	e8 06 aa ff ff       	call   c0021492 <intr_get_level>
c0026a8c:	85 c0                	test   %eax,%eax
c0026a8e:	74 1e                	je     c0026aae <input_putc+0x33>
c0026a90:	83 ec 0c             	sub    $0xc,%esp
c0026a93:	68 7c 09 03 c0       	push   $0xc003097c
c0026a98:	68 9a 09 03 c0       	push   $0xc003099a
c0026a9d:	68 dc 09 03 c0       	push   $0xc00309dc
c0026aa2:	6a 15                	push   $0x15
c0026aa4:	68 b1 09 03 c0       	push   $0xc00309b1
c0026aa9:	e8 6d 31 00 00       	call   c0029c1b <debug_panic>
  ASSERT (!intq_full (&buffer));
c0026aae:	83 ec 0c             	sub    $0xc,%esp
c0026ab1:	68 40 9c 03 c0       	push   $0xc0039c40
c0026ab6:	e8 42 01 00 00       	call   c0026bfd <intq_full>
c0026abb:	83 c4 10             	add    $0x10,%esp
c0026abe:	83 f0 01             	xor    $0x1,%eax
c0026ac1:	84 c0                	test   %al,%al
c0026ac3:	75 1e                	jne    c0026ae3 <input_putc+0x68>
c0026ac5:	83 ec 0c             	sub    $0xc,%esp
c0026ac8:	68 c7 09 03 c0       	push   $0xc00309c7
c0026acd:	68 9a 09 03 c0       	push   $0xc003099a
c0026ad2:	68 dc 09 03 c0       	push   $0xc00309dc
c0026ad7:	6a 16                	push   $0x16
c0026ad9:	68 b1 09 03 c0       	push   $0xc00309b1
c0026ade:	e8 38 31 00 00       	call   c0029c1b <debug_panic>

  intq_putc (&buffer, key);
c0026ae3:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c0026ae7:	83 ec 08             	sub    $0x8,%esp
c0026aea:	50                   	push   %eax
c0026aeb:	68 40 9c 03 c0       	push   $0xc0039c40
c0026af0:	e8 38 02 00 00       	call   c0026d2d <intq_putc>
c0026af5:	83 c4 10             	add    $0x10,%esp
  serial_notify ();
c0026af8:	e8 e6 e5 ff ff       	call   c00250e3 <serial_notify>
}
c0026afd:	90                   	nop
c0026afe:	c9                   	leave  
c0026aff:	c3                   	ret    

c0026b00 <input_getc>:

/* Retrieves a key from the input buffer.
   If the buffer is empty, waits for a key to be pressed. */
uint8_t
input_getc (void) 
{
c0026b00:	55                   	push   %ebp
c0026b01:	89 e5                	mov    %esp,%ebp
c0026b03:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level;
  uint8_t key;

  old_level = intr_disable ();
c0026b06:	e8 fc a9 ff ff       	call   c0021507 <intr_disable>
c0026b0b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  key = intq_getc (&buffer);
c0026b0e:	83 ec 0c             	sub    $0xc,%esp
c0026b11:	68 40 9c 03 c0       	push   $0xc0039c40
c0026b16:	e8 30 01 00 00       	call   c0026c4b <intq_getc>
c0026b1b:	83 c4 10             	add    $0x10,%esp
c0026b1e:	88 45 f3             	mov    %al,-0xd(%ebp)
  serial_notify ();
c0026b21:	e8 bd e5 ff ff       	call   c00250e3 <serial_notify>
  intr_set_level (old_level);
c0026b26:	83 ec 0c             	sub    $0xc,%esp
c0026b29:	ff 75 f4             	pushl  -0xc(%ebp)
c0026b2c:	e8 7e a9 ff ff       	call   c00214af <intr_set_level>
c0026b31:	83 c4 10             	add    $0x10,%esp
  
  return key;
c0026b34:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
}
c0026b38:	c9                   	leave  
c0026b39:	c3                   	ret    

c0026b3a <input_full>:
/* Returns true if the input buffer is full,
   false otherwise.
   Interrupts must be off. */
bool
input_full (void) 
{
c0026b3a:	55                   	push   %ebp
c0026b3b:	89 e5                	mov    %esp,%ebp
c0026b3d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026b40:	e8 4d a9 ff ff       	call   c0021492 <intr_get_level>
c0026b45:	85 c0                	test   %eax,%eax
c0026b47:	74 1e                	je     c0026b67 <input_full+0x2d>
c0026b49:	83 ec 0c             	sub    $0xc,%esp
c0026b4c:	68 7c 09 03 c0       	push   $0xc003097c
c0026b51:	68 9a 09 03 c0       	push   $0xc003099a
c0026b56:	68 e8 09 03 c0       	push   $0xc00309e8
c0026b5b:	6a 32                	push   $0x32
c0026b5d:	68 b1 09 03 c0       	push   $0xc00309b1
c0026b62:	e8 b4 30 00 00       	call   c0029c1b <debug_panic>
  return intq_full (&buffer);
c0026b67:	83 ec 0c             	sub    $0xc,%esp
c0026b6a:	68 40 9c 03 c0       	push   $0xc0039c40
c0026b6f:	e8 89 00 00 00       	call   c0026bfd <intq_full>
c0026b74:	83 c4 10             	add    $0x10,%esp
}
c0026b77:	c9                   	leave  
c0026b78:	c3                   	ret    

c0026b79 <intq_init>:
static void signal (struct intq *q, struct thread **waiter);

/* Initializes interrupt queue Q. */
void
intq_init (struct intq *q) 
{
c0026b79:	55                   	push   %ebp
c0026b7a:	89 e5                	mov    %esp,%ebp
c0026b7c:	83 ec 08             	sub    $0x8,%esp
  lock_init (&q->lock);
c0026b7f:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b82:	83 ec 0c             	sub    $0xc,%esp
c0026b85:	50                   	push   %eax
c0026b86:	e8 0b c1 ff ff       	call   c0022c96 <lock_init>
c0026b8b:	83 c4 10             	add    $0x10,%esp
  q->not_full = q->not_empty = NULL;
c0026b8e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b91:	c7 40 24 00 00 00 00 	movl   $0x0,0x24(%eax)
c0026b98:	8b 45 08             	mov    0x8(%ebp),%eax
c0026b9b:	8b 50 24             	mov    0x24(%eax),%edx
c0026b9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ba1:	89 50 20             	mov    %edx,0x20(%eax)
  q->head = q->tail = 0;
c0026ba4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ba7:	c7 40 6c 00 00 00 00 	movl   $0x0,0x6c(%eax)
c0026bae:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bb1:	8b 50 6c             	mov    0x6c(%eax),%edx
c0026bb4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bb7:	89 50 68             	mov    %edx,0x68(%eax)
}
c0026bba:	90                   	nop
c0026bbb:	c9                   	leave  
c0026bbc:	c3                   	ret    

c0026bbd <intq_empty>:

/* Returns true if Q is empty, false otherwise. */
bool
intq_empty (const struct intq *q) 
{
c0026bbd:	55                   	push   %ebp
c0026bbe:	89 e5                	mov    %esp,%ebp
c0026bc0:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026bc3:	e8 ca a8 ff ff       	call   c0021492 <intr_get_level>
c0026bc8:	85 c0                	test   %eax,%eax
c0026bca:	74 1e                	je     c0026bea <intq_empty+0x2d>
c0026bcc:	83 ec 0c             	sub    $0xc,%esp
c0026bcf:	68 f4 09 03 c0       	push   $0xc00309f4
c0026bd4:	68 12 0a 03 c0       	push   $0xc0030a12
c0026bd9:	68 08 0b 03 c0       	push   $0xc0030b08
c0026bde:	6a 16                	push   $0x16
c0026be0:	68 29 0a 03 c0       	push   $0xc0030a29
c0026be5:	e8 31 30 00 00       	call   c0029c1b <debug_panic>
  return q->head == q->tail;
c0026bea:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bed:	8b 50 68             	mov    0x68(%eax),%edx
c0026bf0:	8b 45 08             	mov    0x8(%ebp),%eax
c0026bf3:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026bf6:	39 c2                	cmp    %eax,%edx
c0026bf8:	0f 94 c0             	sete   %al
}
c0026bfb:	c9                   	leave  
c0026bfc:	c3                   	ret    

c0026bfd <intq_full>:

/* Returns true if Q is full, false otherwise. */
bool
intq_full (const struct intq *q) 
{
c0026bfd:	55                   	push   %ebp
c0026bfe:	89 e5                	mov    %esp,%ebp
c0026c00:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026c03:	e8 8a a8 ff ff       	call   c0021492 <intr_get_level>
c0026c08:	85 c0                	test   %eax,%eax
c0026c0a:	74 1e                	je     c0026c2a <intq_full+0x2d>
c0026c0c:	83 ec 0c             	sub    $0xc,%esp
c0026c0f:	68 f4 09 03 c0       	push   $0xc00309f4
c0026c14:	68 12 0a 03 c0       	push   $0xc0030a12
c0026c19:	68 14 0b 03 c0       	push   $0xc0030b14
c0026c1e:	6a 1e                	push   $0x1e
c0026c20:	68 29 0a 03 c0       	push   $0xc0030a29
c0026c25:	e8 f1 2f 00 00       	call   c0029c1b <debug_panic>
  return next (q->head) == q->tail;
c0026c2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c2d:	8b 40 68             	mov    0x68(%eax),%eax
c0026c30:	83 ec 0c             	sub    $0xc,%esp
c0026c33:	50                   	push   %eax
c0026c34:	e8 d9 01 00 00       	call   c0026e12 <next>
c0026c39:	83 c4 10             	add    $0x10,%esp
c0026c3c:	89 c2                	mov    %eax,%edx
c0026c3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026c41:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026c44:	39 c2                	cmp    %eax,%edx
c0026c46:	0f 94 c0             	sete   %al
}
c0026c49:	c9                   	leave  
c0026c4a:	c3                   	ret    

c0026c4b <intq_getc>:
/* Removes a byte from Q and returns it.
   If Q is empty, sleeps until a byte is added.
   When called from an interrupt handler, Q must not be empty. */
uint8_t
intq_getc (struct intq *q) 
{
c0026c4b:	55                   	push   %ebp
c0026c4c:	89 e5                	mov    %esp,%ebp
c0026c4e:	83 ec 18             	sub    $0x18,%esp
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
c0026c51:	e8 3c a8 ff ff       	call   c0021492 <intr_get_level>
c0026c56:	85 c0                	test   %eax,%eax
c0026c58:	74 7b                	je     c0026cd5 <intq_getc+0x8a>
c0026c5a:	83 ec 0c             	sub    $0xc,%esp
c0026c5d:	68 f4 09 03 c0       	push   $0xc00309f4
c0026c62:	68 12 0a 03 c0       	push   $0xc0030a12
c0026c67:	68 20 0b 03 c0       	push   $0xc0030b20
c0026c6c:	6a 2a                	push   $0x2a
c0026c6e:	68 29 0a 03 c0       	push   $0xc0030a29
c0026c73:	e8 a3 2f 00 00       	call   c0029c1b <debug_panic>
  while (intq_empty (q)) 
    {
      ASSERT (!intr_context ());
c0026c78:	e8 59 ab ff ff       	call   c00217d6 <intr_context>
c0026c7d:	83 f0 01             	xor    $0x1,%eax
c0026c80:	84 c0                	test   %al,%al
c0026c82:	75 1e                	jne    c0026ca2 <intq_getc+0x57>
c0026c84:	83 ec 0c             	sub    $0xc,%esp
c0026c87:	68 3e 0a 03 c0       	push   $0xc0030a3e
c0026c8c:	68 12 0a 03 c0       	push   $0xc0030a12
c0026c91:	68 20 0b 03 c0       	push   $0xc0030b20
c0026c96:	6a 2d                	push   $0x2d
c0026c98:	68 29 0a 03 c0       	push   $0xc0030a29
c0026c9d:	e8 79 2f 00 00       	call   c0029c1b <debug_panic>
      lock_acquire (&q->lock);
c0026ca2:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ca5:	83 ec 0c             	sub    $0xc,%esp
c0026ca8:	50                   	push   %eax
c0026ca9:	e8 35 c0 ff ff       	call   c0022ce3 <lock_acquire>
c0026cae:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_empty);
c0026cb1:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cb4:	83 c0 24             	add    $0x24,%eax
c0026cb7:	83 ec 08             	sub    $0x8,%esp
c0026cba:	50                   	push   %eax
c0026cbb:	ff 75 08             	pushl  0x8(%ebp)
c0026cbe:	e8 6b 01 00 00       	call   c0026e2e <wait>
c0026cc3:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026cc6:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cc9:	83 ec 0c             	sub    $0xc,%esp
c0026ccc:	50                   	push   %eax
c0026ccd:	e8 f4 c1 ff ff       	call   c0022ec6 <lock_release>
c0026cd2:	83 c4 10             	add    $0x10,%esp
intq_getc (struct intq *q) 
{
  uint8_t byte;
  
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_empty (q)) 
c0026cd5:	83 ec 0c             	sub    $0xc,%esp
c0026cd8:	ff 75 08             	pushl  0x8(%ebp)
c0026cdb:	e8 dd fe ff ff       	call   c0026bbd <intq_empty>
c0026ce0:	83 c4 10             	add    $0x10,%esp
c0026ce3:	84 c0                	test   %al,%al
c0026ce5:	75 91                	jne    c0026c78 <intq_getc+0x2d>
      lock_acquire (&q->lock);
      wait (q, &q->not_empty);
      lock_release (&q->lock);
    }
  
  byte = q->buf[q->tail];
c0026ce7:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cea:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026ced:	8b 55 08             	mov    0x8(%ebp),%edx
c0026cf0:	0f b6 44 02 28       	movzbl 0x28(%edx,%eax,1),%eax
c0026cf5:	88 45 f7             	mov    %al,-0x9(%ebp)
  q->tail = next (q->tail);
c0026cf8:	8b 45 08             	mov    0x8(%ebp),%eax
c0026cfb:	8b 40 6c             	mov    0x6c(%eax),%eax
c0026cfe:	83 ec 0c             	sub    $0xc,%esp
c0026d01:	50                   	push   %eax
c0026d02:	e8 0b 01 00 00       	call   c0026e12 <next>
c0026d07:	83 c4 10             	add    $0x10,%esp
c0026d0a:	89 c2                	mov    %eax,%edx
c0026d0c:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d0f:	89 50 6c             	mov    %edx,0x6c(%eax)
  signal (q, &q->not_full);
c0026d12:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d15:	83 c0 20             	add    $0x20,%eax
c0026d18:	83 ec 08             	sub    $0x8,%esp
c0026d1b:	50                   	push   %eax
c0026d1c:	ff 75 08             	pushl  0x8(%ebp)
c0026d1f:	e8 cd 01 00 00       	call   c0026ef1 <signal>
c0026d24:	83 c4 10             	add    $0x10,%esp
  return byte;
c0026d27:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
c0026d2b:	c9                   	leave  
c0026d2c:	c3                   	ret    

c0026d2d <intq_putc>:
/* Adds BYTE to the end of Q.
   If Q is full, sleeps until a byte is removed.
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
c0026d2d:	55                   	push   %ebp
c0026d2e:	89 e5                	mov    %esp,%ebp
c0026d30:	83 ec 18             	sub    $0x18,%esp
c0026d33:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026d36:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (intr_get_level () == INTR_OFF);
c0026d39:	e8 54 a7 ff ff       	call   c0021492 <intr_get_level>
c0026d3e:	85 c0                	test   %eax,%eax
c0026d40:	74 7b                	je     c0026dbd <intq_putc+0x90>
c0026d42:	83 ec 0c             	sub    $0xc,%esp
c0026d45:	68 f4 09 03 c0       	push   $0xc00309f4
c0026d4a:	68 12 0a 03 c0       	push   $0xc0030a12
c0026d4f:	68 2c 0b 03 c0       	push   $0xc0030b2c
c0026d54:	6a 3f                	push   $0x3f
c0026d56:	68 29 0a 03 c0       	push   $0xc0030a29
c0026d5b:	e8 bb 2e 00 00       	call   c0029c1b <debug_panic>
  while (intq_full (q))
    {
      ASSERT (!intr_context ());
c0026d60:	e8 71 aa ff ff       	call   c00217d6 <intr_context>
c0026d65:	83 f0 01             	xor    $0x1,%eax
c0026d68:	84 c0                	test   %al,%al
c0026d6a:	75 1e                	jne    c0026d8a <intq_putc+0x5d>
c0026d6c:	83 ec 0c             	sub    $0xc,%esp
c0026d6f:	68 3e 0a 03 c0       	push   $0xc0030a3e
c0026d74:	68 12 0a 03 c0       	push   $0xc0030a12
c0026d79:	68 2c 0b 03 c0       	push   $0xc0030b2c
c0026d7e:	6a 42                	push   $0x42
c0026d80:	68 29 0a 03 c0       	push   $0xc0030a29
c0026d85:	e8 91 2e 00 00       	call   c0029c1b <debug_panic>
      lock_acquire (&q->lock);
c0026d8a:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d8d:	83 ec 0c             	sub    $0xc,%esp
c0026d90:	50                   	push   %eax
c0026d91:	e8 4d bf ff ff       	call   c0022ce3 <lock_acquire>
c0026d96:	83 c4 10             	add    $0x10,%esp
      wait (q, &q->not_full);
c0026d99:	8b 45 08             	mov    0x8(%ebp),%eax
c0026d9c:	83 c0 20             	add    $0x20,%eax
c0026d9f:	83 ec 08             	sub    $0x8,%esp
c0026da2:	50                   	push   %eax
c0026da3:	ff 75 08             	pushl  0x8(%ebp)
c0026da6:	e8 83 00 00 00       	call   c0026e2e <wait>
c0026dab:	83 c4 10             	add    $0x10,%esp
      lock_release (&q->lock);
c0026dae:	8b 45 08             	mov    0x8(%ebp),%eax
c0026db1:	83 ec 0c             	sub    $0xc,%esp
c0026db4:	50                   	push   %eax
c0026db5:	e8 0c c1 ff ff       	call   c0022ec6 <lock_release>
c0026dba:	83 c4 10             	add    $0x10,%esp
   When called from an interrupt handler, Q must not be full. */
void
intq_putc (struct intq *q, uint8_t byte) 
{
  ASSERT (intr_get_level () == INTR_OFF);
  while (intq_full (q))
c0026dbd:	83 ec 0c             	sub    $0xc,%esp
c0026dc0:	ff 75 08             	pushl  0x8(%ebp)
c0026dc3:	e8 35 fe ff ff       	call   c0026bfd <intq_full>
c0026dc8:	83 c4 10             	add    $0x10,%esp
c0026dcb:	84 c0                	test   %al,%al
c0026dcd:	75 91                	jne    c0026d60 <intq_putc+0x33>
      lock_acquire (&q->lock);
      wait (q, &q->not_full);
      lock_release (&q->lock);
    }

  q->buf[q->head] = byte;
c0026dcf:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dd2:	8b 40 68             	mov    0x68(%eax),%eax
c0026dd5:	8b 55 08             	mov    0x8(%ebp),%edx
c0026dd8:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
c0026ddc:	88 4c 02 28          	mov    %cl,0x28(%edx,%eax,1)
  q->head = next (q->head);
c0026de0:	8b 45 08             	mov    0x8(%ebp),%eax
c0026de3:	8b 40 68             	mov    0x68(%eax),%eax
c0026de6:	83 ec 0c             	sub    $0xc,%esp
c0026de9:	50                   	push   %eax
c0026dea:	e8 23 00 00 00       	call   c0026e12 <next>
c0026def:	83 c4 10             	add    $0x10,%esp
c0026df2:	89 c2                	mov    %eax,%edx
c0026df4:	8b 45 08             	mov    0x8(%ebp),%eax
c0026df7:	89 50 68             	mov    %edx,0x68(%eax)
  signal (q, &q->not_empty);
c0026dfa:	8b 45 08             	mov    0x8(%ebp),%eax
c0026dfd:	83 c0 24             	add    $0x24,%eax
c0026e00:	83 ec 08             	sub    $0x8,%esp
c0026e03:	50                   	push   %eax
c0026e04:	ff 75 08             	pushl  0x8(%ebp)
c0026e07:	e8 e5 00 00 00       	call   c0026ef1 <signal>
c0026e0c:	83 c4 10             	add    $0x10,%esp
}
c0026e0f:	90                   	nop
c0026e10:	c9                   	leave  
c0026e11:	c3                   	ret    

c0026e12 <next>:

/* Returns the position after POS within an intq. */
static int
next (int pos) 
{
c0026e12:	55                   	push   %ebp
c0026e13:	89 e5                	mov    %esp,%ebp
  return (pos + 1) % INTQ_BUFSIZE;
c0026e15:	8b 45 08             	mov    0x8(%ebp),%eax
c0026e18:	8d 50 01             	lea    0x1(%eax),%edx
c0026e1b:	89 d0                	mov    %edx,%eax
c0026e1d:	c1 f8 1f             	sar    $0x1f,%eax
c0026e20:	c1 e8 1a             	shr    $0x1a,%eax
c0026e23:	01 c2                	add    %eax,%edx
c0026e25:	83 e2 3f             	and    $0x3f,%edx
c0026e28:	29 c2                	sub    %eax,%edx
c0026e2a:	89 d0                	mov    %edx,%eax
}
c0026e2c:	5d                   	pop    %ebp
c0026e2d:	c3                   	ret    

c0026e2e <wait>:

/* WAITER must be the address of Q's not_empty or not_full
   member.  Waits until the given condition is true. */
static void
wait (struct intq *q UNUSED, struct thread **waiter) 
{
c0026e2e:	55                   	push   %ebp
c0026e2f:	89 e5                	mov    %esp,%ebp
c0026e31:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!intr_context ());
c0026e34:	e8 9d a9 ff ff       	call   c00217d6 <intr_context>
c0026e39:	83 f0 01             	xor    $0x1,%eax
c0026e3c:	84 c0                	test   %al,%al
c0026e3e:	75 1e                	jne    c0026e5e <wait+0x30>
c0026e40:	83 ec 0c             	sub    $0xc,%esp
c0026e43:	68 3e 0a 03 c0       	push   $0xc0030a3e
c0026e48:	68 12 0a 03 c0       	push   $0xc0030a12
c0026e4d:	68 38 0b 03 c0       	push   $0xc0030b38
c0026e52:	6a 59                	push   $0x59
c0026e54:	68 29 0a 03 c0       	push   $0xc0030a29
c0026e59:	e8 bd 2d 00 00       	call   c0029c1b <debug_panic>
  ASSERT (intr_get_level () == INTR_OFF);
c0026e5e:	e8 2f a6 ff ff       	call   c0021492 <intr_get_level>
c0026e63:	85 c0                	test   %eax,%eax
c0026e65:	74 1e                	je     c0026e85 <wait+0x57>
c0026e67:	83 ec 0c             	sub    $0xc,%esp
c0026e6a:	68 f4 09 03 c0       	push   $0xc00309f4
c0026e6f:	68 12 0a 03 c0       	push   $0xc0030a12
c0026e74:	68 38 0b 03 c0       	push   $0xc0030b38
c0026e79:	6a 5a                	push   $0x5a
c0026e7b:	68 29 0a 03 c0       	push   $0xc0030a29
c0026e80:	e8 96 2d 00 00       	call   c0029c1b <debug_panic>
  ASSERT ((waiter == &q->not_empty && intq_empty (q))
c0026e85:	8b 45 08             	mov    0x8(%ebp),%eax
c0026e88:	83 c0 24             	add    $0x24,%eax
c0026e8b:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026e8e:	75 12                	jne    c0026ea2 <wait+0x74>
c0026e90:	83 ec 0c             	sub    $0xc,%esp
c0026e93:	ff 75 08             	pushl  0x8(%ebp)
c0026e96:	e8 22 fd ff ff       	call   c0026bbd <intq_empty>
c0026e9b:	83 c4 10             	add    $0x10,%esp
c0026e9e:	84 c0                	test   %al,%al
c0026ea0:	75 3b                	jne    c0026edd <wait+0xaf>
c0026ea2:	8b 45 08             	mov    0x8(%ebp),%eax
c0026ea5:	83 c0 20             	add    $0x20,%eax
c0026ea8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026eab:	75 12                	jne    c0026ebf <wait+0x91>
c0026ead:	83 ec 0c             	sub    $0xc,%esp
c0026eb0:	ff 75 08             	pushl  0x8(%ebp)
c0026eb3:	e8 45 fd ff ff       	call   c0026bfd <intq_full>
c0026eb8:	83 c4 10             	add    $0x10,%esp
c0026ebb:	84 c0                	test   %al,%al
c0026ebd:	75 1e                	jne    c0026edd <wait+0xaf>
c0026ebf:	83 ec 0c             	sub    $0xc,%esp
c0026ec2:	68 50 0a 03 c0       	push   $0xc0030a50
c0026ec7:	68 12 0a 03 c0       	push   $0xc0030a12
c0026ecc:	68 38 0b 03 c0       	push   $0xc0030b38
c0026ed1:	6a 5c                	push   $0x5c
c0026ed3:	68 29 0a 03 c0       	push   $0xc0030a29
c0026ed8:	e8 3e 2d 00 00       	call   c0029c1b <debug_panic>
          || (waiter == &q->not_full && intq_full (q)));

  *waiter = thread_current ();
c0026edd:	e8 0a 9e ff ff       	call   c0020cec <thread_current>
c0026ee2:	89 c2                	mov    %eax,%edx
c0026ee4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026ee7:	89 10                	mov    %edx,(%eax)
  thread_block ();
c0026ee9:	e8 de 9c ff ff       	call   c0020bcc <thread_block>
}
c0026eee:	90                   	nop
c0026eef:	c9                   	leave  
c0026ef0:	c3                   	ret    

c0026ef1 <signal>:
   member, and the associated condition must be true.  If a
   thread is waiting for the condition, wakes it up and resets
   the waiting thread. */
static void
signal (struct intq *q UNUSED, struct thread **waiter) 
{
c0026ef1:	55                   	push   %ebp
c0026ef2:	89 e5                	mov    %esp,%ebp
c0026ef4:	83 ec 08             	sub    $0x8,%esp
  ASSERT (intr_get_level () == INTR_OFF);
c0026ef7:	e8 96 a5 ff ff       	call   c0021492 <intr_get_level>
c0026efc:	85 c0                	test   %eax,%eax
c0026efe:	74 1e                	je     c0026f1e <signal+0x2d>
c0026f00:	83 ec 0c             	sub    $0xc,%esp
c0026f03:	68 f4 09 03 c0       	push   $0xc00309f4
c0026f08:	68 12 0a 03 c0       	push   $0xc0030a12
c0026f0d:	68 40 0b 03 c0       	push   $0xc0030b40
c0026f12:	6a 69                	push   $0x69
c0026f14:	68 29 0a 03 c0       	push   $0xc0030a29
c0026f19:	e8 fd 2c 00 00       	call   c0029c1b <debug_panic>
  ASSERT ((waiter == &q->not_empty && !intq_empty (q))
c0026f1e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f21:	83 c0 24             	add    $0x24,%eax
c0026f24:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026f27:	75 15                	jne    c0026f3e <signal+0x4d>
c0026f29:	83 ec 0c             	sub    $0xc,%esp
c0026f2c:	ff 75 08             	pushl  0x8(%ebp)
c0026f2f:	e8 89 fc ff ff       	call   c0026bbd <intq_empty>
c0026f34:	83 c4 10             	add    $0x10,%esp
c0026f37:	83 f0 01             	xor    $0x1,%eax
c0026f3a:	84 c0                	test   %al,%al
c0026f3c:	75 3e                	jne    c0026f7c <signal+0x8b>
c0026f3e:	8b 45 08             	mov    0x8(%ebp),%eax
c0026f41:	83 c0 20             	add    $0x20,%eax
c0026f44:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0026f47:	75 15                	jne    c0026f5e <signal+0x6d>
c0026f49:	83 ec 0c             	sub    $0xc,%esp
c0026f4c:	ff 75 08             	pushl  0x8(%ebp)
c0026f4f:	e8 a9 fc ff ff       	call   c0026bfd <intq_full>
c0026f54:	83 c4 10             	add    $0x10,%esp
c0026f57:	83 f0 01             	xor    $0x1,%eax
c0026f5a:	84 c0                	test   %al,%al
c0026f5c:	75 1e                	jne    c0026f7c <signal+0x8b>
c0026f5e:	83 ec 0c             	sub    $0xc,%esp
c0026f61:	68 ac 0a 03 c0       	push   $0xc0030aac
c0026f66:	68 12 0a 03 c0       	push   $0xc0030a12
c0026f6b:	68 40 0b 03 c0       	push   $0xc0030b40
c0026f70:	6a 6b                	push   $0x6b
c0026f72:	68 29 0a 03 c0       	push   $0xc0030a29
c0026f77:	e8 9f 2c 00 00       	call   c0029c1b <debug_panic>
          || (waiter == &q->not_full && !intq_full (q)));

  if (*waiter != NULL) 
c0026f7c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f7f:	8b 00                	mov    (%eax),%eax
c0026f81:	85 c0                	test   %eax,%eax
c0026f83:	74 1a                	je     c0026f9f <signal+0xae>
    {
      thread_unblock (*waiter);
c0026f85:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f88:	8b 00                	mov    (%eax),%eax
c0026f8a:	83 ec 0c             	sub    $0xc,%esp
c0026f8d:	50                   	push   %eax
c0026f8e:	e8 aa 9c ff ff       	call   c0020c3d <thread_unblock>
c0026f93:	83 c4 10             	add    $0x10,%esp
      *waiter = NULL;
c0026f96:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026f99:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    }
}
c0026f9f:	90                   	nop
c0026fa0:	c9                   	leave  
c0026fa1:	c3                   	ret    

c0026fa2 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0026fa2:	55                   	push   %ebp
c0026fa3:	89 e5                	mov    %esp,%ebp
c0026fa5:	83 ec 14             	sub    $0x14,%esp
c0026fa8:	8b 45 08             	mov    0x8(%ebp),%eax
c0026fab:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c0026faf:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c0026fb3:	89 c2                	mov    %eax,%edx
c0026fb5:	ec                   	in     (%dx),%al
c0026fb6:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c0026fb9:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c0026fbd:	c9                   	leave  
c0026fbe:	c3                   	ret    

c0026fbf <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c0026fbf:	55                   	push   %ebp
c0026fc0:	89 e5                	mov    %esp,%ebp
c0026fc2:	83 ec 08             	sub    $0x8,%esp
c0026fc5:	8b 55 08             	mov    0x8(%ebp),%edx
c0026fc8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0026fcb:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c0026fcf:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c0026fd2:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c0026fd6:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c0026fda:	ee                   	out    %al,(%dx)
}
c0026fdb:	90                   	nop
c0026fdc:	c9                   	leave  
c0026fdd:	c3                   	ret    

c0026fde <rtc_get_time>:

/* Returns number of seconds since Unix epoch of January 1,
   1970. */
time_t
rtc_get_time (void)
{
c0026fde:	55                   	push   %ebp
c0026fdf:	89 e5                	mov    %esp,%ebp
c0026fe1:	83 ec 28             	sub    $0x28,%esp
     but for historical reasons everyone always uses BCD format
     except on obscure non-PC platforms, so we don't bother
     trying to detect the format in use. */
  do
    {
      sec = bcd_to_bin (cmos_read (RTC_REG_SEC));
c0026fe4:	83 ec 0c             	sub    $0xc,%esp
c0026fe7:	6a 00                	push   $0x0
c0026fe9:	e8 ae 01 00 00       	call   c002719c <cmos_read>
c0026fee:	83 c4 10             	add    $0x10,%esp
c0026ff1:	0f b6 c0             	movzbl %al,%eax
c0026ff4:	83 ec 0c             	sub    $0xc,%esp
c0026ff7:	50                   	push   %eax
c0026ff8:	e8 73 01 00 00       	call   c0027170 <bcd_to_bin>
c0026ffd:	83 c4 10             	add    $0x10,%esp
c0027000:	89 45 e8             	mov    %eax,-0x18(%ebp)
      min = bcd_to_bin (cmos_read (RTC_REG_MIN));
c0027003:	83 ec 0c             	sub    $0xc,%esp
c0027006:	6a 02                	push   $0x2
c0027008:	e8 8f 01 00 00       	call   c002719c <cmos_read>
c002700d:	83 c4 10             	add    $0x10,%esp
c0027010:	0f b6 c0             	movzbl %al,%eax
c0027013:	83 ec 0c             	sub    $0xc,%esp
c0027016:	50                   	push   %eax
c0027017:	e8 54 01 00 00       	call   c0027170 <bcd_to_bin>
c002701c:	83 c4 10             	add    $0x10,%esp
c002701f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      hour = bcd_to_bin (cmos_read (RTC_REG_HOUR));
c0027022:	83 ec 0c             	sub    $0xc,%esp
c0027025:	6a 04                	push   $0x4
c0027027:	e8 70 01 00 00       	call   c002719c <cmos_read>
c002702c:	83 c4 10             	add    $0x10,%esp
c002702f:	0f b6 c0             	movzbl %al,%eax
c0027032:	83 ec 0c             	sub    $0xc,%esp
c0027035:	50                   	push   %eax
c0027036:	e8 35 01 00 00       	call   c0027170 <bcd_to_bin>
c002703b:	83 c4 10             	add    $0x10,%esp
c002703e:	89 45 e0             	mov    %eax,-0x20(%ebp)
      mday = bcd_to_bin (cmos_read (RTC_REG_MDAY));
c0027041:	83 ec 0c             	sub    $0xc,%esp
c0027044:	6a 07                	push   $0x7
c0027046:	e8 51 01 00 00       	call   c002719c <cmos_read>
c002704b:	83 c4 10             	add    $0x10,%esp
c002704e:	0f b6 c0             	movzbl %al,%eax
c0027051:	83 ec 0c             	sub    $0xc,%esp
c0027054:	50                   	push   %eax
c0027055:	e8 16 01 00 00       	call   c0027170 <bcd_to_bin>
c002705a:	83 c4 10             	add    $0x10,%esp
c002705d:	89 45 dc             	mov    %eax,-0x24(%ebp)
      mon = bcd_to_bin (cmos_read (RTC_REG_MON));
c0027060:	83 ec 0c             	sub    $0xc,%esp
c0027063:	6a 08                	push   $0x8
c0027065:	e8 32 01 00 00       	call   c002719c <cmos_read>
c002706a:	83 c4 10             	add    $0x10,%esp
c002706d:	0f b6 c0             	movzbl %al,%eax
c0027070:	83 ec 0c             	sub    $0xc,%esp
c0027073:	50                   	push   %eax
c0027074:	e8 f7 00 00 00       	call   c0027170 <bcd_to_bin>
c0027079:	83 c4 10             	add    $0x10,%esp
c002707c:	89 45 d8             	mov    %eax,-0x28(%ebp)
      year = bcd_to_bin (cmos_read (RTC_REG_YEAR));
c002707f:	83 ec 0c             	sub    $0xc,%esp
c0027082:	6a 09                	push   $0x9
c0027084:	e8 13 01 00 00       	call   c002719c <cmos_read>
c0027089:	83 c4 10             	add    $0x10,%esp
c002708c:	0f b6 c0             	movzbl %al,%eax
c002708f:	83 ec 0c             	sub    $0xc,%esp
c0027092:	50                   	push   %eax
c0027093:	e8 d8 00 00 00       	call   c0027170 <bcd_to_bin>
c0027098:	83 c4 10             	add    $0x10,%esp
c002709b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }
  while (sec != bcd_to_bin (cmos_read (RTC_REG_SEC)));
c002709e:	83 ec 0c             	sub    $0xc,%esp
c00270a1:	6a 00                	push   $0x0
c00270a3:	e8 f4 00 00 00       	call   c002719c <cmos_read>
c00270a8:	83 c4 10             	add    $0x10,%esp
c00270ab:	0f b6 c0             	movzbl %al,%eax
c00270ae:	83 ec 0c             	sub    $0xc,%esp
c00270b1:	50                   	push   %eax
c00270b2:	e8 b9 00 00 00       	call   c0027170 <bcd_to_bin>
c00270b7:	83 c4 10             	add    $0x10,%esp
c00270ba:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00270bd:	0f 85 21 ff ff ff    	jne    c0026fe4 <rtc_get_time+0x6>

  /* Translate years-since-1900 into years-since-1970.
     If it's before the epoch, assume that it has passed 2000.
     This will break at 2070, but that's long after our 31-bit
     time_t breaks in 2038. */
  if (year < 70)
c00270c3:	83 7d f4 45          	cmpl   $0x45,-0xc(%ebp)
c00270c7:	7f 04                	jg     c00270cd <rtc_get_time+0xef>
    year += 100;
c00270c9:	83 45 f4 64          	addl   $0x64,-0xc(%ebp)
  year -= 70;
c00270cd:	83 6d f4 46          	subl   $0x46,-0xc(%ebp)

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
c00270d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270d4:	69 d0 6d 01 00 00    	imul   $0x16d,%eax,%edx
c00270da:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00270dd:	83 e8 01             	sub    $0x1,%eax
c00270e0:	8d 48 03             	lea    0x3(%eax),%ecx
c00270e3:	85 c0                	test   %eax,%eax
c00270e5:	0f 48 c1             	cmovs  %ecx,%eax
c00270e8:	c1 f8 02             	sar    $0x2,%eax
c00270eb:	01 d0                	add    %edx,%eax
c00270ed:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c00270f3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  for (i = 1; i <= mon; i++)
c00270f6:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
c00270fd:	eb 1a                	jmp    c0027119 <rtc_get_time+0x13b>
    time += days_per_month[i - 1] * 24 * 60 * 60;
c00270ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027102:	83 e8 01             	sub    $0x1,%eax
c0027105:	8b 04 85 60 0b 03 c0 	mov    -0x3ffcf4a0(,%eax,4),%eax
c002710c:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0027112:	01 45 f0             	add    %eax,-0x10(%ebp)
    year += 100;
  year -= 70;

  /* Break down all components into seconds. */
  time = (year * 365 + (year - 1) / 4) * 24 * 60 * 60;
  for (i = 1; i <= mon; i++)
c0027115:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0027119:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002711c:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002711f:	7e de                	jle    c00270ff <rtc_get_time+0x121>
    time += days_per_month[i - 1] * 24 * 60 * 60;
  if (mon > 2 && year % 4 == 0)
c0027121:	83 7d d8 02          	cmpl   $0x2,-0x28(%ebp)
c0027125:	7e 11                	jle    c0027138 <rtc_get_time+0x15a>
c0027127:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002712a:	83 e0 03             	and    $0x3,%eax
c002712d:	85 c0                	test   %eax,%eax
c002712f:	75 07                	jne    c0027138 <rtc_get_time+0x15a>
    time += 24 * 60 * 60;
c0027131:	81 45 f0 80 51 01 00 	addl   $0x15180,-0x10(%ebp)
  time += (mday - 1) * 24 * 60 * 60;
c0027138:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002713b:	83 e8 01             	sub    $0x1,%eax
c002713e:	69 c0 80 51 01 00    	imul   $0x15180,%eax,%eax
c0027144:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += hour * 60 * 60;
c0027147:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002714a:	69 c0 10 0e 00 00    	imul   $0xe10,%eax,%eax
c0027150:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += min * 60;
c0027153:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0027156:	c1 e0 02             	shl    $0x2,%eax
c0027159:	89 c2                	mov    %eax,%edx
c002715b:	c1 e2 04             	shl    $0x4,%edx
c002715e:	29 c2                	sub    %eax,%edx
c0027160:	89 d0                	mov    %edx,%eax
c0027162:	01 45 f0             	add    %eax,-0x10(%ebp)
  time += sec;
c0027165:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0027168:	01 45 f0             	add    %eax,-0x10(%ebp)

  return time;
c002716b:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002716e:	c9                   	leave  
c002716f:	c3                   	ret    

c0027170 <bcd_to_bin>:

/* Returns the integer value of the given BCD byte. */
static int
bcd_to_bin (uint8_t x)
{
c0027170:	55                   	push   %ebp
c0027171:	89 e5                	mov    %esp,%ebp
c0027173:	83 ec 04             	sub    $0x4,%esp
c0027176:	8b 45 08             	mov    0x8(%ebp),%eax
c0027179:	88 45 fc             	mov    %al,-0x4(%ebp)
  return (x & 0x0f) + ((x >> 4) * 10);
c002717c:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0027180:	83 e0 0f             	and    $0xf,%eax
c0027183:	89 c1                	mov    %eax,%ecx
c0027185:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c0027189:	c0 e8 04             	shr    $0x4,%al
c002718c:	0f b6 d0             	movzbl %al,%edx
c002718f:	89 d0                	mov    %edx,%eax
c0027191:	c1 e0 02             	shl    $0x2,%eax
c0027194:	01 d0                	add    %edx,%eax
c0027196:	01 c0                	add    %eax,%eax
c0027198:	01 c8                	add    %ecx,%eax
}
c002719a:	c9                   	leave  
c002719b:	c3                   	ret    

c002719c <cmos_read>:

/* Reads a byte from the CMOS register with the given INDEX and
   returns the byte read. */
static uint8_t
cmos_read (uint8_t index)
{
c002719c:	55                   	push   %ebp
c002719d:	89 e5                	mov    %esp,%ebp
c002719f:	83 ec 04             	sub    $0x4,%esp
c00271a2:	8b 45 08             	mov    0x8(%ebp),%eax
c00271a5:	88 45 fc             	mov    %al,-0x4(%ebp)
  outb (CMOS_REG_SET, index);
c00271a8:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
c00271ac:	50                   	push   %eax
c00271ad:	6a 70                	push   $0x70
c00271af:	e8 0b fe ff ff       	call   c0026fbf <outb>
c00271b4:	83 c4 08             	add    $0x8,%esp
  return inb (CMOS_REG_IO);
c00271b7:	6a 71                	push   $0x71
c00271b9:	e8 e4 fd ff ff       	call   c0026fa2 <inb>
c00271be:	83 c4 04             	add    $0x4,%esp
}
c00271c1:	c9                   	leave  
c00271c2:	c3                   	ret    

c00271c3 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c00271c3:	55                   	push   %ebp
c00271c4:	89 e5                	mov    %esp,%ebp
c00271c6:	83 ec 14             	sub    $0x14,%esp
c00271c9:	8b 45 08             	mov    0x8(%ebp),%eax
c00271cc:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00271d0:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00271d4:	89 c2                	mov    %eax,%edx
c00271d6:	ec                   	in     (%dx),%al
c00271d7:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00271da:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00271de:	c9                   	leave  
c00271df:	c3                   	ret    

c00271e0 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00271e0:	55                   	push   %ebp
c00271e1:	89 e5                	mov    %esp,%ebp
c00271e3:	83 ec 08             	sub    $0x8,%esp
c00271e6:	8b 55 08             	mov    0x8(%ebp),%edx
c00271e9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00271ec:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00271f0:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00271f3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00271f7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00271fb:	ee                   	out    %al,(%dx)
}
c00271fc:	90                   	nop
c00271fd:	c9                   	leave  
c00271fe:	c3                   	ret    

c00271ff <outw>:
}

/* Writes the 16-bit DATA to PORT. */
static inline void
outw (uint16_t port, uint16_t data)
{
c00271ff:	55                   	push   %ebp
c0027200:	89 e5                	mov    %esp,%ebp
c0027202:	83 ec 08             	sub    $0x8,%esp
c0027205:	8b 55 08             	mov    0x8(%ebp),%edx
c0027208:	8b 45 0c             	mov    0xc(%ebp),%eax
c002720b:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c002720f:	66 89 45 f8          	mov    %ax,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outw %w0, %w1" : : "a" (data), "Nd" (port));
c0027213:	0f b7 45 f8          	movzwl -0x8(%ebp),%eax
c0027217:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c002721b:	66 ef                	out    %ax,(%dx)
}
c002721d:	90                   	nop
c002721e:	c9                   	leave  
c002721f:	c3                   	ret    

c0027220 <shutdown>:
/* Shuts down the machine in the way configured by
   shutdown_configure().  If the shutdown type is SHUTDOWN_NONE
   (which is the default), returns without doing anything. */
void
shutdown (void)
{
c0027220:	55                   	push   %ebp
c0027221:	89 e5                	mov    %esp,%ebp
c0027223:	83 ec 08             	sub    $0x8,%esp
  switch (how)
c0027226:	a1 b0 9c 03 c0       	mov    0xc0039cb0,%eax
c002722b:	83 f8 01             	cmp    $0x1,%eax
c002722e:	74 07                	je     c0027237 <shutdown+0x17>
c0027230:	83 f8 02             	cmp    $0x2,%eax
c0027233:	74 07                	je     c002723c <shutdown+0x1c>
      shutdown_reboot ();
      break;

    default:
      /* Nothing to do. */
      break;
c0027235:	eb 0a                	jmp    c0027241 <shutdown+0x21>
shutdown (void)
{
  switch (how)
    {
    case SHUTDOWN_POWER_OFF:
      shutdown_power_off ();
c0027237:	e8 9d 00 00 00       	call   c00272d9 <shutdown_power_off>
      break;

    case SHUTDOWN_REBOOT:
      shutdown_reboot ();
c002723c:	e8 11 00 00 00       	call   c0027252 <shutdown_reboot>

    default:
      /* Nothing to do. */
      break;
    }
}
c0027241:	90                   	nop
c0027242:	c9                   	leave  
c0027243:	c3                   	ret    

c0027244 <shutdown_configure>:

/* Sets TYPE as the way that machine will shut down when Pintos
   execution is complete. */
void
shutdown_configure (enum shutdown_type type)
{
c0027244:	55                   	push   %ebp
c0027245:	89 e5                	mov    %esp,%ebp
  how = type;
c0027247:	8b 45 08             	mov    0x8(%ebp),%eax
c002724a:	a3 b0 9c 03 c0       	mov    %eax,0xc0039cb0
}
c002724f:	90                   	nop
c0027250:	5d                   	pop    %ebp
c0027251:	c3                   	ret    

c0027252 <shutdown_reboot>:

/* Reboots the machine via the keyboard controller. */
void
shutdown_reboot (void)
{
c0027252:	55                   	push   %ebp
c0027253:	89 e5                	mov    %esp,%ebp
c0027255:	83 ec 18             	sub    $0x18,%esp
  printf ("Rebooting...\n");
c0027258:	83 ec 0c             	sub    $0xc,%esp
c002725b:	68 90 0b 03 c0       	push   $0xc0030b90
c0027260:	e8 69 4b 00 00       	call   c002bdce <puts>
c0027265:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0027268:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002726f:	eb 2a                	jmp    c002729b <shutdown_reboot+0x49>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
c0027271:	83 ec 0c             	sub    $0xc,%esp
c0027274:	6a 64                	push   $0x64
c0027276:	e8 48 ff ff ff       	call   c00271c3 <inb>
c002727b:	83 c4 10             	add    $0x10,%esp
c002727e:	0f b6 c0             	movzbl %al,%eax
c0027281:	83 e0 02             	and    $0x2,%eax
c0027284:	85 c0                	test   %eax,%eax
c0027286:	74 1e                	je     c00272a6 <shutdown_reboot+0x54>
            break;
          timer_udelay (2);
c0027288:	83 ec 08             	sub    $0x8,%esp
c002728b:	6a 00                	push   $0x0
c002728d:	6a 02                	push   $0x2
c002728f:	e8 07 d1 ff ff       	call   c002439b <timer_udelay>
c0027294:	83 c4 10             	add    $0x10,%esp
    {
      int i;

      /* Poll keyboard controller's status byte until
       * 'input buffer empty' is reported. */
      for (i = 0; i < 0x10000; i++)
c0027297:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002729b:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
c00272a2:	7e cd                	jle    c0027271 <shutdown_reboot+0x1f>
c00272a4:	eb 01                	jmp    c00272a7 <shutdown_reboot+0x55>
        {
          if ((inb (CONTROL_REG) & 0x02) == 0)
            break;
c00272a6:	90                   	nop
          timer_udelay (2);
        }

      timer_udelay (50);
c00272a7:	83 ec 08             	sub    $0x8,%esp
c00272aa:	6a 00                	push   $0x0
c00272ac:	6a 32                	push   $0x32
c00272ae:	e8 e8 d0 ff ff       	call   c002439b <timer_udelay>
c00272b3:	83 c4 10             	add    $0x10,%esp

      /* Pulse bit 0 of the output port P2 of the keyboard controller.
       * This will reset the CPU. */
      outb (CONTROL_REG, 0xfe);
c00272b6:	83 ec 08             	sub    $0x8,%esp
c00272b9:	68 fe 00 00 00       	push   $0xfe
c00272be:	6a 64                	push   $0x64
c00272c0:	e8 1b ff ff ff       	call   c00271e0 <outb>
c00272c5:	83 c4 10             	add    $0x10,%esp
      timer_udelay (50);
c00272c8:	83 ec 08             	sub    $0x8,%esp
c00272cb:	6a 00                	push   $0x0
c00272cd:	6a 32                	push   $0x32
c00272cf:	e8 c7 d0 ff ff       	call   c002439b <timer_udelay>
c00272d4:	83 c4 10             	add    $0x10,%esp
    }
c00272d7:	eb 8f                	jmp    c0027268 <shutdown_reboot+0x16>

c00272d9 <shutdown_power_off>:

/* Powers down the machine we're running on,
   as long as we're running on Bochs or QEMU. */
void
shutdown_power_off (void)
{
c00272d9:	55                   	push   %ebp
c00272da:	89 e5                	mov    %esp,%ebp
c00272dc:	83 ec 18             	sub    $0x18,%esp
  const char s[] = "Shutdown";
c00272df:	c7 45 eb 53 68 75 74 	movl   $0x74756853,-0x15(%ebp)
c00272e6:	c7 45 ef 64 6f 77 6e 	movl   $0x6e776f64,-0x11(%ebp)
c00272ed:	c6 45 f3 00          	movb   $0x0,-0xd(%ebp)

#ifdef FILESYS
  filesys_done ();
#endif

  print_stats ();
c00272f1:	e8 80 00 00 00       	call   c0027376 <print_stats>

  printf ("Powering off...\n");
c00272f6:	83 ec 0c             	sub    $0xc,%esp
c00272f9:	68 9d 0b 03 c0       	push   $0xc0030b9d
c00272fe:	e8 cb 4a 00 00       	call   c002bdce <puts>
c0027303:	83 c4 10             	add    $0x10,%esp
  serial_flush ();
c0027306:	e8 81 dd ff ff       	call   c002508c <serial_flush>

  /* ACPI power-off */
  outw (0xB004, 0x2000);
c002730b:	83 ec 08             	sub    $0x8,%esp
c002730e:	68 00 20 00 00       	push   $0x2000
c0027313:	68 04 b0 00 00       	push   $0xb004
c0027318:	e8 e2 fe ff ff       	call   c00271ff <outw>
c002731d:	83 c4 10             	add    $0x10,%esp

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0027320:	8d 45 eb             	lea    -0x15(%ebp),%eax
c0027323:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0027326:	eb 1e                	jmp    c0027346 <shutdown_power_off+0x6d>
    outb (0x8900, *p);
c0027328:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002732b:	0f b6 00             	movzbl (%eax),%eax
c002732e:	0f b6 c0             	movzbl %al,%eax
c0027331:	83 ec 08             	sub    $0x8,%esp
c0027334:	50                   	push   %eax
c0027335:	68 00 89 00 00       	push   $0x8900
c002733a:	e8 a1 fe ff ff       	call   c00271e0 <outb>
c002733f:	83 c4 10             	add    $0x10,%esp
  /* ACPI power-off */
  outw (0xB004, 0x2000);

  /* This is a special power-off sequence supported by Bochs and
     QEMU, but not by physical hardware. */
  for (p = s; *p != '\0'; p++)
c0027342:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0027346:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027349:	0f b6 00             	movzbl (%eax),%eax
c002734c:	84 c0                	test   %al,%al
c002734e:	75 d8                	jne    c0027328 <shutdown_power_off+0x4f>
  /* For newer versions of qemu, you must run with -device
   * isa-debug-exit, which exits on any write to an IO port (by
   * default 0x501).  Qemu's exit code is double the value plus one,
   * so there is no way to exit cleanly.  We use 0x31 which should
   * result in a qemu exit code of 0x63.  */
  outb (0x501, 0x31);
c0027350:	83 ec 08             	sub    $0x8,%esp
c0027353:	6a 31                	push   $0x31
c0027355:	68 01 05 00 00       	push   $0x501
c002735a:	e8 81 fe ff ff       	call   c00271e0 <outb>
c002735f:	83 c4 10             	add    $0x10,%esp

  /* This will power off a VMware VM if "gui.exitOnCLIHLT = TRUE"
     is set in its configuration file.  (The "pintos" script does
     that automatically.)  */
  asm volatile ("cli; hlt" : : : "memory");
c0027362:	fa                   	cli    
c0027363:	f4                   	hlt    

  /* None of those worked. */
  printf ("still running...\n");
c0027364:	83 ec 0c             	sub    $0xc,%esp
c0027367:	68 ad 0b 03 c0       	push   $0xc0030bad
c002736c:	e8 5d 4a 00 00       	call   c002bdce <puts>
c0027371:	83 c4 10             	add    $0x10,%esp
  for (;;);
c0027374:	eb fe                	jmp    c0027374 <shutdown_power_off+0x9b>

c0027376 <print_stats>:
}

/* Print statistics about Pintos execution. */
static void
print_stats (void)
{
c0027376:	55                   	push   %ebp
c0027377:	89 e5                	mov    %esp,%ebp
c0027379:	83 ec 08             	sub    $0x8,%esp
  timer_print_stats ();
c002737c:	e8 70 d0 ff ff       	call   c00243f1 <timer_print_stats>
  thread_print_stats ();
c0027381:	e8 d6 96 ff ff       	call   c0020a5c <thread_print_stats>
#ifdef FILESYS
  block_print_stats ();
#endif
  console_print_stats ();
c0027386:	e8 0d 49 00 00       	call   c002bc98 <console_print_stats>
  kbd_print_stats ();
c002738b:	e8 04 d4 ff ff       	call   c0024794 <kbd_print_stats>
#ifdef USERPROG
  exception_print_stats ();
#endif
}
c0027390:	90                   	nop
c0027391:	c9                   	leave  
c0027392:	c3                   	ret    

c0027393 <inb>:
#include <stdint.h>

/* Reads and returns a byte from PORT. */
static inline uint8_t
inb (uint16_t port)
{
c0027393:	55                   	push   %ebp
c0027394:	89 e5                	mov    %esp,%ebp
c0027396:	83 ec 14             	sub    $0x14,%esp
c0027399:	8b 45 08             	mov    0x8(%ebp),%eax
c002739c:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  /* See [IA32-v2a] "IN". */
  uint8_t data;
  asm volatile ("inb %w1, %b0" : "=a" (data) : "Nd" (port));
c00273a0:	0f b7 45 ec          	movzwl -0x14(%ebp),%eax
c00273a4:	89 c2                	mov    %eax,%edx
c00273a6:	ec                   	in     (%dx),%al
c00273a7:	88 45 ff             	mov    %al,-0x1(%ebp)
  return data;
c00273aa:	0f b6 45 ff          	movzbl -0x1(%ebp),%eax
}
c00273ae:	c9                   	leave  
c00273af:	c3                   	ret    

c00273b0 <outb>:
}

/* Writes byte DATA to PORT. */
static inline void
outb (uint16_t port, uint8_t data)
{
c00273b0:	55                   	push   %ebp
c00273b1:	89 e5                	mov    %esp,%ebp
c00273b3:	83 ec 08             	sub    $0x8,%esp
c00273b6:	8b 55 08             	mov    0x8(%ebp),%edx
c00273b9:	8b 45 0c             	mov    0xc(%ebp),%eax
c00273bc:	66 89 55 fc          	mov    %dx,-0x4(%ebp)
c00273c0:	88 45 f8             	mov    %al,-0x8(%ebp)
  /* See [IA32-v2b] "OUT". */
  asm volatile ("outb %b0, %w1" : : "a" (data), "Nd" (port));
c00273c3:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
c00273c7:	0f b7 55 fc          	movzwl -0x4(%ebp),%edx
c00273cb:	ee                   	out    %al,(%dx)
}
c00273cc:	90                   	nop
c00273cd:	c9                   	leave  
c00273ce:	c3                   	ret    

c00273cf <speaker_on>:

/* Sets the PC speaker to emit a tone at the given FREQUENCY, in
   Hz. */
void
speaker_on (int frequency)
{
c00273cf:	55                   	push   %ebp
c00273d0:	89 e5                	mov    %esp,%ebp
c00273d2:	83 ec 18             	sub    $0x18,%esp
  if (frequency >= 20 && frequency <= 20000)
c00273d5:	83 7d 08 13          	cmpl   $0x13,0x8(%ebp)
c00273d9:	7e 54                	jle    c002742f <speaker_on+0x60>
c00273db:	81 7d 08 20 4e 00 00 	cmpl   $0x4e20,0x8(%ebp)
c00273e2:	7f 4b                	jg     c002742f <speaker_on+0x60>
    {
      /* Set the timer channel that's connected to the speaker to
         output a square wave at the given FREQUENCY, then
         connect the timer channel output to the speaker. */
      enum intr_level old_level = intr_disable ();
c00273e4:	e8 1e a1 ff ff       	call   c0021507 <intr_disable>
c00273e9:	89 45 f4             	mov    %eax,-0xc(%ebp)
      pit_configure_channel (2, 3, frequency);
c00273ec:	83 ec 04             	sub    $0x4,%esp
c00273ef:	ff 75 08             	pushl  0x8(%ebp)
c00273f2:	6a 03                	push   $0x3
c00273f4:	6a 02                	push   $0x2
c00273f6:	e8 63 cb ff ff       	call   c0023f5e <pit_configure_channel>
c00273fb:	83 c4 10             	add    $0x10,%esp
      outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) | SPEAKER_GATE_ENABLE);
c00273fe:	83 ec 0c             	sub    $0xc,%esp
c0027401:	6a 61                	push   $0x61
c0027403:	e8 8b ff ff ff       	call   c0027393 <inb>
c0027408:	83 c4 10             	add    $0x10,%esp
c002740b:	83 c8 03             	or     $0x3,%eax
c002740e:	0f b6 c0             	movzbl %al,%eax
c0027411:	83 ec 08             	sub    $0x8,%esp
c0027414:	50                   	push   %eax
c0027415:	6a 61                	push   $0x61
c0027417:	e8 94 ff ff ff       	call   c00273b0 <outb>
c002741c:	83 c4 10             	add    $0x10,%esp
      intr_set_level (old_level);
c002741f:	83 ec 0c             	sub    $0xc,%esp
c0027422:	ff 75 f4             	pushl  -0xc(%ebp)
c0027425:	e8 85 a0 ff ff       	call   c00214af <intr_set_level>
c002742a:	83 c4 10             	add    $0x10,%esp
   Hz. */
void
speaker_on (int frequency)
{
  if (frequency >= 20 && frequency <= 20000)
    {
c002742d:	eb 05                	jmp    c0027434 <speaker_on+0x65>
    }
  else
    {
      /* FREQUENCY is outside the range of normal human hearing.
         Just turn off the speaker. */
      speaker_off ();
c002742f:	e8 03 00 00 00       	call   c0027437 <speaker_off>
    }
}
c0027434:	90                   	nop
c0027435:	c9                   	leave  
c0027436:	c3                   	ret    

c0027437 <speaker_off>:

/* Turn off the PC speaker, by disconnecting the timer channel's
   output from the speaker. */
void
speaker_off (void)
{
c0027437:	55                   	push   %ebp
c0027438:	89 e5                	mov    %esp,%ebp
c002743a:	83 ec 18             	sub    $0x18,%esp
  enum intr_level old_level = intr_disable ();
c002743d:	e8 c5 a0 ff ff       	call   c0021507 <intr_disable>
c0027442:	89 45 f4             	mov    %eax,-0xc(%ebp)
  outb (SPEAKER_PORT_GATE, inb (SPEAKER_PORT_GATE) & ~SPEAKER_GATE_ENABLE);
c0027445:	83 ec 0c             	sub    $0xc,%esp
c0027448:	6a 61                	push   $0x61
c002744a:	e8 44 ff ff ff       	call   c0027393 <inb>
c002744f:	83 c4 10             	add    $0x10,%esp
c0027452:	0f b6 c0             	movzbl %al,%eax
c0027455:	25 fc 00 00 00       	and    $0xfc,%eax
c002745a:	83 ec 08             	sub    $0x8,%esp
c002745d:	50                   	push   %eax
c002745e:	6a 61                	push   $0x61
c0027460:	e8 4b ff ff ff       	call   c00273b0 <outb>
c0027465:	83 c4 10             	add    $0x10,%esp
  intr_set_level (old_level);
c0027468:	83 ec 0c             	sub    $0xc,%esp
c002746b:	ff 75 f4             	pushl  -0xc(%ebp)
c002746e:	e8 3c a0 ff ff       	call   c00214af <intr_set_level>
c0027473:	83 c4 10             	add    $0x10,%esp
}
c0027476:	90                   	nop
c0027477:	c9                   	leave  
c0027478:	c3                   	ret    

c0027479 <speaker_beep>:

/* Briefly beep the PC speaker. */
void
speaker_beep (void)
{
c0027479:	55                   	push   %ebp
c002747a:	89 e5                	mov    %esp,%ebp
c002747c:	83 ec 08             	sub    $0x8,%esp

     We can't just enable interrupts while we sleep.  For one
     thing, we get called (indirectly) from printf, which should
     always work, even during boot before we're ready to enable
     interrupts. */
  if (intr_get_level () == INTR_ON)
c002747f:	e8 0e a0 ff ff       	call   c0021492 <intr_get_level>
c0027484:	83 f8 01             	cmp    $0x1,%eax
c0027487:	75 27                	jne    c00274b0 <speaker_beep+0x37>
    {
      speaker_on (440);
c0027489:	83 ec 0c             	sub    $0xc,%esp
c002748c:	68 b8 01 00 00       	push   $0x1b8
c0027491:	e8 39 ff ff ff       	call   c00273cf <speaker_on>
c0027496:	83 c4 10             	add    $0x10,%esp
      timer_msleep (250);
c0027499:	83 ec 08             	sub    $0x8,%esp
c002749c:	6a 00                	push   $0x0
c002749e:	68 fa 00 00 00       	push   $0xfa
c00274a3:	e8 47 ce ff ff       	call   c00242ef <timer_msleep>
c00274a8:	83 c4 10             	add    $0x10,%esp
      speaker_off ();
c00274ab:	e8 87 ff ff ff       	call   c0027437 <speaker_off>
    }
}
c00274b0:	90                   	nop
c00274b1:	c9                   	leave  
c00274b2:	c3                   	ret    

c00274b3 <debug_backtrace>:
   each of the functions we are nested within.  gdb or addr2line
   may be applied to kernel.o to translate these into file names,
   line numbers, and function names.  */
void
debug_backtrace (void) 
{
c00274b3:	55                   	push   %ebp
c00274b4:	89 e5                	mov    %esp,%ebp
c00274b6:	83 ec 18             	sub    $0x18,%esp
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
c00274b9:	8b 45 04             	mov    0x4(%ebp),%eax
c00274bc:	83 ec 08             	sub    $0x8,%esp
c00274bf:	50                   	push   %eax
c00274c0:	68 c0 0b 03 c0       	push   $0xc0030bc0
c00274c5:	e8 1e 03 00 00       	call   c00277e8 <printf>
c00274ca:	83 c4 10             	add    $0x10,%esp
  for (frame = __builtin_frame_address (1);
c00274cd:	8b 45 00             	mov    0x0(%ebp),%eax
c00274d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00274d3:	eb 21                	jmp    c00274f6 <debug_backtrace+0x43>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
    printf (" %p", frame[1]);
c00274d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00274d8:	83 c0 04             	add    $0x4,%eax
c00274db:	8b 00                	mov    (%eax),%eax
c00274dd:	83 ec 08             	sub    $0x8,%esp
c00274e0:	50                   	push   %eax
c00274e1:	68 cf 0b 03 c0       	push   $0xc0030bcf
c00274e6:	e8 fd 02 00 00       	call   c00277e8 <printf>
c00274eb:	83 c4 10             	add    $0x10,%esp
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
       frame = frame[0]) 
c00274ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00274f1:	8b 00                	mov    (%eax),%eax
c00274f3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c00274f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
{
  static bool explained;
  void **frame;
  
  printf ("Call stack: %p", __builtin_return_address (0));
  for (frame = __builtin_frame_address (1);
c00274f9:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c00274fe:	76 09                	jbe    c0027509 <debug_backtrace+0x56>
       (uintptr_t) frame >= 0x1000 && frame[0] != NULL;
c0027500:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0027503:	8b 00                	mov    (%eax),%eax
c0027505:	85 c0                	test   %eax,%eax
c0027507:	75 cc                	jne    c00274d5 <debug_backtrace+0x22>
       frame = frame[0]) 
    printf (" %p", frame[1]);
  printf (".\n");
c0027509:	83 ec 0c             	sub    $0xc,%esp
c002750c:	68 d3 0b 03 c0       	push   $0xc0030bd3
c0027511:	e8 b8 48 00 00       	call   c002bdce <puts>
c0027516:	83 c4 10             	add    $0x10,%esp

  if (!explained) 
c0027519:	0f b6 05 b4 9c 03 c0 	movzbl 0xc0039cb4,%eax
c0027520:	83 f0 01             	xor    $0x1,%eax
c0027523:	84 c0                	test   %al,%al
c0027525:	74 17                	je     c002753e <debug_backtrace+0x8b>
    {
      explained = true;
c0027527:	c6 05 b4 9c 03 c0 01 	movb   $0x1,0xc0039cb4
      printf ("The `backtrace' program can make call stacks useful.\n"
c002752e:	83 ec 0c             	sub    $0xc,%esp
c0027531:	68 d8 0b 03 c0       	push   $0xc0030bd8
c0027536:	e8 93 48 00 00       	call   c002bdce <puts>
c002753b:	83 c4 10             	add    $0x10,%esp
              "Read \"Backtraces\" in the \"Debugging Tools\" chapter\n"
              "of the Pintos documentation for more information.\n");
    }
}
c002753e:	90                   	nop
c002753f:	c9                   	leave  
c0027540:	c3                   	ret    

c0027541 <swap_byte>:
static bool inited;     

/* Swaps the bytes pointed to by A and B. */
static inline void
swap_byte (uint8_t *a, uint8_t *b) 
{
c0027541:	55                   	push   %ebp
c0027542:	89 e5                	mov    %esp,%ebp
c0027544:	83 ec 10             	sub    $0x10,%esp
  uint8_t t = *a;
c0027547:	8b 45 08             	mov    0x8(%ebp),%eax
c002754a:	0f b6 00             	movzbl (%eax),%eax
c002754d:	88 45 ff             	mov    %al,-0x1(%ebp)
  *a = *b;
c0027550:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027553:	0f b6 10             	movzbl (%eax),%edx
c0027556:	8b 45 08             	mov    0x8(%ebp),%eax
c0027559:	88 10                	mov    %dl,(%eax)
  *b = t;
c002755b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002755e:	0f b6 55 ff          	movzbl -0x1(%ebp),%edx
c0027562:	88 10                	mov    %dl,(%eax)
}
c0027564:	90                   	nop
c0027565:	c9                   	leave  
c0027566:	c3                   	ret    

c0027567 <random_init>:

/* Initializes or reinitializes the PRNG with the given SEED. */
void
random_init (unsigned seed)
{
c0027567:	55                   	push   %ebp
c0027568:	89 e5                	mov    %esp,%ebp
c002756a:	83 ec 10             	sub    $0x10,%esp
  uint8_t *seedp = (uint8_t *) &seed;
c002756d:	8d 45 08             	lea    0x8(%ebp),%eax
c0027570:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c0027573:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c002757a:	eb 13                	jmp    c002758f <random_init+0x28>
    s[i] = i;
c002757c:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002757f:	89 c2                	mov    %eax,%edx
c0027581:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027584:	05 c0 9c 03 c0       	add    $0xc0039cc0,%eax
c0027589:	88 10                	mov    %dl,(%eax)
{
  uint8_t *seedp = (uint8_t *) &seed;
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
c002758b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c002758f:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c0027596:	7e e4                	jle    c002757c <random_init+0x15>
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c0027598:	c6 45 fb 00          	movb   $0x0,-0x5(%ebp)
c002759c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00275a3:	eb 40                	jmp    c00275e5 <random_init+0x7e>
    {
      j += s[i] + seedp[i % sizeof seed];
c00275a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275a8:	05 c0 9c 03 c0       	add    $0xc0039cc0,%eax
c00275ad:	0f b6 10             	movzbl (%eax),%edx
c00275b0:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275b3:	83 e0 03             	and    $0x3,%eax
c00275b6:	89 c1                	mov    %eax,%ecx
c00275b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00275bb:	01 c8                	add    %ecx,%eax
c00275bd:	0f b6 00             	movzbl (%eax),%eax
c00275c0:	01 d0                	add    %edx,%eax
c00275c2:	00 45 fb             	add    %al,-0x5(%ebp)
      swap_byte (s + i, s + j);
c00275c5:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00275c9:	8d 90 c0 9c 03 c0    	lea    -0x3ffc6340(%eax),%edx
c00275cf:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00275d2:	05 c0 9c 03 c0       	add    $0xc0039cc0,%eax
c00275d7:	52                   	push   %edx
c00275d8:	50                   	push   %eax
c00275d9:	e8 63 ff ff ff       	call   c0027541 <swap_byte>
c00275de:	83 c4 08             	add    $0x8,%esp
  int i;
  uint8_t j;

  for (i = 0; i < 256; i++) 
    s[i] = i;
  for (i = j = 0; i < 256; i++) 
c00275e1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00275e5:	81 7d fc ff 00 00 00 	cmpl   $0xff,-0x4(%ebp)
c00275ec:	7e b7                	jle    c00275a5 <random_init+0x3e>
    {
      j += s[i] + seedp[i % sizeof seed];
      swap_byte (s + i, s + j);
    }

  s_i = s_j = 0;
c00275ee:	c6 05 c1 9d 03 c0 00 	movb   $0x0,0xc0039dc1
c00275f5:	0f b6 05 c1 9d 03 c0 	movzbl 0xc0039dc1,%eax
c00275fc:	a2 c0 9d 03 c0       	mov    %al,0xc0039dc0
  inited = true;
c0027601:	c6 05 c2 9d 03 c0 01 	movb   $0x1,0xc0039dc2
}
c0027608:	90                   	nop
c0027609:	c9                   	leave  
c002760a:	c3                   	ret    

c002760b <random_bytes>:

/* Writes SIZE random bytes into BUF. */
void
random_bytes (void *buf_, size_t size) 
{
c002760b:	55                   	push   %ebp
c002760c:	89 e5                	mov    %esp,%ebp
c002760e:	83 ec 10             	sub    $0x10,%esp
  uint8_t *buf;

  if (!inited)
c0027611:	0f b6 05 c2 9d 03 c0 	movzbl 0xc0039dc2,%eax
c0027618:	83 f0 01             	xor    $0x1,%eax
c002761b:	84 c0                	test   %al,%al
c002761d:	74 0a                	je     c0027629 <random_bytes+0x1e>
    random_init (0);
c002761f:	6a 00                	push   $0x0
c0027621:	e8 41 ff ff ff       	call   c0027567 <random_init>
c0027626:	83 c4 04             	add    $0x4,%esp

  for (buf = buf_; size-- > 0; buf++)
c0027629:	8b 45 08             	mov    0x8(%ebp),%eax
c002762c:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002762f:	e9 92 00 00 00       	jmp    c00276c6 <random_bytes+0xbb>
    {
      uint8_t s_k;
      
      s_i++;
c0027634:	0f b6 05 c0 9d 03 c0 	movzbl 0xc0039dc0,%eax
c002763b:	83 c0 01             	add    $0x1,%eax
c002763e:	a2 c0 9d 03 c0       	mov    %al,0xc0039dc0
      s_j += s[s_i];
c0027643:	0f b6 05 c0 9d 03 c0 	movzbl 0xc0039dc0,%eax
c002764a:	0f b6 c0             	movzbl %al,%eax
c002764d:	0f b6 90 c0 9c 03 c0 	movzbl -0x3ffc6340(%eax),%edx
c0027654:	0f b6 05 c1 9d 03 c0 	movzbl 0xc0039dc1,%eax
c002765b:	01 d0                	add    %edx,%eax
c002765d:	a2 c1 9d 03 c0       	mov    %al,0xc0039dc1
      swap_byte (s + s_i, s + s_j);
c0027662:	0f b6 05 c1 9d 03 c0 	movzbl 0xc0039dc1,%eax
c0027669:	0f b6 c0             	movzbl %al,%eax
c002766c:	8d 90 c0 9c 03 c0    	lea    -0x3ffc6340(%eax),%edx
c0027672:	0f b6 05 c0 9d 03 c0 	movzbl 0xc0039dc0,%eax
c0027679:	0f b6 c0             	movzbl %al,%eax
c002767c:	05 c0 9c 03 c0       	add    $0xc0039cc0,%eax
c0027681:	52                   	push   %edx
c0027682:	50                   	push   %eax
c0027683:	e8 b9 fe ff ff       	call   c0027541 <swap_byte>
c0027688:	83 c4 08             	add    $0x8,%esp

      s_k = s[s_i] + s[s_j];
c002768b:	0f b6 05 c0 9d 03 c0 	movzbl 0xc0039dc0,%eax
c0027692:	0f b6 c0             	movzbl %al,%eax
c0027695:	0f b6 90 c0 9c 03 c0 	movzbl -0x3ffc6340(%eax),%edx
c002769c:	0f b6 05 c1 9d 03 c0 	movzbl 0xc0039dc1,%eax
c00276a3:	0f b6 c0             	movzbl %al,%eax
c00276a6:	0f b6 80 c0 9c 03 c0 	movzbl -0x3ffc6340(%eax),%eax
c00276ad:	01 d0                	add    %edx,%eax
c00276af:	88 45 fb             	mov    %al,-0x5(%ebp)
      *buf = s[s_k];
c00276b2:	0f b6 45 fb          	movzbl -0x5(%ebp),%eax
c00276b6:	0f b6 90 c0 9c 03 c0 	movzbl -0x3ffc6340(%eax),%edx
c00276bd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00276c0:	88 10                	mov    %dl,(%eax)
  uint8_t *buf;

  if (!inited)
    random_init (0);

  for (buf = buf_; size-- > 0; buf++)
c00276c2:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00276c6:	8b 45 0c             	mov    0xc(%ebp),%eax
c00276c9:	8d 50 ff             	lea    -0x1(%eax),%edx
c00276cc:	89 55 0c             	mov    %edx,0xc(%ebp)
c00276cf:	85 c0                	test   %eax,%eax
c00276d1:	0f 85 5d ff ff ff    	jne    c0027634 <random_bytes+0x29>
      swap_byte (s + s_i, s + s_j);

      s_k = s[s_i] + s[s_j];
      *buf = s[s_k];
    }
}
c00276d7:	90                   	nop
c00276d8:	c9                   	leave  
c00276d9:	c3                   	ret    

c00276da <random_ulong>:
/* Returns a pseudo-random unsigned long.
   Use random_ulong() % n to obtain a random number in the range
   0...n (exclusive). */
unsigned long
random_ulong (void) 
{
c00276da:	55                   	push   %ebp
c00276db:	89 e5                	mov    %esp,%ebp
c00276dd:	83 ec 10             	sub    $0x10,%esp
  unsigned long ul;
  random_bytes (&ul, sizeof ul);
c00276e0:	6a 04                	push   $0x4
c00276e2:	8d 45 fc             	lea    -0x4(%ebp),%eax
c00276e5:	50                   	push   %eax
c00276e6:	e8 20 ff ff ff       	call   c002760b <random_bytes>
c00276eb:	83 c4 08             	add    $0x8,%esp
  return ul;
c00276ee:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00276f1:	c9                   	leave  
c00276f2:	c3                   	ret    

c00276f3 <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c00276f3:	55                   	push   %ebp
c00276f4:	89 e5                	mov    %esp,%ebp
c00276f6:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00276fa:	7e 0d                	jle    c0027709 <isdigit+0x16>
c00276fc:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c0027700:	7f 07                	jg     c0027709 <isdigit+0x16>
c0027702:	b8 01 00 00 00       	mov    $0x1,%eax
c0027707:	eb 05                	jmp    c002770e <isdigit+0x1b>
c0027709:	b8 00 00 00 00       	mov    $0x0,%eax
c002770e:	5d                   	pop    %ebp
c002770f:	c3                   	ret    

c0027710 <isprint>:
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
}
static inline int isblank (int c) { return c == ' ' || c == '\t'; }
static inline int isgraph (int c) { return c > 32 && c < 127; }
static inline int isprint (int c) { return c >= 32 && c < 127; }
c0027710:	55                   	push   %ebp
c0027711:	89 e5                	mov    %esp,%ebp
c0027713:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
c0027717:	7e 0d                	jle    c0027726 <isprint+0x16>
c0027719:	83 7d 08 7e          	cmpl   $0x7e,0x8(%ebp)
c002771d:	7f 07                	jg     c0027726 <isprint+0x16>
c002771f:	b8 01 00 00 00       	mov    $0x1,%eax
c0027724:	eb 05                	jmp    c002772b <isprint+0x1b>
c0027726:	b8 00 00 00 00       	mov    $0x0,%eax
c002772b:	5d                   	pop    %ebp
c002772c:	c3                   	ret    

c002772d <vsnprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
vsnprintf (char *buffer, size_t buf_size, const char *format, va_list args) 
{
c002772d:	55                   	push   %ebp
c002772e:	89 e5                	mov    %esp,%ebp
c0027730:	83 ec 18             	sub    $0x18,%esp
  /* Set up aux data for vsnprintf_helper(). */
  struct vsnprintf_aux aux;
  aux.p = buffer;
c0027733:	8b 45 08             	mov    0x8(%ebp),%eax
c0027736:	89 45 ec             	mov    %eax,-0x14(%ebp)
  aux.length = 0;
c0027739:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  aux.max_length = buf_size > 0 ? buf_size - 1 : 0;
c0027740:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027744:	74 08                	je     c002774e <vsnprintf+0x21>
c0027746:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027749:	83 e8 01             	sub    $0x1,%eax
c002774c:	eb 05                	jmp    c0027753 <vsnprintf+0x26>
c002774e:	b8 00 00 00 00       	mov    $0x0,%eax
c0027753:	89 45 f4             	mov    %eax,-0xc(%ebp)

  /* Do most of the work. */
  __vprintf (format, args, vsnprintf_helper, &aux);
c0027756:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0027759:	50                   	push   %eax
c002775a:	68 7e 77 02 c0       	push   $0xc002777e
c002775f:	ff 75 14             	pushl  0x14(%ebp)
c0027762:	ff 75 10             	pushl  0x10(%ebp)
c0027765:	e8 a4 00 00 00       	call   c002780e <__vprintf>
c002776a:	83 c4 10             	add    $0x10,%esp

  /* Add null terminator. */
  if (buf_size > 0)
c002776d:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0027771:	74 06                	je     c0027779 <vsnprintf+0x4c>
    *aux.p = '\0';
c0027773:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0027776:	c6 00 00             	movb   $0x0,(%eax)

  return aux.length;
c0027779:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002777c:	c9                   	leave  
c002777d:	c3                   	ret    

c002777e <vsnprintf_helper>:

/* Helper function for vsnprintf(). */
static void
vsnprintf_helper (char ch, void *aux_)
{
c002777e:	55                   	push   %ebp
c002777f:	89 e5                	mov    %esp,%ebp
c0027781:	83 ec 14             	sub    $0x14,%esp
c0027784:	8b 45 08             	mov    0x8(%ebp),%eax
c0027787:	88 45 ec             	mov    %al,-0x14(%ebp)
  struct vsnprintf_aux *aux = aux_;
c002778a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002778d:	89 45 fc             	mov    %eax,-0x4(%ebp)

  if (aux->length++ < aux->max_length)
c0027790:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0027793:	8b 40 04             	mov    0x4(%eax),%eax
c0027796:	8d 48 01             	lea    0x1(%eax),%ecx
c0027799:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002779c:	89 4a 04             	mov    %ecx,0x4(%edx)
c002779f:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00277a2:	8b 52 08             	mov    0x8(%edx),%edx
c00277a5:	39 d0                	cmp    %edx,%eax
c00277a7:	7d 13                	jge    c00277bc <vsnprintf_helper+0x3e>
    *aux->p++ = ch;
c00277a9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00277ac:	8b 00                	mov    (%eax),%eax
c00277ae:	8d 48 01             	lea    0x1(%eax),%ecx
c00277b1:	8b 55 fc             	mov    -0x4(%ebp),%edx
c00277b4:	89 0a                	mov    %ecx,(%edx)
c00277b6:	0f b6 55 ec          	movzbl -0x14(%ebp),%edx
c00277ba:	88 10                	mov    %dl,(%eax)
}
c00277bc:	90                   	nop
c00277bd:	c9                   	leave  
c00277be:	c3                   	ret    

c00277bf <snprintf>:
   BUF_SIZE is zero.  Returns the number of characters that would
   have been written to BUFFER, not including a null terminator,
   had there been enough room. */
int
snprintf (char *buffer, size_t buf_size, const char *format, ...) 
{
c00277bf:	55                   	push   %ebp
c00277c0:	89 e5                	mov    %esp,%ebp
c00277c2:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00277c5:	8d 45 14             	lea    0x14(%ebp),%eax
c00277c8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vsnprintf (buffer, buf_size, format, args);
c00277cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00277ce:	50                   	push   %eax
c00277cf:	ff 75 10             	pushl  0x10(%ebp)
c00277d2:	ff 75 0c             	pushl  0xc(%ebp)
c00277d5:	ff 75 08             	pushl  0x8(%ebp)
c00277d8:	e8 50 ff ff ff       	call   c002772d <vsnprintf>
c00277dd:	83 c4 10             	add    $0x10,%esp
c00277e0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c00277e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c00277e6:	c9                   	leave  
c00277e7:	c3                   	ret    

c00277e8 <printf>:
   In the kernel, the console is both the video display and first
   serial port.
   In userspace, the console is file descriptor 1. */
int
printf (const char *format, ...) 
{
c00277e8:	55                   	push   %ebp
c00277e9:	89 e5                	mov    %esp,%ebp
c00277eb:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  int retval;

  va_start (args, format);
c00277ee:	8d 45 0c             	lea    0xc(%ebp),%eax
c00277f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
  retval = vprintf (format, args);
c00277f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00277f7:	83 ec 08             	sub    $0x8,%esp
c00277fa:	50                   	push   %eax
c00277fb:	ff 75 08             	pushl  0x8(%ebp)
c00277fe:	e8 98 45 00 00       	call   c002bd9b <vprintf>
c0027803:	83 c4 10             	add    $0x10,%esp
c0027806:	89 45 f4             	mov    %eax,-0xc(%ebp)
  va_end (args);

  return retval;
c0027809:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002780c:	c9                   	leave  
c002780d:	c3                   	ret    

c002780e <__vprintf>:
                           void (*output) (char, void *), void *aux);

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
c002780e:	55                   	push   %ebp
c002780f:	89 e5                	mov    %esp,%ebp
c0027811:	57                   	push   %edi
c0027812:	56                   	push   %esi
c0027813:	53                   	push   %ebx
c0027814:	83 ec 3c             	sub    $0x3c,%esp
  for (; *format != '\0'; format++)
c0027817:	e9 45 04 00 00       	jmp    c0027c61 <__vprintf+0x453>
    {
      struct printf_conversion c;

      /* Literally copy non-conversions to output. */
      if (*format != '%') 
c002781c:	8b 45 08             	mov    0x8(%ebp),%eax
c002781f:	0f b6 00             	movzbl (%eax),%eax
c0027822:	3c 25                	cmp    $0x25,%al
c0027824:	74 1d                	je     c0027843 <__vprintf+0x35>
        {
          output (*format, aux);
c0027826:	8b 45 08             	mov    0x8(%ebp),%eax
c0027829:	0f b6 00             	movzbl (%eax),%eax
c002782c:	0f be c0             	movsbl %al,%eax
c002782f:	83 ec 08             	sub    $0x8,%esp
c0027832:	ff 75 14             	pushl  0x14(%ebp)
c0027835:	50                   	push   %eax
c0027836:	8b 45 10             	mov    0x10(%ebp),%eax
c0027839:	ff d0                	call   *%eax
c002783b:	83 c4 10             	add    $0x10,%esp
          continue;
c002783e:	e9 1a 04 00 00       	jmp    c0027c5d <__vprintf+0x44f>
        }
      format++;
c0027843:	83 45 08 01          	addl   $0x1,0x8(%ebp)

      /* %% => %. */
      if (*format == '%') 
c0027847:	8b 45 08             	mov    0x8(%ebp),%eax
c002784a:	0f b6 00             	movzbl (%eax),%eax
c002784d:	3c 25                	cmp    $0x25,%al
c002784f:	75 15                	jne    c0027866 <__vprintf+0x58>
        {
          output ('%', aux);
c0027851:	83 ec 08             	sub    $0x8,%esp
c0027854:	ff 75 14             	pushl  0x14(%ebp)
c0027857:	6a 25                	push   $0x25
c0027859:	8b 45 10             	mov    0x10(%ebp),%eax
c002785c:	ff d0                	call   *%eax
c002785e:	83 c4 10             	add    $0x10,%esp
          continue;
c0027861:	e9 f7 03 00 00       	jmp    c0027c5d <__vprintf+0x44f>
        }

      /* Parse conversion specifiers. */
      format = parse_conversion (format, &c, &args);
c0027866:	83 ec 04             	sub    $0x4,%esp
c0027869:	8d 45 0c             	lea    0xc(%ebp),%eax
c002786c:	50                   	push   %eax
c002786d:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027870:	50                   	push   %eax
c0027871:	ff 75 08             	pushl  0x8(%ebp)
c0027874:	e8 ff 03 00 00       	call   c0027c78 <parse_conversion>
c0027879:	83 c4 10             	add    $0x10,%esp
c002787c:	89 45 08             	mov    %eax,0x8(%ebp)

      /* Do conversion. */
      switch (*format) 
c002787f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027882:	0f b6 00             	movzbl (%eax),%eax
c0027885:	0f be c0             	movsbl %al,%eax
c0027888:	83 e8 45             	sub    $0x45,%eax
c002788b:	83 f8 33             	cmp    $0x33,%eax
c002788e:	0f 87 ab 03 00 00    	ja     c0027c3f <__vprintf+0x431>
c0027894:	8b 04 85 5c 0d 03 c0 	mov    -0x3ffcf2a4(,%eax,4),%eax
c002789b:	ff e0                	jmp    *%eax
        case 'i': 
          {
            /* Signed integer conversions. */
            intmax_t value;
            
            switch (c.type) 
c002789d:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00278a0:	83 f8 08             	cmp    $0x8,%eax
c00278a3:	0f 87 dd 00 00 00    	ja     c0027986 <__vprintf+0x178>
c00278a9:	8b 04 85 2c 0e 03 c0 	mov    -0x3ffcf1d4(,%eax,4),%eax
c00278b0:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (signed char) va_arg (args, int);
c00278b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278b5:	8d 50 04             	lea    0x4(%eax),%edx
c00278b8:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278bb:	8b 00                	mov    (%eax),%eax
c00278bd:	0f be c0             	movsbl %al,%eax
c00278c0:	99                   	cltd   
c00278c1:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00278c4:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00278c7:	e9 d4 00 00 00       	jmp    c00279a0 <__vprintf+0x192>
              case SHORT:
                value = (short) va_arg (args, int);
c00278cc:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278cf:	8d 50 04             	lea    0x4(%eax),%edx
c00278d2:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278d5:	8b 00                	mov    (%eax),%eax
c00278d7:	98                   	cwtl   
c00278d8:	99                   	cltd   
c00278d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00278dc:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00278df:	e9 bc 00 00 00       	jmp    c00279a0 <__vprintf+0x192>
              case INT:
                value = va_arg (args, int);
c00278e4:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278e7:	8d 50 04             	lea    0x4(%eax),%edx
c00278ea:	89 55 0c             	mov    %edx,0xc(%ebp)
c00278ed:	8b 00                	mov    (%eax),%eax
c00278ef:	99                   	cltd   
c00278f0:	89 45 e0             	mov    %eax,-0x20(%ebp)
c00278f3:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c00278f6:	e9 a5 00 00 00       	jmp    c00279a0 <__vprintf+0x192>
              case INTMAX:
                value = va_arg (args, intmax_t);
c00278fb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00278fe:	8d 50 08             	lea    0x8(%eax),%edx
c0027901:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027904:	8b 50 04             	mov    0x4(%eax),%edx
c0027907:	8b 00                	mov    (%eax),%eax
c0027909:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002790c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002790f:	e9 8c 00 00 00       	jmp    c00279a0 <__vprintf+0x192>
              case LONG:
                value = va_arg (args, long);
c0027914:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027917:	8d 50 04             	lea    0x4(%eax),%edx
c002791a:	89 55 0c             	mov    %edx,0xc(%ebp)
c002791d:	8b 00                	mov    (%eax),%eax
c002791f:	99                   	cltd   
c0027920:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027923:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027926:	eb 78                	jmp    c00279a0 <__vprintf+0x192>
              case LONGLONG:
                value = va_arg (args, long long);
c0027928:	8b 45 0c             	mov    0xc(%ebp),%eax
c002792b:	8d 50 08             	lea    0x8(%eax),%edx
c002792e:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027931:	8b 50 04             	mov    0x4(%eax),%edx
c0027934:	8b 00                	mov    (%eax),%eax
c0027936:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027939:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c002793c:	eb 62                	jmp    c00279a0 <__vprintf+0x192>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c002793e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027941:	8d 50 04             	lea    0x4(%eax),%edx
c0027944:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027947:	8b 00                	mov    (%eax),%eax
c0027949:	99                   	cltd   
c002794a:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002794d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
                break;
c0027950:	eb 4e                	jmp    c00279a0 <__vprintf+0x192>
              case SIZET:
                value = va_arg (args, size_t);
c0027952:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027955:	8d 50 04             	lea    0x4(%eax),%edx
c0027958:	89 55 0c             	mov    %edx,0xc(%ebp)
c002795b:	8b 00                	mov    (%eax),%eax
c002795d:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027960:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
                if (value > SIZE_MAX / 2)
c0027967:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002796b:	78 32                	js     c002799f <__vprintf+0x191>
c002796d:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0027971:	7f 09                	jg     c002797c <__vprintf+0x16e>
c0027973:	81 7d e0 ff ff ff 7f 	cmpl   $0x7fffffff,-0x20(%ebp)
c002797a:	76 23                	jbe    c002799f <__vprintf+0x191>
                  value = value - SIZE_MAX - 1;
c002797c:	83 45 e0 00          	addl   $0x0,-0x20(%ebp)
c0027980:	83 55 e4 ff          	adcl   $0xffffffff,-0x1c(%ebp)
                break;
c0027984:	eb 19                	jmp    c002799f <__vprintf+0x191>
              default:
                NOT_REACHED ();
c0027986:	68 f4 0c 03 c0       	push   $0xc0030cf4
c002798b:	68 28 0f 03 c0       	push   $0xc0030f28
c0027990:	68 dc 00 00 00       	push   $0xdc
c0027995:	68 16 0d 03 c0       	push   $0xc0030d16
c002799a:	e8 7c 22 00 00       	call   c0029c1b <debug_panic>
                break;
              case SIZET:
                value = va_arg (args, size_t);
                if (value > SIZE_MAX / 2)
                  value = value - SIZE_MAX - 1;
                break;
c002799f:	90                   	nop
              default:
                NOT_REACHED ();
              }

            format_integer (value < 0 ? -value : value,
c00279a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00279a3:	c1 e8 1f             	shr    $0x1f,%eax
c00279a6:	0f b6 c8             	movzbl %al,%ecx
c00279a9:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00279ac:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00279af:	89 d2                	mov    %edx,%edx
c00279b1:	c1 fa 1f             	sar    $0x1f,%edx
c00279b4:	89 d0                	mov    %edx,%eax
c00279b6:	89 c7                	mov    %eax,%edi
c00279b8:	33 7d e0             	xor    -0x20(%ebp),%edi
c00279bb:	89 fb                	mov    %edi,%ebx
c00279bd:	89 d7                	mov    %edx,%edi
c00279bf:	33 7d e4             	xor    -0x1c(%ebp),%edi
c00279c2:	89 fe                	mov    %edi,%esi
c00279c4:	29 c3                	sub    %eax,%ebx
c00279c6:	19 d6                	sbb    %edx,%esi
c00279c8:	89 d8                	mov    %ebx,%eax
c00279ca:	89 f2                	mov    %esi,%edx
c00279cc:	ff 75 14             	pushl  0x14(%ebp)
c00279cf:	ff 75 10             	pushl  0x10(%ebp)
c00279d2:	8d 7d bc             	lea    -0x44(%ebp),%edi
c00279d5:	57                   	push   %edi
c00279d6:	68 80 0c 03 c0       	push   $0xc0030c80
c00279db:	51                   	push   %ecx
c00279dc:	6a 01                	push   $0x1
c00279de:	52                   	push   %edx
c00279df:	50                   	push   %eax
c00279e0:	e8 5b 05 00 00       	call   c0027f40 <format_integer>
c00279e5:	83 c4 20             	add    $0x20,%esp
                            true, value < 0, &base_d, &c, output, aux);
          }
          break;
c00279e8:	e9 70 02 00 00       	jmp    c0027c5d <__vprintf+0x44f>
          {
            /* Unsigned integer conversions. */
            uintmax_t value;
            const struct integer_base *b;

            switch (c.type) 
c00279ed:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00279f0:	83 f8 08             	cmp    $0x8,%eax
c00279f3:	0f 87 d3 00 00 00    	ja     c0027acc <__vprintf+0x2be>
c00279f9:	8b 04 85 50 0e 03 c0 	mov    -0x3ffcf1b0(,%eax,4),%eax
c0027a00:	ff e0                	jmp    *%eax
              {
              case CHAR: 
                value = (unsigned char) va_arg (args, unsigned);
c0027a02:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a05:	8d 50 04             	lea    0x4(%eax),%edx
c0027a08:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a0b:	8b 00                	mov    (%eax),%eax
c0027a0d:	0f b6 c0             	movzbl %al,%eax
c0027a10:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a13:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027a1a:	e9 c6 00 00 00       	jmp    c0027ae5 <__vprintf+0x2d7>
              case SHORT:
                value = (unsigned short) va_arg (args, unsigned);
c0027a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a22:	8d 50 04             	lea    0x4(%eax),%edx
c0027a25:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a28:	8b 00                	mov    (%eax),%eax
c0027a2a:	0f b7 c0             	movzwl %ax,%eax
c0027a2d:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a30:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027a37:	e9 a9 00 00 00       	jmp    c0027ae5 <__vprintf+0x2d7>
              case INT:
                value = va_arg (args, unsigned);
c0027a3c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a3f:	8d 50 04             	lea    0x4(%eax),%edx
c0027a42:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a45:	8b 00                	mov    (%eax),%eax
c0027a47:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a4a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027a51:	e9 8f 00 00 00       	jmp    c0027ae5 <__vprintf+0x2d7>
              case INTMAX:
                value = va_arg (args, uintmax_t);
c0027a56:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a59:	8d 50 08             	lea    0x8(%eax),%edx
c0027a5c:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a5f:	8b 50 04             	mov    0x4(%eax),%edx
c0027a62:	8b 00                	mov    (%eax),%eax
c0027a64:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a67:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c0027a6a:	eb 79                	jmp    c0027ae5 <__vprintf+0x2d7>
              case LONG:
                value = va_arg (args, unsigned long);
c0027a6c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a6f:	8d 50 04             	lea    0x4(%eax),%edx
c0027a72:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a75:	8b 00                	mov    (%eax),%eax
c0027a77:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a7a:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027a81:	eb 62                	jmp    c0027ae5 <__vprintf+0x2d7>
              case LONGLONG:
                value = va_arg (args, unsigned long long);
c0027a83:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a86:	8d 50 08             	lea    0x8(%eax),%edx
c0027a89:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027a8c:	8b 50 04             	mov    0x4(%eax),%edx
c0027a8f:	8b 00                	mov    (%eax),%eax
c0027a91:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027a94:	89 55 dc             	mov    %edx,-0x24(%ebp)
                break;
c0027a97:	eb 4c                	jmp    c0027ae5 <__vprintf+0x2d7>
              case PTRDIFFT:
                value = va_arg (args, ptrdiff_t);
c0027a99:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027a9c:	8d 50 04             	lea    0x4(%eax),%edx
c0027a9f:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027aa2:	8b 00                	mov    (%eax),%eax
c0027aa4:	99                   	cltd   
c0027aa5:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027aa8:	89 55 dc             	mov    %edx,-0x24(%ebp)
#if UINTMAX_MAX != PTRDIFF_MAX
                value &= ((uintmax_t) PTRDIFF_MAX << 1) | 1;
c0027aab:	83 65 d8 ff          	andl   $0xffffffff,-0x28(%ebp)
c0027aaf:	83 65 dc 00          	andl   $0x0,-0x24(%ebp)
#endif
                break;
c0027ab3:	eb 30                	jmp    c0027ae5 <__vprintf+0x2d7>
              case SIZET:
                value = va_arg (args, size_t);
c0027ab5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ab8:	8d 50 04             	lea    0x4(%eax),%edx
c0027abb:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027abe:	8b 00                	mov    (%eax),%eax
c0027ac0:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0027ac3:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
                break;
c0027aca:	eb 19                	jmp    c0027ae5 <__vprintf+0x2d7>
              default:
                NOT_REACHED ();
c0027acc:	68 f4 0c 03 c0       	push   $0xc0030cf4
c0027ad1:	68 28 0f 03 c0       	push   $0xc0030f28
c0027ad6:	68 0b 01 00 00       	push   $0x10b
c0027adb:	68 16 0d 03 c0       	push   $0xc0030d16
c0027ae0:	e8 36 21 00 00       	call   c0029c1b <debug_panic>
              }

            switch (*format) 
c0027ae5:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ae8:	0f b6 00             	movzbl (%eax),%eax
c0027aeb:	0f be c0             	movsbl %al,%eax
c0027aee:	83 f8 6f             	cmp    $0x6f,%eax
c0027af1:	74 18                	je     c0027b0b <__vprintf+0x2fd>
c0027af3:	83 f8 6f             	cmp    $0x6f,%eax
c0027af6:	7f 07                	jg     c0027aff <__vprintf+0x2f1>
c0027af8:	83 f8 58             	cmp    $0x58,%eax
c0027afb:	74 29                	je     c0027b26 <__vprintf+0x318>
c0027afd:	eb 30                	jmp    c0027b2f <__vprintf+0x321>
c0027aff:	83 f8 75             	cmp    $0x75,%eax
c0027b02:	74 10                	je     c0027b14 <__vprintf+0x306>
c0027b04:	83 f8 78             	cmp    $0x78,%eax
c0027b07:	74 14                	je     c0027b1d <__vprintf+0x30f>
c0027b09:	eb 24                	jmp    c0027b2f <__vprintf+0x321>
              {
              case 'o': b = &base_o; break;
c0027b0b:	c7 45 d4 9c 0c 03 c0 	movl   $0xc0030c9c,-0x2c(%ebp)
c0027b12:	eb 34                	jmp    c0027b48 <__vprintf+0x33a>
              case 'u': b = &base_d; break;
c0027b14:	c7 45 d4 80 0c 03 c0 	movl   $0xc0030c80,-0x2c(%ebp)
c0027b1b:	eb 2b                	jmp    c0027b48 <__vprintf+0x33a>
              case 'x': b = &base_x; break;
c0027b1d:	c7 45 d4 c0 0c 03 c0 	movl   $0xc0030cc0,-0x2c(%ebp)
c0027b24:	eb 22                	jmp    c0027b48 <__vprintf+0x33a>
              case 'X': b = &base_X; break;
c0027b26:	c7 45 d4 e4 0c 03 c0 	movl   $0xc0030ce4,-0x2c(%ebp)
c0027b2d:	eb 19                	jmp    c0027b48 <__vprintf+0x33a>
              default: NOT_REACHED ();
c0027b2f:	68 f4 0c 03 c0       	push   $0xc0030cf4
c0027b34:	68 28 0f 03 c0       	push   $0xc0030f28
c0027b39:	68 14 01 00 00       	push   $0x114
c0027b3e:	68 16 0d 03 c0       	push   $0xc0030d16
c0027b43:	e8 d3 20 00 00       	call   c0029c1b <debug_panic>
              }

            format_integer (value, false, false, b, &c, output, aux);
c0027b48:	ff 75 14             	pushl  0x14(%ebp)
c0027b4b:	ff 75 10             	pushl  0x10(%ebp)
c0027b4e:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027b51:	50                   	push   %eax
c0027b52:	ff 75 d4             	pushl  -0x2c(%ebp)
c0027b55:	6a 00                	push   $0x0
c0027b57:	6a 00                	push   $0x0
c0027b59:	ff 75 dc             	pushl  -0x24(%ebp)
c0027b5c:	ff 75 d8             	pushl  -0x28(%ebp)
c0027b5f:	e8 dc 03 00 00       	call   c0027f40 <format_integer>
c0027b64:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027b67:	e9 f1 00 00 00       	jmp    c0027c5d <__vprintf+0x44f>

        case 'c': 
          {
            /* Treat character as single-character string. */
            char ch = va_arg (args, int);
c0027b6c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027b6f:	8d 50 04             	lea    0x4(%eax),%edx
c0027b72:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027b75:	8b 00                	mov    (%eax),%eax
c0027b77:	88 45 bb             	mov    %al,-0x45(%ebp)
            format_string (&ch, 1, &c, output, aux);
c0027b7a:	83 ec 0c             	sub    $0xc,%esp
c0027b7d:	ff 75 14             	pushl  0x14(%ebp)
c0027b80:	ff 75 10             	pushl  0x10(%ebp)
c0027b83:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027b86:	50                   	push   %eax
c0027b87:	6a 01                	push   $0x1
c0027b89:	8d 45 bb             	lea    -0x45(%ebp),%eax
c0027b8c:	50                   	push   %eax
c0027b8d:	e8 d0 06 00 00       	call   c0028262 <format_string>
c0027b92:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027b95:	e9 c3 00 00 00       	jmp    c0027c5d <__vprintf+0x44f>

        case 's':
          {
            /* String conversion. */
            const char *s = va_arg (args, char *);
c0027b9a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027b9d:	8d 50 04             	lea    0x4(%eax),%edx
c0027ba0:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027ba3:	8b 00                	mov    (%eax),%eax
c0027ba5:	89 45 d0             	mov    %eax,-0x30(%ebp)
            if (s == NULL)
c0027ba8:	83 7d d0 00          	cmpl   $0x0,-0x30(%ebp)
c0027bac:	75 07                	jne    c0027bb5 <__vprintf+0x3a7>
              s = "(null)";
c0027bae:	c7 45 d0 28 0d 03 c0 	movl   $0xc0030d28,-0x30(%ebp)

            /* Limit string length according to precision.
               Note: if c.precision == -1 then strnlen() will get
               SIZE_MAX for MAXLEN, which is just what we want. */
            format_string (s, strnlen (s, c.precision), &c, output, aux);
c0027bb5:	8b 45 c4             	mov    -0x3c(%ebp),%eax
c0027bb8:	83 ec 08             	sub    $0x8,%esp
c0027bbb:	50                   	push   %eax
c0027bbc:	ff 75 d0             	pushl  -0x30(%ebp)
c0027bbf:	e8 f3 14 00 00       	call   c00290b7 <strnlen>
c0027bc4:	83 c4 10             	add    $0x10,%esp
c0027bc7:	89 c2                	mov    %eax,%edx
c0027bc9:	83 ec 0c             	sub    $0xc,%esp
c0027bcc:	ff 75 14             	pushl  0x14(%ebp)
c0027bcf:	ff 75 10             	pushl  0x10(%ebp)
c0027bd2:	8d 45 bc             	lea    -0x44(%ebp),%eax
c0027bd5:	50                   	push   %eax
c0027bd6:	52                   	push   %edx
c0027bd7:	ff 75 d0             	pushl  -0x30(%ebp)
c0027bda:	e8 83 06 00 00       	call   c0028262 <format_string>
c0027bdf:	83 c4 20             	add    $0x20,%esp
          }
          break;
c0027be2:	eb 79                	jmp    c0027c5d <__vprintf+0x44f>
          
        case 'p':
          {
            /* Pointer conversion.
               Format pointers as %#x. */
            void *p = va_arg (args, void *);
c0027be4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027be7:	8d 50 04             	lea    0x4(%eax),%edx
c0027bea:	89 55 0c             	mov    %edx,0xc(%ebp)
c0027bed:	8b 00                	mov    (%eax),%eax
c0027bef:	89 45 cc             	mov    %eax,-0x34(%ebp)

            c.flags = POUND;
c0027bf2:	c7 45 bc 08 00 00 00 	movl   $0x8,-0x44(%ebp)
            format_integer ((uintptr_t) p, false, false,
c0027bf9:	8b 45 cc             	mov    -0x34(%ebp),%eax
c0027bfc:	ba 00 00 00 00       	mov    $0x0,%edx
c0027c01:	ff 75 14             	pushl  0x14(%ebp)
c0027c04:	ff 75 10             	pushl  0x10(%ebp)
c0027c07:	8d 4d bc             	lea    -0x44(%ebp),%ecx
c0027c0a:	51                   	push   %ecx
c0027c0b:	68 c0 0c 03 c0       	push   $0xc0030cc0
c0027c10:	6a 00                	push   $0x0
c0027c12:	6a 00                	push   $0x0
c0027c14:	52                   	push   %edx
c0027c15:	50                   	push   %eax
c0027c16:	e8 25 03 00 00       	call   c0027f40 <format_integer>
c0027c1b:	83 c4 20             	add    $0x20,%esp
                            &base_x, &c, output, aux);
          }
          break;
c0027c1e:	eb 3d                	jmp    c0027c5d <__vprintf+0x44f>
        case 'g':
        case 'G':
        case 'n':
          /* We don't support floating-point arithmetic,
             and %n can be part of a security hole. */
          __printf ("<<no %%%c in kernel>>", output, aux, *format);
c0027c20:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c23:	0f b6 00             	movzbl (%eax),%eax
c0027c26:	0f be c0             	movsbl %al,%eax
c0027c29:	50                   	push   %eax
c0027c2a:	ff 75 14             	pushl  0x14(%ebp)
c0027c2d:	ff 75 10             	pushl  0x10(%ebp)
c0027c30:	68 2f 0d 03 c0       	push   $0xc0030d2f
c0027c35:	e8 c5 06 00 00       	call   c00282ff <__printf>
c0027c3a:	83 c4 10             	add    $0x10,%esp
          break;
c0027c3d:	eb 1e                	jmp    c0027c5d <__vprintf+0x44f>

        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
c0027c3f:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c42:	0f b6 00             	movzbl (%eax),%eax
c0027c45:	0f be c0             	movsbl %al,%eax
c0027c48:	50                   	push   %eax
c0027c49:	ff 75 14             	pushl  0x14(%ebp)
c0027c4c:	ff 75 10             	pushl  0x10(%ebp)
c0027c4f:	68 45 0d 03 c0       	push   $0xc0030d45
c0027c54:	e8 a6 06 00 00       	call   c00282ff <__printf>
c0027c59:	83 c4 10             	add    $0x10,%esp
          break;
c0027c5c:	90                   	nop

void
__vprintf (const char *format, va_list args,
           void (*output) (char, void *), void *aux)
{
  for (; *format != '\0'; format++)
c0027c5d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0027c61:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c64:	0f b6 00             	movzbl (%eax),%eax
c0027c67:	84 c0                	test   %al,%al
c0027c69:	0f 85 ad fb ff ff    	jne    c002781c <__vprintf+0xe>
        default:
          __printf ("<<no %%%c conversion>>", output, aux, *format);
          break;
        }
    }
}
c0027c6f:	90                   	nop
c0027c70:	8d 65 f4             	lea    -0xc(%ebp),%esp
c0027c73:	5b                   	pop    %ebx
c0027c74:	5e                   	pop    %esi
c0027c75:	5f                   	pop    %edi
c0027c76:	5d                   	pop    %ebp
c0027c77:	c3                   	ret    

c0027c78 <parse_conversion>:
   that indicates the conversion (e.g. the `d' in `%d').  Uses
   *ARGS for `*' field widths and precisions. */
static const char *
parse_conversion (const char *format, struct printf_conversion *c,
                  va_list *args) 
{
c0027c78:	55                   	push   %ebp
c0027c79:	89 e5                	mov    %esp,%ebp
  /* Parse flag characters. */
  c->flags = 0;
c0027c7b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027c7e:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (;;) 
    {
      switch (*format++) 
c0027c84:	8b 45 08             	mov    0x8(%ebp),%eax
c0027c87:	8d 50 01             	lea    0x1(%eax),%edx
c0027c8a:	89 55 08             	mov    %edx,0x8(%ebp)
c0027c8d:	0f b6 00             	movzbl (%eax),%eax
c0027c90:	0f be c0             	movsbl %al,%eax
c0027c93:	83 e8 20             	sub    $0x20,%eax
c0027c96:	83 f8 10             	cmp    $0x10,%eax
c0027c99:	77 6f                	ja     c0027d0a <parse_conversion+0x92>
c0027c9b:	8b 04 85 74 0e 03 c0 	mov    -0x3ffcf18c(,%eax,4),%eax
c0027ca2:	ff e0                	jmp    *%eax
        {
        case '-':
          c->flags |= MINUS;
c0027ca4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ca7:	8b 00                	mov    (%eax),%eax
c0027ca9:	83 c8 01             	or     $0x1,%eax
c0027cac:	89 c2                	mov    %eax,%edx
c0027cae:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cb1:	89 10                	mov    %edx,(%eax)
          break;
c0027cb3:	eb 68                	jmp    c0027d1d <parse_conversion+0xa5>
        case '+':
          c->flags |= PLUS;
c0027cb5:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cb8:	8b 00                	mov    (%eax),%eax
c0027cba:	83 c8 02             	or     $0x2,%eax
c0027cbd:	89 c2                	mov    %eax,%edx
c0027cbf:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cc2:	89 10                	mov    %edx,(%eax)
          break;
c0027cc4:	eb 57                	jmp    c0027d1d <parse_conversion+0xa5>
        case ' ':
          c->flags |= SPACE;
c0027cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cc9:	8b 00                	mov    (%eax),%eax
c0027ccb:	83 c8 04             	or     $0x4,%eax
c0027cce:	89 c2                	mov    %eax,%edx
c0027cd0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cd3:	89 10                	mov    %edx,(%eax)
          break;
c0027cd5:	eb 46                	jmp    c0027d1d <parse_conversion+0xa5>
        case '#':
          c->flags |= POUND;
c0027cd7:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cda:	8b 00                	mov    (%eax),%eax
c0027cdc:	83 c8 08             	or     $0x8,%eax
c0027cdf:	89 c2                	mov    %eax,%edx
c0027ce1:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ce4:	89 10                	mov    %edx,(%eax)
          break;
c0027ce6:	eb 35                	jmp    c0027d1d <parse_conversion+0xa5>
        case '0':
          c->flags |= ZERO;
c0027ce8:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ceb:	8b 00                	mov    (%eax),%eax
c0027ced:	83 c8 10             	or     $0x10,%eax
c0027cf0:	89 c2                	mov    %eax,%edx
c0027cf2:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cf5:	89 10                	mov    %edx,(%eax)
          break;
c0027cf7:	eb 24                	jmp    c0027d1d <parse_conversion+0xa5>
        case '\'':
          c->flags |= GROUP;
c0027cf9:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027cfc:	8b 00                	mov    (%eax),%eax
c0027cfe:	83 c8 20             	or     $0x20,%eax
c0027d01:	89 c2                	mov    %eax,%edx
c0027d03:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d06:	89 10                	mov    %edx,(%eax)
          break;
c0027d08:	eb 13                	jmp    c0027d1d <parse_conversion+0xa5>
        default:
          format--;
c0027d0a:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
          goto not_a_flag;
c0027d0e:	90                   	nop
        }
    }
 not_a_flag:
  if (c->flags & MINUS)
c0027d0f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d12:	8b 00                	mov    (%eax),%eax
c0027d14:	83 e0 01             	and    $0x1,%eax
c0027d17:	85 c0                	test   %eax,%eax
c0027d19:	74 16                	je     c0027d31 <parse_conversion+0xb9>
c0027d1b:	eb 05                	jmp    c0027d22 <parse_conversion+0xaa>
          break;
        default:
          format--;
          goto not_a_flag;
        }
    }
c0027d1d:	e9 62 ff ff ff       	jmp    c0027c84 <parse_conversion+0xc>
 not_a_flag:
  if (c->flags & MINUS)
    c->flags &= ~ZERO;
c0027d22:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d25:	8b 00                	mov    (%eax),%eax
c0027d27:	83 e0 ef             	and    $0xffffffef,%eax
c0027d2a:	89 c2                	mov    %eax,%edx
c0027d2c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d2f:	89 10                	mov    %edx,(%eax)
  if (c->flags & PLUS)
c0027d31:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d34:	8b 00                	mov    (%eax),%eax
c0027d36:	83 e0 02             	and    $0x2,%eax
c0027d39:	85 c0                	test   %eax,%eax
c0027d3b:	74 0f                	je     c0027d4c <parse_conversion+0xd4>
    c->flags &= ~SPACE;
c0027d3d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d40:	8b 00                	mov    (%eax),%eax
c0027d42:	83 e0 fb             	and    $0xfffffffb,%eax
c0027d45:	89 c2                	mov    %eax,%edx
c0027d47:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d4a:	89 10                	mov    %edx,(%eax)

  /* Parse field width. */
  c->width = 0;
c0027d4c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d4f:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  if (*format == '*')
c0027d56:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d59:	0f b6 00             	movzbl (%eax),%eax
c0027d5c:	3c 2a                	cmp    $0x2a,%al
c0027d5e:	75 44                	jne    c0027da4 <parse_conversion+0x12c>
    {
      format++;
c0027d60:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      c->width = va_arg (*args, int);
c0027d64:	8b 45 10             	mov    0x10(%ebp),%eax
c0027d67:	8b 00                	mov    (%eax),%eax
c0027d69:	8d 48 04             	lea    0x4(%eax),%ecx
c0027d6c:	8b 55 10             	mov    0x10(%ebp),%edx
c0027d6f:	89 0a                	mov    %ecx,(%edx)
c0027d71:	8b 10                	mov    (%eax),%edx
c0027d73:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d76:	89 50 04             	mov    %edx,0x4(%eax)
c0027d79:	eb 3f                	jmp    c0027dba <parse_conversion+0x142>
    }
  else 
    {
      for (; isdigit (*format); format++)
        c->width = c->width * 10 + *format - '0';
c0027d7b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d7e:	8b 50 04             	mov    0x4(%eax),%edx
c0027d81:	89 d0                	mov    %edx,%eax
c0027d83:	c1 e0 02             	shl    $0x2,%eax
c0027d86:	01 d0                	add    %edx,%eax
c0027d88:	01 c0                	add    %eax,%eax
c0027d8a:	89 c2                	mov    %eax,%edx
c0027d8c:	8b 45 08             	mov    0x8(%ebp),%eax
c0027d8f:	0f b6 00             	movzbl (%eax),%eax
c0027d92:	0f be c0             	movsbl %al,%eax
c0027d95:	01 d0                	add    %edx,%eax
c0027d97:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027d9a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027d9d:	89 50 04             	mov    %edx,0x4(%eax)
      format++;
      c->width = va_arg (*args, int);
    }
  else 
    {
      for (; isdigit (*format); format++)
c0027da0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0027da4:	8b 45 08             	mov    0x8(%ebp),%eax
c0027da7:	0f b6 00             	movzbl (%eax),%eax
c0027daa:	0f be c0             	movsbl %al,%eax
c0027dad:	50                   	push   %eax
c0027dae:	e8 40 f9 ff ff       	call   c00276f3 <isdigit>
c0027db3:	83 c4 04             	add    $0x4,%esp
c0027db6:	85 c0                	test   %eax,%eax
c0027db8:	75 c1                	jne    c0027d7b <parse_conversion+0x103>
        c->width = c->width * 10 + *format - '0';
    }
  if (c->width < 0) 
c0027dba:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dbd:	8b 40 04             	mov    0x4(%eax),%eax
c0027dc0:	85 c0                	test   %eax,%eax
c0027dc2:	79 1f                	jns    c0027de3 <parse_conversion+0x16b>
    {
      c->width = -c->width;
c0027dc4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dc7:	8b 40 04             	mov    0x4(%eax),%eax
c0027dca:	f7 d8                	neg    %eax
c0027dcc:	89 c2                	mov    %eax,%edx
c0027dce:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dd1:	89 50 04             	mov    %edx,0x4(%eax)
      c->flags |= MINUS;
c0027dd4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027dd7:	8b 00                	mov    (%eax),%eax
c0027dd9:	83 c8 01             	or     $0x1,%eax
c0027ddc:	89 c2                	mov    %eax,%edx
c0027dde:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027de1:	89 10                	mov    %edx,(%eax)
    }
      
  /* Parse precision. */
  c->precision = -1;
c0027de3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027de6:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
  if (*format == '.') 
c0027ded:	8b 45 08             	mov    0x8(%ebp),%eax
c0027df0:	0f b6 00             	movzbl (%eax),%eax
c0027df3:	3c 2e                	cmp    $0x2e,%al
c0027df5:	0f 85 88 00 00 00    	jne    c0027e83 <parse_conversion+0x20b>
    {
      format++;
c0027dfb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      if (*format == '*') 
c0027dff:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e02:	0f b6 00             	movzbl (%eax),%eax
c0027e05:	3c 2a                	cmp    $0x2a,%al
c0027e07:	75 1b                	jne    c0027e24 <parse_conversion+0x1ac>
        {
          format++;
c0027e09:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->precision = va_arg (*args, int);
c0027e0d:	8b 45 10             	mov    0x10(%ebp),%eax
c0027e10:	8b 00                	mov    (%eax),%eax
c0027e12:	8d 48 04             	lea    0x4(%eax),%ecx
c0027e15:	8b 55 10             	mov    0x10(%ebp),%edx
c0027e18:	89 0a                	mov    %ecx,(%edx)
c0027e1a:	8b 10                	mov    (%eax),%edx
c0027e1c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e1f:	89 50 08             	mov    %edx,0x8(%eax)
c0027e22:	eb 4b                	jmp    c0027e6f <parse_conversion+0x1f7>
        }
      else 
        {
          c->precision = 0;
c0027e24:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e27:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          for (; isdigit (*format); format++)
c0027e2e:	eb 29                	jmp    c0027e59 <parse_conversion+0x1e1>
            c->precision = c->precision * 10 + *format - '0';
c0027e30:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e33:	8b 50 08             	mov    0x8(%eax),%edx
c0027e36:	89 d0                	mov    %edx,%eax
c0027e38:	c1 e0 02             	shl    $0x2,%eax
c0027e3b:	01 d0                	add    %edx,%eax
c0027e3d:	01 c0                	add    %eax,%eax
c0027e3f:	89 c2                	mov    %eax,%edx
c0027e41:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e44:	0f b6 00             	movzbl (%eax),%eax
c0027e47:	0f be c0             	movsbl %al,%eax
c0027e4a:	01 d0                	add    %edx,%eax
c0027e4c:	8d 50 d0             	lea    -0x30(%eax),%edx
c0027e4f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e52:	89 50 08             	mov    %edx,0x8(%eax)
          c->precision = va_arg (*args, int);
        }
      else 
        {
          c->precision = 0;
          for (; isdigit (*format); format++)
c0027e55:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0027e59:	8b 45 08             	mov    0x8(%ebp),%eax
c0027e5c:	0f b6 00             	movzbl (%eax),%eax
c0027e5f:	0f be c0             	movsbl %al,%eax
c0027e62:	50                   	push   %eax
c0027e63:	e8 8b f8 ff ff       	call   c00276f3 <isdigit>
c0027e68:	83 c4 04             	add    $0x4,%esp
c0027e6b:	85 c0                	test   %eax,%eax
c0027e6d:	75 c1                	jne    c0027e30 <parse_conversion+0x1b8>
            c->precision = c->precision * 10 + *format - '0';
        }
      if (c->precision < 0) 
c0027e6f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e72:	8b 40 08             	mov    0x8(%eax),%eax
c0027e75:	85 c0                	test   %eax,%eax
c0027e77:	79 0a                	jns    c0027e83 <parse_conversion+0x20b>
        c->precision = -1;
c0027e79:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e7c:	c7 40 08 ff ff ff ff 	movl   $0xffffffff,0x8(%eax)
    }
  if (c->precision >= 0)
c0027e83:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e86:	8b 40 08             	mov    0x8(%eax),%eax
c0027e89:	85 c0                	test   %eax,%eax
c0027e8b:	78 0f                	js     c0027e9c <parse_conversion+0x224>
    c->flags &= ~ZERO;
c0027e8d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e90:	8b 00                	mov    (%eax),%eax
c0027e92:	83 e0 ef             	and    $0xffffffef,%eax
c0027e95:	89 c2                	mov    %eax,%edx
c0027e97:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e9a:	89 10                	mov    %edx,(%eax)

  /* Parse type. */
  c->type = INT;
c0027e9c:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027e9f:	c7 40 0c 03 00 00 00 	movl   $0x3,0xc(%eax)
  switch (*format++) 
c0027ea6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ea9:	8d 50 01             	lea    0x1(%eax),%edx
c0027eac:	89 55 08             	mov    %edx,0x8(%ebp)
c0027eaf:	0f b6 00             	movzbl (%eax),%eax
c0027eb2:	0f be c0             	movsbl %al,%eax
c0027eb5:	83 e8 68             	sub    $0x68,%eax
c0027eb8:	83 f8 12             	cmp    $0x12,%eax
c0027ebb:	77 79                	ja     c0027f36 <parse_conversion+0x2be>
c0027ebd:	8b 04 85 b8 0e 03 c0 	mov    -0x3ffcf148(,%eax,4),%eax
c0027ec4:	ff e0                	jmp    *%eax
    {
    case 'h':
      if (*format == 'h') 
c0027ec6:	8b 45 08             	mov    0x8(%ebp),%eax
c0027ec9:	0f b6 00             	movzbl (%eax),%eax
c0027ecc:	3c 68                	cmp    $0x68,%al
c0027ece:	75 10                	jne    c0027ee0 <parse_conversion+0x268>
        {
          format++;
c0027ed0:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = CHAR;
c0027ed4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ed7:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        }
      else
        c->type = SHORT;
      break;
c0027ede:	eb 5b                	jmp    c0027f3b <parse_conversion+0x2c3>
        {
          format++;
          c->type = CHAR;
        }
      else
        c->type = SHORT;
c0027ee0:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027ee3:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
      break;
c0027eea:	eb 4f                	jmp    c0027f3b <parse_conversion+0x2c3>
      
    case 'j':
      c->type = INTMAX;
c0027eec:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027eef:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
      break;
c0027ef6:	eb 43                	jmp    c0027f3b <parse_conversion+0x2c3>

    case 'l':
      if (*format == 'l')
c0027ef8:	8b 45 08             	mov    0x8(%ebp),%eax
c0027efb:	0f b6 00             	movzbl (%eax),%eax
c0027efe:	3c 6c                	cmp    $0x6c,%al
c0027f00:	75 10                	jne    c0027f12 <parse_conversion+0x29a>
        {
          format++;
c0027f02:	83 45 08 01          	addl   $0x1,0x8(%ebp)
          c->type = LONGLONG;
c0027f06:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f09:	c7 40 0c 06 00 00 00 	movl   $0x6,0xc(%eax)
        }
      else
        c->type = LONG;
      break;
c0027f10:	eb 29                	jmp    c0027f3b <parse_conversion+0x2c3>
        {
          format++;
          c->type = LONGLONG;
        }
      else
        c->type = LONG;
c0027f12:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f15:	c7 40 0c 05 00 00 00 	movl   $0x5,0xc(%eax)
      break;
c0027f1c:	eb 1d                	jmp    c0027f3b <parse_conversion+0x2c3>

    case 't':
      c->type = PTRDIFFT;
c0027f1e:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f21:	c7 40 0c 07 00 00 00 	movl   $0x7,0xc(%eax)
      break;
c0027f28:	eb 11                	jmp    c0027f3b <parse_conversion+0x2c3>

    case 'z':
      c->type = SIZET;
c0027f2a:	8b 45 0c             	mov    0xc(%ebp),%eax
c0027f2d:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
      break;
c0027f34:	eb 05                	jmp    c0027f3b <parse_conversion+0x2c3>

    default:
      format--;
c0027f36:	83 6d 08 01          	subl   $0x1,0x8(%ebp)
      break;
c0027f3a:	90                   	nop
    }

  return format;
c0027f3b:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0027f3e:	c9                   	leave  
c0027f3f:	c3                   	ret    

c0027f40 <format_integer>:
static void
format_integer (uintmax_t value, bool is_signed, bool negative, 
                const struct integer_base *b,
                const struct printf_conversion *c,
                void (*output) (char, void *), void *aux)
{
c0027f40:	55                   	push   %ebp
c0027f41:	89 e5                	mov    %esp,%ebp
c0027f43:	57                   	push   %edi
c0027f44:	56                   	push   %esi
c0027f45:	53                   	push   %ebx
c0027f46:	83 ec 7c             	sub    $0x7c,%esp
c0027f49:	8b 55 10             	mov    0x10(%ebp),%edx
c0027f4c:	8b 45 14             	mov    0x14(%ebp),%eax
c0027f4f:	8b 4d 08             	mov    0x8(%ebp),%ecx
c0027f52:	89 4d 80             	mov    %ecx,-0x80(%ebp)
c0027f55:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c0027f58:	89 4d 84             	mov    %ecx,-0x7c(%ebp)
c0027f5b:	88 95 7c ff ff ff    	mov    %dl,-0x84(%ebp)
c0027f61:	88 85 78 ff ff ff    	mov    %al,-0x88(%ebp)
  int digit_cnt;                /* # of digits output so far. */

  /* Determine sign character, if any.
     An unsigned conversion will never have a sign character,
     even if one of the flags requests one. */
  sign = 0;
c0027f67:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  if (is_signed) 
c0027f6e:	80 bd 7c ff ff ff 00 	cmpb   $0x0,-0x84(%ebp)
c0027f75:	74 5c                	je     c0027fd3 <format_integer+0x93>
    {
      if (c->flags & PLUS)
c0027f77:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027f7a:	8b 00                	mov    (%eax),%eax
c0027f7c:	83 e0 02             	and    $0x2,%eax
c0027f7f:	85 c0                	test   %eax,%eax
c0027f81:	74 1a                	je     c0027f9d <format_integer+0x5d>
        sign = negative ? '-' : '+';
c0027f83:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027f8a:	74 07                	je     c0027f93 <format_integer+0x53>
c0027f8c:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027f91:	eb 05                	jmp    c0027f98 <format_integer+0x58>
c0027f93:	b8 2b 00 00 00       	mov    $0x2b,%eax
c0027f98:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027f9b:	eb 36                	jmp    c0027fd3 <format_integer+0x93>
      else if (c->flags & SPACE)
c0027f9d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027fa0:	8b 00                	mov    (%eax),%eax
c0027fa2:	83 e0 04             	and    $0x4,%eax
c0027fa5:	85 c0                	test   %eax,%eax
c0027fa7:	74 1a                	je     c0027fc3 <format_integer+0x83>
        sign = negative ? '-' : ' ';
c0027fa9:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027fb0:	74 07                	je     c0027fb9 <format_integer+0x79>
c0027fb2:	b8 2d 00 00 00       	mov    $0x2d,%eax
c0027fb7:	eb 05                	jmp    c0027fbe <format_integer+0x7e>
c0027fb9:	b8 20 00 00 00       	mov    $0x20,%eax
c0027fbe:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0027fc1:	eb 10                	jmp    c0027fd3 <format_integer+0x93>
      else if (negative)
c0027fc3:	80 bd 78 ff ff ff 00 	cmpb   $0x0,-0x88(%ebp)
c0027fca:	74 07                	je     c0027fd3 <format_integer+0x93>
        sign = '-';
c0027fcc:	c7 45 e0 2d 00 00 00 	movl   $0x2d,-0x20(%ebp)
    }

  /* Determine whether to include `0x' or `0X'.
     It will only be included with a hexadecimal conversion of a
     nonzero value with the # flag. */
  x = (c->flags & POUND) && value ? b->x : 0;
c0027fd3:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0027fd6:	8b 00                	mov    (%eax),%eax
c0027fd8:	83 e0 08             	and    $0x8,%eax
c0027fdb:	85 c0                	test   %eax,%eax
c0027fdd:	74 12                	je     c0027ff1 <format_integer+0xb1>
c0027fdf:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0027fe2:	0b 45 80             	or     -0x80(%ebp),%eax
c0027fe5:	85 c0                	test   %eax,%eax
c0027fe7:	74 08                	je     c0027ff1 <format_integer+0xb1>
c0027fe9:	8b 45 18             	mov    0x18(%ebp),%eax
c0027fec:	8b 40 08             	mov    0x8(%eax),%eax
c0027fef:	eb 05                	jmp    c0027ff6 <format_integer+0xb6>
c0027ff1:	b8 00 00 00 00       	mov    $0x0,%eax
c0027ff6:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
c0027ff9:	8d 45 90             	lea    -0x70(%ebp),%eax
c0027ffc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  digit_cnt = 0;
c0027fff:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  while (value > 0) 
c0028006:	e9 84 00 00 00       	jmp    c002808f <format_integer+0x14f>
    {
      if ((c->flags & GROUP) && digit_cnt > 0 && digit_cnt % b->group == 0)
c002800b:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002800e:	8b 00                	mov    (%eax),%eax
c0028010:	83 e0 20             	and    $0x20,%eax
c0028013:	85 c0                	test   %eax,%eax
c0028015:	74 24                	je     c002803b <format_integer+0xfb>
c0028017:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
c002801b:	7e 1e                	jle    c002803b <format_integer+0xfb>
c002801d:	8b 45 18             	mov    0x18(%ebp),%eax
c0028020:	8b 48 0c             	mov    0xc(%eax),%ecx
c0028023:	8b 45 d8             	mov    -0x28(%ebp),%eax
c0028026:	99                   	cltd   
c0028027:	f7 f9                	idiv   %ecx
c0028029:	89 d0                	mov    %edx,%eax
c002802b:	85 c0                	test   %eax,%eax
c002802d:	75 0c                	jne    c002803b <format_integer+0xfb>
        *cp++ = ',';
c002802f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028032:	8d 50 01             	lea    0x1(%eax),%edx
c0028035:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0028038:	c6 00 2c             	movb   $0x2c,(%eax)
      *cp++ = b->digits[value % b->base];
c002803b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
c002803e:	8d 46 01             	lea    0x1(%esi),%eax
c0028041:	89 45 e4             	mov    %eax,-0x1c(%ebp)
c0028044:	8b 45 18             	mov    0x18(%ebp),%eax
c0028047:	8b 78 04             	mov    0x4(%eax),%edi
c002804a:	8b 45 18             	mov    0x18(%ebp),%eax
c002804d:	8b 00                	mov    (%eax),%eax
c002804f:	89 c1                	mov    %eax,%ecx
c0028051:	89 c3                	mov    %eax,%ebx
c0028053:	c1 fb 1f             	sar    $0x1f,%ebx
c0028056:	8b 45 80             	mov    -0x80(%ebp),%eax
c0028059:	8b 55 84             	mov    -0x7c(%ebp),%edx
c002805c:	53                   	push   %ebx
c002805d:	51                   	push   %ecx
c002805e:	52                   	push   %edx
c002805f:	50                   	push   %eax
c0028060:	e8 2d 16 00 00       	call   c0029692 <__umoddi3>
c0028065:	83 c4 10             	add    $0x10,%esp
c0028068:	01 f8                	add    %edi,%eax
c002806a:	0f b6 00             	movzbl (%eax),%eax
c002806d:	88 06                	mov    %al,(%esi)
      value /= b->base;
c002806f:	8b 45 18             	mov    0x18(%ebp),%eax
c0028072:	8b 00                	mov    (%eax),%eax
c0028074:	99                   	cltd   
c0028075:	52                   	push   %edx
c0028076:	50                   	push   %eax
c0028077:	ff 75 84             	pushl  -0x7c(%ebp)
c002807a:	ff 75 80             	pushl  -0x80(%ebp)
c002807d:	e8 dc 15 00 00       	call   c002965e <__udivdi3>
c0028082:	83 c4 10             	add    $0x10,%esp
c0028085:	89 45 80             	mov    %eax,-0x80(%ebp)
c0028088:	89 55 84             	mov    %edx,-0x7c(%ebp)
      digit_cnt++;
c002808b:	83 45 d8 01          	addl   $0x1,-0x28(%ebp)
  /* Accumulate digits into buffer.
     This algorithm produces digits in reverse order, so later we
     will output the buffer's content in reverse. */
  cp = buf;
  digit_cnt = 0;
  while (value > 0) 
c002808f:	8b 45 84             	mov    -0x7c(%ebp),%eax
c0028092:	0b 45 80             	or     -0x80(%ebp),%eax
c0028095:	85 c0                	test   %eax,%eax
c0028097:	0f 85 6e ff ff ff    	jne    c002800b <format_integer+0xcb>
  /* Append enough zeros to match precision.
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
c002809d:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00280a0:	8b 40 08             	mov    0x8(%eax),%eax
c00280a3:	85 c0                	test   %eax,%eax
c00280a5:	78 08                	js     c00280af <format_integer+0x16f>
c00280a7:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00280aa:	8b 40 08             	mov    0x8(%eax),%eax
c00280ad:	eb 05                	jmp    c00280b4 <format_integer+0x174>
c00280af:	b8 01 00 00 00       	mov    $0x1,%eax
c00280b4:	89 45 d0             	mov    %eax,-0x30(%ebp)
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00280b7:	eb 0c                	jmp    c00280c5 <format_integer+0x185>
    *cp++ = '0';
c00280b9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00280bc:	8d 50 01             	lea    0x1(%eax),%edx
c00280bf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c00280c2:	c6 00 30             	movb   $0x30,(%eax)
     If requested precision is 0, then a value of zero is
     rendered as a null string, otherwise as "0".
     If the # flag is used with base 8, the result must always
     begin with a zero. */
  precision = c->precision < 0 ? 1 : c->precision;
  while (cp - buf < precision && cp < buf + sizeof buf - 1)
c00280c5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c00280c8:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280cb:	29 c2                	sub    %eax,%edx
c00280cd:	89 d0                	mov    %edx,%eax
c00280cf:	3b 45 d0             	cmp    -0x30(%ebp),%eax
c00280d2:	7d 0b                	jge    c00280df <format_integer+0x19f>
c00280d4:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280d7:	83 c0 3f             	add    $0x3f,%eax
c00280da:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00280dd:	77 da                	ja     c00280b9 <format_integer+0x179>
    *cp++ = '0';
  if ((c->flags & POUND) && b->base == 8 && (cp == buf || cp[-1] != '0'))
c00280df:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00280e2:	8b 00                	mov    (%eax),%eax
c00280e4:	83 e0 08             	and    $0x8,%eax
c00280e7:	85 c0                	test   %eax,%eax
c00280e9:	74 2b                	je     c0028116 <format_integer+0x1d6>
c00280eb:	8b 45 18             	mov    0x18(%ebp),%eax
c00280ee:	8b 00                	mov    (%eax),%eax
c00280f0:	83 f8 08             	cmp    $0x8,%eax
c00280f3:	75 21                	jne    c0028116 <format_integer+0x1d6>
c00280f5:	8d 45 90             	lea    -0x70(%ebp),%eax
c00280f8:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c00280fb:	74 0d                	je     c002810a <format_integer+0x1ca>
c00280fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0028100:	83 e8 01             	sub    $0x1,%eax
c0028103:	0f b6 00             	movzbl (%eax),%eax
c0028106:	3c 30                	cmp    $0x30,%al
c0028108:	74 0c                	je     c0028116 <format_integer+0x1d6>
    *cp++ = '0';
c002810a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002810d:	8d 50 01             	lea    0x1(%eax),%edx
c0028110:	89 55 e4             	mov    %edx,-0x1c(%ebp)
c0028113:	c6 00 30             	movb   $0x30,(%eax)

  /* Calculate number of pad characters to fill field width. */
  pad_cnt = c->width - (cp - buf) - (x ? 2 : 0) - (sign != 0);
c0028116:	8b 45 1c             	mov    0x1c(%ebp),%eax
c0028119:	8b 40 04             	mov    0x4(%eax),%eax
c002811c:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002811f:	8d 55 90             	lea    -0x70(%ebp),%edx
c0028122:	29 d1                	sub    %edx,%ecx
c0028124:	89 ca                	mov    %ecx,%edx
c0028126:	29 d0                	sub    %edx,%eax
c0028128:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002812c:	74 07                	je     c0028135 <format_integer+0x1f5>
c002812e:	ba 02 00 00 00       	mov    $0x2,%edx
c0028133:	eb 05                	jmp    c002813a <format_integer+0x1fa>
c0028135:	ba 00 00 00 00       	mov    $0x0,%edx
c002813a:	29 d0                	sub    %edx,%eax
c002813c:	89 c2                	mov    %eax,%edx
c002813e:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0028142:	0f 95 c0             	setne  %al
c0028145:	0f b6 c0             	movzbl %al,%eax
c0028148:	29 c2                	sub    %eax,%edx
c002814a:	89 d0                	mov    %edx,%eax
c002814c:	89 45 dc             	mov    %eax,-0x24(%ebp)
  if (pad_cnt < 0)
c002814f:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0028153:	79 07                	jns    c002815c <format_integer+0x21c>
    pad_cnt = 0;
c0028155:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)

  /* Do output. */
  if ((c->flags & (MINUS | ZERO)) == 0)
c002815c:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002815f:	8b 00                	mov    (%eax),%eax
c0028161:	83 e0 11             	and    $0x11,%eax
c0028164:	85 c0                	test   %eax,%eax
c0028166:	75 14                	jne    c002817c <format_integer+0x23c>
    output_dup (' ', pad_cnt, output, aux);
c0028168:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002816b:	ff 75 24             	pushl  0x24(%ebp)
c002816e:	ff 75 20             	pushl  0x20(%ebp)
c0028171:	50                   	push   %eax
c0028172:	6a 20                	push   $0x20
c0028174:	e8 b8 00 00 00       	call   c0028231 <output_dup>
c0028179:	83 c4 10             	add    $0x10,%esp
  if (sign)
c002817c:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c0028180:	74 15                	je     c0028197 <format_integer+0x257>
    output (sign, aux);
c0028182:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028185:	0f be c0             	movsbl %al,%eax
c0028188:	83 ec 08             	sub    $0x8,%esp
c002818b:	ff 75 24             	pushl  0x24(%ebp)
c002818e:	50                   	push   %eax
c002818f:	8b 45 20             	mov    0x20(%ebp),%eax
c0028192:	ff d0                	call   *%eax
c0028194:	83 c4 10             	add    $0x10,%esp
  if (x) 
c0028197:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002819b:	74 25                	je     c00281c2 <format_integer+0x282>
    {
      output ('0', aux);
c002819d:	83 ec 08             	sub    $0x8,%esp
c00281a0:	ff 75 24             	pushl  0x24(%ebp)
c00281a3:	6a 30                	push   $0x30
c00281a5:	8b 45 20             	mov    0x20(%ebp),%eax
c00281a8:	ff d0                	call   *%eax
c00281aa:	83 c4 10             	add    $0x10,%esp
      output (x, aux); 
c00281ad:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c00281b0:	0f be c0             	movsbl %al,%eax
c00281b3:	83 ec 08             	sub    $0x8,%esp
c00281b6:	ff 75 24             	pushl  0x24(%ebp)
c00281b9:	50                   	push   %eax
c00281ba:	8b 45 20             	mov    0x20(%ebp),%eax
c00281bd:	ff d0                	call   *%eax
c00281bf:	83 c4 10             	add    $0x10,%esp
    }
  if (c->flags & ZERO)
c00281c2:	8b 45 1c             	mov    0x1c(%ebp),%eax
c00281c5:	8b 00                	mov    (%eax),%eax
c00281c7:	83 e0 10             	and    $0x10,%eax
c00281ca:	85 c0                	test   %eax,%eax
c00281cc:	74 32                	je     c0028200 <format_integer+0x2c0>
    output_dup ('0', pad_cnt, output, aux);
c00281ce:	8b 45 dc             	mov    -0x24(%ebp),%eax
c00281d1:	ff 75 24             	pushl  0x24(%ebp)
c00281d4:	ff 75 20             	pushl  0x20(%ebp)
c00281d7:	50                   	push   %eax
c00281d8:	6a 30                	push   $0x30
c00281da:	e8 52 00 00 00       	call   c0028231 <output_dup>
c00281df:	83 c4 10             	add    $0x10,%esp
  while (cp > buf)
c00281e2:	eb 1c                	jmp    c0028200 <format_integer+0x2c0>
    output (*--cp, aux);
c00281e4:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
c00281e8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00281eb:	0f b6 00             	movzbl (%eax),%eax
c00281ee:	0f be c0             	movsbl %al,%eax
c00281f1:	83 ec 08             	sub    $0x8,%esp
c00281f4:	ff 75 24             	pushl  0x24(%ebp)
c00281f7:	50                   	push   %eax
c00281f8:	8b 45 20             	mov    0x20(%ebp),%eax
c00281fb:	ff d0                	call   *%eax
c00281fd:	83 c4 10             	add    $0x10,%esp
      output ('0', aux);
      output (x, aux); 
    }
  if (c->flags & ZERO)
    output_dup ('0', pad_cnt, output, aux);
  while (cp > buf)
c0028200:	8d 45 90             	lea    -0x70(%ebp),%eax
c0028203:	39 45 e4             	cmp    %eax,-0x1c(%ebp)
c0028206:	77 dc                	ja     c00281e4 <format_integer+0x2a4>
    output (*--cp, aux);
  if (c->flags & MINUS)
c0028208:	8b 45 1c             	mov    0x1c(%ebp),%eax
c002820b:	8b 00                	mov    (%eax),%eax
c002820d:	83 e0 01             	and    $0x1,%eax
c0028210:	85 c0                	test   %eax,%eax
c0028212:	74 14                	je     c0028228 <format_integer+0x2e8>
    output_dup (' ', pad_cnt, output, aux);
c0028214:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0028217:	ff 75 24             	pushl  0x24(%ebp)
c002821a:	ff 75 20             	pushl  0x20(%ebp)
c002821d:	50                   	push   %eax
c002821e:	6a 20                	push   $0x20
c0028220:	e8 0c 00 00 00       	call   c0028231 <output_dup>
c0028225:	83 c4 10             	add    $0x10,%esp
}
c0028228:	90                   	nop
c0028229:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002822c:	5b                   	pop    %ebx
c002822d:	5e                   	pop    %esi
c002822e:	5f                   	pop    %edi
c002822f:	5d                   	pop    %ebp
c0028230:	c3                   	ret    

c0028231 <output_dup>:

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
c0028231:	55                   	push   %ebp
c0028232:	89 e5                	mov    %esp,%ebp
c0028234:	83 ec 18             	sub    $0x18,%esp
c0028237:	8b 45 08             	mov    0x8(%ebp),%eax
c002823a:	88 45 f4             	mov    %al,-0xc(%ebp)
  while (cnt-- > 0)
c002823d:	eb 13                	jmp    c0028252 <output_dup+0x21>
    output (ch, aux);
c002823f:	0f be 45 f4          	movsbl -0xc(%ebp),%eax
c0028243:	83 ec 08             	sub    $0x8,%esp
c0028246:	ff 75 14             	pushl  0x14(%ebp)
c0028249:	50                   	push   %eax
c002824a:	8b 45 10             	mov    0x10(%ebp),%eax
c002824d:	ff d0                	call   *%eax
c002824f:	83 c4 10             	add    $0x10,%esp

/* Writes CH to OUTPUT with auxiliary data AUX, CNT times. */
static void
output_dup (char ch, size_t cnt, void (*output) (char, void *), void *aux) 
{
  while (cnt-- > 0)
c0028252:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028255:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028258:	89 55 0c             	mov    %edx,0xc(%ebp)
c002825b:	85 c0                	test   %eax,%eax
c002825d:	75 e0                	jne    c002823f <output_dup+0xe>
    output (ch, aux);
}
c002825f:	90                   	nop
c0028260:	c9                   	leave  
c0028261:	c3                   	ret    

c0028262 <format_string>:
   auxiliary data AUX. */
static void
format_string (const char *string, int length,
               struct printf_conversion *c,
               void (*output) (char, void *), void *aux) 
{
c0028262:	55                   	push   %ebp
c0028263:	89 e5                	mov    %esp,%ebp
c0028265:	83 ec 18             	sub    $0x18,%esp
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
c0028268:	8b 45 10             	mov    0x10(%ebp),%eax
c002826b:	8b 40 04             	mov    0x4(%eax),%eax
c002826e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0028271:	7e 26                	jle    c0028299 <format_string+0x37>
c0028273:	8b 45 10             	mov    0x10(%ebp),%eax
c0028276:	8b 00                	mov    (%eax),%eax
c0028278:	83 e0 01             	and    $0x1,%eax
c002827b:	85 c0                	test   %eax,%eax
c002827d:	75 1a                	jne    c0028299 <format_string+0x37>
    output_dup (' ', c->width - length, output, aux);
c002827f:	8b 45 10             	mov    0x10(%ebp),%eax
c0028282:	8b 40 04             	mov    0x4(%eax),%eax
c0028285:	2b 45 0c             	sub    0xc(%ebp),%eax
c0028288:	ff 75 18             	pushl  0x18(%ebp)
c002828b:	ff 75 14             	pushl  0x14(%ebp)
c002828e:	50                   	push   %eax
c002828f:	6a 20                	push   $0x20
c0028291:	e8 9b ff ff ff       	call   c0028231 <output_dup>
c0028296:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < length; i++)
c0028299:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c00282a0:	eb 21                	jmp    c00282c3 <format_string+0x61>
    output (string[i], aux);
c00282a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00282a5:	8b 45 08             	mov    0x8(%ebp),%eax
c00282a8:	01 d0                	add    %edx,%eax
c00282aa:	0f b6 00             	movzbl (%eax),%eax
c00282ad:	0f be c0             	movsbl %al,%eax
c00282b0:	83 ec 08             	sub    $0x8,%esp
c00282b3:	ff 75 18             	pushl  0x18(%ebp)
c00282b6:	50                   	push   %eax
c00282b7:	8b 45 14             	mov    0x14(%ebp),%eax
c00282ba:	ff d0                	call   *%eax
c00282bc:	83 c4 10             	add    $0x10,%esp
               void (*output) (char, void *), void *aux) 
{
  int i;
  if (c->width > length && (c->flags & MINUS) == 0)
    output_dup (' ', c->width - length, output, aux);
  for (i = 0; i < length; i++)
c00282bf:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00282c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00282c6:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00282c9:	7c d7                	jl     c00282a2 <format_string+0x40>
    output (string[i], aux);
  if (c->width > length && (c->flags & MINUS) != 0)
c00282cb:	8b 45 10             	mov    0x10(%ebp),%eax
c00282ce:	8b 40 04             	mov    0x4(%eax),%eax
c00282d1:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00282d4:	7e 26                	jle    c00282fc <format_string+0x9a>
c00282d6:	8b 45 10             	mov    0x10(%ebp),%eax
c00282d9:	8b 00                	mov    (%eax),%eax
c00282db:	83 e0 01             	and    $0x1,%eax
c00282de:	85 c0                	test   %eax,%eax
c00282e0:	74 1a                	je     c00282fc <format_string+0x9a>
    output_dup (' ', c->width - length, output, aux);
c00282e2:	8b 45 10             	mov    0x10(%ebp),%eax
c00282e5:	8b 40 04             	mov    0x4(%eax),%eax
c00282e8:	2b 45 0c             	sub    0xc(%ebp),%eax
c00282eb:	ff 75 18             	pushl  0x18(%ebp)
c00282ee:	ff 75 14             	pushl  0x14(%ebp)
c00282f1:	50                   	push   %eax
c00282f2:	6a 20                	push   $0x20
c00282f4:	e8 38 ff ff ff       	call   c0028231 <output_dup>
c00282f9:	83 c4 10             	add    $0x10,%esp
}
c00282fc:	90                   	nop
c00282fd:	c9                   	leave  
c00282fe:	c3                   	ret    

c00282ff <__printf>:
/* Wrapper for __vprintf() that converts varargs into a
   va_list. */
void
__printf (const char *format,
          void (*output) (char, void *), void *aux, ...) 
{
c00282ff:	55                   	push   %ebp
c0028300:	89 e5                	mov    %esp,%ebp
c0028302:	83 ec 18             	sub    $0x18,%esp
  va_list args;

  va_start (args, aux);
c0028305:	8d 45 14             	lea    0x14(%ebp),%eax
c0028308:	89 45 f4             	mov    %eax,-0xc(%ebp)
  __vprintf (format, args, output, aux);
c002830b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002830e:	ff 75 10             	pushl  0x10(%ebp)
c0028311:	ff 75 0c             	pushl  0xc(%ebp)
c0028314:	50                   	push   %eax
c0028315:	ff 75 08             	pushl  0x8(%ebp)
c0028318:	e8 f1 f4 ff ff       	call   c002780e <__vprintf>
c002831d:	83 c4 10             	add    $0x10,%esp
  va_end (args);
}
c0028320:	90                   	nop
c0028321:	c9                   	leave  
c0028322:	c3                   	ret    

c0028323 <hex_dump>:
   starting at OFS for the first byte in BUF.  If ASCII is true
   then the corresponding ASCII characters are also rendered
   alongside. */   
void
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
c0028323:	55                   	push   %ebp
c0028324:	89 e5                	mov    %esp,%ebp
c0028326:	83 ec 38             	sub    $0x38,%esp
c0028329:	8b 45 14             	mov    0x14(%ebp),%eax
c002832c:	88 45 d4             	mov    %al,-0x2c(%ebp)
  const uint8_t *buf = buf_;
c002832f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028332:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const size_t per_line = 16; /* Maximum bytes per line. */
c0028335:	c7 45 e8 10 00 00 00 	movl   $0x10,-0x18(%ebp)

  while (size > 0)
c002833c:	e9 bf 01 00 00       	jmp    c0028500 <hex_dump+0x1dd>
    {
      size_t start, end, n;
      size_t i;
      
      /* Number of bytes on this line. */
      start = ofs % per_line;
c0028341:	8b 45 08             	mov    0x8(%ebp),%eax
c0028344:	ba 00 00 00 00       	mov    $0x0,%edx
c0028349:	f7 75 e8             	divl   -0x18(%ebp)
c002834c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      end = per_line;
c002834f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0028352:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (end - start > size)
c0028355:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028358:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002835b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002835e:	76 0b                	jbe    c002836b <hex_dump+0x48>
        end = start + size;
c0028360:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c0028363:	8b 45 10             	mov    0x10(%ebp),%eax
c0028366:	01 d0                	add    %edx,%eax
c0028368:	89 45 f0             	mov    %eax,-0x10(%ebp)
      n = end - start;
c002836b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002836e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c0028371:	89 45 e0             	mov    %eax,-0x20(%ebp)

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
c0028374:	8b 45 08             	mov    0x8(%ebp),%eax
c0028377:	ba 00 00 00 00       	mov    $0x0,%edx
c002837c:	f7 75 e8             	divl   -0x18(%ebp)
c002837f:	0f af 45 e8          	imul   -0x18(%ebp),%eax
c0028383:	ba 00 00 00 00       	mov    $0x0,%edx
c0028388:	83 ec 04             	sub    $0x4,%esp
c002838b:	52                   	push   %edx
c002838c:	50                   	push   %eax
c002838d:	68 04 0f 03 c0       	push   $0xc0030f04
c0028392:	e8 51 f4 ff ff       	call   c00277e8 <printf>
c0028397:	83 c4 10             	add    $0x10,%esp
      for (i = 0; i < start; i++)
c002839a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c00283a1:	eb 14                	jmp    c00283b7 <hex_dump+0x94>
        printf ("   ");
c00283a3:	83 ec 0c             	sub    $0xc,%esp
c00283a6:	68 0c 0f 03 c0       	push   $0xc0030f0c
c00283ab:	e8 38 f4 ff ff       	call   c00277e8 <printf>
c00283b0:	83 c4 10             	add    $0x10,%esp
        end = start + size;
      n = end - start;

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
c00283b3:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c00283b7:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283ba:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c00283bd:	72 e4                	jb     c00283a3 <hex_dump+0x80>
        printf ("   ");
      for (; i < end; i++) 
c00283bf:	eb 42                	jmp    c0028403 <hex_dump+0xe0>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c00283c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00283c4:	d1 e8                	shr    %eax
c00283c6:	83 e8 01             	sub    $0x1,%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c00283c9:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c00283cc:	75 07                	jne    c00283d5 <hex_dump+0xb2>
c00283ce:	b9 2d 00 00 00       	mov    $0x2d,%ecx
c00283d3:	eb 05                	jmp    c00283da <hex_dump+0xb7>
c00283d5:	b9 20 00 00 00       	mov    $0x20,%ecx
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
c00283da:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00283dd:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c00283e0:	89 c2                	mov    %eax,%edx
c00283e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00283e5:	01 d0                	add    %edx,%eax
c00283e7:	0f b6 00             	movzbl (%eax),%eax
      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
        printf ("%02hhx%c",
c00283ea:	0f b6 c0             	movzbl %al,%eax
c00283ed:	83 ec 04             	sub    $0x4,%esp
c00283f0:	51                   	push   %ecx
c00283f1:	50                   	push   %eax
c00283f2:	68 10 0f 03 c0       	push   $0xc0030f10
c00283f7:	e8 ec f3 ff ff       	call   c00277e8 <printf>
c00283fc:	83 c4 10             	add    $0x10,%esp

      /* Print line. */
      printf ("%08jx  ", (uintmax_t) ROUND_DOWN (ofs, per_line));
      for (i = 0; i < start; i++)
        printf ("   ");
      for (; i < end; i++) 
c00283ff:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c0028403:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028406:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028409:	72 b6                	jb     c00283c1 <hex_dump+0x9e>
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
c002840b:	80 7d d4 00          	cmpb   $0x0,-0x2c(%ebp)
c002840f:	0f 84 cc 00 00 00    	je     c00284e1 <hex_dump+0x1be>
        {
          for (; i < per_line; i++)
c0028415:	eb 14                	jmp    c002842b <hex_dump+0x108>
            printf ("   ");
c0028417:	83 ec 0c             	sub    $0xc,%esp
c002841a:	68 0c 0f 03 c0       	push   $0xc0030f0c
c002841f:	e8 c4 f3 ff ff       	call   c00277e8 <printf>
c0028424:	83 c4 10             	add    $0x10,%esp
      for (; i < end; i++) 
        printf ("%02hhx%c",
                buf[i - start], i == per_line / 2 - 1? '-' : ' ');
      if (ascii) 
        {
          for (; i < per_line; i++)
c0028427:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002842b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002842e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c0028431:	72 e4                	jb     c0028417 <hex_dump+0xf4>
            printf ("   ");
          printf ("|");
c0028433:	83 ec 0c             	sub    $0xc,%esp
c0028436:	6a 7c                	push   $0x7c
c0028438:	e8 19 3a 00 00       	call   c002be56 <putchar>
c002843d:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
c0028440:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c0028447:	eb 11                	jmp    c002845a <hex_dump+0x137>
            printf (" ");
c0028449:	83 ec 0c             	sub    $0xc,%esp
c002844c:	6a 20                	push   $0x20
c002844e:	e8 03 3a 00 00       	call   c002be56 <putchar>
c0028453:	83 c4 10             	add    $0x10,%esp
      if (ascii) 
        {
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
c0028456:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002845a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002845d:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c0028460:	72 e7                	jb     c0028449 <hex_dump+0x126>
            printf (" ");
          for (; i < end; i++)
c0028462:	eb 4d                	jmp    c00284b1 <hex_dump+0x18e>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0028464:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028467:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002846a:	89 c2                	mov    %eax,%edx
c002846c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002846f:	01 d0                	add    %edx,%eax
c0028471:	0f b6 00             	movzbl (%eax),%eax
c0028474:	0f b6 c0             	movzbl %al,%eax
c0028477:	83 ec 0c             	sub    $0xc,%esp
c002847a:	50                   	push   %eax
c002847b:	e8 90 f2 ff ff       	call   c0027710 <isprint>
c0028480:	83 c4 10             	add    $0x10,%esp
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0028483:	85 c0                	test   %eax,%eax
c0028485:	74 15                	je     c002849c <hex_dump+0x179>
                    isprint (buf[i - start]) ? buf[i - start] : '.');
c0028487:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002848a:	2b 45 e4             	sub    -0x1c(%ebp),%eax
c002848d:	89 c2                	mov    %eax,%edx
c002848f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028492:	01 d0                	add    %edx,%eax
c0028494:	0f b6 00             	movzbl (%eax),%eax
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
c0028497:	0f b6 c0             	movzbl %al,%eax
c002849a:	eb 05                	jmp    c00284a1 <hex_dump+0x17e>
c002849c:	b8 2e 00 00 00       	mov    $0x2e,%eax
c00284a1:	83 ec 0c             	sub    $0xc,%esp
c00284a4:	50                   	push   %eax
c00284a5:	e8 ac 39 00 00       	call   c002be56 <putchar>
c00284aa:	83 c4 10             	add    $0x10,%esp
          for (; i < per_line; i++)
            printf ("   ");
          printf ("|");
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
c00284ad:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c00284b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00284b4:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00284b7:	72 ab                	jb     c0028464 <hex_dump+0x141>
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c00284b9:	eb 11                	jmp    c00284cc <hex_dump+0x1a9>
            printf (" ");
c00284bb:	83 ec 0c             	sub    $0xc,%esp
c00284be:	6a 20                	push   $0x20
c00284c0:	e8 91 39 00 00       	call   c002be56 <putchar>
c00284c5:	83 c4 10             	add    $0x10,%esp
          for (i = 0; i < start; i++)
            printf (" ");
          for (; i < end; i++)
            printf ("%c",
                    isprint (buf[i - start]) ? buf[i - start] : '.');
          for (; i < per_line; i++)
c00284c8:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c00284cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00284cf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c00284d2:	72 e7                	jb     c00284bb <hex_dump+0x198>
            printf (" ");
          printf ("|");
c00284d4:	83 ec 0c             	sub    $0xc,%esp
c00284d7:	6a 7c                	push   $0x7c
c00284d9:	e8 78 39 00 00       	call   c002be56 <putchar>
c00284de:	83 c4 10             	add    $0x10,%esp
        }
      printf ("\n");
c00284e1:	83 ec 0c             	sub    $0xc,%esp
c00284e4:	6a 0a                	push   $0xa
c00284e6:	e8 6b 39 00 00       	call   c002be56 <putchar>
c00284eb:	83 c4 10             	add    $0x10,%esp

      ofs += n;
c00284ee:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284f1:	01 45 08             	add    %eax,0x8(%ebp)
      buf += n;
c00284f4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284f7:	01 45 f4             	add    %eax,-0xc(%ebp)
      size -= n;
c00284fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
c00284fd:	29 45 10             	sub    %eax,0x10(%ebp)
hex_dump (uintptr_t ofs, const void *buf_, size_t size, bool ascii)
{
  const uint8_t *buf = buf_;
  const size_t per_line = 16; /* Maximum bytes per line. */

  while (size > 0)
c0028500:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028504:	0f 85 37 fe ff ff    	jne    c0028341 <hex_dump+0x1e>

      ofs += n;
      buf += n;
      size -= n;
    }
}
c002850a:	90                   	nop
c002850b:	c9                   	leave  
c002850c:	c3                   	ret    

c002850d <print_human_readable_size>:

/* Prints SIZE, which represents a number of bytes, in a
   human-readable format, e.g. "256 kB". */
void
print_human_readable_size (uint64_t size) 
{
c002850d:	55                   	push   %ebp
c002850e:	89 e5                	mov    %esp,%ebp
c0028510:	83 ec 28             	sub    $0x28,%esp
c0028513:	8b 45 08             	mov    0x8(%ebp),%eax
c0028516:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028519:	8b 45 0c             	mov    0xc(%ebp),%eax
c002851c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (size == 1)
c002851f:	8b 45 e0             	mov    -0x20(%ebp),%eax
c0028522:	83 f0 01             	xor    $0x1,%eax
c0028525:	0b 45 e4             	or     -0x1c(%ebp),%eax
c0028528:	85 c0                	test   %eax,%eax
c002852a:	75 12                	jne    c002853e <print_human_readable_size+0x31>
    printf ("1 byte");
c002852c:	83 ec 0c             	sub    $0xc,%esp
c002852f:	68 19 0f 03 c0       	push   $0xc0030f19
c0028534:	e8 af f2 ff ff       	call   c00277e8 <printf>
c0028539:	83 c4 10             	add    $0x10,%esp

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
    }
}
c002853c:	eb 5a                	jmp    c0028598 <print_human_readable_size+0x8b>
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002853e:	c7 45 f4 c8 81 03 c0 	movl   $0xc00381c8,-0xc(%ebp)
c0028545:	eb 17                	jmp    c002855e <print_human_readable_size+0x51>
        size /= 1024;
c0028547:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002854a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002854d:	0f ac d0 0a          	shrd   $0xa,%edx,%eax
c0028551:	c1 ea 0a             	shr    $0xa,%edx
c0028554:	89 45 e0             	mov    %eax,-0x20(%ebp)
c0028557:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  else 
    {
      static const char *factors[] = {"bytes", "kB", "MB", "GB", "TB", NULL};
      const char **fp;

      for (fp = factors; size >= 1024 && fp[1] != NULL; fp++)
c002855a:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002855e:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028562:	72 1b                	jb     c002857f <print_human_readable_size+0x72>
c0028564:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c0028568:	77 09                	ja     c0028573 <print_human_readable_size+0x66>
c002856a:	81 7d e0 ff 03 00 00 	cmpl   $0x3ff,-0x20(%ebp)
c0028571:	76 0c                	jbe    c002857f <print_human_readable_size+0x72>
c0028573:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028576:	83 c0 04             	add    $0x4,%eax
c0028579:	8b 00                	mov    (%eax),%eax
c002857b:	85 c0                	test   %eax,%eax
c002857d:	75 c8                	jne    c0028547 <print_human_readable_size+0x3a>
        size /= 1024;
      printf ("%"PRIu64" %s", size, *fp);
c002857f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028582:	8b 00                	mov    (%eax),%eax
c0028584:	50                   	push   %eax
c0028585:	ff 75 e4             	pushl  -0x1c(%ebp)
c0028588:	ff 75 e0             	pushl  -0x20(%ebp)
c002858b:	68 20 0f 03 c0       	push   $0xc0030f20
c0028590:	e8 53 f2 ff ff       	call   c00277e8 <printf>
c0028595:	83 c4 10             	add    $0x10,%esp
    }
}
c0028598:	90                   	nop
c0028599:	c9                   	leave  
c002859a:	c3                   	ret    

c002859b <isdigit>:
#define __LIB_CTYPE_H

static inline int islower (int c) { return c >= 'a' && c <= 'z'; }
static inline int isupper (int c) { return c >= 'A' && c <= 'Z'; }
static inline int isalpha (int c) { return islower (c) || isupper (c); }
static inline int isdigit (int c) { return c >= '0' && c <= '9'; }
c002859b:	55                   	push   %ebp
c002859c:	89 e5                	mov    %esp,%ebp
c002859e:	83 7d 08 2f          	cmpl   $0x2f,0x8(%ebp)
c00285a2:	7e 0d                	jle    c00285b1 <isdigit+0x16>
c00285a4:	83 7d 08 39          	cmpl   $0x39,0x8(%ebp)
c00285a8:	7f 07                	jg     c00285b1 <isdigit+0x16>
c00285aa:	b8 01 00 00 00       	mov    $0x1,%eax
c00285af:	eb 05                	jmp    c00285b6 <isdigit+0x1b>
c00285b1:	b8 00 00 00 00       	mov    $0x0,%eax
c00285b6:	5d                   	pop    %ebp
c00285b7:	c3                   	ret    

c00285b8 <isspace>:
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
c00285b8:	55                   	push   %ebp
c00285b9:	89 e5                	mov    %esp,%ebp
  return (c == ' ' || c == '\f' || c == '\n'
          || c == '\r' || c == '\t' || c == '\v');
c00285bb:	83 7d 08 20          	cmpl   $0x20,0x8(%ebp)
c00285bf:	74 1e                	je     c00285df <isspace+0x27>
static inline int isalnum (int c) { return isalpha (c) || isdigit (c); }
static inline int isxdigit (int c) {
  return isdigit (c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F');
}
static inline int isspace (int c) {
  return (c == ' ' || c == '\f' || c == '\n'
c00285c1:	83 7d 08 0c          	cmpl   $0xc,0x8(%ebp)
c00285c5:	74 18                	je     c00285df <isspace+0x27>
c00285c7:	83 7d 08 0a          	cmpl   $0xa,0x8(%ebp)
c00285cb:	74 12                	je     c00285df <isspace+0x27>
          || c == '\r' || c == '\t' || c == '\v');
c00285cd:	83 7d 08 0d          	cmpl   $0xd,0x8(%ebp)
c00285d1:	74 0c                	je     c00285df <isspace+0x27>
c00285d3:	83 7d 08 09          	cmpl   $0x9,0x8(%ebp)
c00285d7:	74 06                	je     c00285df <isspace+0x27>
c00285d9:	83 7d 08 0b          	cmpl   $0xb,0x8(%ebp)
c00285dd:	75 07                	jne    c00285e6 <isspace+0x2e>
c00285df:	b8 01 00 00 00       	mov    $0x1,%eax
c00285e4:	eb 05                	jmp    c00285eb <isspace+0x33>
c00285e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c00285eb:	5d                   	pop    %ebp
c00285ec:	c3                   	ret    

c00285ed <atoi>:

/* Converts a string representation of a signed decimal integer
   in S into an `int', which is returned. */
int
atoi (const char *s) 
{
c00285ed:	55                   	push   %ebp
c00285ee:	89 e5                	mov    %esp,%ebp
c00285f0:	83 ec 18             	sub    $0x18,%esp
  bool negative;
  int value;

  ASSERT (s != NULL);
c00285f3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00285f7:	75 22                	jne    c002861b <atoi+0x2e>
c00285f9:	83 ec 0c             	sub    $0xc,%esp
c00285fc:	68 44 0f 03 c0       	push   $0xc0030f44
c0028601:	68 4e 0f 03 c0       	push   $0xc0030f4e
c0028606:	68 ac 0f 03 c0       	push   $0xc0030fac
c002860b:	6a 0f                	push   $0xf
c002860d:	68 65 0f 03 c0       	push   $0xc0030f65
c0028612:	e8 04 16 00 00       	call   c0029c1b <debug_panic>

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
    s++;
c0028617:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  int value;

  ASSERT (s != NULL);

  /* Skip white space. */
  while (isspace ((unsigned char) *s))
c002861b:	8b 45 08             	mov    0x8(%ebp),%eax
c002861e:	0f b6 00             	movzbl (%eax),%eax
c0028621:	0f b6 c0             	movzbl %al,%eax
c0028624:	83 ec 0c             	sub    $0xc,%esp
c0028627:	50                   	push   %eax
c0028628:	e8 8b ff ff ff       	call   c00285b8 <isspace>
c002862d:	83 c4 10             	add    $0x10,%esp
c0028630:	85 c0                	test   %eax,%eax
c0028632:	75 e3                	jne    c0028617 <atoi+0x2a>
    s++;

  /* Parse sign. */
  negative = false;
c0028634:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
  if (*s == '+')
c0028638:	8b 45 08             	mov    0x8(%ebp),%eax
c002863b:	0f b6 00             	movzbl (%eax),%eax
c002863e:	3c 2b                	cmp    $0x2b,%al
c0028640:	75 06                	jne    c0028648 <atoi+0x5b>
    s++;
c0028642:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028646:	eb 12                	jmp    c002865a <atoi+0x6d>
  else if (*s == '-')
c0028648:	8b 45 08             	mov    0x8(%ebp),%eax
c002864b:	0f b6 00             	movzbl (%eax),%eax
c002864e:	3c 2d                	cmp    $0x2d,%al
c0028650:	75 08                	jne    c002865a <atoi+0x6d>
    {
      negative = true;
c0028652:	c6 45 f7 01          	movb   $0x1,-0x9(%ebp)
      s++;
c0028656:	83 45 08 01          	addl   $0x1,0x8(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c002865a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c0028661:	eb 25                	jmp    c0028688 <atoi+0x9b>
    value = value * 10 - (*s - '0');
c0028663:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028666:	89 d0                	mov    %edx,%eax
c0028668:	c1 e0 02             	shl    $0x2,%eax
c002866b:	01 d0                	add    %edx,%eax
c002866d:	01 c0                	add    %eax,%eax
c002866f:	89 c2                	mov    %eax,%edx
c0028671:	8b 45 08             	mov    0x8(%ebp),%eax
c0028674:	0f b6 00             	movzbl (%eax),%eax
c0028677:	0f be c0             	movsbl %al,%eax
c002867a:	83 e8 30             	sub    $0x30,%eax
c002867d:	29 c2                	sub    %eax,%edx
c002867f:	89 d0                	mov    %edx,%eax
c0028681:	89 45 f0             	mov    %eax,-0x10(%ebp)

  /* Parse digits.  We always initially parse the value as
     negative, and then make it positive later, because the
     negative range of an int is bigger than the positive range
     on a 2's complement system. */
  for (value = 0; isdigit (*s); s++)
c0028684:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028688:	8b 45 08             	mov    0x8(%ebp),%eax
c002868b:	0f b6 00             	movzbl (%eax),%eax
c002868e:	0f be c0             	movsbl %al,%eax
c0028691:	83 ec 0c             	sub    $0xc,%esp
c0028694:	50                   	push   %eax
c0028695:	e8 01 ff ff ff       	call   c002859b <isdigit>
c002869a:	83 c4 10             	add    $0x10,%esp
c002869d:	85 c0                	test   %eax,%eax
c002869f:	75 c2                	jne    c0028663 <atoi+0x76>
    value = value * 10 - (*s - '0');
  if (!negative)
c00286a1:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
c00286a5:	83 f0 01             	xor    $0x1,%eax
c00286a8:	84 c0                	test   %al,%al
c00286aa:	74 03                	je     c00286af <atoi+0xc2>
    value = -value;
c00286ac:	f7 5d f0             	negl   -0x10(%ebp)

  return value;
c00286af:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c00286b2:	c9                   	leave  
c00286b3:	c3                   	ret    

c00286b4 <compare_thunk>:

/* Compares A and B by calling the AUX function. */
static int
compare_thunk (const void *a, const void *b, void *aux) 
{
c00286b4:	55                   	push   %ebp
c00286b5:	89 e5                	mov    %esp,%ebp
c00286b7:	83 ec 18             	sub    $0x18,%esp
  int (**compare) (const void *, const void *) = aux;
c00286ba:	8b 45 10             	mov    0x10(%ebp),%eax
c00286bd:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return (*compare) (a, b);
c00286c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00286c3:	8b 00                	mov    (%eax),%eax
c00286c5:	83 ec 08             	sub    $0x8,%esp
c00286c8:	ff 75 0c             	pushl  0xc(%ebp)
c00286cb:	ff 75 08             	pushl  0x8(%ebp)
c00286ce:	ff d0                	call   *%eax
c00286d0:	83 c4 10             	add    $0x10,%esp
}
c00286d3:	c9                   	leave  
c00286d4:	c3                   	ret    

c00286d5 <qsort>:
   zero if A > B.  Runs in O(n lg n) time and O(1) space in
   CNT. */
void
qsort (void *array, size_t cnt, size_t size,
       int (*compare) (const void *, const void *)) 
{
c00286d5:	55                   	push   %ebp
c00286d6:	89 e5                	mov    %esp,%ebp
c00286d8:	83 ec 08             	sub    $0x8,%esp
  sort (array, cnt, size, compare_thunk, &compare);
c00286db:	83 ec 0c             	sub    $0xc,%esp
c00286de:	8d 45 14             	lea    0x14(%ebp),%eax
c00286e1:	50                   	push   %eax
c00286e2:	68 b4 86 02 c0       	push   $0xc00286b4
c00286e7:	ff 75 10             	pushl  0x10(%ebp)
c00286ea:	ff 75 0c             	pushl  0xc(%ebp)
c00286ed:	ff 75 08             	pushl  0x8(%ebp)
c00286f0:	e8 5f 01 00 00       	call   c0028854 <sort>
c00286f5:	83 c4 20             	add    $0x20,%esp
}
c00286f8:	90                   	nop
c00286f9:	c9                   	leave  
c00286fa:	c3                   	ret    

c00286fb <do_swap>:

/* Swaps elements with 1-based indexes A_IDX and B_IDX in ARRAY
   with elements of SIZE bytes each. */
static void
do_swap (unsigned char *array, size_t a_idx, size_t b_idx, size_t size)
{
c00286fb:	55                   	push   %ebp
c00286fc:	89 e5                	mov    %esp,%ebp
c00286fe:	83 ec 10             	sub    $0x10,%esp
  unsigned char *a = array + (a_idx - 1) * size;
c0028701:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028704:	83 e8 01             	sub    $0x1,%eax
c0028707:	0f af 45 14          	imul   0x14(%ebp),%eax
c002870b:	89 c2                	mov    %eax,%edx
c002870d:	8b 45 08             	mov    0x8(%ebp),%eax
c0028710:	01 d0                	add    %edx,%eax
c0028712:	89 45 f8             	mov    %eax,-0x8(%ebp)
  unsigned char *b = array + (b_idx - 1) * size;
c0028715:	8b 45 10             	mov    0x10(%ebp),%eax
c0028718:	83 e8 01             	sub    $0x1,%eax
c002871b:	0f af 45 14          	imul   0x14(%ebp),%eax
c002871f:	89 c2                	mov    %eax,%edx
c0028721:	8b 45 08             	mov    0x8(%ebp),%eax
c0028724:	01 d0                	add    %edx,%eax
c0028726:	89 45 f4             	mov    %eax,-0xc(%ebp)
  size_t i;

  for (i = 0; i < size; i++)
c0028729:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c0028730:	eb 35                	jmp    c0028767 <do_swap+0x6c>
    {
      unsigned char t = a[i];
c0028732:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028735:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028738:	01 d0                	add    %edx,%eax
c002873a:	0f b6 00             	movzbl (%eax),%eax
c002873d:	88 45 f3             	mov    %al,-0xd(%ebp)
      a[i] = b[i];
c0028740:	8b 55 f8             	mov    -0x8(%ebp),%edx
c0028743:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0028746:	01 c2                	add    %eax,%edx
c0028748:	8b 4d f4             	mov    -0xc(%ebp),%ecx
c002874b:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002874e:	01 c8                	add    %ecx,%eax
c0028750:	0f b6 00             	movzbl (%eax),%eax
c0028753:	88 02                	mov    %al,(%edx)
      b[i] = t;
c0028755:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0028758:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002875b:	01 c2                	add    %eax,%edx
c002875d:	0f b6 45 f3          	movzbl -0xd(%ebp),%eax
c0028761:	88 02                	mov    %al,(%edx)
{
  unsigned char *a = array + (a_idx - 1) * size;
  unsigned char *b = array + (b_idx - 1) * size;
  size_t i;

  for (i = 0; i < size; i++)
c0028763:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0028767:	8b 45 fc             	mov    -0x4(%ebp),%eax
c002876a:	3b 45 14             	cmp    0x14(%ebp),%eax
c002876d:	72 c3                	jb     c0028732 <do_swap+0x37>
    {
      unsigned char t = a[i];
      a[i] = b[i];
      b[i] = t;
    }
}
c002876f:	90                   	nop
c0028770:	c9                   	leave  
c0028771:	c3                   	ret    

c0028772 <do_compare>:
   strcmp()-type result. */
static int
do_compare (unsigned char *array, size_t a_idx, size_t b_idx, size_t size,
            int (*compare) (const void *, const void *, void *aux),
            void *aux) 
{
c0028772:	55                   	push   %ebp
c0028773:	89 e5                	mov    %esp,%ebp
c0028775:	83 ec 08             	sub    $0x8,%esp
  return compare (array + (a_idx - 1) * size, array + (b_idx - 1) * size, aux);
c0028778:	8b 45 10             	mov    0x10(%ebp),%eax
c002877b:	83 e8 01             	sub    $0x1,%eax
c002877e:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028782:	89 c2                	mov    %eax,%edx
c0028784:	8b 45 08             	mov    0x8(%ebp),%eax
c0028787:	01 c2                	add    %eax,%edx
c0028789:	8b 45 0c             	mov    0xc(%ebp),%eax
c002878c:	83 e8 01             	sub    $0x1,%eax
c002878f:	0f af 45 14          	imul   0x14(%ebp),%eax
c0028793:	89 c1                	mov    %eax,%ecx
c0028795:	8b 45 08             	mov    0x8(%ebp),%eax
c0028798:	01 c8                	add    %ecx,%eax
c002879a:	83 ec 04             	sub    $0x4,%esp
c002879d:	ff 75 1c             	pushl  0x1c(%ebp)
c00287a0:	52                   	push   %edx
c00287a1:	50                   	push   %eax
c00287a2:	8b 45 18             	mov    0x18(%ebp),%eax
c00287a5:	ff d0                	call   *%eax
c00287a7:	83 c4 10             	add    $0x10,%esp
}
c00287aa:	c9                   	leave  
c00287ab:	c3                   	ret    

c00287ac <heapify>:
   elements, passing AUX as auxiliary data. */
static void
heapify (unsigned char *array, size_t i, size_t cnt, size_t size,
         int (*compare) (const void *, const void *, void *aux),
         void *aux) 
{
c00287ac:	55                   	push   %ebp
c00287ad:	89 e5                	mov    %esp,%ebp
c00287af:	83 ec 18             	sub    $0x18,%esp
  for (;;) 
    {
      /* Set `max' to the index of the largest element among I
         and its children (if any). */
      size_t left = 2 * i;
c00287b2:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287b5:	01 c0                	add    %eax,%eax
c00287b7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t right = 2 * i + 1;
c00287ba:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287bd:	01 c0                	add    %eax,%eax
c00287bf:	83 c0 01             	add    $0x1,%eax
c00287c2:	89 45 ec             	mov    %eax,-0x14(%ebp)
      size_t max = i;
c00287c5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00287c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (left <= cnt && do_compare (array, left, max, size, compare, aux) > 0)
c00287cb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287ce:	3b 45 10             	cmp    0x10(%ebp),%eax
c00287d1:	77 27                	ja     c00287fa <heapify+0x4e>
c00287d3:	83 ec 08             	sub    $0x8,%esp
c00287d6:	ff 75 1c             	pushl  0x1c(%ebp)
c00287d9:	ff 75 18             	pushl  0x18(%ebp)
c00287dc:	ff 75 14             	pushl  0x14(%ebp)
c00287df:	ff 75 f4             	pushl  -0xc(%ebp)
c00287e2:	ff 75 f0             	pushl  -0x10(%ebp)
c00287e5:	ff 75 08             	pushl  0x8(%ebp)
c00287e8:	e8 85 ff ff ff       	call   c0028772 <do_compare>
c00287ed:	83 c4 20             	add    $0x20,%esp
c00287f0:	85 c0                	test   %eax,%eax
c00287f2:	7e 06                	jle    c00287fa <heapify+0x4e>
        max = left;
c00287f4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00287f7:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (right <= cnt
c00287fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00287fd:	3b 45 10             	cmp    0x10(%ebp),%eax
c0028800:	77 27                	ja     c0028829 <heapify+0x7d>
          && do_compare (array, right, max, size, compare, aux) > 0) 
c0028802:	83 ec 08             	sub    $0x8,%esp
c0028805:	ff 75 1c             	pushl  0x1c(%ebp)
c0028808:	ff 75 18             	pushl  0x18(%ebp)
c002880b:	ff 75 14             	pushl  0x14(%ebp)
c002880e:	ff 75 f4             	pushl  -0xc(%ebp)
c0028811:	ff 75 ec             	pushl  -0x14(%ebp)
c0028814:	ff 75 08             	pushl  0x8(%ebp)
c0028817:	e8 56 ff ff ff       	call   c0028772 <do_compare>
c002881c:	83 c4 20             	add    $0x20,%esp
c002881f:	85 c0                	test   %eax,%eax
c0028821:	7e 06                	jle    c0028829 <heapify+0x7d>
        max = right;
c0028823:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0028826:	89 45 f4             	mov    %eax,-0xc(%ebp)

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
c0028829:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002882c:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002882f:	74 1f                	je     c0028850 <heapify+0xa4>
        break;

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
c0028831:	ff 75 14             	pushl  0x14(%ebp)
c0028834:	ff 75 f4             	pushl  -0xc(%ebp)
c0028837:	ff 75 0c             	pushl  0xc(%ebp)
c002883a:	ff 75 08             	pushl  0x8(%ebp)
c002883d:	e8 b9 fe ff ff       	call   c00286fb <do_swap>
c0028842:	83 c4 10             	add    $0x10,%esp
      i = max;
c0028845:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028848:	89 45 0c             	mov    %eax,0xc(%ebp)
    }
c002884b:	e9 62 ff ff ff       	jmp    c00287b2 <heapify+0x6>
        max = right;

      /* If the maximum value is already in element I, we're
         done. */
      if (max == i)
        break;
c0028850:	90                   	nop

      /* Swap and continue down the heap. */
      do_swap (array, i, max, size);
      i = max;
    }
}
c0028851:	90                   	nop
c0028852:	c9                   	leave  
c0028853:	c3                   	ret    

c0028854 <sort>:
   B.  Runs in O(n lg n) time and O(1) space in CNT. */
void
sort (void *array, size_t cnt, size_t size,
      int (*compare) (const void *, const void *, void *aux),
      void *aux) 
{
c0028854:	55                   	push   %ebp
c0028855:	89 e5                	mov    %esp,%ebp
c0028857:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  ASSERT (array != NULL || cnt == 0);
c002885a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002885e:	75 27                	jne    c0028887 <sort+0x33>
c0028860:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028864:	74 21                	je     c0028887 <sort+0x33>
c0028866:	83 ec 0c             	sub    $0xc,%esp
c0028869:	68 78 0f 03 c0       	push   $0xc0030f78
c002886e:	68 4e 0f 03 c0       	push   $0xc0030f4e
c0028873:	68 b4 0f 03 c0       	push   $0xc0030fb4
c0028878:	68 8a 00 00 00       	push   $0x8a
c002887d:	68 65 0f 03 c0       	push   $0xc0030f65
c0028882:	e8 94 13 00 00       	call   c0029c1b <debug_panic>
  ASSERT (compare != NULL);
c0028887:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002888b:	75 21                	jne    c00288ae <sort+0x5a>
c002888d:	83 ec 0c             	sub    $0xc,%esp
c0028890:	68 92 0f 03 c0       	push   $0xc0030f92
c0028895:	68 4e 0f 03 c0       	push   $0xc0030f4e
c002889a:	68 b4 0f 03 c0       	push   $0xc0030fb4
c002889f:	68 8b 00 00 00       	push   $0x8b
c00288a4:	68 65 0f 03 c0       	push   $0xc0030f65
c00288a9:	e8 6d 13 00 00       	call   c0029c1b <debug_panic>
  ASSERT (size > 0);
c00288ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c00288b2:	75 21                	jne    c00288d5 <sort+0x81>
c00288b4:	83 ec 0c             	sub    $0xc,%esp
c00288b7:	68 a2 0f 03 c0       	push   $0xc0030fa2
c00288bc:	68 4e 0f 03 c0       	push   $0xc0030f4e
c00288c1:	68 b4 0f 03 c0       	push   $0xc0030fb4
c00288c6:	68 8c 00 00 00       	push   $0x8c
c00288cb:	68 65 0f 03 c0       	push   $0xc0030f65
c00288d0:	e8 46 13 00 00       	call   c0029c1b <debug_panic>

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00288d5:	8b 45 0c             	mov    0xc(%ebp),%eax
c00288d8:	d1 e8                	shr    %eax
c00288da:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00288dd:	eb 21                	jmp    c0028900 <sort+0xac>
    heapify (array, i, cnt, size, compare, aux);
c00288df:	83 ec 08             	sub    $0x8,%esp
c00288e2:	ff 75 18             	pushl  0x18(%ebp)
c00288e5:	ff 75 14             	pushl  0x14(%ebp)
c00288e8:	ff 75 10             	pushl  0x10(%ebp)
c00288eb:	ff 75 0c             	pushl  0xc(%ebp)
c00288ee:	ff 75 f4             	pushl  -0xc(%ebp)
c00288f1:	ff 75 08             	pushl  0x8(%ebp)
c00288f4:	e8 b3 fe ff ff       	call   c00287ac <heapify>
c00288f9:	83 c4 20             	add    $0x20,%esp
  ASSERT (array != NULL || cnt == 0);
  ASSERT (compare != NULL);
  ASSERT (size > 0);

  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
c00288fc:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0028900:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028904:	75 d9                	jne    c00288df <sort+0x8b>
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028906:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028909:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002890c:	eb 37                	jmp    c0028945 <sort+0xf1>
    {
      do_swap (array, 1, i, size);
c002890e:	ff 75 10             	pushl  0x10(%ebp)
c0028911:	ff 75 f4             	pushl  -0xc(%ebp)
c0028914:	6a 01                	push   $0x1
c0028916:	ff 75 08             	pushl  0x8(%ebp)
c0028919:	e8 dd fd ff ff       	call   c00286fb <do_swap>
c002891e:	83 c4 10             	add    $0x10,%esp
      heapify (array, 1, i - 1, size, compare, aux); 
c0028921:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028924:	83 e8 01             	sub    $0x1,%eax
c0028927:	83 ec 08             	sub    $0x8,%esp
c002892a:	ff 75 18             	pushl  0x18(%ebp)
c002892d:	ff 75 14             	pushl  0x14(%ebp)
c0028930:	ff 75 10             	pushl  0x10(%ebp)
c0028933:	50                   	push   %eax
c0028934:	6a 01                	push   $0x1
c0028936:	ff 75 08             	pushl  0x8(%ebp)
c0028939:	e8 6e fe ff ff       	call   c00287ac <heapify>
c002893e:	83 c4 20             	add    $0x20,%esp
  /* Build a heap. */
  for (i = cnt / 2; i > 0; i--)
    heapify (array, i, cnt, size, compare, aux);

  /* Sort the heap. */
  for (i = cnt; i > 1; i--) 
c0028941:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0028945:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c0028949:	77 c3                	ja     c002890e <sort+0xba>
    {
      do_swap (array, 1, i, size);
      heapify (array, 1, i - 1, size, compare, aux); 
    }
}
c002894b:	90                   	nop
c002894c:	c9                   	leave  
c002894d:	c3                   	ret    

c002894e <bsearch>:
   strcmp()-type result, i.e. less than zero if A < B, zero if A
   == B, greater than zero if A > B. */
void *
bsearch (const void *key, const void *array, size_t cnt,
         size_t size, int (*compare) (const void *, const void *)) 
{
c002894e:	55                   	push   %ebp
c002894f:	89 e5                	mov    %esp,%ebp
c0028951:	83 ec 08             	sub    $0x8,%esp
  return binary_search (key, array, cnt, size, compare_thunk, &compare);
c0028954:	83 ec 08             	sub    $0x8,%esp
c0028957:	8d 45 18             	lea    0x18(%ebp),%eax
c002895a:	50                   	push   %eax
c002895b:	68 b4 86 02 c0       	push   $0xc00286b4
c0028960:	ff 75 14             	pushl  0x14(%ebp)
c0028963:	ff 75 10             	pushl  0x10(%ebp)
c0028966:	ff 75 0c             	pushl  0xc(%ebp)
c0028969:	ff 75 08             	pushl  0x8(%ebp)
c002896c:	e8 05 00 00 00       	call   c0028976 <binary_search>
c0028971:	83 c4 20             	add    $0x20,%esp
}
c0028974:	c9                   	leave  
c0028975:	c3                   	ret    

c0028976 <binary_search>:
   B. */
void *
binary_search (const void *key, const void *array, size_t cnt, size_t size,
               int (*compare) (const void *, const void *, void *aux),
               void *aux) 
{
c0028976:	55                   	push   %ebp
c0028977:	89 e5                	mov    %esp,%ebp
c0028979:	83 ec 28             	sub    $0x28,%esp
  const unsigned char *first = array;
c002897c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002897f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *last = array + size * cnt;
c0028982:	8b 45 14             	mov    0x14(%ebp),%eax
c0028985:	0f af 45 10          	imul   0x10(%ebp),%eax
c0028989:	89 c2                	mov    %eax,%edx
c002898b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002898e:	01 d0                	add    %edx,%eax
c0028990:	89 45 f0             	mov    %eax,-0x10(%ebp)

  while (first < last) 
c0028993:	eb 65                	jmp    c00289fa <binary_search+0x84>
    {
      size_t range = (last - first) / size;
c0028995:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028998:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002899b:	29 c2                	sub    %eax,%edx
c002899d:	89 d0                	mov    %edx,%eax
c002899f:	ba 00 00 00 00       	mov    $0x0,%edx
c00289a4:	f7 75 14             	divl   0x14(%ebp)
c00289a7:	89 45 ec             	mov    %eax,-0x14(%ebp)
      const unsigned char *middle = first + (range / 2) * size;
c00289aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c00289ad:	d1 e8                	shr    %eax
c00289af:	0f af 45 14          	imul   0x14(%ebp),%eax
c00289b3:	89 c2                	mov    %eax,%edx
c00289b5:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289b8:	01 d0                	add    %edx,%eax
c00289ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
      int cmp = compare (key, middle, aux);
c00289bd:	83 ec 04             	sub    $0x4,%esp
c00289c0:	ff 75 1c             	pushl  0x1c(%ebp)
c00289c3:	ff 75 e8             	pushl  -0x18(%ebp)
c00289c6:	ff 75 08             	pushl  0x8(%ebp)
c00289c9:	8b 45 18             	mov    0x18(%ebp),%eax
c00289cc:	ff d0                	call   *%eax
c00289ce:	83 c4 10             	add    $0x10,%esp
c00289d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

      if (cmp < 0) 
c00289d4:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00289d8:	79 08                	jns    c00289e2 <binary_search+0x6c>
        last = middle;
c00289da:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00289dd:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00289e0:	eb 18                	jmp    c00289fa <binary_search+0x84>
      else if (cmp > 0) 
c00289e2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c00289e6:	7e 0d                	jle    c00289f5 <binary_search+0x7f>
        first = middle + size;
c00289e8:	8b 55 e8             	mov    -0x18(%ebp),%edx
c00289eb:	8b 45 14             	mov    0x14(%ebp),%eax
c00289ee:	01 d0                	add    %edx,%eax
c00289f0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00289f3:	eb 05                	jmp    c00289fa <binary_search+0x84>
      else
        return (void *) middle;
c00289f5:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00289f8:	eb 0d                	jmp    c0028a07 <binary_search+0x91>
               void *aux) 
{
  const unsigned char *first = array;
  const unsigned char *last = array + size * cnt;

  while (first < last) 
c00289fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00289fd:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028a00:	72 93                	jb     c0028995 <binary_search+0x1f>
        first = middle + size;
      else
        return (void *) middle;
    }
  
  return NULL;
c0028a02:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028a07:	c9                   	leave  
c0028a08:	c3                   	ret    

c0028a09 <memcpy>:

/* Copies SIZE bytes from SRC to DST, which must not overlap.
   Returns DST. */
void *
memcpy (void *dst_, const void *src_, size_t size) 
{
c0028a09:	55                   	push   %ebp
c0028a0a:	89 e5                	mov    %esp,%ebp
c0028a0c:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028a0f:	8b 45 08             	mov    0x8(%ebp),%eax
c0028a12:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028a15:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028a18:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028a1b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028a1f:	75 24                	jne    c0028a45 <memcpy+0x3c>
c0028a21:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a25:	74 1e                	je     c0028a45 <memcpy+0x3c>
c0028a27:	83 ec 0c             	sub    $0xc,%esp
c0028a2a:	68 bc 0f 03 c0       	push   $0xc0030fbc
c0028a2f:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028a34:	68 cc 10 03 c0       	push   $0xc00310cc
c0028a39:	6a 0c                	push   $0xc
c0028a3b:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028a40:	e8 d6 11 00 00       	call   c0029c1b <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028a45:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028a49:	75 3b                	jne    c0028a86 <memcpy+0x7d>
c0028a4b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028a4f:	74 35                	je     c0028a86 <memcpy+0x7d>
c0028a51:	83 ec 0c             	sub    $0xc,%esp
c0028a54:	68 ff 0f 03 c0       	push   $0xc0030fff
c0028a59:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028a5e:	68 cc 10 03 c0       	push   $0xc00310cc
c0028a63:	6a 0d                	push   $0xd
c0028a65:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028a6a:	e8 ac 11 00 00       	call   c0029c1b <debug_panic>

  while (size-- > 0)
    *dst++ = *src++;
c0028a6f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028a72:	8d 50 01             	lea    0x1(%eax),%edx
c0028a75:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028a78:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028a7b:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028a7e:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028a81:	0f b6 12             	movzbl (%edx),%edx
c0028a84:	88 10                	mov    %dl,(%eax)
  const unsigned char *src = src_;

  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  while (size-- > 0)
c0028a86:	8b 45 10             	mov    0x10(%ebp),%eax
c0028a89:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028a8c:	89 55 10             	mov    %edx,0x10(%ebp)
c0028a8f:	85 c0                	test   %eax,%eax
c0028a91:	75 dc                	jne    c0028a6f <memcpy+0x66>
    *dst++ = *src++;

  return dst_;
c0028a93:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0028a96:	c9                   	leave  
c0028a97:	c3                   	ret    

c0028a98 <memmove>:

/* Copies SIZE bytes from SRC to DST, which are allowed to
   overlap.  Returns DST. */
void *
memmove (void *dst_, const void *src_, size_t size) 
{
c0028a98:	55                   	push   %ebp
c0028a99:	89 e5                	mov    %esp,%ebp
c0028a9b:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0028a9e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028aa1:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *src = src_;
c0028aa4:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028aa7:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (dst != NULL || size == 0);
c0028aaa:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028aae:	75 24                	jne    c0028ad4 <memmove+0x3c>
c0028ab0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ab4:	74 1e                	je     c0028ad4 <memmove+0x3c>
c0028ab6:	83 ec 0c             	sub    $0xc,%esp
c0028ab9:	68 bc 0f 03 c0       	push   $0xc0030fbc
c0028abe:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028ac3:	68 d4 10 03 c0       	push   $0xc00310d4
c0028ac8:	6a 1d                	push   $0x1d
c0028aca:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028acf:	e8 47 11 00 00       	call   c0029c1b <debug_panic>
  ASSERT (src != NULL || size == 0);
c0028ad4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028ad8:	75 24                	jne    c0028afe <memmove+0x66>
c0028ada:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ade:	74 1e                	je     c0028afe <memmove+0x66>
c0028ae0:	83 ec 0c             	sub    $0xc,%esp
c0028ae3:	68 ff 0f 03 c0       	push   $0xc0030fff
c0028ae8:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028aed:	68 d4 10 03 c0       	push   $0xc00310d4
c0028af2:	6a 1e                	push   $0x1e
c0028af4:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028af9:	e8 1d 11 00 00       	call   c0029c1b <debug_panic>

  if (dst < src) 
c0028afe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b01:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c0028b04:	73 28                	jae    c0028b2e <memmove+0x96>
    {
      while (size-- > 0)
c0028b06:	eb 17                	jmp    c0028b1f <memmove+0x87>
        *dst++ = *src++;
c0028b08:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b0b:	8d 50 01             	lea    0x1(%eax),%edx
c0028b0e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0028b11:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0028b14:	8d 4a 01             	lea    0x1(%edx),%ecx
c0028b17:	89 4d f0             	mov    %ecx,-0x10(%ebp)
c0028b1a:	0f b6 12             	movzbl (%edx),%edx
c0028b1d:	88 10                	mov    %dl,(%eax)
  ASSERT (dst != NULL || size == 0);
  ASSERT (src != NULL || size == 0);

  if (dst < src) 
    {
      while (size-- > 0)
c0028b1f:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b22:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028b25:	89 55 10             	mov    %edx,0x10(%ebp)
c0028b28:	85 c0                	test   %eax,%eax
c0028b2a:	75 dc                	jne    c0028b08 <memmove+0x70>
c0028b2c:	eb 2e                	jmp    c0028b5c <memmove+0xc4>
        *dst++ = *src++;
    }
  else 
    {
      dst += size;
c0028b2e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b31:	01 45 f4             	add    %eax,-0xc(%ebp)
      src += size;
c0028b34:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b37:	01 45 f0             	add    %eax,-0x10(%ebp)
      while (size-- > 0)
c0028b3a:	eb 13                	jmp    c0028b4f <memmove+0xb7>
        *--dst = *--src;
c0028b3c:	83 6d f4 01          	subl   $0x1,-0xc(%ebp)
c0028b40:	83 6d f0 01          	subl   $0x1,-0x10(%ebp)
c0028b44:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028b47:	0f b6 10             	movzbl (%eax),%edx
c0028b4a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028b4d:	88 10                	mov    %dl,(%eax)
    }
  else 
    {
      dst += size;
      src += size;
      while (size-- > 0)
c0028b4f:	8b 45 10             	mov    0x10(%ebp),%eax
c0028b52:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028b55:	89 55 10             	mov    %edx,0x10(%ebp)
c0028b58:	85 c0                	test   %eax,%eax
c0028b5a:	75 e0                	jne    c0028b3c <memmove+0xa4>
        *--dst = *--src;
    }

  return dst;
c0028b5c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028b5f:	c9                   	leave  
c0028b60:	c3                   	ret    

c0028b61 <memcmp>:
   at A and B.  Returns a positive value if the byte in A is
   greater, a negative value if the byte in B is greater, or zero
   if blocks A and B are equal. */
int
memcmp (const void *a_, const void *b_, size_t size) 
{
c0028b61:	55                   	push   %ebp
c0028b62:	89 e5                	mov    %esp,%ebp
c0028b64:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = a_;
c0028b67:	8b 45 08             	mov    0x8(%ebp),%eax
c0028b6a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = b_;
c0028b6d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028b70:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL || size == 0);
c0028b73:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028b77:	75 24                	jne    c0028b9d <memcmp+0x3c>
c0028b79:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028b7d:	74 1e                	je     c0028b9d <memcmp+0x3c>
c0028b7f:	83 ec 0c             	sub    $0xc,%esp
c0028b82:	68 18 10 03 c0       	push   $0xc0031018
c0028b87:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028b8c:	68 dc 10 03 c0       	push   $0xc00310dc
c0028b91:	6a 3a                	push   $0x3a
c0028b93:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028b98:	e8 7e 10 00 00       	call   c0029c1b <debug_panic>
  ASSERT (b != NULL || size == 0);
c0028b9d:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028ba1:	75 5a                	jne    c0028bfd <memcmp+0x9c>
c0028ba3:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028ba7:	74 54                	je     c0028bfd <memcmp+0x9c>
c0028ba9:	83 ec 0c             	sub    $0xc,%esp
c0028bac:	68 2f 10 03 c0       	push   $0xc003102f
c0028bb1:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028bb6:	68 dc 10 03 c0       	push   $0xc00310dc
c0028bbb:	6a 3b                	push   $0x3b
c0028bbd:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028bc2:	e8 54 10 00 00       	call   c0029c1b <debug_panic>

  for (; size-- > 0; a++, b++)
    if (*a != *b)
c0028bc7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028bca:	0f b6 10             	movzbl (%eax),%edx
c0028bcd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028bd0:	0f b6 00             	movzbl (%eax),%eax
c0028bd3:	38 c2                	cmp    %al,%dl
c0028bd5:	74 1e                	je     c0028bf5 <memcmp+0x94>
      return *a > *b ? +1 : -1;
c0028bd7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028bda:	0f b6 10             	movzbl (%eax),%edx
c0028bdd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028be0:	0f b6 00             	movzbl (%eax),%eax
c0028be3:	38 c2                	cmp    %al,%dl
c0028be5:	76 07                	jbe    c0028bee <memcmp+0x8d>
c0028be7:	b8 01 00 00 00       	mov    $0x1,%eax
c0028bec:	eb 21                	jmp    c0028c0f <memcmp+0xae>
c0028bee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
c0028bf3:	eb 1a                	jmp    c0028c0f <memcmp+0xae>
  const unsigned char *b = b_;

  ASSERT (a != NULL || size == 0);
  ASSERT (b != NULL || size == 0);

  for (; size-- > 0; a++, b++)
c0028bf5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028bf9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c0028bfd:	8b 45 10             	mov    0x10(%ebp),%eax
c0028c00:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028c03:	89 55 10             	mov    %edx,0x10(%ebp)
c0028c06:	85 c0                	test   %eax,%eax
c0028c08:	75 bd                	jne    c0028bc7 <memcmp+0x66>
    if (*a != *b)
      return *a > *b ? +1 : -1;
  return 0;
c0028c0a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028c0f:	c9                   	leave  
c0028c10:	c3                   	ret    

c0028c11 <strcmp>:
   char) is greater, a negative value if the character in B (as
   an unsigned char) is greater, or zero if strings A and B are
   equal. */
int
strcmp (const char *a_, const char *b_) 
{
c0028c11:	55                   	push   %ebp
c0028c12:	89 e5                	mov    %esp,%ebp
c0028c14:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *a = (const unsigned char *) a_;
c0028c17:	8b 45 08             	mov    0x8(%ebp),%eax
c0028c1a:	89 45 f4             	mov    %eax,-0xc(%ebp)
  const unsigned char *b = (const unsigned char *) b_;
c0028c1d:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028c20:	89 45 f0             	mov    %eax,-0x10(%ebp)

  ASSERT (a != NULL);
c0028c23:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028c27:	75 1e                	jne    c0028c47 <strcmp+0x36>
c0028c29:	83 ec 0c             	sub    $0xc,%esp
c0028c2c:	68 46 10 03 c0       	push   $0xc0031046
c0028c31:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028c36:	68 e4 10 03 c0       	push   $0xc00310e4
c0028c3b:	6a 4e                	push   $0x4e
c0028c3d:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028c42:	e8 d4 0f 00 00       	call   c0029c1b <debug_panic>
  ASSERT (b != NULL);
c0028c47:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c0028c4b:	75 26                	jne    c0028c73 <strcmp+0x62>
c0028c4d:	83 ec 0c             	sub    $0xc,%esp
c0028c50:	68 50 10 03 c0       	push   $0xc0031050
c0028c55:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028c5a:	68 e4 10 03 c0       	push   $0xc00310e4
c0028c5f:	6a 4f                	push   $0x4f
c0028c61:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028c66:	e8 b0 0f 00 00       	call   c0029c1b <debug_panic>

  while (*a != '\0' && *a == *b) 
    {
      a++;
c0028c6b:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
      b++;
c0028c6f:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  const unsigned char *b = (const unsigned char *) b_;

  ASSERT (a != NULL);
  ASSERT (b != NULL);

  while (*a != '\0' && *a == *b) 
c0028c73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c76:	0f b6 00             	movzbl (%eax),%eax
c0028c79:	84 c0                	test   %al,%al
c0028c7b:	74 10                	je     c0028c8d <strcmp+0x7c>
c0028c7d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c80:	0f b6 10             	movzbl (%eax),%edx
c0028c83:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c86:	0f b6 00             	movzbl (%eax),%eax
c0028c89:	38 c2                	cmp    %al,%dl
c0028c8b:	74 de                	je     c0028c6b <strcmp+0x5a>
    {
      a++;
      b++;
    }

  return *a < *b ? -1 : *a > *b;
c0028c8d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028c90:	0f b6 10             	movzbl (%eax),%edx
c0028c93:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028c96:	0f b6 00             	movzbl (%eax),%eax
c0028c99:	38 c2                	cmp    %al,%dl
c0028c9b:	72 16                	jb     c0028cb3 <strcmp+0xa2>
c0028c9d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ca0:	0f b6 10             	movzbl (%eax),%edx
c0028ca3:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028ca6:	0f b6 00             	movzbl (%eax),%eax
c0028ca9:	38 c2                	cmp    %al,%dl
c0028cab:	0f 97 c0             	seta   %al
c0028cae:	0f b6 c0             	movzbl %al,%eax
c0028cb1:	eb 05                	jmp    c0028cb8 <strcmp+0xa7>
c0028cb3:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c0028cb8:	c9                   	leave  
c0028cb9:	c3                   	ret    

c0028cba <memchr>:
/* Returns a pointer to the first occurrence of CH in the first
   SIZE bytes starting at BLOCK.  Returns a null pointer if CH
   does not occur in BLOCK. */
void *
memchr (const void *block_, int ch_, size_t size) 
{
c0028cba:	55                   	push   %ebp
c0028cbb:	89 e5                	mov    %esp,%ebp
c0028cbd:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *block = block_;
c0028cc0:	8b 45 08             	mov    0x8(%ebp),%eax
c0028cc3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned char ch = ch_;
c0028cc6:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028cc9:	88 45 f3             	mov    %al,-0xd(%ebp)

  ASSERT (block != NULL || size == 0);
c0028ccc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c0028cd0:	75 38                	jne    c0028d0a <memchr+0x50>
c0028cd2:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028cd6:	74 32                	je     c0028d0a <memchr+0x50>
c0028cd8:	83 ec 0c             	sub    $0xc,%esp
c0028cdb:	68 5a 10 03 c0       	push   $0xc003105a
c0028ce0:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028ce5:	68 ec 10 03 c0       	push   $0xc00310ec
c0028cea:	6a 63                	push   $0x63
c0028cec:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028cf1:	e8 25 0f 00 00       	call   c0029c1b <debug_panic>

  for (; size-- > 0; block++)
    if (*block == ch)
c0028cf6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028cf9:	0f b6 00             	movzbl (%eax),%eax
c0028cfc:	3a 45 f3             	cmp    -0xd(%ebp),%al
c0028cff:	75 05                	jne    c0028d06 <memchr+0x4c>
      return (void *) block;
c0028d01:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028d04:	eb 16                	jmp    c0028d1c <memchr+0x62>
  const unsigned char *block = block_;
  unsigned char ch = ch_;

  ASSERT (block != NULL || size == 0);

  for (; size-- > 0; block++)
c0028d06:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028d0a:	8b 45 10             	mov    0x10(%ebp),%eax
c0028d0d:	8d 50 ff             	lea    -0x1(%eax),%edx
c0028d10:	89 55 10             	mov    %edx,0x10(%ebp)
c0028d13:	85 c0                	test   %eax,%eax
c0028d15:	75 df                	jne    c0028cf6 <memchr+0x3c>
    if (*block == ch)
      return (void *) block;

  return NULL;
c0028d17:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028d1c:	c9                   	leave  
c0028d1d:	c3                   	ret    

c0028d1e <strchr>:
   null pointer if C does not appear in STRING.  If C == '\0'
   then returns a pointer to the null terminator at the end of
   STRING. */
char *
strchr (const char *string, int c_) 
{
c0028d1e:	55                   	push   %ebp
c0028d1f:	89 e5                	mov    %esp,%ebp
c0028d21:	83 ec 18             	sub    $0x18,%esp
  char c = c_;
c0028d24:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028d27:	88 45 f7             	mov    %al,-0x9(%ebp)

  ASSERT (string != NULL);
c0028d2a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028d2e:	75 1e                	jne    c0028d4e <strchr+0x30>
c0028d30:	83 ec 0c             	sub    $0xc,%esp
c0028d33:	68 75 10 03 c0       	push   $0xc0031075
c0028d38:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028d3d:	68 f4 10 03 c0       	push   $0xc00310f4
c0028d42:	6a 75                	push   $0x75
c0028d44:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028d49:	e8 cd 0e 00 00       	call   c0029c1b <debug_panic>

  for (;;) 
    if (*string == c)
c0028d4e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d51:	0f b6 00             	movzbl (%eax),%eax
c0028d54:	3a 45 f7             	cmp    -0x9(%ebp),%al
c0028d57:	75 05                	jne    c0028d5e <strchr+0x40>
      return (char *) string;
c0028d59:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d5c:	eb 17                	jmp    c0028d75 <strchr+0x57>
    else if (*string == '\0')
c0028d5e:	8b 45 08             	mov    0x8(%ebp),%eax
c0028d61:	0f b6 00             	movzbl (%eax),%eax
c0028d64:	84 c0                	test   %al,%al
c0028d66:	75 07                	jne    c0028d6f <strchr+0x51>
      return NULL;
c0028d68:	b8 00 00 00 00       	mov    $0x0,%eax
c0028d6d:	eb 06                	jmp    c0028d75 <strchr+0x57>
    else
      string++;
c0028d6f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028d73:	eb d9                	jmp    c0028d4e <strchr+0x30>
}
c0028d75:	c9                   	leave  
c0028d76:	c3                   	ret    

c0028d77 <strcspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters that are not in STOP. */
size_t
strcspn (const char *string, const char *stop) 
{
c0028d77:	55                   	push   %ebp
c0028d78:	89 e5                	mov    %esp,%ebp
c0028d7a:	83 ec 18             	sub    $0x18,%esp
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028d7d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028d84:	eb 25                	jmp    c0028dab <strcspn+0x34>
    if (strchr (stop, string[length]) != NULL)
c0028d86:	8b 55 08             	mov    0x8(%ebp),%edx
c0028d89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028d8c:	01 d0                	add    %edx,%eax
c0028d8e:	0f b6 00             	movzbl (%eax),%eax
c0028d91:	0f be c0             	movsbl %al,%eax
c0028d94:	83 ec 08             	sub    $0x8,%esp
c0028d97:	50                   	push   %eax
c0028d98:	ff 75 0c             	pushl  0xc(%ebp)
c0028d9b:	e8 7e ff ff ff       	call   c0028d1e <strchr>
c0028da0:	83 c4 10             	add    $0x10,%esp
c0028da3:	85 c0                	test   %eax,%eax
c0028da5:	75 15                	jne    c0028dbc <strcspn+0x45>
size_t
strcspn (const char *string, const char *stop) 
{
  size_t length;

  for (length = 0; string[length] != '\0'; length++)
c0028da7:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028dab:	8b 55 08             	mov    0x8(%ebp),%edx
c0028dae:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028db1:	01 d0                	add    %edx,%eax
c0028db3:	0f b6 00             	movzbl (%eax),%eax
c0028db6:	84 c0                	test   %al,%al
c0028db8:	75 cc                	jne    c0028d86 <strcspn+0xf>
c0028dba:	eb 01                	jmp    c0028dbd <strcspn+0x46>
    if (strchr (stop, string[length]) != NULL)
      break;
c0028dbc:	90                   	nop
  return length;
c0028dbd:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028dc0:	c9                   	leave  
c0028dc1:	c3                   	ret    

c0028dc2 <strpbrk>:
/* Returns a pointer to the first character in STRING that is
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
c0028dc2:	55                   	push   %ebp
c0028dc3:	89 e5                	mov    %esp,%ebp
c0028dc5:	83 ec 08             	sub    $0x8,%esp
  for (; *string != '\0'; string++)
c0028dc8:	eb 25                	jmp    c0028def <strpbrk+0x2d>
    if (strchr (stop, *string) != NULL)
c0028dca:	8b 45 08             	mov    0x8(%ebp),%eax
c0028dcd:	0f b6 00             	movzbl (%eax),%eax
c0028dd0:	0f be c0             	movsbl %al,%eax
c0028dd3:	83 ec 08             	sub    $0x8,%esp
c0028dd6:	50                   	push   %eax
c0028dd7:	ff 75 0c             	pushl  0xc(%ebp)
c0028dda:	e8 3f ff ff ff       	call   c0028d1e <strchr>
c0028ddf:	83 c4 10             	add    $0x10,%esp
c0028de2:	85 c0                	test   %eax,%eax
c0028de4:	74 05                	je     c0028deb <strpbrk+0x29>
      return (char *) string;
c0028de6:	8b 45 08             	mov    0x8(%ebp),%eax
c0028de9:	eb 13                	jmp    c0028dfe <strpbrk+0x3c>
   also in STOP.  If no character in STRING is in STOP, returns a
   null pointer. */
char *
strpbrk (const char *string, const char *stop) 
{
  for (; *string != '\0'; string++)
c0028deb:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028def:	8b 45 08             	mov    0x8(%ebp),%eax
c0028df2:	0f b6 00             	movzbl (%eax),%eax
c0028df5:	84 c0                	test   %al,%al
c0028df7:	75 d1                	jne    c0028dca <strpbrk+0x8>
    if (strchr (stop, *string) != NULL)
      return (char *) string;
  return NULL;
c0028df9:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028dfe:	c9                   	leave  
c0028dff:	c3                   	ret    

c0028e00 <strrchr>:

/* Returns a pointer to the last occurrence of C in STRING.
   Returns a null pointer if C does not occur in STRING. */
char *
strrchr (const char *string, int c_) 
{
c0028e00:	55                   	push   %ebp
c0028e01:	89 e5                	mov    %esp,%ebp
c0028e03:	83 ec 10             	sub    $0x10,%esp
  char c = c_;
c0028e06:	8b 45 0c             	mov    0xc(%ebp),%eax
c0028e09:	88 45 fb             	mov    %al,-0x5(%ebp)
  const char *p = NULL;
c0028e0c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

  for (; *string != '\0'; string++)
c0028e13:	eb 15                	jmp    c0028e2a <strrchr+0x2a>
    if (*string == c)
c0028e15:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e18:	0f b6 00             	movzbl (%eax),%eax
c0028e1b:	3a 45 fb             	cmp    -0x5(%ebp),%al
c0028e1e:	75 06                	jne    c0028e26 <strrchr+0x26>
      p = string;
c0028e20:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e23:	89 45 fc             	mov    %eax,-0x4(%ebp)
strrchr (const char *string, int c_) 
{
  char c = c_;
  const char *p = NULL;

  for (; *string != '\0'; string++)
c0028e26:	83 45 08 01          	addl   $0x1,0x8(%ebp)
c0028e2a:	8b 45 08             	mov    0x8(%ebp),%eax
c0028e2d:	0f b6 00             	movzbl (%eax),%eax
c0028e30:	84 c0                	test   %al,%al
c0028e32:	75 e1                	jne    c0028e15 <strrchr+0x15>
    if (*string == c)
      p = string;
  return (char *) p;
c0028e34:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c0028e37:	c9                   	leave  
c0028e38:	c3                   	ret    

c0028e39 <strspn>:

/* Returns the length of the initial substring of STRING that
   consists of characters in SKIP. */
size_t
strspn (const char *string, const char *skip) 
{
c0028e39:	55                   	push   %ebp
c0028e3a:	89 e5                	mov    %esp,%ebp
c0028e3c:	83 ec 18             	sub    $0x18,%esp
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028e3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028e46:	eb 25                	jmp    c0028e6d <strspn+0x34>
    if (strchr (skip, string[length]) == NULL)
c0028e48:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e4b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e4e:	01 d0                	add    %edx,%eax
c0028e50:	0f b6 00             	movzbl (%eax),%eax
c0028e53:	0f be c0             	movsbl %al,%eax
c0028e56:	83 ec 08             	sub    $0x8,%esp
c0028e59:	50                   	push   %eax
c0028e5a:	ff 75 0c             	pushl  0xc(%ebp)
c0028e5d:	e8 bc fe ff ff       	call   c0028d1e <strchr>
c0028e62:	83 c4 10             	add    $0x10,%esp
c0028e65:	85 c0                	test   %eax,%eax
c0028e67:	74 15                	je     c0028e7e <strspn+0x45>
size_t
strspn (const char *string, const char *skip) 
{
  size_t length;
  
  for (length = 0; string[length] != '\0'; length++)
c0028e69:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028e6d:	8b 55 08             	mov    0x8(%ebp),%edx
c0028e70:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028e73:	01 d0                	add    %edx,%eax
c0028e75:	0f b6 00             	movzbl (%eax),%eax
c0028e78:	84 c0                	test   %al,%al
c0028e7a:	75 cc                	jne    c0028e48 <strspn+0xf>
c0028e7c:	eb 01                	jmp    c0028e7f <strspn+0x46>
    if (strchr (skip, string[length]) == NULL)
      break;
c0028e7e:	90                   	nop
  return length;
c0028e7f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c0028e82:	c9                   	leave  
c0028e83:	c3                   	ret    

c0028e84 <strstr>:
/* Returns a pointer to the first occurrence of NEEDLE within
   HAYSTACK.  Returns a null pointer if NEEDLE does not exist
   within HAYSTACK. */
char *
strstr (const char *haystack, const char *needle) 
{
c0028e84:	55                   	push   %ebp
c0028e85:	89 e5                	mov    %esp,%ebp
c0028e87:	83 ec 18             	sub    $0x18,%esp
  size_t haystack_len = strlen (haystack);
c0028e8a:	83 ec 0c             	sub    $0xc,%esp
c0028e8d:	ff 75 08             	pushl  0x8(%ebp)
c0028e90:	e8 d3 01 00 00       	call   c0029068 <strlen>
c0028e95:	83 c4 10             	add    $0x10,%esp
c0028e98:	89 45 f0             	mov    %eax,-0x10(%ebp)
  size_t needle_len = strlen (needle);
c0028e9b:	83 ec 0c             	sub    $0xc,%esp
c0028e9e:	ff 75 0c             	pushl  0xc(%ebp)
c0028ea1:	e8 c2 01 00 00       	call   c0029068 <strlen>
c0028ea6:	83 c4 10             	add    $0x10,%esp
c0028ea9:	89 45 ec             	mov    %eax,-0x14(%ebp)

  if (haystack_len >= needle_len) 
c0028eac:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028eaf:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0028eb2:	72 40                	jb     c0028ef4 <strstr+0x70>
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028eb4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0028ebb:	eb 2c                	jmp    c0028ee9 <strstr+0x65>
        if (!memcmp (haystack + i, needle, needle_len))
c0028ebd:	8b 55 08             	mov    0x8(%ebp),%edx
c0028ec0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ec3:	01 d0                	add    %edx,%eax
c0028ec5:	83 ec 04             	sub    $0x4,%esp
c0028ec8:	ff 75 ec             	pushl  -0x14(%ebp)
c0028ecb:	ff 75 0c             	pushl  0xc(%ebp)
c0028ece:	50                   	push   %eax
c0028ecf:	e8 8d fc ff ff       	call   c0028b61 <memcmp>
c0028ed4:	83 c4 10             	add    $0x10,%esp
c0028ed7:	85 c0                	test   %eax,%eax
c0028ed9:	75 0a                	jne    c0028ee5 <strstr+0x61>
          return (char *) haystack + i;
c0028edb:	8b 55 08             	mov    0x8(%ebp),%edx
c0028ede:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0028ee1:	01 d0                	add    %edx,%eax
c0028ee3:	eb 14                	jmp    c0028ef9 <strstr+0x75>

  if (haystack_len >= needle_len) 
    {
      size_t i;

      for (i = 0; i <= haystack_len - needle_len; i++)
c0028ee5:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c0028ee9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0028eec:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0028eef:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0028ef2:	73 c9                	jae    c0028ebd <strstr+0x39>
        if (!memcmp (haystack + i, needle, needle_len))
          return (char *) haystack + i;
    }

  return NULL;
c0028ef4:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0028ef9:	c9                   	leave  
c0028efa:	c3                   	ret    

c0028efb <strtok_r>:
     'to'
     'tokenize.'
*/
char *
strtok_r (char *s, const char *delimiters, char **save_ptr) 
{
c0028efb:	55                   	push   %ebp
c0028efc:	89 e5                	mov    %esp,%ebp
c0028efe:	83 ec 18             	sub    $0x18,%esp
  char *token;
  
  ASSERT (delimiters != NULL);
c0028f01:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0028f05:	75 21                	jne    c0028f28 <strtok_r+0x2d>
c0028f07:	83 ec 0c             	sub    $0xc,%esp
c0028f0a:	68 84 10 03 c0       	push   $0xc0031084
c0028f0f:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028f14:	68 fc 10 03 c0       	push   $0xc00310fc
c0028f19:	68 ef 00 00 00       	push   $0xef
c0028f1e:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028f23:	e8 f3 0c 00 00       	call   c0029c1b <debug_panic>
  ASSERT (save_ptr != NULL);
c0028f28:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0028f2c:	75 21                	jne    c0028f4f <strtok_r+0x54>
c0028f2e:	83 ec 0c             	sub    $0xc,%esp
c0028f31:	68 97 10 03 c0       	push   $0xc0031097
c0028f36:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028f3b:	68 fc 10 03 c0       	push   $0xc00310fc
c0028f40:	68 f0 00 00 00       	push   $0xf0
c0028f45:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028f4a:	e8 cc 0c 00 00       	call   c0029c1b <debug_panic>

  /* If S is nonnull, start from it.
     If S is null, start from saved position. */
  if (s == NULL)
c0028f4f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028f53:	75 08                	jne    c0028f5d <strtok_r+0x62>
    s = *save_ptr;
c0028f55:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f58:	8b 00                	mov    (%eax),%eax
c0028f5a:	89 45 08             	mov    %eax,0x8(%ebp)
  ASSERT (s != NULL);
c0028f5d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0028f61:	75 3e                	jne    c0028fa1 <strtok_r+0xa6>
c0028f63:	83 ec 0c             	sub    $0xc,%esp
c0028f66:	68 a8 10 03 c0       	push   $0xc00310a8
c0028f6b:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0028f70:	68 fc 10 03 c0       	push   $0xc00310fc
c0028f75:	68 f6 00 00 00       	push   $0xf6
c0028f7a:	68 ec 0f 03 c0       	push   $0xc0030fec
c0028f7f:	e8 97 0c 00 00       	call   c0029c1b <debug_panic>
  while (strchr (delimiters, *s) != NULL) 
    {
      /* strchr() will always return nonnull if we're searching
         for a null byte, because every string contains a null
         byte (at the end). */
      if (*s == '\0')
c0028f84:	8b 45 08             	mov    0x8(%ebp),%eax
c0028f87:	0f b6 00             	movzbl (%eax),%eax
c0028f8a:	84 c0                	test   %al,%al
c0028f8c:	75 0f                	jne    c0028f9d <strtok_r+0xa2>
        {
          *save_ptr = s;
c0028f8e:	8b 45 10             	mov    0x10(%ebp),%eax
c0028f91:	8b 55 08             	mov    0x8(%ebp),%edx
c0028f94:	89 10                	mov    %edx,(%eax)
          return NULL;
c0028f96:	b8 00 00 00 00       	mov    $0x0,%eax
c0028f9b:	eb 70                	jmp    c002900d <strtok_r+0x112>
        }

      s++;
c0028f9d:	83 45 08 01          	addl   $0x1,0x8(%ebp)
  if (s == NULL)
    s = *save_ptr;
  ASSERT (s != NULL);

  /* Skip any DELIMITERS at our current position. */
  while (strchr (delimiters, *s) != NULL) 
c0028fa1:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fa4:	0f b6 00             	movzbl (%eax),%eax
c0028fa7:	0f be c0             	movsbl %al,%eax
c0028faa:	83 ec 08             	sub    $0x8,%esp
c0028fad:	50                   	push   %eax
c0028fae:	ff 75 0c             	pushl  0xc(%ebp)
c0028fb1:	e8 68 fd ff ff       	call   c0028d1e <strchr>
c0028fb6:	83 c4 10             	add    $0x10,%esp
c0028fb9:	85 c0                	test   %eax,%eax
c0028fbb:	75 c7                	jne    c0028f84 <strtok_r+0x89>

      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
c0028fbd:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fc0:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while (strchr (delimiters, *s) == NULL)
c0028fc3:	eb 04                	jmp    c0028fc9 <strtok_r+0xce>
    s++;
c0028fc5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
      s++;
    }

  /* Skip any non-DELIMITERS up to the end of the string. */
  token = s;
  while (strchr (delimiters, *s) == NULL)
c0028fc9:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fcc:	0f b6 00             	movzbl (%eax),%eax
c0028fcf:	0f be c0             	movsbl %al,%eax
c0028fd2:	83 ec 08             	sub    $0x8,%esp
c0028fd5:	50                   	push   %eax
c0028fd6:	ff 75 0c             	pushl  0xc(%ebp)
c0028fd9:	e8 40 fd ff ff       	call   c0028d1e <strchr>
c0028fde:	83 c4 10             	add    $0x10,%esp
c0028fe1:	85 c0                	test   %eax,%eax
c0028fe3:	74 e0                	je     c0028fc5 <strtok_r+0xca>
    s++;
  if (*s != '\0') 
c0028fe5:	8b 45 08             	mov    0x8(%ebp),%eax
c0028fe8:	0f b6 00             	movzbl (%eax),%eax
c0028feb:	84 c0                	test   %al,%al
c0028fed:	74 13                	je     c0029002 <strtok_r+0x107>
    {
      *s = '\0';
c0028fef:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ff2:	c6 00 00             	movb   $0x0,(%eax)
      *save_ptr = s + 1;
c0028ff5:	8b 45 08             	mov    0x8(%ebp),%eax
c0028ff8:	8d 50 01             	lea    0x1(%eax),%edx
c0028ffb:	8b 45 10             	mov    0x10(%ebp),%eax
c0028ffe:	89 10                	mov    %edx,(%eax)
c0029000:	eb 08                	jmp    c002900a <strtok_r+0x10f>
    }
  else 
    *save_ptr = s;
c0029002:	8b 45 10             	mov    0x10(%ebp),%eax
c0029005:	8b 55 08             	mov    0x8(%ebp),%edx
c0029008:	89 10                	mov    %edx,(%eax)
  return token;
c002900a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002900d:	c9                   	leave  
c002900e:	c3                   	ret    

c002900f <memset>:

/* Sets the SIZE bytes in DST to VALUE. */
void *
memset (void *dst_, int value, size_t size) 
{
c002900f:	55                   	push   %ebp
c0029010:	89 e5                	mov    %esp,%ebp
c0029012:	83 ec 18             	sub    $0x18,%esp
  unsigned char *dst = dst_;
c0029015:	8b 45 08             	mov    0x8(%ebp),%eax
c0029018:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (dst != NULL || size == 0);
c002901b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002901f:	75 35                	jne    c0029056 <memset+0x47>
c0029021:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029025:	74 2f                	je     c0029056 <memset+0x47>
c0029027:	83 ec 0c             	sub    $0xc,%esp
c002902a:	68 bc 0f 03 c0       	push   $0xc0030fbc
c002902f:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0029034:	68 08 11 03 c0       	push   $0xc0031108
c0029039:	68 1b 01 00 00       	push   $0x11b
c002903e:	68 ec 0f 03 c0       	push   $0xc0030fec
c0029043:	e8 d3 0b 00 00       	call   c0029c1b <debug_panic>
  
  while (size-- > 0)
    *dst++ = value;
c0029048:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002904b:	8d 50 01             	lea    0x1(%eax),%edx
c002904e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c0029051:	8b 55 0c             	mov    0xc(%ebp),%edx
c0029054:	88 10                	mov    %dl,(%eax)
{
  unsigned char *dst = dst_;

  ASSERT (dst != NULL || size == 0);
  
  while (size-- > 0)
c0029056:	8b 45 10             	mov    0x10(%ebp),%eax
c0029059:	8d 50 ff             	lea    -0x1(%eax),%edx
c002905c:	89 55 10             	mov    %edx,0x10(%ebp)
c002905f:	85 c0                	test   %eax,%eax
c0029061:	75 e5                	jne    c0029048 <memset+0x39>
    *dst++ = value;

  return dst_;
c0029063:	8b 45 08             	mov    0x8(%ebp),%eax
}
c0029066:	c9                   	leave  
c0029067:	c3                   	ret    

c0029068 <strlen>:

/* Returns the length of STRING. */
size_t
strlen (const char *string) 
{
c0029068:	55                   	push   %ebp
c0029069:	89 e5                	mov    %esp,%ebp
c002906b:	83 ec 18             	sub    $0x18,%esp
  const char *p;

  ASSERT (string != NULL);
c002906e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029072:	75 21                	jne    c0029095 <strlen+0x2d>
c0029074:	83 ec 0c             	sub    $0xc,%esp
c0029077:	68 75 10 03 c0       	push   $0xc0031075
c002907c:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0029081:	68 10 11 03 c0       	push   $0xc0031110
c0029086:	68 29 01 00 00       	push   $0x129
c002908b:	68 ec 0f 03 c0       	push   $0xc0030fec
c0029090:	e8 86 0b 00 00       	call   c0029c1b <debug_panic>

  for (p = string; *p != '\0'; p++)
c0029095:	8b 45 08             	mov    0x8(%ebp),%eax
c0029098:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002909b:	eb 04                	jmp    c00290a1 <strlen+0x39>
c002909d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c00290a1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00290a4:	0f b6 00             	movzbl (%eax),%eax
c00290a7:	84 c0                	test   %al,%al
c00290a9:	75 f2                	jne    c002909d <strlen+0x35>
    continue;
  return p - string;
c00290ab:	8b 55 f4             	mov    -0xc(%ebp),%edx
c00290ae:	8b 45 08             	mov    0x8(%ebp),%eax
c00290b1:	29 c2                	sub    %eax,%edx
c00290b3:	89 d0                	mov    %edx,%eax
}
c00290b5:	c9                   	leave  
c00290b6:	c3                   	ret    

c00290b7 <strnlen>:

/* If STRING is less than MAXLEN characters in length, returns
   its actual length.  Otherwise, returns MAXLEN. */
size_t
strnlen (const char *string, size_t maxlen) 
{
c00290b7:	55                   	push   %ebp
c00290b8:	89 e5                	mov    %esp,%ebp
c00290ba:	83 ec 10             	sub    $0x10,%esp
  size_t length;

  for (length = 0; string[length] != '\0' && length < maxlen; length++)
c00290bd:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00290c4:	eb 04                	jmp    c00290ca <strnlen+0x13>
c00290c6:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c00290ca:	8b 55 08             	mov    0x8(%ebp),%edx
c00290cd:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00290d0:	01 d0                	add    %edx,%eax
c00290d2:	0f b6 00             	movzbl (%eax),%eax
c00290d5:	84 c0                	test   %al,%al
c00290d7:	74 08                	je     c00290e1 <strnlen+0x2a>
c00290d9:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00290dc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c00290df:	72 e5                	jb     c00290c6 <strnlen+0xf>
    continue;
  return length;
c00290e1:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00290e4:	c9                   	leave  
c00290e5:	c3                   	ret    

c00290e6 <strlcpy>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcpy (char *dst, const char *src, size_t size) 
{
c00290e6:	55                   	push   %ebp
c00290e7:	89 e5                	mov    %esp,%ebp
c00290e9:	83 ec 18             	sub    $0x18,%esp
  size_t src_len;

  ASSERT (dst != NULL);
c00290ec:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c00290f0:	75 21                	jne    c0029113 <strlcpy+0x2d>
c00290f2:	83 ec 0c             	sub    $0xc,%esp
c00290f5:	68 b2 10 03 c0       	push   $0xc00310b2
c00290fa:	68 d5 0f 03 c0       	push   $0xc0030fd5
c00290ff:	68 18 11 03 c0       	push   $0xc0031118
c0029104:	68 4a 01 00 00       	push   $0x14a
c0029109:	68 ec 0f 03 c0       	push   $0xc0030fec
c002910e:	e8 08 0b 00 00       	call   c0029c1b <debug_panic>
  ASSERT (src != NULL);
c0029113:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c0029117:	75 21                	jne    c002913a <strlcpy+0x54>
c0029119:	83 ec 0c             	sub    $0xc,%esp
c002911c:	68 be 10 03 c0       	push   $0xc00310be
c0029121:	68 d5 0f 03 c0       	push   $0xc0030fd5
c0029126:	68 18 11 03 c0       	push   $0xc0031118
c002912b:	68 4b 01 00 00       	push   $0x14b
c0029130:	68 ec 0f 03 c0       	push   $0xc0030fec
c0029135:	e8 e1 0a 00 00       	call   c0029c1b <debug_panic>

  src_len = strlen (src);
c002913a:	83 ec 0c             	sub    $0xc,%esp
c002913d:	ff 75 0c             	pushl  0xc(%ebp)
c0029140:	e8 23 ff ff ff       	call   c0029068 <strlen>
c0029145:	83 c4 10             	add    $0x10,%esp
c0029148:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (size > 0) 
c002914b:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002914f:	74 36                	je     c0029187 <strlcpy+0xa1>
    {
      size_t dst_len = size - 1;
c0029151:	8b 45 10             	mov    0x10(%ebp),%eax
c0029154:	83 e8 01             	sub    $0x1,%eax
c0029157:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < dst_len)
c002915a:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002915d:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029160:	73 06                	jae    c0029168 <strlcpy+0x82>
        dst_len = src_len;
c0029162:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029165:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst, src, dst_len);
c0029168:	83 ec 04             	sub    $0x4,%esp
c002916b:	ff 75 f4             	pushl  -0xc(%ebp)
c002916e:	ff 75 0c             	pushl  0xc(%ebp)
c0029171:	ff 75 08             	pushl  0x8(%ebp)
c0029174:	e8 90 f8 ff ff       	call   c0028a09 <memcpy>
c0029179:	83 c4 10             	add    $0x10,%esp
      dst[dst_len] = '\0';
c002917c:	8b 55 08             	mov    0x8(%ebp),%edx
c002917f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029182:	01 d0                	add    %edx,%eax
c0029184:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len;
c0029187:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002918a:	c9                   	leave  
c002918b:	c3                   	ret    

c002918c <strlcat>:
   increasingly popular extension.  See
   http://www.courtesan.com/todd/papers/strlcpy.html for
   information on strlcpy(). */
size_t
strlcat (char *dst, const char *src, size_t size) 
{
c002918c:	55                   	push   %ebp
c002918d:	89 e5                	mov    %esp,%ebp
c002918f:	83 ec 18             	sub    $0x18,%esp
  size_t src_len, dst_len;

  ASSERT (dst != NULL);
c0029192:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029196:	75 21                	jne    c00291b9 <strlcat+0x2d>
c0029198:	83 ec 0c             	sub    $0xc,%esp
c002919b:	68 b2 10 03 c0       	push   $0xc00310b2
c00291a0:	68 d5 0f 03 c0       	push   $0xc0030fd5
c00291a5:	68 20 11 03 c0       	push   $0xc0031120
c00291aa:	68 68 01 00 00       	push   $0x168
c00291af:	68 ec 0f 03 c0       	push   $0xc0030fec
c00291b4:	e8 62 0a 00 00       	call   c0029c1b <debug_panic>
  ASSERT (src != NULL);
c00291b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c00291bd:	75 21                	jne    c00291e0 <strlcat+0x54>
c00291bf:	83 ec 0c             	sub    $0xc,%esp
c00291c2:	68 be 10 03 c0       	push   $0xc00310be
c00291c7:	68 d5 0f 03 c0       	push   $0xc0030fd5
c00291cc:	68 20 11 03 c0       	push   $0xc0031120
c00291d1:	68 69 01 00 00       	push   $0x169
c00291d6:	68 ec 0f 03 c0       	push   $0xc0030fec
c00291db:	e8 3b 0a 00 00       	call   c0029c1b <debug_panic>

  src_len = strlen (src);
c00291e0:	83 ec 0c             	sub    $0xc,%esp
c00291e3:	ff 75 0c             	pushl  0xc(%ebp)
c00291e6:	e8 7d fe ff ff       	call   c0029068 <strlen>
c00291eb:	83 c4 10             	add    $0x10,%esp
c00291ee:	89 45 f0             	mov    %eax,-0x10(%ebp)
  dst_len = strlen (dst);
c00291f1:	83 ec 0c             	sub    $0xc,%esp
c00291f4:	ff 75 08             	pushl  0x8(%ebp)
c00291f7:	e8 6c fe ff ff       	call   c0029068 <strlen>
c00291fc:	83 c4 10             	add    $0x10,%esp
c00291ff:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (size > 0 && dst_len < size) 
c0029202:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c0029206:	74 4c                	je     c0029254 <strlcat+0xc8>
c0029208:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002920b:	3b 45 10             	cmp    0x10(%ebp),%eax
c002920e:	73 44                	jae    c0029254 <strlcat+0xc8>
    {
      size_t copy_cnt = size - dst_len - 1;
c0029210:	8b 45 10             	mov    0x10(%ebp),%eax
c0029213:	2b 45 ec             	sub    -0x14(%ebp),%eax
c0029216:	83 e8 01             	sub    $0x1,%eax
c0029219:	89 45 f4             	mov    %eax,-0xc(%ebp)
      if (src_len < copy_cnt)
c002921c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002921f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c0029222:	73 06                	jae    c002922a <strlcat+0x9e>
        copy_cnt = src_len;
c0029224:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029227:	89 45 f4             	mov    %eax,-0xc(%ebp)
      memcpy (dst + dst_len, src, copy_cnt);
c002922a:	8b 55 08             	mov    0x8(%ebp),%edx
c002922d:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029230:	01 d0                	add    %edx,%eax
c0029232:	83 ec 04             	sub    $0x4,%esp
c0029235:	ff 75 f4             	pushl  -0xc(%ebp)
c0029238:	ff 75 0c             	pushl  0xc(%ebp)
c002923b:	50                   	push   %eax
c002923c:	e8 c8 f7 ff ff       	call   c0028a09 <memcpy>
c0029241:	83 c4 10             	add    $0x10,%esp
      dst[dst_len + copy_cnt] = '\0';
c0029244:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029247:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002924a:	01 c2                	add    %eax,%edx
c002924c:	8b 45 08             	mov    0x8(%ebp),%eax
c002924f:	01 d0                	add    %edx,%eax
c0029251:	c6 00 00             	movb   $0x0,(%eax)
    }
  return src_len + dst_len;
c0029254:	8b 55 f0             	mov    -0x10(%ebp),%edx
c0029257:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002925a:	01 d0                	add    %edx,%eax
}
c002925c:	c9                   	leave  
c002925d:	c3                   	ret    

c002925e <divl>:
   yield a 32-bit quotient.  Returns the quotient.
   Traps with a divide error (#DE) if the quotient does not fit
   in 32 bits. */
static inline uint32_t
divl (uint64_t n, uint32_t d)
{
c002925e:	55                   	push   %ebp
c002925f:	89 e5                	mov    %esp,%ebp
c0029261:	83 ec 18             	sub    $0x18,%esp
c0029264:	8b 45 08             	mov    0x8(%ebp),%eax
c0029267:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002926a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002926d:	89 45 ec             	mov    %eax,-0x14(%ebp)
  uint32_t n1 = n >> 32;
c0029270:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029273:	8b 55 ec             	mov    -0x14(%ebp),%edx
c0029276:	89 d0                	mov    %edx,%eax
c0029278:	31 d2                	xor    %edx,%edx
c002927a:	89 45 fc             	mov    %eax,-0x4(%ebp)
  uint32_t n0 = n;
c002927d:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029280:	89 45 f8             	mov    %eax,-0x8(%ebp)
  uint32_t q, r;

  asm ("divl %4"
c0029283:	8b 55 fc             	mov    -0x4(%ebp),%edx
c0029286:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029289:	f7 75 10             	divl   0x10(%ebp)
c002928c:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002928f:	89 45 f0             	mov    %eax,-0x10(%ebp)
       : "=d" (r), "=a" (q)
       : "0" (n1), "1" (n0), "rm" (d));

  return q;
c0029292:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c0029295:	c9                   	leave  
c0029296:	c3                   	ret    

c0029297 <nlz>:

/* Returns the number of leading zero bits in X,
   which must be nonzero. */
static int
nlz (uint32_t x) 
{
c0029297:	55                   	push   %ebp
c0029298:	89 e5                	mov    %esp,%ebp
c002929a:	83 ec 10             	sub    $0x10,%esp
  /* This technique is portable, but there are better ways to do
     it on particular systems.  With sufficiently new enough GCC,
     you can use __builtin_clz() to take advantage of GCC's
     knowledge of how to do it.  Or you can use the x86 BSR
     instruction directly. */
  int n = 0;
c002929d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  if (x <= 0x0000FFFF)
c00292a4:	81 7d 08 ff ff 00 00 	cmpl   $0xffff,0x8(%ebp)
c00292ab:	77 08                	ja     c00292b5 <nlz+0x1e>
    {
      n += 16;
c00292ad:	83 45 fc 10          	addl   $0x10,-0x4(%ebp)
      x <<= 16; 
c00292b1:	c1 65 08 10          	shll   $0x10,0x8(%ebp)
    }
  if (x <= 0x00FFFFFF)
c00292b5:	81 7d 08 ff ff ff 00 	cmpl   $0xffffff,0x8(%ebp)
c00292bc:	77 08                	ja     c00292c6 <nlz+0x2f>
    {
      n += 8;
c00292be:	83 45 fc 08          	addl   $0x8,-0x4(%ebp)
      x <<= 8; 
c00292c2:	c1 65 08 08          	shll   $0x8,0x8(%ebp)
    }
  if (x <= 0x0FFFFFFF)
c00292c6:	81 7d 08 ff ff ff 0f 	cmpl   $0xfffffff,0x8(%ebp)
c00292cd:	77 08                	ja     c00292d7 <nlz+0x40>
    {
      n += 4;
c00292cf:	83 45 fc 04          	addl   $0x4,-0x4(%ebp)
      x <<= 4;
c00292d3:	c1 65 08 04          	shll   $0x4,0x8(%ebp)
    }
  if (x <= 0x3FFFFFFF)
c00292d7:	81 7d 08 ff ff ff 3f 	cmpl   $0x3fffffff,0x8(%ebp)
c00292de:	77 08                	ja     c00292e8 <nlz+0x51>
    {
      n += 2;
c00292e0:	83 45 fc 02          	addl   $0x2,-0x4(%ebp)
      x <<= 2; 
c00292e4:	c1 65 08 02          	shll   $0x2,0x8(%ebp)
    }
  if (x <= 0x7FFFFFFF)
c00292e8:	8b 45 08             	mov    0x8(%ebp),%eax
c00292eb:	85 c0                	test   %eax,%eax
c00292ed:	78 04                	js     c00292f3 <nlz+0x5c>
    n++;
c00292ef:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
  return n;
c00292f3:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c00292f6:	c9                   	leave  
c00292f7:	c3                   	ret    

c00292f8 <udiv64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   quotient. */
static uint64_t
udiv64 (uint64_t n, uint64_t d)
{
c00292f8:	55                   	push   %ebp
c00292f9:	89 e5                	mov    %esp,%ebp
c00292fb:	57                   	push   %edi
c00292fc:	56                   	push   %esi
c00292fd:	53                   	push   %ebx
c00292fe:	83 ec 44             	sub    $0x44,%esp
c0029301:	8b 45 08             	mov    0x8(%ebp),%eax
c0029304:	89 45 b8             	mov    %eax,-0x48(%ebp)
c0029307:	8b 45 0c             	mov    0xc(%ebp),%eax
c002930a:	89 45 bc             	mov    %eax,-0x44(%ebp)
c002930d:	8b 45 10             	mov    0x10(%ebp),%eax
c0029310:	89 45 b0             	mov    %eax,-0x50(%ebp)
c0029313:	8b 45 14             	mov    0x14(%ebp),%eax
c0029316:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  if ((d >> 32) == 0) 
c0029319:	8b 45 b0             	mov    -0x50(%ebp),%eax
c002931c:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002931f:	89 d0                	mov    %edx,%eax
c0029321:	31 d2                	xor    %edx,%edx
c0029323:	09 d0                	or     %edx,%eax
c0029325:	85 c0                	test   %eax,%eax
c0029327:	0f 85 a3 00 00 00    	jne    c00293d0 <udiv64+0xd8>
             <=> [(bd - 1)/d] < b
             <=> [b - 1/d] < b
         which is a tautology.

         Therefore, this code is correct and will not trap. */
      uint64_t b = 1ULL << 32;
c002932d:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
c0029334:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%ebp)
      uint32_t n1 = n >> 32;
c002933b:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002933e:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0029341:	89 d0                	mov    %edx,%eax
c0029343:	31 d2                	xor    %edx,%edx
c0029345:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      uint32_t n0 = n; 
c0029348:	8b 45 b8             	mov    -0x48(%ebp),%eax
c002934b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      uint32_t d0 = d;
c002934e:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0029351:	89 45 dc             	mov    %eax,-0x24(%ebp)

      return divl (b * (n1 % d0) + n0, d0) + b * (n1 / d0); 
c0029354:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c0029357:	ba 00 00 00 00       	mov    $0x0,%edx
c002935c:	f7 75 dc             	divl   -0x24(%ebp)
c002935f:	89 d0                	mov    %edx,%eax
c0029361:	ba 00 00 00 00       	mov    $0x0,%edx
c0029366:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c0029369:	89 cb                	mov    %ecx,%ebx
c002936b:	0f af da             	imul   %edx,%ebx
c002936e:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c0029371:	0f af c8             	imul   %eax,%ecx
c0029374:	01 d9                	add    %ebx,%ecx
c0029376:	f7 65 e8             	mull   -0x18(%ebp)
c0029379:	01 d1                	add    %edx,%ecx
c002937b:	89 ca                	mov    %ecx,%edx
c002937d:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c0029380:	bb 00 00 00 00       	mov    $0x0,%ebx
c0029385:	01 c8                	add    %ecx,%eax
c0029387:	11 da                	adc    %ebx,%edx
c0029389:	83 ec 04             	sub    $0x4,%esp
c002938c:	ff 75 dc             	pushl  -0x24(%ebp)
c002938f:	52                   	push   %edx
c0029390:	50                   	push   %eax
c0029391:	e8 c8 fe ff ff       	call   c002925e <divl>
c0029396:	83 c4 10             	add    $0x10,%esp
c0029399:	89 c6                	mov    %eax,%esi
c002939b:	bf 00 00 00 00       	mov    $0x0,%edi
c00293a0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c00293a3:	ba 00 00 00 00       	mov    $0x0,%edx
c00293a8:	f7 75 dc             	divl   -0x24(%ebp)
c00293ab:	ba 00 00 00 00       	mov    $0x0,%edx
c00293b0:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c00293b3:	89 cb                	mov    %ecx,%ebx
c00293b5:	0f af da             	imul   %edx,%ebx
c00293b8:	8b 4d ec             	mov    -0x14(%ebp),%ecx
c00293bb:	0f af c8             	imul   %eax,%ecx
c00293be:	01 d9                	add    %ebx,%ecx
c00293c0:	f7 65 e8             	mull   -0x18(%ebp)
c00293c3:	01 d1                	add    %edx,%ecx
c00293c5:	89 ca                	mov    %ecx,%edx
c00293c7:	01 f0                	add    %esi,%eax
c00293c9:	11 fa                	adc    %edi,%edx
c00293cb:	e9 e8 00 00 00       	jmp    c00294b8 <udiv64+0x1c0>
    }
  else 
    {
      /* Based on the algorithm and proof available from
         http://www.hackersdelight.org/revisions.pdf. */
      if (n < d)
c00293d0:	8b 45 b8             	mov    -0x48(%ebp),%eax
c00293d3:	8b 55 bc             	mov    -0x44(%ebp),%edx
c00293d6:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c00293d9:	77 19                	ja     c00293f4 <udiv64+0xfc>
c00293db:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c00293de:	72 05                	jb     c00293e5 <udiv64+0xed>
c00293e0:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c00293e3:	73 0f                	jae    c00293f4 <udiv64+0xfc>
        return 0;
c00293e5:	b8 00 00 00 00       	mov    $0x0,%eax
c00293ea:	ba 00 00 00 00       	mov    $0x0,%edx
c00293ef:	e9 c4 00 00 00       	jmp    c00294b8 <udiv64+0x1c0>
      else 
        {
          uint32_t d1 = d >> 32;
c00293f4:	8b 45 b0             	mov    -0x50(%ebp),%eax
c00293f7:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c00293fa:	89 d0                	mov    %edx,%eax
c00293fc:	31 d2                	xor    %edx,%edx
c00293fe:	89 45 d8             	mov    %eax,-0x28(%ebp)
          int s = nlz (d1);
c0029401:	83 ec 04             	sub    $0x4,%esp
c0029404:	ff 75 d8             	pushl  -0x28(%ebp)
c0029407:	e8 8b fe ff ff       	call   c0029297 <nlz>
c002940c:	83 c4 08             	add    $0x8,%esp
c002940f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          uint64_t q = divl (n >> 1, (d << s) >> 32) >> (31 - s);
c0029412:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c0029415:	8b 45 b0             	mov    -0x50(%ebp),%eax
c0029418:	8b 55 b4             	mov    -0x4c(%ebp),%edx
c002941b:	0f a5 c2             	shld   %cl,%eax,%edx
c002941e:	d3 e0                	shl    %cl,%eax
c0029420:	f6 c1 20             	test   $0x20,%cl
c0029423:	74 04                	je     c0029429 <udiv64+0x131>
c0029425:	89 c2                	mov    %eax,%edx
c0029427:	31 c0                	xor    %eax,%eax
c0029429:	89 d0                	mov    %edx,%eax
c002942b:	31 d2                	xor    %edx,%edx
c002942d:	89 c1                	mov    %eax,%ecx
c002942f:	8b 45 b8             	mov    -0x48(%ebp),%eax
c0029432:	8b 55 bc             	mov    -0x44(%ebp),%edx
c0029435:	0f ac d0 01          	shrd   $0x1,%edx,%eax
c0029439:	d1 ea                	shr    %edx
c002943b:	83 ec 04             	sub    $0x4,%esp
c002943e:	51                   	push   %ecx
c002943f:	52                   	push   %edx
c0029440:	50                   	push   %eax
c0029441:	e8 18 fe ff ff       	call   c002925e <divl>
c0029446:	83 c4 10             	add    $0x10,%esp
c0029449:	89 c2                	mov    %eax,%edx
c002944b:	b8 1f 00 00 00       	mov    $0x1f,%eax
c0029450:	2b 45 d4             	sub    -0x2c(%ebp),%eax
c0029453:	89 c1                	mov    %eax,%ecx
c0029455:	d3 ea                	shr    %cl,%edx
c0029457:	89 d0                	mov    %edx,%eax
c0029459:	89 45 c8             	mov    %eax,-0x38(%ebp)
c002945c:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%ebp)
          return n - (q - 1) * d < d ? q - 1 : q; 
c0029463:	8b 45 c8             	mov    -0x38(%ebp),%eax
c0029466:	8b 55 cc             	mov    -0x34(%ebp),%edx
c0029469:	83 c0 ff             	add    $0xffffffff,%eax
c002946c:	83 d2 ff             	adc    $0xffffffff,%edx
c002946f:	8b 4d b0             	mov    -0x50(%ebp),%ecx
c0029472:	89 cb                	mov    %ecx,%ebx
c0029474:	0f af da             	imul   %edx,%ebx
c0029477:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
c002947a:	0f af c8             	imul   %eax,%ecx
c002947d:	01 d9                	add    %ebx,%ecx
c002947f:	f7 65 b0             	mull   -0x50(%ebp)
c0029482:	01 d1                	add    %edx,%ecx
c0029484:	89 ca                	mov    %ecx,%edx
c0029486:	8b 4d b8             	mov    -0x48(%ebp),%ecx
c0029489:	8b 5d bc             	mov    -0x44(%ebp),%ebx
c002948c:	29 c1                	sub    %eax,%ecx
c002948e:	19 d3                	sbb    %edx,%ebx
c0029490:	89 c8                	mov    %ecx,%eax
c0029492:	89 da                	mov    %ebx,%edx
c0029494:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c0029497:	77 18                	ja     c00294b1 <udiv64+0x1b9>
c0029499:	3b 55 b4             	cmp    -0x4c(%ebp),%edx
c002949c:	72 05                	jb     c00294a3 <udiv64+0x1ab>
c002949e:	3b 45 b0             	cmp    -0x50(%ebp),%eax
c00294a1:	73 0e                	jae    c00294b1 <udiv64+0x1b9>
c00294a3:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00294a6:	8b 55 cc             	mov    -0x34(%ebp),%edx
c00294a9:	83 c0 ff             	add    $0xffffffff,%eax
c00294ac:	83 d2 ff             	adc    $0xffffffff,%edx
c00294af:	eb 06                	jmp    c00294b7 <udiv64+0x1bf>
c00294b1:	8b 45 c8             	mov    -0x38(%ebp),%eax
c00294b4:	8b 55 cc             	mov    -0x34(%ebp),%edx
c00294b7:	90                   	nop
        }
    }
}
c00294b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
c00294bb:	5b                   	pop    %ebx
c00294bc:	5e                   	pop    %esi
c00294bd:	5f                   	pop    %edi
c00294be:	5d                   	pop    %ebp
c00294bf:	c3                   	ret    

c00294c0 <umod64>:

/* Divides unsigned 64-bit N by unsigned 64-bit D and returns the
   remainder. */
static uint32_t
umod64 (uint64_t n, uint64_t d)
{
c00294c0:	55                   	push   %ebp
c00294c1:	89 e5                	mov    %esp,%ebp
c00294c3:	53                   	push   %ebx
c00294c4:	83 ec 14             	sub    $0x14,%esp
c00294c7:	8b 45 08             	mov    0x8(%ebp),%eax
c00294ca:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00294cd:	8b 45 0c             	mov    0xc(%ebp),%eax
c00294d0:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00294d3:	8b 45 10             	mov    0x10(%ebp),%eax
c00294d6:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00294d9:	8b 45 14             	mov    0x14(%ebp),%eax
c00294dc:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * udiv64 (n, d);
c00294df:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c00294e2:	ff 75 ec             	pushl  -0x14(%ebp)
c00294e5:	ff 75 e8             	pushl  -0x18(%ebp)
c00294e8:	ff 75 f4             	pushl  -0xc(%ebp)
c00294eb:	ff 75 f0             	pushl  -0x10(%ebp)
c00294ee:	e8 05 fe ff ff       	call   c00292f8 <udiv64>
c00294f3:	83 c4 10             	add    $0x10,%esp
c00294f6:	89 c2                	mov    %eax,%edx
c00294f8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00294fb:	0f af c2             	imul   %edx,%eax
c00294fe:	29 c3                	sub    %eax,%ebx
c0029500:	89 d8                	mov    %ebx,%eax
}
c0029502:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c0029505:	c9                   	leave  
c0029506:	c3                   	ret    

c0029507 <sdiv64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   quotient. */
static int64_t
sdiv64 (int64_t n, int64_t d)
{
c0029507:	55                   	push   %ebp
c0029508:	89 e5                	mov    %esp,%ebp
c002950a:	83 ec 30             	sub    $0x30,%esp
c002950d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029510:	89 45 d8             	mov    %eax,-0x28(%ebp)
c0029513:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029516:	89 45 dc             	mov    %eax,-0x24(%ebp)
c0029519:	8b 45 10             	mov    0x10(%ebp),%eax
c002951c:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002951f:	8b 45 14             	mov    0x14(%ebp),%eax
c0029522:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  uint64_t n_abs = n >= 0 ? (uint64_t) n : -(uint64_t) n;
c0029525:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
c0029529:	79 0f                	jns    c002953a <sdiv64+0x33>
c002952b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002952e:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0029531:	f7 d8                	neg    %eax
c0029533:	83 d2 00             	adc    $0x0,%edx
c0029536:	f7 da                	neg    %edx
c0029538:	eb 06                	jmp    c0029540 <sdiv64+0x39>
c002953a:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002953d:	8b 55 dc             	mov    -0x24(%ebp),%edx
c0029540:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029543:	89 55 fc             	mov    %edx,-0x4(%ebp)
  uint64_t d_abs = d >= 0 ? (uint64_t) d : -(uint64_t) d;
c0029546:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
c002954a:	79 0f                	jns    c002955b <sdiv64+0x54>
c002954c:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002954f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0029552:	f7 d8                	neg    %eax
c0029554:	83 d2 00             	adc    $0x0,%edx
c0029557:	f7 da                	neg    %edx
c0029559:	eb 06                	jmp    c0029561 <sdiv64+0x5a>
c002955b:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002955e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c0029561:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029564:	89 55 f4             	mov    %edx,-0xc(%ebp)
  uint64_t q_abs = udiv64 (n_abs, d_abs);
c0029567:	ff 75 f4             	pushl  -0xc(%ebp)
c002956a:	ff 75 f0             	pushl  -0x10(%ebp)
c002956d:	ff 75 fc             	pushl  -0x4(%ebp)
c0029570:	ff 75 f8             	pushl  -0x8(%ebp)
c0029573:	e8 80 fd ff ff       	call   c00292f8 <udiv64>
c0029578:	83 c4 10             	add    $0x10,%esp
c002957b:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002957e:	89 55 ec             	mov    %edx,-0x14(%ebp)
  return (n < 0) == (d < 0) ? (int64_t) q_abs : -(int64_t) q_abs;
c0029581:	8b 45 dc             	mov    -0x24(%ebp),%eax
c0029584:	f7 d0                	not    %eax
c0029586:	c1 e8 1f             	shr    $0x1f,%eax
c0029589:	89 c2                	mov    %eax,%edx
c002958b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002958e:	c1 e8 1f             	shr    $0x1f,%eax
c0029591:	31 d0                	xor    %edx,%eax
c0029593:	84 c0                	test   %al,%al
c0029595:	74 08                	je     c002959f <sdiv64+0x98>
c0029597:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002959a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002959d:	eb 0d                	jmp    c00295ac <sdiv64+0xa5>
c002959f:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00295a2:	8b 55 ec             	mov    -0x14(%ebp),%edx
c00295a5:	f7 d8                	neg    %eax
c00295a7:	83 d2 00             	adc    $0x0,%edx
c00295aa:	f7 da                	neg    %edx
}
c00295ac:	c9                   	leave  
c00295ad:	c3                   	ret    

c00295ae <smod64>:

/* Divides signed 64-bit N by signed 64-bit D and returns the
   remainder. */
static int32_t
smod64 (int64_t n, int64_t d)
{
c00295ae:	55                   	push   %ebp
c00295af:	89 e5                	mov    %esp,%ebp
c00295b1:	53                   	push   %ebx
c00295b2:	83 ec 14             	sub    $0x14,%esp
c00295b5:	8b 45 08             	mov    0x8(%ebp),%eax
c00295b8:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00295bb:	8b 45 0c             	mov    0xc(%ebp),%eax
c00295be:	89 45 f4             	mov    %eax,-0xc(%ebp)
c00295c1:	8b 45 10             	mov    0x10(%ebp),%eax
c00295c4:	89 45 e8             	mov    %eax,-0x18(%ebp)
c00295c7:	8b 45 14             	mov    0x14(%ebp),%eax
c00295ca:	89 45 ec             	mov    %eax,-0x14(%ebp)
  return n - d * sdiv64 (n, d);
c00295cd:	8b 5d f0             	mov    -0x10(%ebp),%ebx
c00295d0:	ff 75 ec             	pushl  -0x14(%ebp)
c00295d3:	ff 75 e8             	pushl  -0x18(%ebp)
c00295d6:	ff 75 f4             	pushl  -0xc(%ebp)
c00295d9:	ff 75 f0             	pushl  -0x10(%ebp)
c00295dc:	e8 26 ff ff ff       	call   c0029507 <sdiv64>
c00295e1:	83 c4 10             	add    $0x10,%esp
c00295e4:	89 c2                	mov    %eax,%edx
c00295e6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c00295e9:	0f af c2             	imul   %edx,%eax
c00295ec:	29 c3                	sub    %eax,%ebx
c00295ee:	89 d8                	mov    %ebx,%eax
}
c00295f0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c00295f3:	c9                   	leave  
c00295f4:	c3                   	ret    

c00295f5 <__divdi3>:
unsigned long long __umoddi3 (unsigned long long n, unsigned long long d);

/* Signed 64-bit division. */
long long
__divdi3 (long long n, long long d) 
{
c00295f5:	55                   	push   %ebp
c00295f6:	89 e5                	mov    %esp,%ebp
c00295f8:	83 ec 10             	sub    $0x10,%esp
c00295fb:	8b 45 08             	mov    0x8(%ebp),%eax
c00295fe:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029601:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029604:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029607:	8b 45 10             	mov    0x10(%ebp),%eax
c002960a:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002960d:	8b 45 14             	mov    0x14(%ebp),%eax
c0029610:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return sdiv64 (n, d);
c0029613:	ff 75 f4             	pushl  -0xc(%ebp)
c0029616:	ff 75 f0             	pushl  -0x10(%ebp)
c0029619:	ff 75 fc             	pushl  -0x4(%ebp)
c002961c:	ff 75 f8             	pushl  -0x8(%ebp)
c002961f:	e8 e3 fe ff ff       	call   c0029507 <sdiv64>
c0029624:	83 c4 10             	add    $0x10,%esp
}
c0029627:	c9                   	leave  
c0029628:	c3                   	ret    

c0029629 <__moddi3>:

/* Signed 64-bit remainder. */
long long
__moddi3 (long long n, long long d) 
{
c0029629:	55                   	push   %ebp
c002962a:	89 e5                	mov    %esp,%ebp
c002962c:	83 ec 10             	sub    $0x10,%esp
c002962f:	8b 45 08             	mov    0x8(%ebp),%eax
c0029632:	89 45 f8             	mov    %eax,-0x8(%ebp)
c0029635:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029638:	89 45 fc             	mov    %eax,-0x4(%ebp)
c002963b:	8b 45 10             	mov    0x10(%ebp),%eax
c002963e:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029641:	8b 45 14             	mov    0x14(%ebp),%eax
c0029644:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return smod64 (n, d);
c0029647:	ff 75 f4             	pushl  -0xc(%ebp)
c002964a:	ff 75 f0             	pushl  -0x10(%ebp)
c002964d:	ff 75 fc             	pushl  -0x4(%ebp)
c0029650:	ff 75 f8             	pushl  -0x8(%ebp)
c0029653:	e8 56 ff ff ff       	call   c00295ae <smod64>
c0029658:	83 c4 10             	add    $0x10,%esp
c002965b:	99                   	cltd   
}
c002965c:	c9                   	leave  
c002965d:	c3                   	ret    

c002965e <__udivdi3>:

/* Unsigned 64-bit division. */
unsigned long long
__udivdi3 (unsigned long long n, unsigned long long d) 
{
c002965e:	55                   	push   %ebp
c002965f:	89 e5                	mov    %esp,%ebp
c0029661:	83 ec 10             	sub    $0x10,%esp
c0029664:	8b 45 08             	mov    0x8(%ebp),%eax
c0029667:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002966a:	8b 45 0c             	mov    0xc(%ebp),%eax
c002966d:	89 45 fc             	mov    %eax,-0x4(%ebp)
c0029670:	8b 45 10             	mov    0x10(%ebp),%eax
c0029673:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029676:	8b 45 14             	mov    0x14(%ebp),%eax
c0029679:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return udiv64 (n, d);
c002967c:	ff 75 f4             	pushl  -0xc(%ebp)
c002967f:	ff 75 f0             	pushl  -0x10(%ebp)
c0029682:	ff 75 fc             	pushl  -0x4(%ebp)
c0029685:	ff 75 f8             	pushl  -0x8(%ebp)
c0029688:	e8 6b fc ff ff       	call   c00292f8 <udiv64>
c002968d:	83 c4 10             	add    $0x10,%esp
}
c0029690:	c9                   	leave  
c0029691:	c3                   	ret    

c0029692 <__umoddi3>:

/* Unsigned 64-bit remainder. */
unsigned long long
__umoddi3 (unsigned long long n, unsigned long long d) 
{
c0029692:	55                   	push   %ebp
c0029693:	89 e5                	mov    %esp,%ebp
c0029695:	83 ec 10             	sub    $0x10,%esp
c0029698:	8b 45 08             	mov    0x8(%ebp),%eax
c002969b:	89 45 f8             	mov    %eax,-0x8(%ebp)
c002969e:	8b 45 0c             	mov    0xc(%ebp),%eax
c00296a1:	89 45 fc             	mov    %eax,-0x4(%ebp)
c00296a4:	8b 45 10             	mov    0x10(%ebp),%eax
c00296a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c00296aa:	8b 45 14             	mov    0x14(%ebp),%eax
c00296ad:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return umod64 (n, d);
c00296b0:	ff 75 f4             	pushl  -0xc(%ebp)
c00296b3:	ff 75 f0             	pushl  -0x10(%ebp)
c00296b6:	ff 75 fc             	pushl  -0x4(%ebp)
c00296b9:	ff 75 f8             	pushl  -0x8(%ebp)
c00296bc:	e8 ff fd ff ff       	call   c00294c0 <umod64>
c00296c1:	83 c4 10             	add    $0x10,%esp
c00296c4:	ba 00 00 00 00       	mov    $0x0,%edx
}
c00296c9:	c9                   	leave  
c00296ca:	c3                   	ret    

c00296cb <calculate_chksum>:
PACKED;

/* Returns the checksum for the given ustar format HEADER. */
static unsigned int
calculate_chksum (const struct ustar_header *h)
{
c00296cb:	55                   	push   %ebp
c00296cc:	89 e5                	mov    %esp,%ebp
c00296ce:	83 ec 20             	sub    $0x20,%esp
  const uint8_t *header = (const uint8_t *) h;
c00296d1:	8b 45 08             	mov    0x8(%ebp),%eax
c00296d4:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned int chksum;
  size_t i;

  chksum = 0;
c00296d7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c00296de:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
c00296e5:	eb 5a                	jmp    c0029741 <calculate_chksum+0x76>
    {
      /* The ustar checksum is calculated as if the chksum field
         were all spaces. */
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
c00296e7:	c7 45 f0 94 00 00 00 	movl   $0x94,-0x10(%ebp)
      const size_t chksum_end = chksum_start + sizeof h->chksum;
c00296ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
c00296f1:	83 c0 08             	add    $0x8,%eax
c00296f4:	89 45 ec             	mov    %eax,-0x14(%ebp)
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
c00296f7:	8b 45 f8             	mov    -0x8(%ebp),%eax
c00296fa:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c00296fd:	72 0f                	jb     c002970e <calculate_chksum+0x43>
c00296ff:	8b 45 f8             	mov    -0x8(%ebp),%eax
c0029702:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c0029705:	73 07                	jae    c002970e <calculate_chksum+0x43>
c0029707:	b8 01 00 00 00       	mov    $0x1,%eax
c002970c:	eb 05                	jmp    c0029713 <calculate_chksum+0x48>
c002970e:	b8 00 00 00 00       	mov    $0x0,%eax
c0029713:	88 45 eb             	mov    %al,-0x15(%ebp)
c0029716:	80 65 eb 01          	andb   $0x1,-0x15(%ebp)
      chksum += in_chksum_field ? ' ' : header[i];
c002971a:	0f b6 45 eb          	movzbl -0x15(%ebp),%eax
c002971e:	83 f0 01             	xor    $0x1,%eax
c0029721:	84 c0                	test   %al,%al
c0029723:	74 10                	je     c0029735 <calculate_chksum+0x6a>
c0029725:	8b 55 f4             	mov    -0xc(%ebp),%edx
c0029728:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002972b:	01 d0                	add    %edx,%eax
c002972d:	0f b6 00             	movzbl (%eax),%eax
c0029730:	0f b6 c0             	movzbl %al,%eax
c0029733:	eb 05                	jmp    c002973a <calculate_chksum+0x6f>
c0029735:	b8 20 00 00 00       	mov    $0x20,%eax
c002973a:	01 45 fc             	add    %eax,-0x4(%ebp)
  const uint8_t *header = (const uint8_t *) h;
  unsigned int chksum;
  size_t i;

  chksum = 0;
  for (i = 0; i < USTAR_HEADER_SIZE; i++)
c002973d:	83 45 f8 01          	addl   $0x1,-0x8(%ebp)
c0029741:	81 7d f8 ff 01 00 00 	cmpl   $0x1ff,-0x8(%ebp)
c0029748:	76 9d                	jbe    c00296e7 <calculate_chksum+0x1c>
      const size_t chksum_start = offsetof (struct ustar_header, chksum);
      const size_t chksum_end = chksum_start + sizeof h->chksum;
      bool in_chksum_field = i >= chksum_start && i < chksum_end;
      chksum += in_chksum_field ? ' ' : header[i];
    }
  return chksum;
c002974a:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
c002974d:	c9                   	leave  
c002974e:	c3                   	ret    

c002974f <strip_antisocial_prefixes>:

   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
c002974f:	55                   	push   %ebp
c0029750:	89 e5                	mov    %esp,%ebp
c0029752:	83 ec 08             	sub    $0x8,%esp
  while (*file_name == '/'
c0029755:	eb 16                	jmp    c002976d <strip_antisocial_prefixes+0x1e>
         || !memcmp (file_name, "./", 2)
         || !memcmp (file_name, "../", 3))
    file_name = strchr (file_name, '/') + 1;
c0029757:	83 ec 08             	sub    $0x8,%esp
c002975a:	6a 2f                	push   $0x2f
c002975c:	ff 75 08             	pushl  0x8(%ebp)
c002975f:	e8 ba f5 ff ff       	call   c0028d1e <strchr>
c0029764:	83 c4 10             	add    $0x10,%esp
c0029767:	83 c0 01             	add    $0x1,%eax
c002976a:	89 45 08             	mov    %eax,0x8(%ebp)
   The return value can be a suffix of FILE_NAME or a string
   literal. */
static const char *
strip_antisocial_prefixes (const char *file_name)
{
  while (*file_name == '/'
c002976d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029770:	0f b6 00             	movzbl (%eax),%eax
c0029773:	3c 2f                	cmp    $0x2f,%al
c0029775:	74 e0                	je     c0029757 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "./", 2)
c0029777:	83 ec 04             	sub    $0x4,%esp
c002977a:	6a 02                	push   $0x2
c002977c:	68 28 11 03 c0       	push   $0xc0031128
c0029781:	ff 75 08             	pushl  0x8(%ebp)
c0029784:	e8 d8 f3 ff ff       	call   c0028b61 <memcmp>
c0029789:	83 c4 10             	add    $0x10,%esp
c002978c:	85 c0                	test   %eax,%eax
c002978e:	74 c7                	je     c0029757 <strip_antisocial_prefixes+0x8>
         || !memcmp (file_name, "../", 3))
c0029790:	83 ec 04             	sub    $0x4,%esp
c0029793:	6a 03                	push   $0x3
c0029795:	68 2b 11 03 c0       	push   $0xc003112b
c002979a:	ff 75 08             	pushl  0x8(%ebp)
c002979d:	e8 bf f3 ff ff       	call   c0028b61 <memcmp>
c00297a2:	83 c4 10             	add    $0x10,%esp
c00297a5:	85 c0                	test   %eax,%eax
c00297a7:	74 ae                	je     c0029757 <strip_antisocial_prefixes+0x8>
    file_name = strchr (file_name, '/') + 1;
  return *file_name == '\0' || !strcmp (file_name, "..") ? "." : file_name;
c00297a9:	8b 45 08             	mov    0x8(%ebp),%eax
c00297ac:	0f b6 00             	movzbl (%eax),%eax
c00297af:	84 c0                	test   %al,%al
c00297b1:	74 1c                	je     c00297cf <strip_antisocial_prefixes+0x80>
c00297b3:	83 ec 08             	sub    $0x8,%esp
c00297b6:	68 2f 11 03 c0       	push   $0xc003112f
c00297bb:	ff 75 08             	pushl  0x8(%ebp)
c00297be:	e8 4e f4 ff ff       	call   c0028c11 <strcmp>
c00297c3:	83 c4 10             	add    $0x10,%esp
c00297c6:	85 c0                	test   %eax,%eax
c00297c8:	74 05                	je     c00297cf <strip_antisocial_prefixes+0x80>
c00297ca:	8b 45 08             	mov    0x8(%ebp),%eax
c00297cd:	eb 05                	jmp    c00297d4 <strip_antisocial_prefixes+0x85>
c00297cf:	b8 32 11 03 c0       	mov    $0xc0031132,%eax
}
c00297d4:	c9                   	leave  
c00297d5:	c3                   	ret    

c00297d6 <ustar_make_header>:
   If successful, returns true.  On failure (due to an
   excessively long file name), returns false. */
bool
ustar_make_header (const char *file_name, enum ustar_type type,
                   int size, char header[USTAR_HEADER_SIZE])
{
c00297d6:	55                   	push   %ebp
c00297d7:	89 e5                	mov    %esp,%ebp
c00297d9:	83 ec 18             	sub    $0x18,%esp
  struct ustar_header *h = (struct ustar_header *) header;
c00297dc:	8b 45 14             	mov    0x14(%ebp),%eax
c00297df:	89 45 f4             	mov    %eax,-0xc(%ebp)

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);
  ASSERT (type == USTAR_REGULAR || type == USTAR_DIRECTORY);
c00297e2:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c00297e6:	74 24                	je     c002980c <ustar_make_header+0x36>
c00297e8:	83 7d 0c 35          	cmpl   $0x35,0xc(%ebp)
c00297ec:	74 1e                	je     c002980c <ustar_make_header+0x36>
c00297ee:	83 ec 0c             	sub    $0xc,%esp
c00297f1:	68 34 11 03 c0       	push   $0xc0031134
c00297f6:	68 65 11 03 c0       	push   $0xc0031165
c00297fb:	68 68 12 03 c0       	push   $0xc0031268
c0029800:	6a 59                	push   $0x59
c0029802:	68 7c 11 03 c0       	push   $0xc003117c
c0029807:	e8 0f 04 00 00       	call   c0029c1b <debug_panic>

  /* Check file name. */
  file_name = strip_antisocial_prefixes (file_name);
c002980c:	83 ec 0c             	sub    $0xc,%esp
c002980f:	ff 75 08             	pushl  0x8(%ebp)
c0029812:	e8 38 ff ff ff       	call   c002974f <strip_antisocial_prefixes>
c0029817:	83 c4 10             	add    $0x10,%esp
c002981a:	89 45 08             	mov    %eax,0x8(%ebp)
  if (strlen (file_name) > 99)
c002981d:	83 ec 0c             	sub    $0xc,%esp
c0029820:	ff 75 08             	pushl  0x8(%ebp)
c0029823:	e8 40 f8 ff ff       	call   c0029068 <strlen>
c0029828:	83 c4 10             	add    $0x10,%esp
c002982b:	83 f8 63             	cmp    $0x63,%eax
c002982e:	76 1d                	jbe    c002984d <ustar_make_header+0x77>
    {
      printf ("%s: file name too long\n", file_name);
c0029830:	83 ec 08             	sub    $0x8,%esp
c0029833:	ff 75 08             	pushl  0x8(%ebp)
c0029836:	68 8e 11 03 c0       	push   $0xc003118e
c002983b:	e8 a8 df ff ff       	call   c00277e8 <printf>
c0029840:	83 c4 10             	add    $0x10,%esp
      return false;
c0029843:	b8 00 00 00 00       	mov    $0x0,%eax
c0029848:	e9 64 01 00 00       	jmp    c00299b1 <ustar_make_header+0x1db>
    }

  /* Fill in header except for final checksum. */
  memset (h, 0, sizeof *h);
c002984d:	83 ec 04             	sub    $0x4,%esp
c0029850:	68 00 02 00 00       	push   $0x200
c0029855:	6a 00                	push   $0x0
c0029857:	ff 75 f4             	pushl  -0xc(%ebp)
c002985a:	e8 b0 f7 ff ff       	call   c002900f <memset>
c002985f:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->name, file_name, sizeof h->name);
c0029862:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029865:	83 ec 04             	sub    $0x4,%esp
c0029868:	6a 64                	push   $0x64
c002986a:	ff 75 08             	pushl  0x8(%ebp)
c002986d:	50                   	push   %eax
c002986e:	e8 73 f8 ff ff       	call   c00290e6 <strlcpy>
c0029873:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mode, sizeof h->mode, "%07o",
c0029876:	83 7d 0c 30          	cmpl   $0x30,0xc(%ebp)
c002987a:	75 07                	jne    c0029883 <ustar_make_header+0xad>
c002987c:	ba a4 01 00 00       	mov    $0x1a4,%edx
c0029881:	eb 05                	jmp    c0029888 <ustar_make_header+0xb2>
c0029883:	ba ed 01 00 00       	mov    $0x1ed,%edx
c0029888:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002988b:	83 c0 64             	add    $0x64,%eax
c002988e:	52                   	push   %edx
c002988f:	68 a6 11 03 c0       	push   $0xc00311a6
c0029894:	6a 08                	push   $0x8
c0029896:	50                   	push   %eax
c0029897:	e8 23 df ff ff       	call   c00277bf <snprintf>
c002989c:	83 c4 10             	add    $0x10,%esp
            type == USTAR_REGULAR ? 0644 : 0755);
  strlcpy (h->uid, "0000000", sizeof h->uid);
c002989f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298a2:	83 c0 6c             	add    $0x6c,%eax
c00298a5:	83 ec 04             	sub    $0x4,%esp
c00298a8:	6a 08                	push   $0x8
c00298aa:	68 ab 11 03 c0       	push   $0xc00311ab
c00298af:	50                   	push   %eax
c00298b0:	e8 31 f8 ff ff       	call   c00290e6 <strlcpy>
c00298b5:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->gid, "0000000", sizeof h->gid);
c00298b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298bb:	83 c0 74             	add    $0x74,%eax
c00298be:	83 ec 04             	sub    $0x4,%esp
c00298c1:	6a 08                	push   $0x8
c00298c3:	68 ab 11 03 c0       	push   $0xc00311ab
c00298c8:	50                   	push   %eax
c00298c9:	e8 18 f8 ff ff       	call   c00290e6 <strlcpy>
c00298ce:	83 c4 10             	add    $0x10,%esp
  snprintf (h->size, sizeof h->size, "%011o", size);
c00298d1:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298d4:	83 c0 7c             	add    $0x7c,%eax
c00298d7:	ff 75 10             	pushl  0x10(%ebp)
c00298da:	68 b3 11 03 c0       	push   $0xc00311b3
c00298df:	6a 0c                	push   $0xc
c00298e1:	50                   	push   %eax
c00298e2:	e8 d8 de ff ff       	call   c00277bf <snprintf>
c00298e7:	83 c4 10             	add    $0x10,%esp
  snprintf (h->mtime, sizeof h->size, "%011o", 1136102400);
c00298ea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c00298ed:	05 88 00 00 00       	add    $0x88,%eax
c00298f2:	68 00 8c b7 43       	push   $0x43b78c00
c00298f7:	68 b3 11 03 c0       	push   $0xc00311b3
c00298fc:	6a 0c                	push   $0xc
c00298fe:	50                   	push   %eax
c00298ff:	e8 bb de ff ff       	call   c00277bf <snprintf>
c0029904:	83 c4 10             	add    $0x10,%esp
  h->typeflag = type;
c0029907:	8b 45 0c             	mov    0xc(%ebp),%eax
c002990a:	89 c2                	mov    %eax,%edx
c002990c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002990f:	88 90 9c 00 00 00    	mov    %dl,0x9c(%eax)
  strlcpy (h->magic, "ustar", sizeof h->magic);
c0029915:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029918:	05 01 01 00 00       	add    $0x101,%eax
c002991d:	83 ec 04             	sub    $0x4,%esp
c0029920:	6a 06                	push   $0x6
c0029922:	68 b9 11 03 c0       	push   $0xc00311b9
c0029927:	50                   	push   %eax
c0029928:	e8 b9 f7 ff ff       	call   c00290e6 <strlcpy>
c002992d:	83 c4 10             	add    $0x10,%esp
  h->version[0] = h->version[1] = '0';
c0029930:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029933:	c6 80 08 01 00 00 30 	movb   $0x30,0x108(%eax)
c002993a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002993d:	0f b6 90 08 01 00 00 	movzbl 0x108(%eax),%edx
c0029944:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029947:	88 90 07 01 00 00    	mov    %dl,0x107(%eax)
  strlcpy (h->gname, "root", sizeof h->gname);
c002994d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029950:	05 29 01 00 00       	add    $0x129,%eax
c0029955:	83 ec 04             	sub    $0x4,%esp
c0029958:	6a 20                	push   $0x20
c002995a:	68 bf 11 03 c0       	push   $0xc00311bf
c002995f:	50                   	push   %eax
c0029960:	e8 81 f7 ff ff       	call   c00290e6 <strlcpy>
c0029965:	83 c4 10             	add    $0x10,%esp
  strlcpy (h->uname, "root", sizeof h->uname);
c0029968:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002996b:	05 09 01 00 00       	add    $0x109,%eax
c0029970:	83 ec 04             	sub    $0x4,%esp
c0029973:	6a 20                	push   $0x20
c0029975:	68 bf 11 03 c0       	push   $0xc00311bf
c002997a:	50                   	push   %eax
c002997b:	e8 66 f7 ff ff       	call   c00290e6 <strlcpy>
c0029980:	83 c4 10             	add    $0x10,%esp

  /* Compute and fill in final checksum. */
  snprintf (h->chksum, sizeof h->chksum, "%07o", calculate_chksum (h));
c0029983:	83 ec 0c             	sub    $0xc,%esp
c0029986:	ff 75 f4             	pushl  -0xc(%ebp)
c0029989:	e8 3d fd ff ff       	call   c00296cb <calculate_chksum>
c002998e:	83 c4 10             	add    $0x10,%esp
c0029991:	89 c2                	mov    %eax,%edx
c0029993:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029996:	05 94 00 00 00       	add    $0x94,%eax
c002999b:	52                   	push   %edx
c002999c:	68 a6 11 03 c0       	push   $0xc00311a6
c00299a1:	6a 08                	push   $0x8
c00299a3:	50                   	push   %eax
c00299a4:	e8 16 de ff ff       	call   c00277bf <snprintf>
c00299a9:	83 c4 10             	add    $0x10,%esp

  return true;
c00299ac:	b8 01 00 00 00       	mov    $0x1,%eax
}
c00299b1:	c9                   	leave  
c00299b2:	c3                   	ret    

c00299b3 <parse_octal_field>:
   seems ambiguous as to whether these fields must be padded on
   the left with '0's, so we accept any field that fits in the
   available space, regardless of whether it fills the space. */
static bool
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
c00299b3:	55                   	push   %ebp
c00299b4:	89 e5                	mov    %esp,%ebp
c00299b6:	83 ec 10             	sub    $0x10,%esp
  size_t ofs;

  *value = 0;
c00299b9:	8b 45 10             	mov    0x10(%ebp),%eax
c00299bc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  for (ofs = 0; ofs < size; ofs++)
c00299c2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
c00299c9:	eb 65                	jmp    c0029a30 <parse_octal_field+0x7d>
    {
      char c = s[ofs];
c00299cb:	8b 55 08             	mov    0x8(%ebp),%edx
c00299ce:	8b 45 fc             	mov    -0x4(%ebp),%eax
c00299d1:	01 d0                	add    %edx,%eax
c00299d3:	0f b6 00             	movzbl (%eax),%eax
c00299d6:	88 45 fb             	mov    %al,-0x5(%ebp)
      if (c >= '0' && c <= '7')
c00299d9:	80 7d fb 2f          	cmpb   $0x2f,-0x5(%ebp)
c00299dd:	7e 35                	jle    c0029a14 <parse_octal_field+0x61>
c00299df:	80 7d fb 37          	cmpb   $0x37,-0x5(%ebp)
c00299e3:	7f 2f                	jg     c0029a14 <parse_octal_field+0x61>
        {
          if (*value > ULONG_MAX / 8)
c00299e5:	8b 45 10             	mov    0x10(%ebp),%eax
c00299e8:	8b 00                	mov    (%eax),%eax
c00299ea:	3d ff ff ff 1f       	cmp    $0x1fffffff,%eax
c00299ef:	76 07                	jbe    c00299f8 <parse_octal_field+0x45>
            {
              /* Overflow. */
              return false;
c00299f1:	b8 00 00 00 00       	mov    $0x0,%eax
c00299f6:	eb 45                	jmp    c0029a3d <parse_octal_field+0x8a>
            }
          *value = c - '0' + *value * 8;
c00299f8:	0f be 55 fb          	movsbl -0x5(%ebp),%edx
c00299fc:	8b 45 10             	mov    0x10(%ebp),%eax
c00299ff:	8b 00                	mov    (%eax),%eax
c0029a01:	c1 e0 03             	shl    $0x3,%eax
c0029a04:	01 d0                	add    %edx,%eax
c0029a06:	8d 50 d0             	lea    -0x30(%eax),%edx
c0029a09:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a0c:	89 10                	mov    %edx,(%eax)
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c0029a0e:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
c0029a12:	eb 1c                	jmp    c0029a30 <parse_octal_field+0x7d>
              /* Overflow. */
              return false;
            }
          *value = c - '0' + *value * 8;
        }
      else if (c == ' ' || c == '\0')
c0029a14:	80 7d fb 20          	cmpb   $0x20,-0x5(%ebp)
c0029a18:	74 06                	je     c0029a20 <parse_octal_field+0x6d>
c0029a1a:	80 7d fb 00          	cmpb   $0x0,-0x5(%ebp)
c0029a1e:	75 09                	jne    c0029a29 <parse_octal_field+0x76>
        {
          /* End of field, but disallow completely empty
             fields. */
          return ofs > 0;
c0029a20:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
c0029a24:	0f 95 c0             	setne  %al
c0029a27:	eb 14                	jmp    c0029a3d <parse_octal_field+0x8a>
        }
      else
        {
          /* Bad character. */
          return false;
c0029a29:	b8 00 00 00 00       	mov    $0x0,%eax
c0029a2e:	eb 0d                	jmp    c0029a3d <parse_octal_field+0x8a>
parse_octal_field (const char *s, size_t size, unsigned long int *value)
{
  size_t ofs;

  *value = 0;
  for (ofs = 0; ofs < size; ofs++)
c0029a30:	8b 45 fc             	mov    -0x4(%ebp),%eax
c0029a33:	3b 45 0c             	cmp    0xc(%ebp),%eax
c0029a36:	72 93                	jb     c00299cb <parse_octal_field+0x18>
          return false;
        }
    }

  /* Field did not end in space or null byte. */
  return false;
c0029a38:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029a3d:	c9                   	leave  
c0029a3e:	c3                   	ret    

c0029a3f <is_all_zeros>:

/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
c0029a3f:	55                   	push   %ebp
c0029a40:	89 e5                	mov    %esp,%ebp
  while (cnt-- > 0)
c0029a42:	eb 17                	jmp    c0029a5b <is_all_zeros+0x1c>
    if (*block++ != 0)
c0029a44:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a47:	8d 50 01             	lea    0x1(%eax),%edx
c0029a4a:	89 55 08             	mov    %edx,0x8(%ebp)
c0029a4d:	0f b6 00             	movzbl (%eax),%eax
c0029a50:	84 c0                	test   %al,%al
c0029a52:	74 07                	je     c0029a5b <is_all_zeros+0x1c>
      return false;
c0029a54:	b8 00 00 00 00       	mov    $0x0,%eax
c0029a59:	eb 12                	jmp    c0029a6d <is_all_zeros+0x2e>
/* Returns true if the CNT bytes starting at BLOCK are all zero,
   false otherwise. */
static bool
is_all_zeros (const char *block, size_t cnt)
{
  while (cnt-- > 0)
c0029a5b:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a5e:	8d 50 ff             	lea    -0x1(%eax),%edx
c0029a61:	89 55 0c             	mov    %edx,0xc(%ebp)
c0029a64:	85 c0                	test   %eax,%eax
c0029a66:	75 dc                	jne    c0029a44 <is_all_zeros+0x5>
    if (*block++ != 0)
      return false;
  return true;
c0029a68:	b8 01 00 00 00       	mov    $0x1,%eax
}
c0029a6d:	5d                   	pop    %ebp
c0029a6e:	c3                   	ret    

c0029a6f <ustar_parse_header>:
   and returns a null pointer.  On failure, returns a
   human-readable error message. */
const char *
ustar_parse_header (const char header[USTAR_HEADER_SIZE],
                    const char **file_name, enum ustar_type *type, int *size)
{
c0029a6f:	55                   	push   %ebp
c0029a70:	89 e5                	mov    %esp,%ebp
c0029a72:	83 ec 18             	sub    $0x18,%esp
  const struct ustar_header *h = (const struct ustar_header *) header;
c0029a75:	8b 45 08             	mov    0x8(%ebp),%eax
c0029a78:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned long int chksum, size_ul;

  ASSERT (sizeof (struct ustar_header) == USTAR_HEADER_SIZE);

  /* Detect end of archive. */
  if (is_all_zeros (header, USTAR_HEADER_SIZE))
c0029a7b:	68 00 02 00 00       	push   $0x200
c0029a80:	ff 75 08             	pushl  0x8(%ebp)
c0029a83:	e8 b7 ff ff ff       	call   c0029a3f <is_all_zeros>
c0029a88:	83 c4 08             	add    $0x8,%esp
c0029a8b:	84 c0                	test   %al,%al
c0029a8d:	74 25                	je     c0029ab4 <ustar_parse_header+0x45>
    {
      *file_name = NULL;
c0029a8f:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029a92:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      *type = USTAR_EOF;
c0029a98:	8b 45 10             	mov    0x10(%ebp),%eax
c0029a9b:	c7 00 ff ff ff ff    	movl   $0xffffffff,(%eax)
      *size = 0;
c0029aa1:	8b 45 14             	mov    0x14(%ebp),%eax
c0029aa4:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      return NULL;
c0029aaa:	b8 00 00 00 00       	mov    $0x0,%eax
c0029aaf:	e9 65 01 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
    }

  /* Validate ustar header. */
  if (memcmp (h->magic, "ustar", 6))
c0029ab4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ab7:	05 01 01 00 00       	add    $0x101,%eax
c0029abc:	83 ec 04             	sub    $0x4,%esp
c0029abf:	6a 06                	push   $0x6
c0029ac1:	68 b9 11 03 c0       	push   $0xc00311b9
c0029ac6:	50                   	push   %eax
c0029ac7:	e8 95 f0 ff ff       	call   c0028b61 <memcmp>
c0029acc:	83 c4 10             	add    $0x10,%esp
c0029acf:	85 c0                	test   %eax,%eax
c0029ad1:	74 0a                	je     c0029add <ustar_parse_header+0x6e>
    return "not a ustar archive";
c0029ad3:	b8 c4 11 03 c0       	mov    $0xc00311c4,%eax
c0029ad8:	e9 3c 01 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  else if (h->version[0] != '0' || h->version[1] != '0')
c0029add:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029ae0:	0f b6 80 07 01 00 00 	movzbl 0x107(%eax),%eax
c0029ae7:	3c 30                	cmp    $0x30,%al
c0029ae9:	75 0e                	jne    c0029af9 <ustar_parse_header+0x8a>
c0029aeb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029aee:	0f b6 80 08 01 00 00 	movzbl 0x108(%eax),%eax
c0029af5:	3c 30                	cmp    $0x30,%al
c0029af7:	74 0a                	je     c0029b03 <ustar_parse_header+0x94>
    return "invalid ustar version";
c0029af9:	b8 d8 11 03 c0       	mov    $0xc00311d8,%eax
c0029afe:	e9 16 01 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  else if (!parse_octal_field (h->chksum, sizeof h->chksum, &chksum))
c0029b03:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b06:	8d 90 94 00 00 00    	lea    0x94(%eax),%edx
c0029b0c:	83 ec 04             	sub    $0x4,%esp
c0029b0f:	8d 45 f0             	lea    -0x10(%ebp),%eax
c0029b12:	50                   	push   %eax
c0029b13:	6a 08                	push   $0x8
c0029b15:	52                   	push   %edx
c0029b16:	e8 98 fe ff ff       	call   c00299b3 <parse_octal_field>
c0029b1b:	83 c4 10             	add    $0x10,%esp
c0029b1e:	83 f0 01             	xor    $0x1,%eax
c0029b21:	84 c0                	test   %al,%al
c0029b23:	74 0a                	je     c0029b2f <ustar_parse_header+0xc0>
    return "corrupt chksum field";
c0029b25:	b8 ee 11 03 c0       	mov    $0xc00311ee,%eax
c0029b2a:	e9 ea 00 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  else if (chksum != calculate_chksum (h))
c0029b2f:	83 ec 0c             	sub    $0xc,%esp
c0029b32:	ff 75 f4             	pushl  -0xc(%ebp)
c0029b35:	e8 91 fb ff ff       	call   c00296cb <calculate_chksum>
c0029b3a:	83 c4 10             	add    $0x10,%esp
c0029b3d:	89 c2                	mov    %eax,%edx
c0029b3f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029b42:	39 c2                	cmp    %eax,%edx
c0029b44:	74 0a                	je     c0029b50 <ustar_parse_header+0xe1>
    return "checksum mismatch";
c0029b46:	b8 03 12 03 c0       	mov    $0xc0031203,%eax
c0029b4b:	e9 c9 00 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  else if (h->name[sizeof h->name - 1] != '\0' || h->prefix[0] != '\0')
c0029b50:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b53:	0f b6 40 63          	movzbl 0x63(%eax),%eax
c0029b57:	84 c0                	test   %al,%al
c0029b59:	75 0e                	jne    c0029b69 <ustar_parse_header+0xfa>
c0029b5b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b5e:	0f b6 80 59 01 00 00 	movzbl 0x159(%eax),%eax
c0029b65:	84 c0                	test   %al,%al
c0029b67:	74 0a                	je     c0029b73 <ustar_parse_header+0x104>
    return "file name too long";
c0029b69:	b8 15 12 03 c0       	mov    $0xc0031215,%eax
c0029b6e:	e9 a6 00 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  else if (h->typeflag != USTAR_REGULAR && h->typeflag != USTAR_DIRECTORY)
c0029b73:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b76:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029b7d:	3c 30                	cmp    $0x30,%al
c0029b7f:	74 18                	je     c0029b99 <ustar_parse_header+0x12a>
c0029b81:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b84:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029b8b:	3c 35                	cmp    $0x35,%al
c0029b8d:	74 0a                	je     c0029b99 <ustar_parse_header+0x12a>
    return "unimplemented file type";
c0029b8f:	b8 28 12 03 c0       	mov    $0xc0031228,%eax
c0029b94:	e9 80 00 00 00       	jmp    c0029c19 <ustar_parse_header+0x1aa>
  if (h->typeflag == USTAR_REGULAR)
c0029b99:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029b9c:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029ba3:	3c 30                	cmp    $0x30,%al
c0029ba5:	75 34                	jne    c0029bdb <ustar_parse_header+0x16c>
    {
      if (!parse_octal_field (h->size, sizeof h->size, &size_ul))
c0029ba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029baa:	8d 50 7c             	lea    0x7c(%eax),%edx
c0029bad:	83 ec 04             	sub    $0x4,%esp
c0029bb0:	8d 45 ec             	lea    -0x14(%ebp),%eax
c0029bb3:	50                   	push   %eax
c0029bb4:	6a 0c                	push   $0xc
c0029bb6:	52                   	push   %edx
c0029bb7:	e8 f7 fd ff ff       	call   c00299b3 <parse_octal_field>
c0029bbc:	83 c4 10             	add    $0x10,%esp
c0029bbf:	83 f0 01             	xor    $0x1,%eax
c0029bc2:	84 c0                	test   %al,%al
c0029bc4:	74 07                	je     c0029bcd <ustar_parse_header+0x15e>
        return "corrupt file size field";
c0029bc6:	b8 40 12 03 c0       	mov    $0xc0031240,%eax
c0029bcb:	eb 4c                	jmp    c0029c19 <ustar_parse_header+0x1aa>
      else if (size_ul > INT_MAX)
c0029bcd:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029bd0:	85 c0                	test   %eax,%eax
c0029bd2:	79 0e                	jns    c0029be2 <ustar_parse_header+0x173>
        return "file too large";
c0029bd4:	b8 58 12 03 c0       	mov    $0xc0031258,%eax
c0029bd9:	eb 3e                	jmp    c0029c19 <ustar_parse_header+0x1aa>
    }
  else
    size_ul = 0;
c0029bdb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)

  /* Success. */
  *file_name = strip_antisocial_prefixes (h->name);
c0029be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029be5:	83 ec 0c             	sub    $0xc,%esp
c0029be8:	50                   	push   %eax
c0029be9:	e8 61 fb ff ff       	call   c002974f <strip_antisocial_prefixes>
c0029bee:	83 c4 10             	add    $0x10,%esp
c0029bf1:	89 c2                	mov    %eax,%edx
c0029bf3:	8b 45 0c             	mov    0xc(%ebp),%eax
c0029bf6:	89 10                	mov    %edx,(%eax)
  *type = h->typeflag;
c0029bf8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029bfb:	0f b6 80 9c 00 00 00 	movzbl 0x9c(%eax),%eax
c0029c02:	0f be d0             	movsbl %al,%edx
c0029c05:	8b 45 10             	mov    0x10(%ebp),%eax
c0029c08:	89 10                	mov    %edx,(%eax)
  *size = size_ul;
c0029c0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
c0029c0d:	89 c2                	mov    %eax,%edx
c0029c0f:	8b 45 14             	mov    0x14(%ebp),%eax
c0029c12:	89 10                	mov    %edx,(%eax)
  return NULL;
c0029c14:	b8 00 00 00 00       	mov    $0x0,%eax
}
c0029c19:	c9                   	leave  
c0029c1a:	c3                   	ret    

c0029c1b <debug_panic>:
/* Halts the OS, printing the source file name, line number, and
   function name, plus a user-specific message. */
void
debug_panic (const char *file, int line, const char *function,
             const char *message, ...)
{
c0029c1b:	55                   	push   %ebp
c0029c1c:	89 e5                	mov    %esp,%ebp
c0029c1e:	83 ec 18             	sub    $0x18,%esp
  static int level;
  va_list args;

  intr_disable ();
c0029c21:	e8 e1 78 ff ff       	call   c0021507 <intr_disable>
  console_panic ();
c0029c26:	e8 60 20 00 00       	call   c002bc8b <console_panic>

  level++;
c0029c2b:	a1 c4 9d 03 c0       	mov    0xc0039dc4,%eax
c0029c30:	83 c0 01             	add    $0x1,%eax
c0029c33:	a3 c4 9d 03 c0       	mov    %eax,0xc0039dc4
  if (level == 1) 
c0029c38:	a1 c4 9d 03 c0       	mov    0xc0039dc4,%eax
c0029c3d:	83 f8 01             	cmp    $0x1,%eax
c0029c40:	75 42                	jne    c0029c84 <debug_panic+0x69>
    {
      printf ("Kernel PANIC at %s:%d in %s(): ", file, line, function);
c0029c42:	ff 75 10             	pushl  0x10(%ebp)
c0029c45:	ff 75 0c             	pushl  0xc(%ebp)
c0029c48:	ff 75 08             	pushl  0x8(%ebp)
c0029c4b:	68 7c 12 03 c0       	push   $0xc003127c
c0029c50:	e8 93 db ff ff       	call   c00277e8 <printf>
c0029c55:	83 c4 10             	add    $0x10,%esp

      va_start (args, message);
c0029c58:	8d 45 18             	lea    0x18(%ebp),%eax
c0029c5b:	89 45 f4             	mov    %eax,-0xc(%ebp)
      vprintf (message, args);
c0029c5e:	8b 45 f4             	mov    -0xc(%ebp),%eax
c0029c61:	83 ec 08             	sub    $0x8,%esp
c0029c64:	50                   	push   %eax
c0029c65:	ff 75 14             	pushl  0x14(%ebp)
c0029c68:	e8 2e 21 00 00       	call   c002bd9b <vprintf>
c0029c6d:	83 c4 10             	add    $0x10,%esp
      printf ("\n");
c0029c70:	83 ec 0c             	sub    $0xc,%esp
c0029c73:	6a 0a                	push   $0xa
c0029c75:	e8 dc 21 00 00       	call   c002be56 <putchar>
c0029c7a:	83 c4 10             	add    $0x10,%esp
      va_end (args);

      debug_backtrace ();
c0029c7d:	e8 31 d8 ff ff       	call   c00274b3 <debug_backtrace>
c0029c82:	eb 20                	jmp    c0029ca4 <debug_panic+0x89>
    }
  else if (level == 2)
c0029c84:	a1 c4 9d 03 c0       	mov    0xc0039dc4,%eax
c0029c89:	83 f8 02             	cmp    $0x2,%eax
c0029c8c:	75 16                	jne    c0029ca4 <debug_panic+0x89>
    printf ("Kernel PANIC recursion at %s:%d in %s().\n",
c0029c8e:	ff 75 10             	pushl  0x10(%ebp)
c0029c91:	ff 75 0c             	pushl  0xc(%ebp)
c0029c94:	ff 75 08             	pushl  0x8(%ebp)
c0029c97:	68 9c 12 03 c0       	push   $0xc003129c
c0029c9c:	e8 47 db ff ff       	call   c00277e8 <printf>
c0029ca1:	83 c4 10             	add    $0x10,%esp
  else 
    {
      /* Don't print anything: that's probably why we recursed. */
    }

  serial_flush ();
c0029ca4:	e8 e3 b3 ff ff       	call   c002508c <serial_flush>
  shutdown ();
c0029ca9:	e8 72 d5 ff ff       	call   c0027220 <shutdown>
  for (;;);
c0029cae:	eb fe                	jmp    c0029cae <debug_panic+0x93>

c0029cb0 <print_stacktrace>:

/* Print call stack of a thread.
   The thread may be running, ready, or blocked. */
static void
print_stacktrace(struct thread *t, void *aux UNUSED)
{
c0029cb0:	55                   	push   %ebp
c0029cb1:	89 e5                	mov    %esp,%ebp
c0029cb3:	83 ec 18             	sub    $0x18,%esp
  void *retaddr = NULL, **frame = NULL;
c0029cb6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c0029cbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  const char *status = "UNKNOWN";
c0029cc4:	c7 45 ec c6 12 03 c0 	movl   $0xc00312c6,-0x14(%ebp)

  switch (t->status) {
c0029ccb:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cce:	8b 40 04             	mov    0x4(%eax),%eax
c0029cd1:	83 f8 01             	cmp    $0x1,%eax
c0029cd4:	74 15                	je     c0029ceb <print_stacktrace+0x3b>
c0029cd6:	83 f8 01             	cmp    $0x1,%eax
c0029cd9:	72 07                	jb     c0029ce2 <print_stacktrace+0x32>
c0029cdb:	83 f8 02             	cmp    $0x2,%eax
c0029cde:	74 14                	je     c0029cf4 <print_stacktrace+0x44>
    case THREAD_BLOCKED:  
      status = "BLOCKED";
      break;

    default:
      break;
c0029ce0:	eb 1a                	jmp    c0029cfc <print_stacktrace+0x4c>
  void *retaddr = NULL, **frame = NULL;
  const char *status = "UNKNOWN";

  switch (t->status) {
    case THREAD_RUNNING:  
      status = "RUNNING";
c0029ce2:	c7 45 ec ce 12 03 c0 	movl   $0xc00312ce,-0x14(%ebp)
      break;
c0029ce9:	eb 11                	jmp    c0029cfc <print_stacktrace+0x4c>

    case THREAD_READY:  
      status = "READY";
c0029ceb:	c7 45 ec d6 12 03 c0 	movl   $0xc00312d6,-0x14(%ebp)
      break;
c0029cf2:	eb 08                	jmp    c0029cfc <print_stacktrace+0x4c>

    case THREAD_BLOCKED:  
      status = "BLOCKED";
c0029cf4:	c7 45 ec dc 12 03 c0 	movl   $0xc00312dc,-0x14(%ebp)
      break;
c0029cfb:	90                   	nop

    default:
      break;
  }

  printf ("Call stack of thread `%s' (status %s):", t->name, status);
c0029cfc:	8b 45 08             	mov    0x8(%ebp),%eax
c0029cff:	83 c0 08             	add    $0x8,%eax
c0029d02:	83 ec 04             	sub    $0x4,%esp
c0029d05:	ff 75 ec             	pushl  -0x14(%ebp)
c0029d08:	50                   	push   %eax
c0029d09:	68 e4 12 03 c0       	push   $0xc00312e4
c0029d0e:	e8 d5 da ff ff       	call   c00277e8 <printf>
c0029d13:	83 c4 10             	add    $0x10,%esp

  if (t == thread_current()) 
c0029d16:	e8 d1 6f ff ff       	call   c0020cec <thread_current>
c0029d1b:	3b 45 08             	cmp    0x8(%ebp),%eax
c0029d1e:	75 0e                	jne    c0029d2e <print_stacktrace+0x7e>
    {
      frame = __builtin_frame_address (1);
c0029d20:	8b 45 00             	mov    0x0(%ebp),%eax
c0029d23:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = __builtin_return_address (0);
c0029d26:	8b 45 04             	mov    0x4(%ebp),%eax
c0029d29:	89 45 f4             	mov    %eax,-0xc(%ebp)
c0029d2c:	eb 4d                	jmp    c0029d7b <print_stacktrace+0xcb>
    {
      /* Retrieve the values of the base and instruction pointers
         as they were saved when this thread called switch_threads. */
      struct switch_threads_frame * saved_frame;

      saved_frame = (struct switch_threads_frame *)t->stack;
c0029d2e:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d31:	8b 40 18             	mov    0x18(%eax),%eax
c0029d34:	89 45 e8             	mov    %eax,-0x18(%ebp)
         list, but have never been scheduled.
         We can identify because their `stack' member either points 
         at the top of their kernel stack page, or the 
         switch_threads_frame's 'eip' member points at switch_entry.
         See also threads.c. */
      if (t->stack == (uint8_t *)t + PGSIZE || saved_frame->eip == switch_entry)
c0029d37:	8b 45 08             	mov    0x8(%ebp),%eax
c0029d3a:	8b 40 18             	mov    0x18(%eax),%eax
c0029d3d:	8b 55 08             	mov    0x8(%ebp),%edx
c0029d40:	81 c2 00 10 00 00    	add    $0x1000,%edx
c0029d46:	39 d0                	cmp    %edx,%eax
c0029d48:	74 0d                	je     c0029d57 <print_stacktrace+0xa7>
c0029d4a:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029d4d:	8b 40 10             	mov    0x10(%eax),%eax
c0029d50:	3d 66 14 02 c0       	cmp    $0xc0021466,%eax
c0029d55:	75 12                	jne    c0029d69 <print_stacktrace+0xb9>
        {
          printf (" thread was never scheduled.\n");
c0029d57:	83 ec 0c             	sub    $0xc,%esp
c0029d5a:	68 0b 13 03 c0       	push   $0xc003130b
c0029d5f:	e8 6a 20 00 00       	call   c002bdce <puts>
c0029d64:	83 c4 10             	add    $0x10,%esp
          return;
c0029d67:	eb 6b                	jmp    c0029dd4 <print_stacktrace+0x124>
        }

      frame = (void **) saved_frame->ebp;
c0029d69:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029d6c:	8b 40 08             	mov    0x8(%eax),%eax
c0029d6f:	89 45 f0             	mov    %eax,-0x10(%ebp)
      retaddr = (void *) saved_frame->eip;
c0029d72:	8b 45 e8             	mov    -0x18(%ebp),%eax
c0029d75:	8b 40 10             	mov    0x10(%eax),%eax
c0029d78:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

  printf (" %p", retaddr);
c0029d7b:	83 ec 08             	sub    $0x8,%esp
c0029d7e:	ff 75 f4             	pushl  -0xc(%ebp)
c0029d81:	68 28 13 03 c0       	push   $0xc0031328
c0029d86:	e8 5d da ff ff       	call   c00277e8 <printf>
c0029d8b:	83 c4 10             	add    $0x10,%esp
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029d8e:	eb 21                	jmp    c0029db1 <print_stacktrace+0x101>
    printf (" %p", frame[1]);
c0029d90:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029d93:	83 c0 04             	add    $0x4,%eax
c0029d96:	8b 00                	mov    (%eax),%eax
c0029d98:	83 ec 08             	sub    $0x8,%esp
c0029d9b:	50                   	push   %eax
c0029d9c:	68 28 13 03 c0       	push   $0xc0031328
c0029da1:	e8 42 da ff ff       	call   c00277e8 <printf>
c0029da6:	83 c4 10             	add    $0x10,%esp
      frame = (void **) saved_frame->ebp;
      retaddr = (void *) saved_frame->eip;
    }

  printf (" %p", retaddr);
  for (; (uintptr_t) frame >= 0x1000 && frame[0] != NULL; frame = frame[0])
c0029da9:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029dac:	8b 00                	mov    (%eax),%eax
c0029dae:	89 45 f0             	mov    %eax,-0x10(%ebp)
c0029db1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029db4:	3d ff 0f 00 00       	cmp    $0xfff,%eax
c0029db9:	76 09                	jbe    c0029dc4 <print_stacktrace+0x114>
c0029dbb:	8b 45 f0             	mov    -0x10(%ebp),%eax
c0029dbe:	8b 00                	mov    (%eax),%eax
c0029dc0:	85 c0                	test   %eax,%eax
c0029dc2:	75 cc                	jne    c0029d90 <print_stacktrace+0xe0>
    printf (" %p", frame[1]);
  printf (".\n");
c0029dc4:	83 ec 0c             	sub    $0xc,%esp
c0029dc7:	68 2c 13 03 c0       	push   $0xc003132c
c0029dcc:	e8 fd 1f 00 00       	call   c002bdce <puts>
c0029dd1:	83 c4 10             	add    $0x10,%esp
}
c0029dd4:	c9                   	leave  
c0029dd5:	c3                   	ret    

c0029dd6 <debug_backtrace_all>:

/* Prints call stack of all threads. */
void
debug_backtrace_all (void)
{
c0029dd6:	55                   	push   %ebp
c0029dd7:	89 e5                	mov    %esp,%ebp
c0029dd9:	83 ec 18             	sub    $0x18,%esp
  enum intr_level oldlevel = intr_disable ();
c0029ddc:	e8 26 77 ff ff       	call   c0021507 <intr_disable>
c0029de1:	89 45 f4             	mov    %eax,-0xc(%ebp)

  thread_foreach (print_stacktrace, 0);
c0029de4:	83 ec 08             	sub    $0x8,%esp
c0029de7:	6a 00                	push   $0x0
c0029de9:	68 b0 9c 02 c0       	push   $0xc0029cb0
c0029dee:	e8 73 70 ff ff       	call   c0020e66 <thread_foreach>
c0029df3:	83 c4 10             	add    $0x10,%esp
  intr_set_level (oldlevel);
c0029df6:	83 ec 0c             	sub    $0xc,%esp
c0029df9:	ff 75 f4             	pushl  -0xc(%ebp)
c0029dfc:	e8 ae 76 ff ff       	call   c00214af <intr_set_level>
c0029e01:	83 c4 10             	add    $0x10,%esp
}
c0029e04:	90                   	nop
c0029e05:	c9                   	leave  
c0029e06:	c3                   	ret    

c0029e07 <is_head>:
                       list_less_func *less, void *aux) UNUSED;

/* Returns true if ELEM is a head, false otherwise. */
static inline bool
is_head (struct list_elem *elem)
{
c0029e07:	55                   	push   %ebp
c0029e08:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev == NULL && elem->next != NULL;
c0029e0a:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e0e:	74 1a                	je     c0029e2a <is_head+0x23>
c0029e10:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e13:	8b 00                	mov    (%eax),%eax
c0029e15:	85 c0                	test   %eax,%eax
c0029e17:	75 11                	jne    c0029e2a <is_head+0x23>
c0029e19:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e1c:	8b 40 04             	mov    0x4(%eax),%eax
c0029e1f:	85 c0                	test   %eax,%eax
c0029e21:	74 07                	je     c0029e2a <is_head+0x23>
c0029e23:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e28:	eb 05                	jmp    c0029e2f <is_head+0x28>
c0029e2a:	b8 00 00 00 00       	mov    $0x0,%eax
c0029e2f:	83 e0 01             	and    $0x1,%eax
}
c0029e32:	5d                   	pop    %ebp
c0029e33:	c3                   	ret    

c0029e34 <is_interior>:

/* Returns true if ELEM is an interior element,
   false otherwise. */
static inline bool
is_interior (struct list_elem *elem)
{
c0029e34:	55                   	push   %ebp
c0029e35:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next != NULL;
c0029e37:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e3b:	74 1a                	je     c0029e57 <is_interior+0x23>
c0029e3d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e40:	8b 00                	mov    (%eax),%eax
c0029e42:	85 c0                	test   %eax,%eax
c0029e44:	74 11                	je     c0029e57 <is_interior+0x23>
c0029e46:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e49:	8b 40 04             	mov    0x4(%eax),%eax
c0029e4c:	85 c0                	test   %eax,%eax
c0029e4e:	74 07                	je     c0029e57 <is_interior+0x23>
c0029e50:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e55:	eb 05                	jmp    c0029e5c <is_interior+0x28>
c0029e57:	b8 00 00 00 00       	mov    $0x0,%eax
c0029e5c:	83 e0 01             	and    $0x1,%eax
}
c0029e5f:	5d                   	pop    %ebp
c0029e60:	c3                   	ret    

c0029e61 <is_tail>:

/* Returns true if ELEM is a tail, false otherwise. */
static inline bool
is_tail (struct list_elem *elem)
{
c0029e61:	55                   	push   %ebp
c0029e62:	89 e5                	mov    %esp,%ebp
  return elem != NULL && elem->prev != NULL && elem->next == NULL;
c0029e64:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e68:	74 1a                	je     c0029e84 <is_tail+0x23>
c0029e6a:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e6d:	8b 00                	mov    (%eax),%eax
c0029e6f:	85 c0                	test   %eax,%eax
c0029e71:	74 11                	je     c0029e84 <is_tail+0x23>
c0029e73:	8b 45 08             	mov    0x8(%ebp),%eax
c0029e76:	8b 40 04             	mov    0x4(%eax),%eax
c0029e79:	85 c0                	test   %eax,%eax
c0029e7b:	75 07                	jne    c0029e84 <is_tail+0x23>
c0029e7d:	b8 01 00 00 00       	mov    $0x1,%eax
c0029e82:	eb 05                	jmp    c0029e89 <is_tail+0x28>
c0029e84:	b8 00 00 00 00       	mov    $0x0,%eax
c0029e89:	83 e0 01             	and    $0x1,%eax
}
c0029e8c:	5d                   	pop    %ebp
c0029e8d:	c3                   	ret    

c0029e8e <list_init>:

/* Initializes LIST as an empty list. */
void
list_init (struct list *list)
{
c0029e8e:	55                   	push   %ebp
c0029e8f:	89 e5                	mov    %esp,%ebp
c0029e91:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029e94:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029e98:	75 1e                	jne    c0029eb8 <list_init+0x2a>
c0029e9a:	83 ec 0c             	sub    $0xc,%esp
c0029e9d:	68 30 13 03 c0       	push   $0xc0031330
c0029ea2:	68 3d 13 03 c0       	push   $0xc003133d
c0029ea7:	68 08 15 03 c0       	push   $0xc0031508
c0029eac:	6a 3f                	push   $0x3f
c0029eae:	68 54 13 03 c0       	push   $0xc0031354
c0029eb3:	e8 63 fd ff ff       	call   c0029c1b <debug_panic>
  list->head.prev = NULL;
c0029eb8:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ebb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  list->head.next = &list->tail;
c0029ec1:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ec4:	8d 50 08             	lea    0x8(%eax),%edx
c0029ec7:	8b 45 08             	mov    0x8(%ebp),%eax
c0029eca:	89 50 04             	mov    %edx,0x4(%eax)
  list->tail.prev = &list->head;
c0029ecd:	8b 55 08             	mov    0x8(%ebp),%edx
c0029ed0:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ed3:	89 50 08             	mov    %edx,0x8(%eax)
  list->tail.next = NULL;
c0029ed6:	8b 45 08             	mov    0x8(%ebp),%eax
c0029ed9:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
c0029ee0:	90                   	nop
c0029ee1:	c9                   	leave  
c0029ee2:	c3                   	ret    

c0029ee3 <list_begin>:

/* Returns the beginning of LIST.  */
struct list_elem *
list_begin (struct list *list)
{
c0029ee3:	55                   	push   %ebp
c0029ee4:	89 e5                	mov    %esp,%ebp
c0029ee6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029ee9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029eed:	75 1e                	jne    c0029f0d <list_begin+0x2a>
c0029eef:	83 ec 0c             	sub    $0xc,%esp
c0029ef2:	68 30 13 03 c0       	push   $0xc0031330
c0029ef7:	68 3d 13 03 c0       	push   $0xc003133d
c0029efc:	68 14 15 03 c0       	push   $0xc0031514
c0029f01:	6a 4a                	push   $0x4a
c0029f03:	68 54 13 03 c0       	push   $0xc0031354
c0029f08:	e8 0e fd ff ff       	call   c0029c1b <debug_panic>
  return list->head.next;
c0029f0d:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f10:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029f13:	c9                   	leave  
c0029f14:	c3                   	ret    

c0029f15 <list_next>:
/* Returns the element after ELEM in its list.  If ELEM is the
   last element in its list, returns the list tail.  Results are
   undefined if ELEM is itself a list tail. */
struct list_elem *
list_next (struct list_elem *elem)
{
c0029f15:	55                   	push   %ebp
c0029f16:	89 e5                	mov    %esp,%ebp
c0029f18:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_head (elem) || is_interior (elem));
c0029f1b:	ff 75 08             	pushl  0x8(%ebp)
c0029f1e:	e8 e4 fe ff ff       	call   c0029e07 <is_head>
c0029f23:	83 c4 04             	add    $0x4,%esp
c0029f26:	84 c0                	test   %al,%al
c0029f28:	75 2d                	jne    c0029f57 <list_next+0x42>
c0029f2a:	ff 75 08             	pushl  0x8(%ebp)
c0029f2d:	e8 02 ff ff ff       	call   c0029e34 <is_interior>
c0029f32:	83 c4 04             	add    $0x4,%esp
c0029f35:	84 c0                	test   %al,%al
c0029f37:	75 1e                	jne    c0029f57 <list_next+0x42>
c0029f39:	83 ec 0c             	sub    $0xc,%esp
c0029f3c:	68 6c 13 03 c0       	push   $0xc003136c
c0029f41:	68 3d 13 03 c0       	push   $0xc003133d
c0029f46:	68 20 15 03 c0       	push   $0xc0031520
c0029f4b:	6a 54                	push   $0x54
c0029f4d:	68 54 13 03 c0       	push   $0xc0031354
c0029f52:	e8 c4 fc ff ff       	call   c0029c1b <debug_panic>
  return elem->next;
c0029f57:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f5a:	8b 40 04             	mov    0x4(%eax),%eax
}
c0029f5d:	c9                   	leave  
c0029f5e:	c3                   	ret    

c0029f5f <list_end>:
   list_end() is often used in iterating through a list from
   front to back.  See the big comment at the top of list.h for
   an example. */
struct list_elem *
list_end (struct list *list)
{
c0029f5f:	55                   	push   %ebp
c0029f60:	89 e5                	mov    %esp,%ebp
c0029f62:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029f65:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f69:	75 1e                	jne    c0029f89 <list_end+0x2a>
c0029f6b:	83 ec 0c             	sub    $0xc,%esp
c0029f6e:	68 30 13 03 c0       	push   $0xc0031330
c0029f73:	68 3d 13 03 c0       	push   $0xc003133d
c0029f78:	68 2c 15 03 c0       	push   $0xc003152c
c0029f7d:	6a 60                	push   $0x60
c0029f7f:	68 54 13 03 c0       	push   $0xc0031354
c0029f84:	e8 92 fc ff ff       	call   c0029c1b <debug_panic>
  return &list->tail;
c0029f89:	8b 45 08             	mov    0x8(%ebp),%eax
c0029f8c:	83 c0 08             	add    $0x8,%eax
}
c0029f8f:	c9                   	leave  
c0029f90:	c3                   	ret    

c0029f91 <list_rbegin>:

/* Returns the LIST's reverse beginning, for iterating through
   LIST in reverse order, from back to front. */
struct list_elem *
list_rbegin (struct list *list) 
{
c0029f91:	55                   	push   %ebp
c0029f92:	89 e5                	mov    %esp,%ebp
c0029f94:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c0029f97:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c0029f9b:	75 1e                	jne    c0029fbb <list_rbegin+0x2a>
c0029f9d:	83 ec 0c             	sub    $0xc,%esp
c0029fa0:	68 30 13 03 c0       	push   $0xc0031330
c0029fa5:	68 3d 13 03 c0       	push   $0xc003133d
c0029faa:	68 38 15 03 c0       	push   $0xc0031538
c0029faf:	6a 69                	push   $0x69
c0029fb1:	68 54 13 03 c0       	push   $0xc0031354
c0029fb6:	e8 60 fc ff ff       	call   c0029c1b <debug_panic>
  return list->tail.prev;
c0029fbb:	8b 45 08             	mov    0x8(%ebp),%eax
c0029fbe:	8b 40 08             	mov    0x8(%eax),%eax
}
c0029fc1:	c9                   	leave  
c0029fc2:	c3                   	ret    

c0029fc3 <list_prev>:
/* Returns the element before ELEM in its list.  If ELEM is the
   first element in its list, returns the list head.  Results are
   undefined if ELEM is itself a list head. */
struct list_elem *
list_prev (struct list_elem *elem)
{
c0029fc3:	55                   	push   %ebp
c0029fc4:	89 e5                	mov    %esp,%ebp
c0029fc6:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem) || is_tail (elem));
c0029fc9:	ff 75 08             	pushl  0x8(%ebp)
c0029fcc:	e8 63 fe ff ff       	call   c0029e34 <is_interior>
c0029fd1:	83 c4 04             	add    $0x4,%esp
c0029fd4:	84 c0                	test   %al,%al
c0029fd6:	75 2d                	jne    c002a005 <list_prev+0x42>
c0029fd8:	ff 75 08             	pushl  0x8(%ebp)
c0029fdb:	e8 81 fe ff ff       	call   c0029e61 <is_tail>
c0029fe0:	83 c4 04             	add    $0x4,%esp
c0029fe3:	84 c0                	test   %al,%al
c0029fe5:	75 1e                	jne    c002a005 <list_prev+0x42>
c0029fe7:	83 ec 0c             	sub    $0xc,%esp
c0029fea:	68 94 13 03 c0       	push   $0xc0031394
c0029fef:	68 3d 13 03 c0       	push   $0xc003133d
c0029ff4:	68 44 15 03 c0       	push   $0xc0031544
c0029ff9:	6a 73                	push   $0x73
c0029ffb:	68 54 13 03 c0       	push   $0xc0031354
c002a000:	e8 16 fc ff ff       	call   c0029c1b <debug_panic>
  return elem->prev;
c002a005:	8b 45 08             	mov    0x8(%ebp),%eax
c002a008:	8b 00                	mov    (%eax),%eax
}
c002a00a:	c9                   	leave  
c002a00b:	c3                   	ret    

c002a00c <list_rend>:
          ...do something with f...
        }
*/
struct list_elem *
list_rend (struct list *list) 
{
c002a00c:	55                   	push   %ebp
c002a00d:	89 e5                	mov    %esp,%ebp
c002a00f:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a012:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a016:	75 21                	jne    c002a039 <list_rend+0x2d>
c002a018:	83 ec 0c             	sub    $0xc,%esp
c002a01b:	68 30 13 03 c0       	push   $0xc0031330
c002a020:	68 3d 13 03 c0       	push   $0xc003133d
c002a025:	68 50 15 03 c0       	push   $0xc0031550
c002a02a:	68 87 00 00 00       	push   $0x87
c002a02f:	68 54 13 03 c0       	push   $0xc0031354
c002a034:	e8 e2 fb ff ff       	call   c0029c1b <debug_panic>
  return &list->head;
c002a039:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a03c:	c9                   	leave  
c002a03d:	c3                   	ret    

c002a03e <list_head>:
          ...
        }
*/
struct list_elem *
list_head (struct list *list) 
{
c002a03e:	55                   	push   %ebp
c002a03f:	89 e5                	mov    %esp,%ebp
c002a041:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a044:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a048:	75 21                	jne    c002a06b <list_head+0x2d>
c002a04a:	83 ec 0c             	sub    $0xc,%esp
c002a04d:	68 30 13 03 c0       	push   $0xc0031330
c002a052:	68 3d 13 03 c0       	push   $0xc003133d
c002a057:	68 5c 15 03 c0       	push   $0xc003155c
c002a05c:	68 99 00 00 00       	push   $0x99
c002a061:	68 54 13 03 c0       	push   $0xc0031354
c002a066:	e8 b0 fb ff ff       	call   c0029c1b <debug_panic>
  return &list->head;
c002a06b:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a06e:	c9                   	leave  
c002a06f:	c3                   	ret    

c002a070 <list_tail>:

/* Return's LIST's tail. */
struct list_elem *
list_tail (struct list *list) 
{
c002a070:	55                   	push   %ebp
c002a071:	89 e5                	mov    %esp,%ebp
c002a073:	83 ec 08             	sub    $0x8,%esp
  ASSERT (list != NULL);
c002a076:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a07a:	75 21                	jne    c002a09d <list_tail+0x2d>
c002a07c:	83 ec 0c             	sub    $0xc,%esp
c002a07f:	68 30 13 03 c0       	push   $0xc0031330
c002a084:	68 3d 13 03 c0       	push   $0xc003133d
c002a089:	68 68 15 03 c0       	push   $0xc0031568
c002a08e:	68 a1 00 00 00       	push   $0xa1
c002a093:	68 54 13 03 c0       	push   $0xc0031354
c002a098:	e8 7e fb ff ff       	call   c0029c1b <debug_panic>
  return &list->tail;
c002a09d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a0a0:	83 c0 08             	add    $0x8,%eax
}
c002a0a3:	c9                   	leave  
c002a0a4:	c3                   	ret    

c002a0a5 <list_insert>:
/* Inserts ELEM just before BEFORE, which may be either an
   interior element or a tail.  The latter case is equivalent to
   list_push_back(). */
void
list_insert (struct list_elem *before, struct list_elem *elem)
{
c002a0a5:	55                   	push   %ebp
c002a0a6:	89 e5                	mov    %esp,%ebp
c002a0a8:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a0ab:	ff 75 08             	pushl  0x8(%ebp)
c002a0ae:	e8 81 fd ff ff       	call   c0029e34 <is_interior>
c002a0b3:	83 c4 04             	add    $0x4,%esp
c002a0b6:	84 c0                	test   %al,%al
c002a0b8:	75 30                	jne    c002a0ea <list_insert+0x45>
c002a0ba:	ff 75 08             	pushl  0x8(%ebp)
c002a0bd:	e8 9f fd ff ff       	call   c0029e61 <is_tail>
c002a0c2:	83 c4 04             	add    $0x4,%esp
c002a0c5:	84 c0                	test   %al,%al
c002a0c7:	75 21                	jne    c002a0ea <list_insert+0x45>
c002a0c9:	83 ec 0c             	sub    $0xc,%esp
c002a0cc:	68 bc 13 03 c0       	push   $0xc00313bc
c002a0d1:	68 3d 13 03 c0       	push   $0xc003133d
c002a0d6:	68 74 15 03 c0       	push   $0xc0031574
c002a0db:	68 ab 00 00 00       	push   $0xab
c002a0e0:	68 54 13 03 c0       	push   $0xc0031354
c002a0e5:	e8 31 fb ff ff       	call   c0029c1b <debug_panic>
  ASSERT (elem != NULL);
c002a0ea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a0ee:	75 21                	jne    c002a111 <list_insert+0x6c>
c002a0f0:	83 ec 0c             	sub    $0xc,%esp
c002a0f3:	68 e5 13 03 c0       	push   $0xc00313e5
c002a0f8:	68 3d 13 03 c0       	push   $0xc003133d
c002a0fd:	68 74 15 03 c0       	push   $0xc0031574
c002a102:	68 ac 00 00 00       	push   $0xac
c002a107:	68 54 13 03 c0       	push   $0xc0031354
c002a10c:	e8 0a fb ff ff       	call   c0029c1b <debug_panic>

  elem->prev = before->prev;
c002a111:	8b 45 08             	mov    0x8(%ebp),%eax
c002a114:	8b 10                	mov    (%eax),%edx
c002a116:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a119:	89 10                	mov    %edx,(%eax)
  elem->next = before;
c002a11b:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a11e:	8b 55 08             	mov    0x8(%ebp),%edx
c002a121:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = elem;
c002a124:	8b 45 08             	mov    0x8(%ebp),%eax
c002a127:	8b 00                	mov    (%eax),%eax
c002a129:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a12c:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = elem;
c002a12f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a132:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a135:	89 10                	mov    %edx,(%eax)
}
c002a137:	90                   	nop
c002a138:	c9                   	leave  
c002a139:	c3                   	ret    

c002a13a <list_splice>:
   current list, then inserts them just before BEFORE, which may
   be either an interior element or a tail. */
void
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
c002a13a:	55                   	push   %ebp
c002a13b:	89 e5                	mov    %esp,%ebp
c002a13d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (before) || is_tail (before));
c002a140:	ff 75 08             	pushl  0x8(%ebp)
c002a143:	e8 ec fc ff ff       	call   c0029e34 <is_interior>
c002a148:	83 c4 04             	add    $0x4,%esp
c002a14b:	84 c0                	test   %al,%al
c002a14d:	75 30                	jne    c002a17f <list_splice+0x45>
c002a14f:	ff 75 08             	pushl  0x8(%ebp)
c002a152:	e8 0a fd ff ff       	call   c0029e61 <is_tail>
c002a157:	83 c4 04             	add    $0x4,%esp
c002a15a:	84 c0                	test   %al,%al
c002a15c:	75 21                	jne    c002a17f <list_splice+0x45>
c002a15e:	83 ec 0c             	sub    $0xc,%esp
c002a161:	68 bc 13 03 c0       	push   $0xc00313bc
c002a166:	68 3d 13 03 c0       	push   $0xc003133d
c002a16b:	68 80 15 03 c0       	push   $0xc0031580
c002a170:	68 bb 00 00 00       	push   $0xbb
c002a175:	68 54 13 03 c0       	push   $0xc0031354
c002a17a:	e8 9c fa ff ff       	call   c0029c1b <debug_panic>
  if (first == last)
c002a17f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a182:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a185:	0f 84 ba 00 00 00    	je     c002a245 <list_splice+0x10b>
    return;
  last = list_prev (last);
c002a18b:	83 ec 0c             	sub    $0xc,%esp
c002a18e:	ff 75 10             	pushl  0x10(%ebp)
c002a191:	e8 2d fe ff ff       	call   c0029fc3 <list_prev>
c002a196:	83 c4 10             	add    $0x10,%esp
c002a199:	89 45 10             	mov    %eax,0x10(%ebp)

  ASSERT (is_interior (first));
c002a19c:	83 ec 0c             	sub    $0xc,%esp
c002a19f:	ff 75 0c             	pushl  0xc(%ebp)
c002a1a2:	e8 8d fc ff ff       	call   c0029e34 <is_interior>
c002a1a7:	83 c4 10             	add    $0x10,%esp
c002a1aa:	84 c0                	test   %al,%al
c002a1ac:	75 21                	jne    c002a1cf <list_splice+0x95>
c002a1ae:	83 ec 0c             	sub    $0xc,%esp
c002a1b1:	68 f2 13 03 c0       	push   $0xc00313f2
c002a1b6:	68 3d 13 03 c0       	push   $0xc003133d
c002a1bb:	68 80 15 03 c0       	push   $0xc0031580
c002a1c0:	68 c0 00 00 00       	push   $0xc0
c002a1c5:	68 54 13 03 c0       	push   $0xc0031354
c002a1ca:	e8 4c fa ff ff       	call   c0029c1b <debug_panic>
  ASSERT (is_interior (last));
c002a1cf:	83 ec 0c             	sub    $0xc,%esp
c002a1d2:	ff 75 10             	pushl  0x10(%ebp)
c002a1d5:	e8 5a fc ff ff       	call   c0029e34 <is_interior>
c002a1da:	83 c4 10             	add    $0x10,%esp
c002a1dd:	84 c0                	test   %al,%al
c002a1df:	75 21                	jne    c002a202 <list_splice+0xc8>
c002a1e1:	83 ec 0c             	sub    $0xc,%esp
c002a1e4:	68 06 14 03 c0       	push   $0xc0031406
c002a1e9:	68 3d 13 03 c0       	push   $0xc003133d
c002a1ee:	68 80 15 03 c0       	push   $0xc0031580
c002a1f3:	68 c1 00 00 00       	push   $0xc1
c002a1f8:	68 54 13 03 c0       	push   $0xc0031354
c002a1fd:	e8 19 fa ff ff       	call   c0029c1b <debug_panic>

  /* Cleanly remove FIRST...LAST from its current list. */
  first->prev->next = last->next;
c002a202:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a205:	8b 00                	mov    (%eax),%eax
c002a207:	8b 55 10             	mov    0x10(%ebp),%edx
c002a20a:	8b 52 04             	mov    0x4(%edx),%edx
c002a20d:	89 50 04             	mov    %edx,0x4(%eax)
  last->next->prev = first->prev;
c002a210:	8b 45 10             	mov    0x10(%ebp),%eax
c002a213:	8b 40 04             	mov    0x4(%eax),%eax
c002a216:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a219:	8b 12                	mov    (%edx),%edx
c002a21b:	89 10                	mov    %edx,(%eax)

  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
c002a21d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a220:	8b 10                	mov    (%eax),%edx
c002a222:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a225:	89 10                	mov    %edx,(%eax)
  last->next = before;
c002a227:	8b 45 10             	mov    0x10(%ebp),%eax
c002a22a:	8b 55 08             	mov    0x8(%ebp),%edx
c002a22d:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev->next = first;
c002a230:	8b 45 08             	mov    0x8(%ebp),%eax
c002a233:	8b 00                	mov    (%eax),%eax
c002a235:	8b 55 0c             	mov    0xc(%ebp),%edx
c002a238:	89 50 04             	mov    %edx,0x4(%eax)
  before->prev = last;
c002a23b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a23e:	8b 55 10             	mov    0x10(%ebp),%edx
c002a241:	89 10                	mov    %edx,(%eax)
c002a243:	eb 01                	jmp    c002a246 <list_splice+0x10c>
list_splice (struct list_elem *before,
             struct list_elem *first, struct list_elem *last)
{
  ASSERT (is_interior (before) || is_tail (before));
  if (first == last)
    return;
c002a245:	90                   	nop
  /* Splice FIRST...LAST into new list. */
  first->prev = before->prev;
  last->next = before;
  before->prev->next = first;
  before->prev = last;
}
c002a246:	c9                   	leave  
c002a247:	c3                   	ret    

c002a248 <list_push_front>:

/* Inserts ELEM at the beginning of LIST, so that it becomes the
   front in LIST. */
void
list_push_front (struct list *list, struct list_elem *elem)
{
c002a248:	55                   	push   %ebp
c002a249:	89 e5                	mov    %esp,%ebp
c002a24b:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_begin (list), elem);
c002a24e:	83 ec 0c             	sub    $0xc,%esp
c002a251:	ff 75 08             	pushl  0x8(%ebp)
c002a254:	e8 8a fc ff ff       	call   c0029ee3 <list_begin>
c002a259:	83 c4 10             	add    $0x10,%esp
c002a25c:	83 ec 08             	sub    $0x8,%esp
c002a25f:	ff 75 0c             	pushl  0xc(%ebp)
c002a262:	50                   	push   %eax
c002a263:	e8 3d fe ff ff       	call   c002a0a5 <list_insert>
c002a268:	83 c4 10             	add    $0x10,%esp
}
c002a26b:	90                   	nop
c002a26c:	c9                   	leave  
c002a26d:	c3                   	ret    

c002a26e <list_push_back>:

/* Inserts ELEM at the end of LIST, so that it becomes the
   back in LIST. */
void
list_push_back (struct list *list, struct list_elem *elem)
{
c002a26e:	55                   	push   %ebp
c002a26f:	89 e5                	mov    %esp,%ebp
c002a271:	83 ec 08             	sub    $0x8,%esp
  list_insert (list_end (list), elem);
c002a274:	83 ec 0c             	sub    $0xc,%esp
c002a277:	ff 75 08             	pushl  0x8(%ebp)
c002a27a:	e8 e0 fc ff ff       	call   c0029f5f <list_end>
c002a27f:	83 c4 10             	add    $0x10,%esp
c002a282:	83 ec 08             	sub    $0x8,%esp
c002a285:	ff 75 0c             	pushl  0xc(%ebp)
c002a288:	50                   	push   %eax
c002a289:	e8 17 fe ff ff       	call   c002a0a5 <list_insert>
c002a28e:	83 c4 10             	add    $0x10,%esp
}
c002a291:	90                   	nop
c002a292:	c9                   	leave  
c002a293:	c3                   	ret    

c002a294 <list_remove>:
       ...do something with e...
     }
*/
struct list_elem *
list_remove (struct list_elem *elem)
{
c002a294:	55                   	push   %ebp
c002a295:	89 e5                	mov    %esp,%ebp
c002a297:	83 ec 08             	sub    $0x8,%esp
  ASSERT (is_interior (elem));
c002a29a:	ff 75 08             	pushl  0x8(%ebp)
c002a29d:	e8 92 fb ff ff       	call   c0029e34 <is_interior>
c002a2a2:	83 c4 04             	add    $0x4,%esp
c002a2a5:	84 c0                	test   %al,%al
c002a2a7:	75 21                	jne    c002a2ca <list_remove+0x36>
c002a2a9:	83 ec 0c             	sub    $0xc,%esp
c002a2ac:	68 19 14 03 c0       	push   $0xc0031419
c002a2b1:	68 3d 13 03 c0       	push   $0xc003133d
c002a2b6:	68 8c 15 03 c0       	push   $0xc003158c
c002a2bb:	68 fb 00 00 00       	push   $0xfb
c002a2c0:	68 54 13 03 c0       	push   $0xc0031354
c002a2c5:	e8 51 f9 ff ff       	call   c0029c1b <debug_panic>
  elem->prev->next = elem->next;
c002a2ca:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2cd:	8b 00                	mov    (%eax),%eax
c002a2cf:	8b 55 08             	mov    0x8(%ebp),%edx
c002a2d2:	8b 52 04             	mov    0x4(%edx),%edx
c002a2d5:	89 50 04             	mov    %edx,0x4(%eax)
  elem->next->prev = elem->prev;
c002a2d8:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2db:	8b 40 04             	mov    0x4(%eax),%eax
c002a2de:	8b 55 08             	mov    0x8(%ebp),%edx
c002a2e1:	8b 12                	mov    (%edx),%edx
c002a2e3:	89 10                	mov    %edx,(%eax)
  return elem->next;
c002a2e5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a2e8:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a2eb:	c9                   	leave  
c002a2ec:	c3                   	ret    

c002a2ed <list_pop_front>:

/* Removes the front element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_front (struct list *list)
{
c002a2ed:	55                   	push   %ebp
c002a2ee:	89 e5                	mov    %esp,%ebp
c002a2f0:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *front = list_front (list);
c002a2f3:	83 ec 0c             	sub    $0xc,%esp
c002a2f6:	ff 75 08             	pushl  0x8(%ebp)
c002a2f9:	e8 43 00 00 00       	call   c002a341 <list_front>
c002a2fe:	83 c4 10             	add    $0x10,%esp
c002a301:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (front);
c002a304:	83 ec 0c             	sub    $0xc,%esp
c002a307:	ff 75 f4             	pushl  -0xc(%ebp)
c002a30a:	e8 85 ff ff ff       	call   c002a294 <list_remove>
c002a30f:	83 c4 10             	add    $0x10,%esp
  return front;
c002a312:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a315:	c9                   	leave  
c002a316:	c3                   	ret    

c002a317 <list_pop_back>:

/* Removes the back element from LIST and returns it.
   Undefined behavior if LIST is empty before removal. */
struct list_elem *
list_pop_back (struct list *list)
{
c002a317:	55                   	push   %ebp
c002a318:	89 e5                	mov    %esp,%ebp
c002a31a:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *back = list_back (list);
c002a31d:	83 ec 0c             	sub    $0xc,%esp
c002a320:	ff 75 08             	pushl  0x8(%ebp)
c002a323:	e8 5d 00 00 00       	call   c002a385 <list_back>
c002a328:	83 c4 10             	add    $0x10,%esp
c002a32b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  list_remove (back);
c002a32e:	83 ec 0c             	sub    $0xc,%esp
c002a331:	ff 75 f4             	pushl  -0xc(%ebp)
c002a334:	e8 5b ff ff ff       	call   c002a294 <list_remove>
c002a339:	83 c4 10             	add    $0x10,%esp
  return back;
c002a33c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002a33f:	c9                   	leave  
c002a340:	c3                   	ret    

c002a341 <list_front>:

/* Returns the front element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_front (struct list *list)
{
c002a341:	55                   	push   %ebp
c002a342:	89 e5                	mov    %esp,%ebp
c002a344:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a347:	83 ec 0c             	sub    $0xc,%esp
c002a34a:	ff 75 08             	pushl  0x8(%ebp)
c002a34d:	e8 c4 00 00 00       	call   c002a416 <list_empty>
c002a352:	83 c4 10             	add    $0x10,%esp
c002a355:	83 f0 01             	xor    $0x1,%eax
c002a358:	84 c0                	test   %al,%al
c002a35a:	75 21                	jne    c002a37d <list_front+0x3c>
c002a35c:	83 ec 0c             	sub    $0xc,%esp
c002a35f:	68 2c 14 03 c0       	push   $0xc003142c
c002a364:	68 3d 13 03 c0       	push   $0xc003133d
c002a369:	68 98 15 03 c0       	push   $0xc0031598
c002a36e:	68 1a 01 00 00       	push   $0x11a
c002a373:	68 54 13 03 c0       	push   $0xc0031354
c002a378:	e8 9e f8 ff ff       	call   c0029c1b <debug_panic>
  return list->head.next;
c002a37d:	8b 45 08             	mov    0x8(%ebp),%eax
c002a380:	8b 40 04             	mov    0x4(%eax),%eax
}
c002a383:	c9                   	leave  
c002a384:	c3                   	ret    

c002a385 <list_back>:

/* Returns the back element in LIST.
   Undefined behavior if LIST is empty. */
struct list_elem *
list_back (struct list *list)
{
c002a385:	55                   	push   %ebp
c002a386:	89 e5                	mov    %esp,%ebp
c002a388:	83 ec 08             	sub    $0x8,%esp
  ASSERT (!list_empty (list));
c002a38b:	83 ec 0c             	sub    $0xc,%esp
c002a38e:	ff 75 08             	pushl  0x8(%ebp)
c002a391:	e8 80 00 00 00       	call   c002a416 <list_empty>
c002a396:	83 c4 10             	add    $0x10,%esp
c002a399:	83 f0 01             	xor    $0x1,%eax
c002a39c:	84 c0                	test   %al,%al
c002a39e:	75 21                	jne    c002a3c1 <list_back+0x3c>
c002a3a0:	83 ec 0c             	sub    $0xc,%esp
c002a3a3:	68 2c 14 03 c0       	push   $0xc003142c
c002a3a8:	68 3d 13 03 c0       	push   $0xc003133d
c002a3ad:	68 a4 15 03 c0       	push   $0xc00315a4
c002a3b2:	68 23 01 00 00       	push   $0x123
c002a3b7:	68 54 13 03 c0       	push   $0xc0031354
c002a3bc:	e8 5a f8 ff ff       	call   c0029c1b <debug_panic>
  return list->tail.prev;
c002a3c1:	8b 45 08             	mov    0x8(%ebp),%eax
c002a3c4:	8b 40 08             	mov    0x8(%eax),%eax
}
c002a3c7:	c9                   	leave  
c002a3c8:	c3                   	ret    

c002a3c9 <list_size>:

/* Returns the number of elements in LIST.
   Runs in O(n) in the number of elements. */
size_t
list_size (struct list *list)
{
c002a3c9:	55                   	push   %ebp
c002a3ca:	89 e5                	mov    %esp,%ebp
c002a3cc:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;
  size_t cnt = 0;
c002a3cf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a3d6:	83 ec 0c             	sub    $0xc,%esp
c002a3d9:	ff 75 08             	pushl  0x8(%ebp)
c002a3dc:	e8 02 fb ff ff       	call   c0029ee3 <list_begin>
c002a3e1:	83 c4 10             	add    $0x10,%esp
c002a3e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a3e7:	eb 15                	jmp    c002a3fe <list_size+0x35>
    cnt++;
c002a3e9:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
list_size (struct list *list)
{
  struct list_elem *e;
  size_t cnt = 0;

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a3ed:	83 ec 0c             	sub    $0xc,%esp
c002a3f0:	ff 75 f4             	pushl  -0xc(%ebp)
c002a3f3:	e8 1d fb ff ff       	call   c0029f15 <list_next>
c002a3f8:	83 c4 10             	add    $0x10,%esp
c002a3fb:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a3fe:	83 ec 0c             	sub    $0xc,%esp
c002a401:	ff 75 08             	pushl  0x8(%ebp)
c002a404:	e8 56 fb ff ff       	call   c0029f5f <list_end>
c002a409:	83 c4 10             	add    $0x10,%esp
c002a40c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a40f:	75 d8                	jne    c002a3e9 <list_size+0x20>
    cnt++;
  return cnt;
c002a411:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002a414:	c9                   	leave  
c002a415:	c3                   	ret    

c002a416 <list_empty>:

/* Returns true if LIST is empty, false otherwise. */
bool
list_empty (struct list *list)
{
c002a416:	55                   	push   %ebp
c002a417:	89 e5                	mov    %esp,%ebp
c002a419:	53                   	push   %ebx
c002a41a:	83 ec 04             	sub    $0x4,%esp
  return list_begin (list) == list_end (list);
c002a41d:	83 ec 0c             	sub    $0xc,%esp
c002a420:	ff 75 08             	pushl  0x8(%ebp)
c002a423:	e8 bb fa ff ff       	call   c0029ee3 <list_begin>
c002a428:	83 c4 10             	add    $0x10,%esp
c002a42b:	89 c3                	mov    %eax,%ebx
c002a42d:	83 ec 0c             	sub    $0xc,%esp
c002a430:	ff 75 08             	pushl  0x8(%ebp)
c002a433:	e8 27 fb ff ff       	call   c0029f5f <list_end>
c002a438:	83 c4 10             	add    $0x10,%esp
c002a43b:	39 c3                	cmp    %eax,%ebx
c002a43d:	0f 94 c0             	sete   %al
}
c002a440:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a443:	c9                   	leave  
c002a444:	c3                   	ret    

c002a445 <swap>:

/* Swaps the `struct list_elem *'s that A and B point to. */
static void
swap (struct list_elem **a, struct list_elem **b) 
{
c002a445:	55                   	push   %ebp
c002a446:	89 e5                	mov    %esp,%ebp
c002a448:	83 ec 10             	sub    $0x10,%esp
  struct list_elem *t = *a;
c002a44b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a44e:	8b 00                	mov    (%eax),%eax
c002a450:	89 45 fc             	mov    %eax,-0x4(%ebp)
  *a = *b;
c002a453:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a456:	8b 10                	mov    (%eax),%edx
c002a458:	8b 45 08             	mov    0x8(%ebp),%eax
c002a45b:	89 10                	mov    %edx,(%eax)
  *b = t;
c002a45d:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a460:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002a463:	89 10                	mov    %edx,(%eax)
}
c002a465:	90                   	nop
c002a466:	c9                   	leave  
c002a467:	c3                   	ret    

c002a468 <list_reverse>:

/* Reverses the order of LIST. */
void
list_reverse (struct list *list)
{
c002a468:	55                   	push   %ebp
c002a469:	89 e5                	mov    %esp,%ebp
c002a46b:	83 ec 18             	sub    $0x18,%esp
  if (!list_empty (list)) 
c002a46e:	83 ec 0c             	sub    $0xc,%esp
c002a471:	ff 75 08             	pushl  0x8(%ebp)
c002a474:	e8 9d ff ff ff       	call   c002a416 <list_empty>
c002a479:	83 c4 10             	add    $0x10,%esp
c002a47c:	83 f0 01             	xor    $0x1,%eax
c002a47f:	84 c0                	test   %al,%al
c002a481:	74 79                	je     c002a4fc <list_reverse+0x94>
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a483:	83 ec 0c             	sub    $0xc,%esp
c002a486:	ff 75 08             	pushl  0x8(%ebp)
c002a489:	e8 55 fa ff ff       	call   c0029ee3 <list_begin>
c002a48e:	83 c4 10             	add    $0x10,%esp
c002a491:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a494:	eb 1e                	jmp    c002a4b4 <list_reverse+0x4c>
        swap (&e->prev, &e->next);
c002a496:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a499:	8d 50 04             	lea    0x4(%eax),%edx
c002a49c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a49f:	83 ec 08             	sub    $0x8,%esp
c002a4a2:	52                   	push   %edx
c002a4a3:	50                   	push   %eax
c002a4a4:	e8 9c ff ff ff       	call   c002a445 <swap>
c002a4a9:	83 c4 10             	add    $0x10,%esp
{
  if (!list_empty (list)) 
    {
      struct list_elem *e;

      for (e = list_begin (list); e != list_end (list); e = e->prev)
c002a4ac:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002a4af:	8b 00                	mov    (%eax),%eax
c002a4b1:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a4b4:	83 ec 0c             	sub    $0xc,%esp
c002a4b7:	ff 75 08             	pushl  0x8(%ebp)
c002a4ba:	e8 a0 fa ff ff       	call   c0029f5f <list_end>
c002a4bf:	83 c4 10             	add    $0x10,%esp
c002a4c2:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a4c5:	75 cf                	jne    c002a496 <list_reverse+0x2e>
        swap (&e->prev, &e->next);
      swap (&list->head.next, &list->tail.prev);
c002a4c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4ca:	8d 50 08             	lea    0x8(%eax),%edx
c002a4cd:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4d0:	83 c0 04             	add    $0x4,%eax
c002a4d3:	83 ec 08             	sub    $0x8,%esp
c002a4d6:	52                   	push   %edx
c002a4d7:	50                   	push   %eax
c002a4d8:	e8 68 ff ff ff       	call   c002a445 <swap>
c002a4dd:	83 c4 10             	add    $0x10,%esp
      swap (&list->head.next->prev, &list->tail.prev->next);
c002a4e0:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4e3:	8b 40 08             	mov    0x8(%eax),%eax
c002a4e6:	8d 50 04             	lea    0x4(%eax),%edx
c002a4e9:	8b 45 08             	mov    0x8(%ebp),%eax
c002a4ec:	8b 40 04             	mov    0x4(%eax),%eax
c002a4ef:	83 ec 08             	sub    $0x8,%esp
c002a4f2:	52                   	push   %edx
c002a4f3:	50                   	push   %eax
c002a4f4:	e8 4c ff ff ff       	call   c002a445 <swap>
c002a4f9:	83 c4 10             	add    $0x10,%esp
    }
}
c002a4fc:	90                   	nop
c002a4fd:	c9                   	leave  
c002a4fe:	c3                   	ret    

c002a4ff <is_sorted>:
/* Returns true only if the list elements A through B (exclusive)
   are in order according to LESS given auxiliary data AUX. */
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
c002a4ff:	55                   	push   %ebp
c002a500:	89 e5                	mov    %esp,%ebp
c002a502:	83 ec 08             	sub    $0x8,%esp
  if (a != b)
c002a505:	8b 45 08             	mov    0x8(%ebp),%eax
c002a508:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a50b:	74 46                	je     c002a553 <is_sorted+0x54>
    while ((a = list_next (a)) != b) 
c002a50d:	eb 2b                	jmp    c002a53a <is_sorted+0x3b>
      if (less (a, list_prev (a), aux))
c002a50f:	83 ec 0c             	sub    $0xc,%esp
c002a512:	ff 75 08             	pushl  0x8(%ebp)
c002a515:	e8 a9 fa ff ff       	call   c0029fc3 <list_prev>
c002a51a:	83 c4 10             	add    $0x10,%esp
c002a51d:	83 ec 04             	sub    $0x4,%esp
c002a520:	ff 75 14             	pushl  0x14(%ebp)
c002a523:	50                   	push   %eax
c002a524:	ff 75 08             	pushl  0x8(%ebp)
c002a527:	8b 45 10             	mov    0x10(%ebp),%eax
c002a52a:	ff d0                	call   *%eax
c002a52c:	83 c4 10             	add    $0x10,%esp
c002a52f:	84 c0                	test   %al,%al
c002a531:	74 07                	je     c002a53a <is_sorted+0x3b>
        return false;
c002a533:	b8 00 00 00 00       	mov    $0x0,%eax
c002a538:	eb 1e                	jmp    c002a558 <is_sorted+0x59>
static bool
is_sorted (struct list_elem *a, struct list_elem *b,
           list_less_func *less, void *aux)
{
  if (a != b)
    while ((a = list_next (a)) != b) 
c002a53a:	83 ec 0c             	sub    $0xc,%esp
c002a53d:	ff 75 08             	pushl  0x8(%ebp)
c002a540:	e8 d0 f9 ff ff       	call   c0029f15 <list_next>
c002a545:	83 c4 10             	add    $0x10,%esp
c002a548:	89 45 08             	mov    %eax,0x8(%ebp)
c002a54b:	8b 45 08             	mov    0x8(%ebp),%eax
c002a54e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a551:	75 bc                	jne    c002a50f <is_sorted+0x10>
      if (less (a, list_prev (a), aux))
        return false;
  return true;
c002a553:	b8 01 00 00 00       	mov    $0x1,%eax
}
c002a558:	c9                   	leave  
c002a559:	c3                   	ret    

c002a55a <find_end_of_run>:
   run.
   A through B (exclusive) must form a non-empty range. */
static struct list_elem *
find_end_of_run (struct list_elem *a, struct list_elem *b,
                 list_less_func *less, void *aux)
{
c002a55a:	55                   	push   %ebp
c002a55b:	89 e5                	mov    %esp,%ebp
c002a55d:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a != NULL);
c002a560:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a564:	75 21                	jne    c002a587 <find_end_of_run+0x2d>
c002a566:	83 ec 0c             	sub    $0xc,%esp
c002a569:	68 3f 14 03 c0       	push   $0xc003143f
c002a56e:	68 3d 13 03 c0       	push   $0xc003133d
c002a573:	68 b0 15 03 c0       	push   $0xc00315b0
c002a578:	68 69 01 00 00       	push   $0x169
c002a57d:	68 54 13 03 c0       	push   $0xc0031354
c002a582:	e8 94 f6 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (b != NULL);
c002a587:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a58b:	75 21                	jne    c002a5ae <find_end_of_run+0x54>
c002a58d:	83 ec 0c             	sub    $0xc,%esp
c002a590:	68 49 14 03 c0       	push   $0xc0031449
c002a595:	68 3d 13 03 c0       	push   $0xc003133d
c002a59a:	68 b0 15 03 c0       	push   $0xc00315b0
c002a59f:	68 6a 01 00 00       	push   $0x16a
c002a5a4:	68 54 13 03 c0       	push   $0xc0031354
c002a5a9:	e8 6d f6 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (less != NULL);
c002a5ae:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a5b2:	75 21                	jne    c002a5d5 <find_end_of_run+0x7b>
c002a5b4:	83 ec 0c             	sub    $0xc,%esp
c002a5b7:	68 53 14 03 c0       	push   $0xc0031453
c002a5bc:	68 3d 13 03 c0       	push   $0xc003133d
c002a5c1:	68 b0 15 03 c0       	push   $0xc00315b0
c002a5c6:	68 6b 01 00 00       	push   $0x16b
c002a5cb:	68 54 13 03 c0       	push   $0xc0031354
c002a5d0:	e8 46 f6 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (a != b);
c002a5d5:	8b 45 08             	mov    0x8(%ebp),%eax
c002a5d8:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a5db:	75 21                	jne    c002a5fe <find_end_of_run+0xa4>
c002a5dd:	83 ec 0c             	sub    $0xc,%esp
c002a5e0:	68 60 14 03 c0       	push   $0xc0031460
c002a5e5:	68 3d 13 03 c0       	push   $0xc003133d
c002a5ea:	68 b0 15 03 c0       	push   $0xc00315b0
c002a5ef:	68 6c 01 00 00       	push   $0x16c
c002a5f4:	68 54 13 03 c0       	push   $0xc0031354
c002a5f9:	e8 1d f6 ff ff       	call   c0029c1b <debug_panic>
  
  do 
    {
      a = list_next (a);
c002a5fe:	83 ec 0c             	sub    $0xc,%esp
c002a601:	ff 75 08             	pushl  0x8(%ebp)
c002a604:	e8 0c f9 ff ff       	call   c0029f15 <list_next>
c002a609:	83 c4 10             	add    $0x10,%esp
c002a60c:	89 45 08             	mov    %eax,0x8(%ebp)
    }
  while (a != b && !less (a, list_prev (a), aux));
c002a60f:	8b 45 08             	mov    0x8(%ebp),%eax
c002a612:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a615:	74 27                	je     c002a63e <find_end_of_run+0xe4>
c002a617:	83 ec 0c             	sub    $0xc,%esp
c002a61a:	ff 75 08             	pushl  0x8(%ebp)
c002a61d:	e8 a1 f9 ff ff       	call   c0029fc3 <list_prev>
c002a622:	83 c4 10             	add    $0x10,%esp
c002a625:	83 ec 04             	sub    $0x4,%esp
c002a628:	ff 75 14             	pushl  0x14(%ebp)
c002a62b:	50                   	push   %eax
c002a62c:	ff 75 08             	pushl  0x8(%ebp)
c002a62f:	8b 45 10             	mov    0x10(%ebp),%eax
c002a632:	ff d0                	call   *%eax
c002a634:	83 c4 10             	add    $0x10,%esp
c002a637:	83 f0 01             	xor    $0x1,%eax
c002a63a:	84 c0                	test   %al,%al
c002a63c:	75 c0                	jne    c002a5fe <find_end_of_run+0xa4>
  return a;
c002a63e:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002a641:	c9                   	leave  
c002a642:	c3                   	ret    

c002a643 <inplace_merge>:
   AUX.  The output range will be sorted the same way. */
static void
inplace_merge (struct list_elem *a0, struct list_elem *a1b0,
               struct list_elem *b1,
               list_less_func *less, void *aux)
{
c002a643:	55                   	push   %ebp
c002a644:	89 e5                	mov    %esp,%ebp
c002a646:	83 ec 08             	sub    $0x8,%esp
  ASSERT (a0 != NULL);
c002a649:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a64d:	75 21                	jne    c002a670 <inplace_merge+0x2d>
c002a64f:	83 ec 0c             	sub    $0xc,%esp
c002a652:	68 67 14 03 c0       	push   $0xc0031467
c002a657:	68 3d 13 03 c0       	push   $0xc003133d
c002a65c:	68 c0 15 03 c0       	push   $0xc00315c0
c002a661:	68 80 01 00 00       	push   $0x180
c002a666:	68 54 13 03 c0       	push   $0xc0031354
c002a66b:	e8 ab f5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (a1b0 != NULL);
c002a670:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a674:	75 21                	jne    c002a697 <inplace_merge+0x54>
c002a676:	83 ec 0c             	sub    $0xc,%esp
c002a679:	68 72 14 03 c0       	push   $0xc0031472
c002a67e:	68 3d 13 03 c0       	push   $0xc003133d
c002a683:	68 c0 15 03 c0       	push   $0xc00315c0
c002a688:	68 81 01 00 00       	push   $0x181
c002a68d:	68 54 13 03 c0       	push   $0xc0031354
c002a692:	e8 84 f5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (b1 != NULL);
c002a697:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a69b:	75 21                	jne    c002a6be <inplace_merge+0x7b>
c002a69d:	83 ec 0c             	sub    $0xc,%esp
c002a6a0:	68 7f 14 03 c0       	push   $0xc003147f
c002a6a5:	68 3d 13 03 c0       	push   $0xc003133d
c002a6aa:	68 c0 15 03 c0       	push   $0xc00315c0
c002a6af:	68 82 01 00 00       	push   $0x182
c002a6b4:	68 54 13 03 c0       	push   $0xc0031354
c002a6b9:	e8 5d f5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (less != NULL);
c002a6be:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
c002a6c2:	75 21                	jne    c002a6e5 <inplace_merge+0xa2>
c002a6c4:	83 ec 0c             	sub    $0xc,%esp
c002a6c7:	68 53 14 03 c0       	push   $0xc0031453
c002a6cc:	68 3d 13 03 c0       	push   $0xc003133d
c002a6d1:	68 c0 15 03 c0       	push   $0xc00315c0
c002a6d6:	68 83 01 00 00       	push   $0x183
c002a6db:	68 54 13 03 c0       	push   $0xc0031354
c002a6e0:	e8 36 f5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (is_sorted (a0, a1b0, less, aux));
c002a6e5:	ff 75 18             	pushl  0x18(%ebp)
c002a6e8:	ff 75 14             	pushl  0x14(%ebp)
c002a6eb:	ff 75 0c             	pushl  0xc(%ebp)
c002a6ee:	ff 75 08             	pushl  0x8(%ebp)
c002a6f1:	e8 09 fe ff ff       	call   c002a4ff <is_sorted>
c002a6f6:	83 c4 10             	add    $0x10,%esp
c002a6f9:	84 c0                	test   %al,%al
c002a6fb:	75 21                	jne    c002a71e <inplace_merge+0xdb>
c002a6fd:	83 ec 0c             	sub    $0xc,%esp
c002a700:	68 8c 14 03 c0       	push   $0xc003148c
c002a705:	68 3d 13 03 c0       	push   $0xc003133d
c002a70a:	68 c0 15 03 c0       	push   $0xc00315c0
c002a70f:	68 84 01 00 00       	push   $0x184
c002a714:	68 54 13 03 c0       	push   $0xc0031354
c002a719:	e8 fd f4 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (is_sorted (a1b0, b1, less, aux));
c002a71e:	ff 75 18             	pushl  0x18(%ebp)
c002a721:	ff 75 14             	pushl  0x14(%ebp)
c002a724:	ff 75 10             	pushl  0x10(%ebp)
c002a727:	ff 75 0c             	pushl  0xc(%ebp)
c002a72a:	e8 d0 fd ff ff       	call   c002a4ff <is_sorted>
c002a72f:	83 c4 10             	add    $0x10,%esp
c002a732:	84 c0                	test   %al,%al
c002a734:	0f 85 80 00 00 00    	jne    c002a7ba <inplace_merge+0x177>
c002a73a:	83 ec 0c             	sub    $0xc,%esp
c002a73d:	68 ac 14 03 c0       	push   $0xc00314ac
c002a742:	68 3d 13 03 c0       	push   $0xc003133d
c002a747:	68 c0 15 03 c0       	push   $0xc00315c0
c002a74c:	68 85 01 00 00       	push   $0x185
c002a751:	68 54 13 03 c0       	push   $0xc0031354
c002a756:	e8 c0 f4 ff ff       	call   c0029c1b <debug_panic>

  while (a0 != a1b0 && a1b0 != b1)
    if (!less (a1b0, a0, aux)) 
c002a75b:	83 ec 04             	sub    $0x4,%esp
c002a75e:	ff 75 18             	pushl  0x18(%ebp)
c002a761:	ff 75 08             	pushl  0x8(%ebp)
c002a764:	ff 75 0c             	pushl  0xc(%ebp)
c002a767:	8b 45 14             	mov    0x14(%ebp),%eax
c002a76a:	ff d0                	call   *%eax
c002a76c:	83 c4 10             	add    $0x10,%esp
c002a76f:	83 f0 01             	xor    $0x1,%eax
c002a772:	84 c0                	test   %al,%al
c002a774:	74 13                	je     c002a789 <inplace_merge+0x146>
      a0 = list_next (a0);
c002a776:	83 ec 0c             	sub    $0xc,%esp
c002a779:	ff 75 08             	pushl  0x8(%ebp)
c002a77c:	e8 94 f7 ff ff       	call   c0029f15 <list_next>
c002a781:	83 c4 10             	add    $0x10,%esp
c002a784:	89 45 08             	mov    %eax,0x8(%ebp)
c002a787:	eb 31                	jmp    c002a7ba <inplace_merge+0x177>
    else 
      {
        a1b0 = list_next (a1b0);
c002a789:	83 ec 0c             	sub    $0xc,%esp
c002a78c:	ff 75 0c             	pushl  0xc(%ebp)
c002a78f:	e8 81 f7 ff ff       	call   c0029f15 <list_next>
c002a794:	83 c4 10             	add    $0x10,%esp
c002a797:	89 45 0c             	mov    %eax,0xc(%ebp)
        list_splice (a0, list_prev (a1b0), a1b0);
c002a79a:	83 ec 0c             	sub    $0xc,%esp
c002a79d:	ff 75 0c             	pushl  0xc(%ebp)
c002a7a0:	e8 1e f8 ff ff       	call   c0029fc3 <list_prev>
c002a7a5:	83 c4 10             	add    $0x10,%esp
c002a7a8:	83 ec 04             	sub    $0x4,%esp
c002a7ab:	ff 75 0c             	pushl  0xc(%ebp)
c002a7ae:	50                   	push   %eax
c002a7af:	ff 75 08             	pushl  0x8(%ebp)
c002a7b2:	e8 83 f9 ff ff       	call   c002a13a <list_splice>
c002a7b7:	83 c4 10             	add    $0x10,%esp
  ASSERT (b1 != NULL);
  ASSERT (less != NULL);
  ASSERT (is_sorted (a0, a1b0, less, aux));
  ASSERT (is_sorted (a1b0, b1, less, aux));

  while (a0 != a1b0 && a1b0 != b1)
c002a7ba:	8b 45 08             	mov    0x8(%ebp),%eax
c002a7bd:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002a7c0:	74 08                	je     c002a7ca <inplace_merge+0x187>
c002a7c2:	8b 45 0c             	mov    0xc(%ebp),%eax
c002a7c5:	3b 45 10             	cmp    0x10(%ebp),%eax
c002a7c8:	75 91                	jne    c002a75b <inplace_merge+0x118>
    else 
      {
        a1b0 = list_next (a1b0);
        list_splice (a0, list_prev (a1b0), a1b0);
      }
}
c002a7ca:	90                   	nop
c002a7cb:	c9                   	leave  
c002a7cc:	c3                   	ret    

c002a7cd <list_sort>:
/* Sorts LIST according to LESS given auxiliary data AUX, using a
   natural iterative merge sort that runs in O(n lg n) time and
   O(1) space in the number of elements in LIST. */
void
list_sort (struct list *list, list_less_func *less, void *aux)
{
c002a7cd:	55                   	push   %ebp
c002a7ce:	89 e5                	mov    %esp,%ebp
c002a7d0:	53                   	push   %ebx
c002a7d1:	83 ec 14             	sub    $0x14,%esp
  size_t output_run_cnt;        /* Number of runs output in current pass. */

  ASSERT (list != NULL);
c002a7d4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a7d8:	75 21                	jne    c002a7fb <list_sort+0x2e>
c002a7da:	83 ec 0c             	sub    $0xc,%esp
c002a7dd:	68 30 13 03 c0       	push   $0xc0031330
c002a7e2:	68 3d 13 03 c0       	push   $0xc003133d
c002a7e7:	68 d0 15 03 c0       	push   $0xc00315d0
c002a7ec:	68 99 01 00 00       	push   $0x199
c002a7f1:	68 54 13 03 c0       	push   $0xc0031354
c002a7f6:	e8 20 f4 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (less != NULL);
c002a7fb:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a7ff:	75 21                	jne    c002a822 <list_sort+0x55>
c002a801:	83 ec 0c             	sub    $0xc,%esp
c002a804:	68 53 14 03 c0       	push   $0xc0031453
c002a809:	68 3d 13 03 c0       	push   $0xc003133d
c002a80e:	68 d0 15 03 c0       	push   $0xc00315d0
c002a813:	68 9a 01 00 00       	push   $0x19a
c002a818:	68 54 13 03 c0       	push   $0xc0031354
c002a81d:	e8 f9 f3 ff ff       	call   c0029c1b <debug_panic>
    {
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
c002a822:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a829:	83 ec 0c             	sub    $0xc,%esp
c002a82c:	ff 75 08             	pushl  0x8(%ebp)
c002a82f:	e8 af f6 ff ff       	call   c0029ee3 <list_begin>
c002a834:	83 c4 10             	add    $0x10,%esp
c002a837:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a83a:	eb 7d                	jmp    c002a8b9 <list_sort+0xec>
        {
          /* Each iteration produces one output run. */
          output_run_cnt++;
c002a83c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
c002a840:	83 ec 0c             	sub    $0xc,%esp
c002a843:	ff 75 08             	pushl  0x8(%ebp)
c002a846:	e8 14 f7 ff ff       	call   c0029f5f <list_end>
c002a84b:	83 c4 10             	add    $0x10,%esp
c002a84e:	ff 75 10             	pushl  0x10(%ebp)
c002a851:	ff 75 0c             	pushl  0xc(%ebp)
c002a854:	50                   	push   %eax
c002a855:	ff 75 f0             	pushl  -0x10(%ebp)
c002a858:	e8 fd fc ff ff       	call   c002a55a <find_end_of_run>
c002a85d:	83 c4 10             	add    $0x10,%esp
c002a860:	89 45 ec             	mov    %eax,-0x14(%ebp)
          if (a1b0 == list_end (list))
c002a863:	83 ec 0c             	sub    $0xc,%esp
c002a866:	ff 75 08             	pushl  0x8(%ebp)
c002a869:	e8 f1 f6 ff ff       	call   c0029f5f <list_end>
c002a86e:	83 c4 10             	add    $0x10,%esp
c002a871:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002a874:	74 5c                	je     c002a8d2 <list_sort+0x105>
            break;
          b1 = find_end_of_run (a1b0, list_end (list), less, aux);
c002a876:	83 ec 0c             	sub    $0xc,%esp
c002a879:	ff 75 08             	pushl  0x8(%ebp)
c002a87c:	e8 de f6 ff ff       	call   c0029f5f <list_end>
c002a881:	83 c4 10             	add    $0x10,%esp
c002a884:	ff 75 10             	pushl  0x10(%ebp)
c002a887:	ff 75 0c             	pushl  0xc(%ebp)
c002a88a:	50                   	push   %eax
c002a88b:	ff 75 ec             	pushl  -0x14(%ebp)
c002a88e:	e8 c7 fc ff ff       	call   c002a55a <find_end_of_run>
c002a893:	83 c4 10             	add    $0x10,%esp
c002a896:	89 45 e8             	mov    %eax,-0x18(%ebp)

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
c002a899:	83 ec 0c             	sub    $0xc,%esp
c002a89c:	ff 75 10             	pushl  0x10(%ebp)
c002a89f:	ff 75 0c             	pushl  0xc(%ebp)
c002a8a2:	ff 75 e8             	pushl  -0x18(%ebp)
c002a8a5:	ff 75 ec             	pushl  -0x14(%ebp)
c002a8a8:	ff 75 f0             	pushl  -0x10(%ebp)
c002a8ab:	e8 93 fd ff ff       	call   c002a643 <inplace_merge>
c002a8b0:	83 c4 20             	add    $0x20,%esp
      struct list_elem *a0;     /* Start of first run. */
      struct list_elem *a1b0;   /* End of first run, start of second. */
      struct list_elem *b1;     /* End of second run. */

      output_run_cnt = 0;
      for (a0 = list_begin (list); a0 != list_end (list); a0 = b1)
c002a8b3:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002a8b6:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002a8b9:	83 ec 0c             	sub    $0xc,%esp
c002a8bc:	ff 75 08             	pushl  0x8(%ebp)
c002a8bf:	e8 9b f6 ff ff       	call   c0029f5f <list_end>
c002a8c4:	83 c4 10             	add    $0x10,%esp
c002a8c7:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002a8ca:	0f 85 6c ff ff ff    	jne    c002a83c <list_sort+0x6f>
c002a8d0:	eb 01                	jmp    c002a8d3 <list_sort+0x106>

          /* Locate two adjacent runs of nondecreasing elements
             A0...A1B0 and A1B0...B1. */
          a1b0 = find_end_of_run (a0, list_end (list), less, aux);
          if (a1b0 == list_end (list))
            break;
c002a8d2:	90                   	nop

          /* Merge the runs. */
          inplace_merge (a0, a1b0, b1, less, aux);
        }
    }
  while (output_run_cnt > 1);
c002a8d3:	83 7d f4 01          	cmpl   $0x1,-0xc(%ebp)
c002a8d7:	0f 87 45 ff ff ff    	ja     c002a822 <list_sort+0x55>

  ASSERT (is_sorted (list_begin (list), list_end (list), less, aux));
c002a8dd:	83 ec 0c             	sub    $0xc,%esp
c002a8e0:	ff 75 08             	pushl  0x8(%ebp)
c002a8e3:	e8 77 f6 ff ff       	call   c0029f5f <list_end>
c002a8e8:	83 c4 10             	add    $0x10,%esp
c002a8eb:	89 c3                	mov    %eax,%ebx
c002a8ed:	83 ec 0c             	sub    $0xc,%esp
c002a8f0:	ff 75 08             	pushl  0x8(%ebp)
c002a8f3:	e8 eb f5 ff ff       	call   c0029ee3 <list_begin>
c002a8f8:	83 c4 10             	add    $0x10,%esp
c002a8fb:	ff 75 10             	pushl  0x10(%ebp)
c002a8fe:	ff 75 0c             	pushl  0xc(%ebp)
c002a901:	53                   	push   %ebx
c002a902:	50                   	push   %eax
c002a903:	e8 f7 fb ff ff       	call   c002a4ff <is_sorted>
c002a908:	83 c4 10             	add    $0x10,%esp
c002a90b:	84 c0                	test   %al,%al
c002a90d:	75 21                	jne    c002a930 <list_sort+0x163>
c002a90f:	83 ec 0c             	sub    $0xc,%esp
c002a912:	68 cc 14 03 c0       	push   $0xc00314cc
c002a917:	68 3d 13 03 c0       	push   $0xc003133d
c002a91c:	68 d0 15 03 c0       	push   $0xc00315d0
c002a921:	68 b7 01 00 00       	push   $0x1b7
c002a926:	68 54 13 03 c0       	push   $0xc0031354
c002a92b:	e8 eb f2 ff ff       	call   c0029c1b <debug_panic>
}
c002a930:	90                   	nop
c002a931:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002a934:	c9                   	leave  
c002a935:	c3                   	ret    

c002a936 <list_insert_ordered>:
   sorted according to LESS given auxiliary data AUX.
   Runs in O(n) average case in the number of elements in LIST. */
void
list_insert_ordered (struct list *list, struct list_elem *elem,
                     list_less_func *less, void *aux)
{
c002a936:	55                   	push   %ebp
c002a937:	89 e5                	mov    %esp,%ebp
c002a939:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *e;

  ASSERT (list != NULL);
c002a93c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002a940:	75 21                	jne    c002a963 <list_insert_ordered+0x2d>
c002a942:	83 ec 0c             	sub    $0xc,%esp
c002a945:	68 30 13 03 c0       	push   $0xc0031330
c002a94a:	68 3d 13 03 c0       	push   $0xc003133d
c002a94f:	68 dc 15 03 c0       	push   $0xc00315dc
c002a954:	68 c3 01 00 00       	push   $0x1c3
c002a959:	68 54 13 03 c0       	push   $0xc0031354
c002a95e:	e8 b8 f2 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (elem != NULL);
c002a963:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002a967:	75 21                	jne    c002a98a <list_insert_ordered+0x54>
c002a969:	83 ec 0c             	sub    $0xc,%esp
c002a96c:	68 e5 13 03 c0       	push   $0xc00313e5
c002a971:	68 3d 13 03 c0       	push   $0xc003133d
c002a976:	68 dc 15 03 c0       	push   $0xc00315dc
c002a97b:	68 c4 01 00 00       	push   $0x1c4
c002a980:	68 54 13 03 c0       	push   $0xc0031354
c002a985:	e8 91 f2 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (less != NULL);
c002a98a:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002a98e:	75 21                	jne    c002a9b1 <list_insert_ordered+0x7b>
c002a990:	83 ec 0c             	sub    $0xc,%esp
c002a993:	68 53 14 03 c0       	push   $0xc0031453
c002a998:	68 3d 13 03 c0       	push   $0xc003133d
c002a99d:	68 dc 15 03 c0       	push   $0xc00315dc
c002a9a2:	68 c5 01 00 00       	push   $0x1c5
c002a9a7:	68 54 13 03 c0       	push   $0xc0031354
c002a9ac:	e8 6a f2 ff ff       	call   c0029c1b <debug_panic>

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a9b1:	83 ec 0c             	sub    $0xc,%esp
c002a9b4:	ff 75 08             	pushl  0x8(%ebp)
c002a9b7:	e8 27 f5 ff ff       	call   c0029ee3 <list_begin>
c002a9bc:	83 c4 10             	add    $0x10,%esp
c002a9bf:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a9c2:	eb 29                	jmp    c002a9ed <list_insert_ordered+0xb7>
    if (less (elem, e, aux))
c002a9c4:	83 ec 04             	sub    $0x4,%esp
c002a9c7:	ff 75 14             	pushl  0x14(%ebp)
c002a9ca:	ff 75 f4             	pushl  -0xc(%ebp)
c002a9cd:	ff 75 0c             	pushl  0xc(%ebp)
c002a9d0:	8b 45 10             	mov    0x10(%ebp),%eax
c002a9d3:	ff d0                	call   *%eax
c002a9d5:	83 c4 10             	add    $0x10,%esp
c002a9d8:	84 c0                	test   %al,%al
c002a9da:	75 26                	jne    c002aa02 <list_insert_ordered+0xcc>

  ASSERT (list != NULL);
  ASSERT (elem != NULL);
  ASSERT (less != NULL);

  for (e = list_begin (list); e != list_end (list); e = list_next (e))
c002a9dc:	83 ec 0c             	sub    $0xc,%esp
c002a9df:	ff 75 f4             	pushl  -0xc(%ebp)
c002a9e2:	e8 2e f5 ff ff       	call   c0029f15 <list_next>
c002a9e7:	83 c4 10             	add    $0x10,%esp
c002a9ea:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002a9ed:	83 ec 0c             	sub    $0xc,%esp
c002a9f0:	ff 75 08             	pushl  0x8(%ebp)
c002a9f3:	e8 67 f5 ff ff       	call   c0029f5f <list_end>
c002a9f8:	83 c4 10             	add    $0x10,%esp
c002a9fb:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002a9fe:	75 c4                	jne    c002a9c4 <list_insert_ordered+0x8e>
c002aa00:	eb 01                	jmp    c002aa03 <list_insert_ordered+0xcd>
    if (less (elem, e, aux))
      break;
c002aa02:	90                   	nop
  return list_insert (e, elem);
c002aa03:	83 ec 08             	sub    $0x8,%esp
c002aa06:	ff 75 0c             	pushl  0xc(%ebp)
c002aa09:	ff 75 f4             	pushl  -0xc(%ebp)
c002aa0c:	e8 94 f6 ff ff       	call   c002a0a5 <list_insert>
c002aa11:	83 c4 10             	add    $0x10,%esp
}
c002aa14:	c9                   	leave  
c002aa15:	c3                   	ret    

c002aa16 <list_unique>:
   given auxiliary data AUX.  If DUPLICATES is non-null, then the
   elements from LIST are appended to DUPLICATES. */
void
list_unique (struct list *list, struct list *duplicates,
             list_less_func *less, void *aux)
{
c002aa16:	55                   	push   %ebp
c002aa17:	89 e5                	mov    %esp,%ebp
c002aa19:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
c002aa1c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aa20:	75 21                	jne    c002aa43 <list_unique+0x2d>
c002aa22:	83 ec 0c             	sub    $0xc,%esp
c002aa25:	68 30 13 03 c0       	push   $0xc0031330
c002aa2a:	68 3d 13 03 c0       	push   $0xc003133d
c002aa2f:	68 f0 15 03 c0       	push   $0xc00315f0
c002aa34:	68 d7 01 00 00       	push   $0x1d7
c002aa39:	68 54 13 03 c0       	push   $0xc0031354
c002aa3e:	e8 d8 f1 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (less != NULL);
c002aa43:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002aa47:	75 21                	jne    c002aa6a <list_unique+0x54>
c002aa49:	83 ec 0c             	sub    $0xc,%esp
c002aa4c:	68 53 14 03 c0       	push   $0xc0031453
c002aa51:	68 3d 13 03 c0       	push   $0xc003133d
c002aa56:	68 f0 15 03 c0       	push   $0xc00315f0
c002aa5b:	68 d8 01 00 00       	push   $0x1d8
c002aa60:	68 54 13 03 c0       	push   $0xc0031354
c002aa65:	e8 b1 f1 ff ff       	call   c0029c1b <debug_panic>
  if (list_empty (list))
c002aa6a:	83 ec 0c             	sub    $0xc,%esp
c002aa6d:	ff 75 08             	pushl  0x8(%ebp)
c002aa70:	e8 a1 f9 ff ff       	call   c002a416 <list_empty>
c002aa75:	83 c4 10             	add    $0x10,%esp
c002aa78:	84 c0                	test   %al,%al
c002aa7a:	0f 85 a0 00 00 00    	jne    c002ab20 <list_unique+0x10a>
    return;

  elem = list_begin (list);
c002aa80:	83 ec 0c             	sub    $0xc,%esp
c002aa83:	ff 75 08             	pushl  0x8(%ebp)
c002aa86:	e8 58 f4 ff ff       	call   c0029ee3 <list_begin>
c002aa8b:	83 c4 10             	add    $0x10,%esp
c002aa8e:	89 45 f4             	mov    %eax,-0xc(%ebp)
  while ((next = list_next (elem)) != list_end (list))
c002aa91:	eb 63                	jmp    c002aaf6 <list_unique+0xe0>
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
c002aa93:	83 ec 04             	sub    $0x4,%esp
c002aa96:	ff 75 14             	pushl  0x14(%ebp)
c002aa99:	ff 75 f0             	pushl  -0x10(%ebp)
c002aa9c:	ff 75 f4             	pushl  -0xc(%ebp)
c002aa9f:	8b 45 10             	mov    0x10(%ebp),%eax
c002aaa2:	ff d0                	call   *%eax
c002aaa4:	83 c4 10             	add    $0x10,%esp
c002aaa7:	83 f0 01             	xor    $0x1,%eax
c002aaaa:	84 c0                	test   %al,%al
c002aaac:	74 42                	je     c002aaf0 <list_unique+0xda>
c002aaae:	83 ec 04             	sub    $0x4,%esp
c002aab1:	ff 75 14             	pushl  0x14(%ebp)
c002aab4:	ff 75 f4             	pushl  -0xc(%ebp)
c002aab7:	ff 75 f0             	pushl  -0x10(%ebp)
c002aaba:	8b 45 10             	mov    0x10(%ebp),%eax
c002aabd:	ff d0                	call   *%eax
c002aabf:	83 c4 10             	add    $0x10,%esp
c002aac2:	83 f0 01             	xor    $0x1,%eax
c002aac5:	84 c0                	test   %al,%al
c002aac7:	74 27                	je     c002aaf0 <list_unique+0xda>
      {
        list_remove (next);
c002aac9:	83 ec 0c             	sub    $0xc,%esp
c002aacc:	ff 75 f0             	pushl  -0x10(%ebp)
c002aacf:	e8 c0 f7 ff ff       	call   c002a294 <list_remove>
c002aad4:	83 c4 10             	add    $0x10,%esp
        if (duplicates != NULL)
c002aad7:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002aadb:	74 19                	je     c002aaf6 <list_unique+0xe0>
          list_push_back (duplicates, next);
c002aadd:	83 ec 08             	sub    $0x8,%esp
c002aae0:	ff 75 f0             	pushl  -0x10(%ebp)
c002aae3:	ff 75 0c             	pushl  0xc(%ebp)
c002aae6:	e8 83 f7 ff ff       	call   c002a26e <list_push_back>
c002aaeb:	83 c4 10             	add    $0x10,%esp
  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
    if (!less (elem, next, aux) && !less (next, elem, aux)) 
      {
        list_remove (next);
        if (duplicates != NULL)
c002aaee:	eb 06                	jmp    c002aaf6 <list_unique+0xe0>
          list_push_back (duplicates, next);
      }
    else
      elem = next;
c002aaf0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002aaf3:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (less != NULL);
  if (list_empty (list))
    return;

  elem = list_begin (list);
  while ((next = list_next (elem)) != list_end (list))
c002aaf6:	83 ec 0c             	sub    $0xc,%esp
c002aaf9:	ff 75 f4             	pushl  -0xc(%ebp)
c002aafc:	e8 14 f4 ff ff       	call   c0029f15 <list_next>
c002ab01:	83 c4 10             	add    $0x10,%esp
c002ab04:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab07:	83 ec 0c             	sub    $0xc,%esp
c002ab0a:	ff 75 08             	pushl  0x8(%ebp)
c002ab0d:	e8 4d f4 ff ff       	call   c0029f5f <list_end>
c002ab12:	83 c4 10             	add    $0x10,%esp
c002ab15:	39 45 f0             	cmp    %eax,-0x10(%ebp)
c002ab18:	0f 85 75 ff ff ff    	jne    c002aa93 <list_unique+0x7d>
c002ab1e:	eb 01                	jmp    c002ab21 <list_unique+0x10b>
  struct list_elem *elem, *next;

  ASSERT (list != NULL);
  ASSERT (less != NULL);
  if (list_empty (list))
    return;
c002ab20:	90                   	nop
        if (duplicates != NULL)
          list_push_back (duplicates, next);
      }
    else
      elem = next;
}
c002ab21:	c9                   	leave  
c002ab22:	c3                   	ret    

c002ab23 <list_max>:
   to LESS given auxiliary data AUX.  If there is more than one
   maximum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_max (struct list *list, list_less_func *less, void *aux)
{
c002ab23:	55                   	push   %ebp
c002ab24:	89 e5                	mov    %esp,%ebp
c002ab26:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *max = list_begin (list);
c002ab29:	83 ec 0c             	sub    $0xc,%esp
c002ab2c:	ff 75 08             	pushl  0x8(%ebp)
c002ab2f:	e8 af f3 ff ff       	call   c0029ee3 <list_begin>
c002ab34:	83 c4 10             	add    $0x10,%esp
c002ab37:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (max != list_end (list)) 
c002ab3a:	83 ec 0c             	sub    $0xc,%esp
c002ab3d:	ff 75 08             	pushl  0x8(%ebp)
c002ab40:	e8 1a f4 ff ff       	call   c0029f5f <list_end>
c002ab45:	83 c4 10             	add    $0x10,%esp
c002ab48:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ab4b:	74 55                	je     c002aba2 <list_max+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002ab4d:	83 ec 0c             	sub    $0xc,%esp
c002ab50:	ff 75 f4             	pushl  -0xc(%ebp)
c002ab53:	e8 bd f3 ff ff       	call   c0029f15 <list_next>
c002ab58:	83 c4 10             	add    $0x10,%esp
c002ab5b:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab5e:	eb 2f                	jmp    c002ab8f <list_max+0x6c>
        if (less (max, e, aux))
c002ab60:	83 ec 04             	sub    $0x4,%esp
c002ab63:	ff 75 10             	pushl  0x10(%ebp)
c002ab66:	ff 75 f0             	pushl  -0x10(%ebp)
c002ab69:	ff 75 f4             	pushl  -0xc(%ebp)
c002ab6c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002ab6f:	ff d0                	call   *%eax
c002ab71:	83 c4 10             	add    $0x10,%esp
c002ab74:	84 c0                	test   %al,%al
c002ab76:	74 06                	je     c002ab7e <list_max+0x5b>
          max = e; 
c002ab78:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ab7b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *max = list_begin (list);
  if (max != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (max); e != list_end (list); e = list_next (e))
c002ab7e:	83 ec 0c             	sub    $0xc,%esp
c002ab81:	ff 75 f0             	pushl  -0x10(%ebp)
c002ab84:	e8 8c f3 ff ff       	call   c0029f15 <list_next>
c002ab89:	83 c4 10             	add    $0x10,%esp
c002ab8c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ab8f:	83 ec 0c             	sub    $0xc,%esp
c002ab92:	ff 75 08             	pushl  0x8(%ebp)
c002ab95:	e8 c5 f3 ff ff       	call   c0029f5f <list_end>
c002ab9a:	83 c4 10             	add    $0x10,%esp
c002ab9d:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002aba0:	75 be                	jne    c002ab60 <list_max+0x3d>
        if (less (max, e, aux))
          max = e; 
    }
  return max;
c002aba2:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002aba5:	c9                   	leave  
c002aba6:	c3                   	ret    

c002aba7 <list_min>:
   to LESS given auxiliary data AUX.  If there is more than one
   minimum, returns the one that appears earlier in the list.  If
   the list is empty, returns its tail. */
struct list_elem *
list_min (struct list *list, list_less_func *less, void *aux)
{
c002aba7:	55                   	push   %ebp
c002aba8:	89 e5                	mov    %esp,%ebp
c002abaa:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *min = list_begin (list);
c002abad:	83 ec 0c             	sub    $0xc,%esp
c002abb0:	ff 75 08             	pushl  0x8(%ebp)
c002abb3:	e8 2b f3 ff ff       	call   c0029ee3 <list_begin>
c002abb8:	83 c4 10             	add    $0x10,%esp
c002abbb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (min != list_end (list)) 
c002abbe:	83 ec 0c             	sub    $0xc,%esp
c002abc1:	ff 75 08             	pushl  0x8(%ebp)
c002abc4:	e8 96 f3 ff ff       	call   c0029f5f <list_end>
c002abc9:	83 c4 10             	add    $0x10,%esp
c002abcc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002abcf:	74 55                	je     c002ac26 <list_min+0x7f>
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002abd1:	83 ec 0c             	sub    $0xc,%esp
c002abd4:	ff 75 f4             	pushl  -0xc(%ebp)
c002abd7:	e8 39 f3 ff ff       	call   c0029f15 <list_next>
c002abdc:	83 c4 10             	add    $0x10,%esp
c002abdf:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002abe2:	eb 2f                	jmp    c002ac13 <list_min+0x6c>
        if (less (e, min, aux))
c002abe4:	83 ec 04             	sub    $0x4,%esp
c002abe7:	ff 75 10             	pushl  0x10(%ebp)
c002abea:	ff 75 f4             	pushl  -0xc(%ebp)
c002abed:	ff 75 f0             	pushl  -0x10(%ebp)
c002abf0:	8b 45 0c             	mov    0xc(%ebp),%eax
c002abf3:	ff d0                	call   *%eax
c002abf5:	83 c4 10             	add    $0x10,%esp
c002abf8:	84 c0                	test   %al,%al
c002abfa:	74 06                	je     c002ac02 <list_min+0x5b>
          min = e; 
c002abfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002abff:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct list_elem *min = list_begin (list);
  if (min != list_end (list)) 
    {
      struct list_elem *e;
      
      for (e = list_next (min); e != list_end (list); e = list_next (e))
c002ac02:	83 ec 0c             	sub    $0xc,%esp
c002ac05:	ff 75 f0             	pushl  -0x10(%ebp)
c002ac08:	e8 08 f3 ff ff       	call   c0029f15 <list_next>
c002ac0d:	83 c4 10             	add    $0x10,%esp
c002ac10:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ac13:	83 ec 0c             	sub    $0xc,%esp
c002ac16:	ff 75 08             	pushl  0x8(%ebp)
c002ac19:	e8 41 f3 ff ff       	call   c0029f5f <list_end>
c002ac1e:	83 c4 10             	add    $0x10,%esp
c002ac21:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002ac24:	75 be                	jne    c002abe4 <list_min+0x3d>
        if (less (e, min, aux))
          min = e; 
    }
  return min;
c002ac26:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ac29:	c9                   	leave  
c002ac2a:	c3                   	ret    

c002ac2b <elem_idx>:

/* Returns the index of the element that contains the bit
   numbered BIT_IDX. */
static inline size_t
elem_idx (size_t bit_idx) 
{
c002ac2b:	55                   	push   %ebp
c002ac2c:	89 e5                	mov    %esp,%ebp
  return bit_idx / ELEM_BITS;
c002ac2e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac31:	c1 e8 05             	shr    $0x5,%eax
}
c002ac34:	5d                   	pop    %ebp
c002ac35:	c3                   	ret    

c002ac36 <bit_mask>:

/* Returns an elem_type where only the bit corresponding to
   BIT_IDX is turned on. */
static inline elem_type
bit_mask (size_t bit_idx) 
{
c002ac36:	55                   	push   %ebp
c002ac37:	89 e5                	mov    %esp,%ebp
  return (elem_type) 1 << (bit_idx % ELEM_BITS);
c002ac39:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac3c:	83 e0 1f             	and    $0x1f,%eax
c002ac3f:	ba 01 00 00 00       	mov    $0x1,%edx
c002ac44:	89 c1                	mov    %eax,%ecx
c002ac46:	d3 e2                	shl    %cl,%edx
c002ac48:	89 d0                	mov    %edx,%eax
}
c002ac4a:	5d                   	pop    %ebp
c002ac4b:	c3                   	ret    

c002ac4c <elem_cnt>:

/* Returns the number of elements required for BIT_CNT bits. */
static inline size_t
elem_cnt (size_t bit_cnt)
{
c002ac4c:	55                   	push   %ebp
c002ac4d:	89 e5                	mov    %esp,%ebp
  return DIV_ROUND_UP (bit_cnt, ELEM_BITS);
c002ac4f:	8b 45 08             	mov    0x8(%ebp),%eax
c002ac52:	83 c0 1f             	add    $0x1f,%eax
c002ac55:	c1 e8 05             	shr    $0x5,%eax
}
c002ac58:	5d                   	pop    %ebp
c002ac59:	c3                   	ret    

c002ac5a <byte_cnt>:

/* Returns the number of bytes required for BIT_CNT bits. */
static inline size_t
byte_cnt (size_t bit_cnt)
{
c002ac5a:	55                   	push   %ebp
c002ac5b:	89 e5                	mov    %esp,%ebp
  return sizeof (elem_type) * elem_cnt (bit_cnt);
c002ac5d:	ff 75 08             	pushl  0x8(%ebp)
c002ac60:	e8 e7 ff ff ff       	call   c002ac4c <elem_cnt>
c002ac65:	83 c4 04             	add    $0x4,%esp
c002ac68:	c1 e0 02             	shl    $0x2,%eax
}
c002ac6b:	c9                   	leave  
c002ac6c:	c3                   	ret    

c002ac6d <bitmap_create>:
   BIT_CNT (or more) bits.  Returns a null pointer if memory allocation fails.
   The caller is responsible for freeing the bitmap, with bitmap_destroy(),
   when it is no longer needed. */
struct bitmap *
bitmap_create (size_t bit_cnt) 
{
c002ac6d:	55                   	push   %ebp
c002ac6e:	89 e5                	mov    %esp,%ebp
c002ac70:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = malloc (sizeof *b);
c002ac73:	83 ec 0c             	sub    $0xc,%esp
c002ac76:	6a 08                	push   $0x8
c002ac78:	e8 e4 8c ff ff       	call   c0023961 <malloc>
c002ac7d:	83 c4 10             	add    $0x10,%esp
c002ac80:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (b != NULL)
c002ac83:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002ac87:	74 5d                	je     c002ace6 <bitmap_create+0x79>
    {
      b->bit_cnt = bit_cnt;
c002ac89:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ac8c:	8b 55 08             	mov    0x8(%ebp),%edx
c002ac8f:	89 10                	mov    %edx,(%eax)
      b->bits = malloc (byte_cnt (bit_cnt));
c002ac91:	83 ec 0c             	sub    $0xc,%esp
c002ac94:	ff 75 08             	pushl  0x8(%ebp)
c002ac97:	e8 be ff ff ff       	call   c002ac5a <byte_cnt>
c002ac9c:	83 c4 10             	add    $0x10,%esp
c002ac9f:	83 ec 0c             	sub    $0xc,%esp
c002aca2:	50                   	push   %eax
c002aca3:	e8 b9 8c ff ff       	call   c0023961 <malloc>
c002aca8:	83 c4 10             	add    $0x10,%esp
c002acab:	89 c2                	mov    %eax,%edx
c002acad:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acb0:	89 50 04             	mov    %edx,0x4(%eax)
      if (b->bits != NULL || bit_cnt == 0)
c002acb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acb6:	8b 40 04             	mov    0x4(%eax),%eax
c002acb9:	85 c0                	test   %eax,%eax
c002acbb:	75 06                	jne    c002acc3 <bitmap_create+0x56>
c002acbd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002acc1:	75 15                	jne    c002acd8 <bitmap_create+0x6b>
        {
          bitmap_set_all (b, false);
c002acc3:	83 ec 08             	sub    $0x8,%esp
c002acc6:	6a 00                	push   $0x0
c002acc8:	ff 75 f4             	pushl  -0xc(%ebp)
c002accb:	e8 92 02 00 00       	call   c002af62 <bitmap_set_all>
c002acd0:	83 c4 10             	add    $0x10,%esp
          return b;
c002acd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002acd6:	eb 13                	jmp    c002aceb <bitmap_create+0x7e>
        }
      free (b);
c002acd8:	83 ec 0c             	sub    $0xc,%esp
c002acdb:	ff 75 f4             	pushl  -0xc(%ebp)
c002acde:	e8 7f 8f ff ff       	call   c0023c62 <free>
c002ace3:	83 c4 10             	add    $0x10,%esp
    }
  return NULL;
c002ace6:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002aceb:	c9                   	leave  
c002acec:	c3                   	ret    

c002aced <bitmap_create_in_buf>:
/* Creates and returns a bitmap with BIT_CNT bits in the
   BLOCK_SIZE bytes of storage preallocated at BLOCK.
   BLOCK_SIZE must be at least bitmap_needed_bytes(BIT_CNT). */
struct bitmap *
bitmap_create_in_buf (size_t bit_cnt, void *block, size_t block_size UNUSED)
{
c002aced:	55                   	push   %ebp
c002acee:	89 e5                	mov    %esp,%ebp
c002acf0:	83 ec 18             	sub    $0x18,%esp
  struct bitmap *b = block;
c002acf3:	8b 45 0c             	mov    0xc(%ebp),%eax
c002acf6:	89 45 f4             	mov    %eax,-0xc(%ebp)
  
  ASSERT (block_size >= bitmap_buf_size (bit_cnt));
c002acf9:	83 ec 0c             	sub    $0xc,%esp
c002acfc:	ff 75 08             	pushl  0x8(%ebp)
c002acff:	e8 4f 00 00 00       	call   c002ad53 <bitmap_buf_size>
c002ad04:	83 c4 10             	add    $0x10,%esp
c002ad07:	3b 45 10             	cmp    0x10(%ebp),%eax
c002ad0a:	76 1e                	jbe    c002ad2a <bitmap_create_in_buf+0x3d>
c002ad0c:	83 ec 0c             	sub    $0xc,%esp
c002ad0f:	68 fc 15 03 c0       	push   $0xc00315fc
c002ad14:	68 24 16 03 c0       	push   $0xc0031624
c002ad19:	68 a0 16 03 c0       	push   $0xc00316a0
c002ad1e:	6a 68                	push   $0x68
c002ad20:	68 3b 16 03 c0       	push   $0xc003163b
c002ad25:	e8 f1 ee ff ff       	call   c0029c1b <debug_panic>

  b->bit_cnt = bit_cnt;
c002ad2a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad2d:	8b 55 08             	mov    0x8(%ebp),%edx
c002ad30:	89 10                	mov    %edx,(%eax)
  b->bits = (elem_type *) (b + 1);
c002ad32:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad35:	8d 50 08             	lea    0x8(%eax),%edx
c002ad38:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002ad3b:	89 50 04             	mov    %edx,0x4(%eax)
  bitmap_set_all (b, false);
c002ad3e:	83 ec 08             	sub    $0x8,%esp
c002ad41:	6a 00                	push   $0x0
c002ad43:	ff 75 f4             	pushl  -0xc(%ebp)
c002ad46:	e8 17 02 00 00       	call   c002af62 <bitmap_set_all>
c002ad4b:	83 c4 10             	add    $0x10,%esp
  return b;
c002ad4e:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002ad51:	c9                   	leave  
c002ad52:	c3                   	ret    

c002ad53 <bitmap_buf_size>:

/* Returns the number of bytes required to accomodate a bitmap
   with BIT_CNT bits (for use with bitmap_create_in_buf()). */
size_t
bitmap_buf_size (size_t bit_cnt) 
{
c002ad53:	55                   	push   %ebp
c002ad54:	89 e5                	mov    %esp,%ebp
  return sizeof (struct bitmap) + byte_cnt (bit_cnt);
c002ad56:	ff 75 08             	pushl  0x8(%ebp)
c002ad59:	e8 fc fe ff ff       	call   c002ac5a <byte_cnt>
c002ad5e:	83 c4 04             	add    $0x4,%esp
c002ad61:	83 c0 08             	add    $0x8,%eax
}
c002ad64:	c9                   	leave  
c002ad65:	c3                   	ret    

c002ad66 <bitmap_destroy>:

/* Destroys bitmap B, freeing its storage.
   Not for use on bitmaps created by bitmap_create_in_buf(). */
void
bitmap_destroy (struct bitmap *b) 
{
c002ad66:	55                   	push   %ebp
c002ad67:	89 e5                	mov    %esp,%ebp
c002ad69:	83 ec 08             	sub    $0x8,%esp
  if (b != NULL) 
c002ad6c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ad70:	74 20                	je     c002ad92 <bitmap_destroy+0x2c>
    {
      free (b->bits);
c002ad72:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad75:	8b 40 04             	mov    0x4(%eax),%eax
c002ad78:	83 ec 0c             	sub    $0xc,%esp
c002ad7b:	50                   	push   %eax
c002ad7c:	e8 e1 8e ff ff       	call   c0023c62 <free>
c002ad81:	83 c4 10             	add    $0x10,%esp
      free (b);
c002ad84:	83 ec 0c             	sub    $0xc,%esp
c002ad87:	ff 75 08             	pushl  0x8(%ebp)
c002ad8a:	e8 d3 8e ff ff       	call   c0023c62 <free>
c002ad8f:	83 c4 10             	add    $0x10,%esp
    }
}
c002ad92:	90                   	nop
c002ad93:	c9                   	leave  
c002ad94:	c3                   	ret    

c002ad95 <bitmap_size>:
/* Bitmap size. */

/* Returns the number of bits in B. */
size_t
bitmap_size (const struct bitmap *b)
{
c002ad95:	55                   	push   %ebp
c002ad96:	89 e5                	mov    %esp,%ebp
  return b->bit_cnt;
c002ad98:	8b 45 08             	mov    0x8(%ebp),%eax
c002ad9b:	8b 00                	mov    (%eax),%eax
}
c002ad9d:	5d                   	pop    %ebp
c002ad9e:	c3                   	ret    

c002ad9f <bitmap_set>:
/* Setting and testing single bits. */

/* Atomically sets the bit numbered IDX in B to VALUE. */
void
bitmap_set (struct bitmap *b, size_t idx, bool value) 
{
c002ad9f:	55                   	push   %ebp
c002ada0:	89 e5                	mov    %esp,%ebp
c002ada2:	83 ec 18             	sub    $0x18,%esp
c002ada5:	8b 45 10             	mov    0x10(%ebp),%eax
c002ada8:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002adab:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002adaf:	75 21                	jne    c002add2 <bitmap_set+0x33>
c002adb1:	83 ec 0c             	sub    $0xc,%esp
c002adb4:	68 55 16 03 c0       	push   $0xc0031655
c002adb9:	68 24 16 03 c0       	push   $0xc0031624
c002adbe:	68 b8 16 03 c0       	push   $0xc00316b8
c002adc3:	68 93 00 00 00       	push   $0x93
c002adc8:	68 3b 16 03 c0       	push   $0xc003163b
c002adcd:	e8 49 ee ff ff       	call   c0029c1b <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002add2:	8b 45 08             	mov    0x8(%ebp),%eax
c002add5:	8b 00                	mov    (%eax),%eax
c002add7:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002adda:	77 21                	ja     c002adfd <bitmap_set+0x5e>
c002addc:	83 ec 0c             	sub    $0xc,%esp
c002addf:	68 5f 16 03 c0       	push   $0xc003165f
c002ade4:	68 24 16 03 c0       	push   $0xc0031624
c002ade9:	68 b8 16 03 c0       	push   $0xc00316b8
c002adee:	68 94 00 00 00       	push   $0x94
c002adf3:	68 3b 16 03 c0       	push   $0xc003163b
c002adf8:	e8 1e ee ff ff       	call   c0029c1b <debug_panic>
  if (value)
c002adfd:	80 7d f4 00          	cmpb   $0x0,-0xc(%ebp)
c002ae01:	74 13                	je     c002ae16 <bitmap_set+0x77>
    bitmap_mark (b, idx);
c002ae03:	83 ec 08             	sub    $0x8,%esp
c002ae06:	ff 75 0c             	pushl  0xc(%ebp)
c002ae09:	ff 75 08             	pushl  0x8(%ebp)
c002ae0c:	e8 19 00 00 00       	call   c002ae2a <bitmap_mark>
c002ae11:	83 c4 10             	add    $0x10,%esp
  else
    bitmap_reset (b, idx);
}
c002ae14:	eb 11                	jmp    c002ae27 <bitmap_set+0x88>
  ASSERT (b != NULL);
  ASSERT (idx < b->bit_cnt);
  if (value)
    bitmap_mark (b, idx);
  else
    bitmap_reset (b, idx);
c002ae16:	83 ec 08             	sub    $0x8,%esp
c002ae19:	ff 75 0c             	pushl  0xc(%ebp)
c002ae1c:	ff 75 08             	pushl  0x8(%ebp)
c002ae1f:	e8 3e 00 00 00       	call   c002ae62 <bitmap_reset>
c002ae24:	83 c4 10             	add    $0x10,%esp
}
c002ae27:	90                   	nop
c002ae28:	c9                   	leave  
c002ae29:	c3                   	ret    

c002ae2a <bitmap_mark>:

/* Atomically sets the bit numbered BIT_IDX in B to true. */
void
bitmap_mark (struct bitmap *b, size_t bit_idx) 
{
c002ae2a:	55                   	push   %ebp
c002ae2b:	89 e5                	mov    %esp,%ebp
c002ae2d:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002ae30:	ff 75 0c             	pushl  0xc(%ebp)
c002ae33:	e8 f3 fd ff ff       	call   c002ac2b <elem_idx>
c002ae38:	83 c4 04             	add    $0x4,%esp
c002ae3b:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002ae3e:	ff 75 0c             	pushl  0xc(%ebp)
c002ae41:	e8 f0 fd ff ff       	call   c002ac36 <bit_mask>
c002ae46:	83 c4 04             	add    $0x4,%esp
c002ae49:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] |= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the OR instruction in [IA32-v2b]. */
  asm ("orl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002ae4c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae4f:	8b 40 04             	mov    0x4(%eax),%eax
c002ae52:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002ae55:	c1 e2 02             	shl    $0x2,%edx
c002ae58:	01 c2                	add    %eax,%edx
c002ae5a:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002ae5d:	09 02                	or     %eax,(%edx)
}
c002ae5f:	90                   	nop
c002ae60:	c9                   	leave  
c002ae61:	c3                   	ret    

c002ae62 <bitmap_reset>:

/* Atomically sets the bit numbered BIT_IDX in B to false. */
void
bitmap_reset (struct bitmap *b, size_t bit_idx) 
{
c002ae62:	55                   	push   %ebp
c002ae63:	89 e5                	mov    %esp,%ebp
c002ae65:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002ae68:	ff 75 0c             	pushl  0xc(%ebp)
c002ae6b:	e8 bb fd ff ff       	call   c002ac2b <elem_idx>
c002ae70:	83 c4 04             	add    $0x4,%esp
c002ae73:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002ae76:	ff 75 0c             	pushl  0xc(%ebp)
c002ae79:	e8 b8 fd ff ff       	call   c002ac36 <bit_mask>
c002ae7e:	83 c4 04             	add    $0x4,%esp
c002ae81:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] &= ~mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the AND instruction in [IA32-v2a]. */
  asm ("andl %1, %0" : "=m" (b->bits[idx]) : "r" (~mask) : "cc");
c002ae84:	8b 45 08             	mov    0x8(%ebp),%eax
c002ae87:	8b 40 04             	mov    0x4(%eax),%eax
c002ae8a:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002ae8d:	c1 e2 02             	shl    $0x2,%edx
c002ae90:	01 d0                	add    %edx,%eax
c002ae92:	8b 55 f8             	mov    -0x8(%ebp),%edx
c002ae95:	f7 d2                	not    %edx
c002ae97:	21 10                	and    %edx,(%eax)
}
c002ae99:	90                   	nop
c002ae9a:	c9                   	leave  
c002ae9b:	c3                   	ret    

c002ae9c <bitmap_flip>:
/* Atomically toggles the bit numbered IDX in B;
   that is, if it is true, makes it false,
   and if it is false, makes it true. */
void
bitmap_flip (struct bitmap *b, size_t bit_idx) 
{
c002ae9c:	55                   	push   %ebp
c002ae9d:	89 e5                	mov    %esp,%ebp
c002ae9f:	83 ec 10             	sub    $0x10,%esp
  size_t idx = elem_idx (bit_idx);
c002aea2:	ff 75 0c             	pushl  0xc(%ebp)
c002aea5:	e8 81 fd ff ff       	call   c002ac2b <elem_idx>
c002aeaa:	83 c4 04             	add    $0x4,%esp
c002aead:	89 45 fc             	mov    %eax,-0x4(%ebp)
  elem_type mask = bit_mask (bit_idx);
c002aeb0:	ff 75 0c             	pushl  0xc(%ebp)
c002aeb3:	e8 7e fd ff ff       	call   c002ac36 <bit_mask>
c002aeb8:	83 c4 04             	add    $0x4,%esp
c002aebb:	89 45 f8             	mov    %eax,-0x8(%ebp)

  /* This is equivalent to `b->bits[idx] ^= mask' except that it
     is guaranteed to be atomic on a uniprocessor machine.  See
     the description of the XOR instruction in [IA32-v2b]. */
  asm ("xorl %1, %0" : "=m" (b->bits[idx]) : "r" (mask) : "cc");
c002aebe:	8b 45 08             	mov    0x8(%ebp),%eax
c002aec1:	8b 40 04             	mov    0x4(%eax),%eax
c002aec4:	8b 55 fc             	mov    -0x4(%ebp),%edx
c002aec7:	c1 e2 02             	shl    $0x2,%edx
c002aeca:	01 c2                	add    %eax,%edx
c002aecc:	8b 45 f8             	mov    -0x8(%ebp),%eax
c002aecf:	31 02                	xor    %eax,(%edx)
}
c002aed1:	90                   	nop
c002aed2:	c9                   	leave  
c002aed3:	c3                   	ret    

c002aed4 <bitmap_test>:

/* Returns the value of the bit numbered IDX in B. */
bool
bitmap_test (const struct bitmap *b, size_t idx) 
{
c002aed4:	55                   	push   %ebp
c002aed5:	89 e5                	mov    %esp,%ebp
c002aed7:	53                   	push   %ebx
c002aed8:	83 ec 04             	sub    $0x4,%esp
  ASSERT (b != NULL);
c002aedb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002aedf:	75 21                	jne    c002af02 <bitmap_test+0x2e>
c002aee1:	83 ec 0c             	sub    $0xc,%esp
c002aee4:	68 55 16 03 c0       	push   $0xc0031655
c002aee9:	68 24 16 03 c0       	push   $0xc0031624
c002aeee:	68 c4 16 03 c0       	push   $0xc00316c4
c002aef3:	68 c8 00 00 00       	push   $0xc8
c002aef8:	68 3b 16 03 c0       	push   $0xc003163b
c002aefd:	e8 19 ed ff ff       	call   c0029c1b <debug_panic>
  ASSERT (idx < b->bit_cnt);
c002af02:	8b 45 08             	mov    0x8(%ebp),%eax
c002af05:	8b 00                	mov    (%eax),%eax
c002af07:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002af0a:	77 21                	ja     c002af2d <bitmap_test+0x59>
c002af0c:	83 ec 0c             	sub    $0xc,%esp
c002af0f:	68 5f 16 03 c0       	push   $0xc003165f
c002af14:	68 24 16 03 c0       	push   $0xc0031624
c002af19:	68 c4 16 03 c0       	push   $0xc00316c4
c002af1e:	68 c9 00 00 00       	push   $0xc9
c002af23:	68 3b 16 03 c0       	push   $0xc003163b
c002af28:	e8 ee ec ff ff       	call   c0029c1b <debug_panic>
  return (b->bits[elem_idx (idx)] & bit_mask (idx)) != 0;
c002af2d:	8b 45 08             	mov    0x8(%ebp),%eax
c002af30:	8b 58 04             	mov    0x4(%eax),%ebx
c002af33:	83 ec 0c             	sub    $0xc,%esp
c002af36:	ff 75 0c             	pushl  0xc(%ebp)
c002af39:	e8 ed fc ff ff       	call   c002ac2b <elem_idx>
c002af3e:	83 c4 10             	add    $0x10,%esp
c002af41:	c1 e0 02             	shl    $0x2,%eax
c002af44:	01 d8                	add    %ebx,%eax
c002af46:	8b 18                	mov    (%eax),%ebx
c002af48:	83 ec 0c             	sub    $0xc,%esp
c002af4b:	ff 75 0c             	pushl  0xc(%ebp)
c002af4e:	e8 e3 fc ff ff       	call   c002ac36 <bit_mask>
c002af53:	83 c4 10             	add    $0x10,%esp
c002af56:	21 d8                	and    %ebx,%eax
c002af58:	85 c0                	test   %eax,%eax
c002af5a:	0f 95 c0             	setne  %al
}
c002af5d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002af60:	c9                   	leave  
c002af61:	c3                   	ret    

c002af62 <bitmap_set_all>:
/* Setting and testing multiple bits. */

/* Sets all bits in B to VALUE. */
void
bitmap_set_all (struct bitmap *b, bool value) 
{
c002af62:	55                   	push   %ebp
c002af63:	89 e5                	mov    %esp,%ebp
c002af65:	53                   	push   %ebx
c002af66:	83 ec 14             	sub    $0x14,%esp
c002af69:	8b 45 0c             	mov    0xc(%ebp),%eax
c002af6c:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (b != NULL);
c002af6f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002af73:	75 21                	jne    c002af96 <bitmap_set_all+0x34>
c002af75:	83 ec 0c             	sub    $0xc,%esp
c002af78:	68 55 16 03 c0       	push   $0xc0031655
c002af7d:	68 24 16 03 c0       	push   $0xc0031624
c002af82:	68 d0 16 03 c0       	push   $0xc00316d0
c002af87:	68 d3 00 00 00       	push   $0xd3
c002af8c:	68 3b 16 03 c0       	push   $0xc003163b
c002af91:	e8 85 ec ff ff       	call   c0029c1b <debug_panic>

  bitmap_set_multiple (b, 0, bitmap_size (b), value);
c002af96:	0f b6 5d f4          	movzbl -0xc(%ebp),%ebx
c002af9a:	83 ec 0c             	sub    $0xc,%esp
c002af9d:	ff 75 08             	pushl  0x8(%ebp)
c002afa0:	e8 f0 fd ff ff       	call   c002ad95 <bitmap_size>
c002afa5:	83 c4 10             	add    $0x10,%esp
c002afa8:	53                   	push   %ebx
c002afa9:	50                   	push   %eax
c002afaa:	6a 00                	push   $0x0
c002afac:	ff 75 08             	pushl  0x8(%ebp)
c002afaf:	e8 09 00 00 00       	call   c002afbd <bitmap_set_multiple>
c002afb4:	83 c4 10             	add    $0x10,%esp
}
c002afb7:	90                   	nop
c002afb8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002afbb:	c9                   	leave  
c002afbc:	c3                   	ret    

c002afbd <bitmap_set_multiple>:

/* Sets the CNT bits starting at START in B to VALUE. */
void
bitmap_set_multiple (struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002afbd:	55                   	push   %ebp
c002afbe:	89 e5                	mov    %esp,%ebp
c002afc0:	83 ec 28             	sub    $0x28,%esp
c002afc3:	8b 45 14             	mov    0x14(%ebp),%eax
c002afc6:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002afc9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002afcd:	75 21                	jne    c002aff0 <bitmap_set_multiple+0x33>
c002afcf:	83 ec 0c             	sub    $0xc,%esp
c002afd2:	68 55 16 03 c0       	push   $0xc0031655
c002afd7:	68 24 16 03 c0       	push   $0xc0031624
c002afdc:	68 e0 16 03 c0       	push   $0xc00316e0
c002afe1:	68 de 00 00 00       	push   $0xde
c002afe6:	68 3b 16 03 c0       	push   $0xc003163b
c002afeb:	e8 2b ec ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002aff0:	8b 45 08             	mov    0x8(%ebp),%eax
c002aff3:	8b 00                	mov    (%eax),%eax
c002aff5:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002aff8:	73 21                	jae    c002b01b <bitmap_set_multiple+0x5e>
c002affa:	83 ec 0c             	sub    $0xc,%esp
c002affd:	68 70 16 03 c0       	push   $0xc0031670
c002b002:	68 24 16 03 c0       	push   $0xc0031624
c002b007:	68 e0 16 03 c0       	push   $0xc00316e0
c002b00c:	68 df 00 00 00       	push   $0xdf
c002b011:	68 3b 16 03 c0       	push   $0xc003163b
c002b016:	e8 00 ec ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b01b:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b01e:	8b 45 10             	mov    0x10(%ebp),%eax
c002b021:	01 c2                	add    %eax,%edx
c002b023:	8b 45 08             	mov    0x8(%ebp),%eax
c002b026:	8b 00                	mov    (%eax),%eax
c002b028:	39 c2                	cmp    %eax,%edx
c002b02a:	76 21                	jbe    c002b04d <bitmap_set_multiple+0x90>
c002b02c:	83 ec 0c             	sub    $0xc,%esp
c002b02f:	68 84 16 03 c0       	push   $0xc0031684
c002b034:	68 24 16 03 c0       	push   $0xc0031624
c002b039:	68 e0 16 03 c0       	push   $0xc00316e0
c002b03e:	68 e0 00 00 00       	push   $0xe0
c002b043:	68 3b 16 03 c0       	push   $0xc003163b
c002b048:	e8 ce eb ff ff       	call   c0029c1b <debug_panic>

  for (i = 0; i < cnt; i++)
c002b04d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b054:	eb 20                	jmp    c002b076 <bitmap_set_multiple+0xb9>
    bitmap_set (b, start + i, value);
c002b056:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b05a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
c002b05d:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b060:	01 ca                	add    %ecx,%edx
c002b062:	83 ec 04             	sub    $0x4,%esp
c002b065:	50                   	push   %eax
c002b066:	52                   	push   %edx
c002b067:	ff 75 08             	pushl  0x8(%ebp)
c002b06a:	e8 30 fd ff ff       	call   c002ad9f <bitmap_set>
c002b06f:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002b072:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b076:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b079:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b07c:	72 d8                	jb     c002b056 <bitmap_set_multiple+0x99>
    bitmap_set (b, start + i, value);
}
c002b07e:	90                   	nop
c002b07f:	c9                   	leave  
c002b080:	c3                   	ret    

c002b081 <bitmap_count>:

/* Returns the number of bits in B between START and START + CNT,
   exclusive, that are set to VALUE. */
size_t
bitmap_count (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b081:	55                   	push   %ebp
c002b082:	89 e5                	mov    %esp,%ebp
c002b084:	83 ec 28             	sub    $0x28,%esp
c002b087:	8b 45 14             	mov    0x14(%ebp),%eax
c002b08a:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i, value_cnt;

  ASSERT (b != NULL);
c002b08d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b091:	75 21                	jne    c002b0b4 <bitmap_count+0x33>
c002b093:	83 ec 0c             	sub    $0xc,%esp
c002b096:	68 55 16 03 c0       	push   $0xc0031655
c002b09b:	68 24 16 03 c0       	push   $0xc0031624
c002b0a0:	68 f4 16 03 c0       	push   $0xc00316f4
c002b0a5:	68 ed 00 00 00       	push   $0xed
c002b0aa:	68 3b 16 03 c0       	push   $0xc003163b
c002b0af:	e8 67 eb ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b0b4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0b7:	8b 00                	mov    (%eax),%eax
c002b0b9:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b0bc:	73 21                	jae    c002b0df <bitmap_count+0x5e>
c002b0be:	83 ec 0c             	sub    $0xc,%esp
c002b0c1:	68 70 16 03 c0       	push   $0xc0031670
c002b0c6:	68 24 16 03 c0       	push   $0xc0031624
c002b0cb:	68 f4 16 03 c0       	push   $0xc00316f4
c002b0d0:	68 ee 00 00 00       	push   $0xee
c002b0d5:	68 3b 16 03 c0       	push   $0xc003163b
c002b0da:	e8 3c eb ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b0df:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b0e2:	8b 45 10             	mov    0x10(%ebp),%eax
c002b0e5:	01 c2                	add    %eax,%edx
c002b0e7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b0ea:	8b 00                	mov    (%eax),%eax
c002b0ec:	39 c2                	cmp    %eax,%edx
c002b0ee:	76 21                	jbe    c002b111 <bitmap_count+0x90>
c002b0f0:	83 ec 0c             	sub    $0xc,%esp
c002b0f3:	68 84 16 03 c0       	push   $0xc0031684
c002b0f8:	68 24 16 03 c0       	push   $0xc0031624
c002b0fd:	68 f4 16 03 c0       	push   $0xc00316f4
c002b102:	68 ef 00 00 00       	push   $0xef
c002b107:	68 3b 16 03 c0       	push   $0xc003163b
c002b10c:	e8 0a eb ff ff       	call   c0029c1b <debug_panic>

  value_cnt = 0;
c002b111:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (i = 0; i < cnt; i++)
c002b118:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b11f:	eb 24                	jmp    c002b145 <bitmap_count+0xc4>
    if (bitmap_test (b, start + i) == value)
c002b121:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b124:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b127:	01 d0                	add    %edx,%eax
c002b129:	83 ec 08             	sub    $0x8,%esp
c002b12c:	50                   	push   %eax
c002b12d:	ff 75 08             	pushl  0x8(%ebp)
c002b130:	e8 9f fd ff ff       	call   c002aed4 <bitmap_test>
c002b135:	83 c4 10             	add    $0x10,%esp
c002b138:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b13b:	75 04                	jne    c002b141 <bitmap_count+0xc0>
      value_cnt++;
c002b13d:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  value_cnt = 0;
  for (i = 0; i < cnt; i++)
c002b141:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b145:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b148:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b14b:	72 d4                	jb     c002b121 <bitmap_count+0xa0>
    if (bitmap_test (b, start + i) == value)
      value_cnt++;
  return value_cnt;
c002b14d:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b150:	c9                   	leave  
c002b151:	c3                   	ret    

c002b152 <bitmap_contains>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to VALUE, and false otherwise. */
bool
bitmap_contains (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b152:	55                   	push   %ebp
c002b153:	89 e5                	mov    %esp,%ebp
c002b155:	83 ec 28             	sub    $0x28,%esp
c002b158:	8b 45 14             	mov    0x14(%ebp),%eax
c002b15b:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t i;
  
  ASSERT (b != NULL);
c002b15e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b162:	75 21                	jne    c002b185 <bitmap_contains+0x33>
c002b164:	83 ec 0c             	sub    $0xc,%esp
c002b167:	68 55 16 03 c0       	push   $0xc0031655
c002b16c:	68 24 16 03 c0       	push   $0xc0031624
c002b171:	68 04 17 03 c0       	push   $0xc0031704
c002b176:	68 ff 00 00 00       	push   $0xff
c002b17b:	68 3b 16 03 c0       	push   $0xc003163b
c002b180:	e8 96 ea ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b185:	8b 45 08             	mov    0x8(%ebp),%eax
c002b188:	8b 00                	mov    (%eax),%eax
c002b18a:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b18d:	73 21                	jae    c002b1b0 <bitmap_contains+0x5e>
c002b18f:	83 ec 0c             	sub    $0xc,%esp
c002b192:	68 70 16 03 c0       	push   $0xc0031670
c002b197:	68 24 16 03 c0       	push   $0xc0031624
c002b19c:	68 04 17 03 c0       	push   $0xc0031704
c002b1a1:	68 00 01 00 00       	push   $0x100
c002b1a6:	68 3b 16 03 c0       	push   $0xc003163b
c002b1ab:	e8 6b ea ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start + cnt <= b->bit_cnt);
c002b1b0:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b1b3:	8b 45 10             	mov    0x10(%ebp),%eax
c002b1b6:	01 c2                	add    %eax,%edx
c002b1b8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b1bb:	8b 00                	mov    (%eax),%eax
c002b1bd:	39 c2                	cmp    %eax,%edx
c002b1bf:	76 21                	jbe    c002b1e2 <bitmap_contains+0x90>
c002b1c1:	83 ec 0c             	sub    $0xc,%esp
c002b1c4:	68 84 16 03 c0       	push   $0xc0031684
c002b1c9:	68 24 16 03 c0       	push   $0xc0031624
c002b1ce:	68 04 17 03 c0       	push   $0xc0031704
c002b1d3:	68 01 01 00 00       	push   $0x101
c002b1d8:	68 3b 16 03 c0       	push   $0xc003163b
c002b1dd:	e8 39 ea ff ff       	call   c0029c1b <debug_panic>

  for (i = 0; i < cnt; i++)
c002b1e2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b1e9:	eb 27                	jmp    c002b212 <bitmap_contains+0xc0>
    if (bitmap_test (b, start + i) == value)
c002b1eb:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b1ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b1f1:	01 d0                	add    %edx,%eax
c002b1f3:	83 ec 08             	sub    $0x8,%esp
c002b1f6:	50                   	push   %eax
c002b1f7:	ff 75 08             	pushl  0x8(%ebp)
c002b1fa:	e8 d5 fc ff ff       	call   c002aed4 <bitmap_test>
c002b1ff:	83 c4 10             	add    $0x10,%esp
c002b202:	3a 45 e4             	cmp    -0x1c(%ebp),%al
c002b205:	75 07                	jne    c002b20e <bitmap_contains+0xbc>
      return true;
c002b207:	b8 01 00 00 00       	mov    $0x1,%eax
c002b20c:	eb 11                	jmp    c002b21f <bitmap_contains+0xcd>
  
  ASSERT (b != NULL);
  ASSERT (start <= b->bit_cnt);
  ASSERT (start + cnt <= b->bit_cnt);

  for (i = 0; i < cnt; i++)
c002b20e:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b212:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b215:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b218:	72 d1                	jb     c002b1eb <bitmap_contains+0x99>
    if (bitmap_test (b, start + i) == value)
      return true;
  return false;
c002b21a:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b21f:	c9                   	leave  
c002b220:	c3                   	ret    

c002b221 <bitmap_any>:

/* Returns true if any bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_any (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b221:	55                   	push   %ebp
c002b222:	89 e5                	mov    %esp,%ebp
c002b224:	83 ec 08             	sub    $0x8,%esp
  return bitmap_contains (b, start, cnt, true);
c002b227:	6a 01                	push   $0x1
c002b229:	ff 75 10             	pushl  0x10(%ebp)
c002b22c:	ff 75 0c             	pushl  0xc(%ebp)
c002b22f:	ff 75 08             	pushl  0x8(%ebp)
c002b232:	e8 1b ff ff ff       	call   c002b152 <bitmap_contains>
c002b237:	83 c4 10             	add    $0x10,%esp
}
c002b23a:	c9                   	leave  
c002b23b:	c3                   	ret    

c002b23c <bitmap_none>:

/* Returns true if no bits in B between START and START + CNT,
   exclusive, are set to true, and false otherwise.*/
bool
bitmap_none (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b23c:	55                   	push   %ebp
c002b23d:	89 e5                	mov    %esp,%ebp
c002b23f:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, true);
c002b242:	6a 01                	push   $0x1
c002b244:	ff 75 10             	pushl  0x10(%ebp)
c002b247:	ff 75 0c             	pushl  0xc(%ebp)
c002b24a:	ff 75 08             	pushl  0x8(%ebp)
c002b24d:	e8 00 ff ff ff       	call   c002b152 <bitmap_contains>
c002b252:	83 c4 10             	add    $0x10,%esp
c002b255:	0f b6 c0             	movzbl %al,%eax
c002b258:	85 c0                	test   %eax,%eax
c002b25a:	0f 95 c0             	setne  %al
c002b25d:	83 f0 01             	xor    $0x1,%eax
c002b260:	0f b6 c0             	movzbl %al,%eax
c002b263:	83 e0 01             	and    $0x1,%eax
}
c002b266:	c9                   	leave  
c002b267:	c3                   	ret    

c002b268 <bitmap_all>:

/* Returns true if every bit in B between START and START + CNT,
   exclusive, is set to true, and false otherwise. */
bool
bitmap_all (const struct bitmap *b, size_t start, size_t cnt) 
{
c002b268:	55                   	push   %ebp
c002b269:	89 e5                	mov    %esp,%ebp
c002b26b:	83 ec 08             	sub    $0x8,%esp
  return !bitmap_contains (b, start, cnt, false);
c002b26e:	6a 00                	push   $0x0
c002b270:	ff 75 10             	pushl  0x10(%ebp)
c002b273:	ff 75 0c             	pushl  0xc(%ebp)
c002b276:	ff 75 08             	pushl  0x8(%ebp)
c002b279:	e8 d4 fe ff ff       	call   c002b152 <bitmap_contains>
c002b27e:	83 c4 10             	add    $0x10,%esp
c002b281:	0f b6 c0             	movzbl %al,%eax
c002b284:	85 c0                	test   %eax,%eax
c002b286:	0f 95 c0             	setne  %al
c002b289:	83 f0 01             	xor    $0x1,%eax
c002b28c:	0f b6 c0             	movzbl %al,%eax
c002b28f:	83 e0 01             	and    $0x1,%eax
}
c002b292:	c9                   	leave  
c002b293:	c3                   	ret    

c002b294 <bitmap_scan>:
   consecutive bits in B at or after START that are all set to
   VALUE.
   If there is no such group, returns BITMAP_ERROR. */
size_t
bitmap_scan (const struct bitmap *b, size_t start, size_t cnt, bool value) 
{
c002b294:	55                   	push   %ebp
c002b295:	89 e5                	mov    %esp,%ebp
c002b297:	83 ec 28             	sub    $0x28,%esp
c002b29a:	8b 45 14             	mov    0x14(%ebp),%eax
c002b29d:	88 45 e4             	mov    %al,-0x1c(%ebp)
  ASSERT (b != NULL);
c002b2a0:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b2a4:	75 21                	jne    c002b2c7 <bitmap_scan+0x33>
c002b2a6:	83 ec 0c             	sub    $0xc,%esp
c002b2a9:	68 55 16 03 c0       	push   $0xc0031655
c002b2ae:	68 24 16 03 c0       	push   $0xc0031624
c002b2b3:	68 14 17 03 c0       	push   $0xc0031714
c002b2b8:	68 2a 01 00 00       	push   $0x12a
c002b2bd:	68 3b 16 03 c0       	push   $0xc003163b
c002b2c2:	e8 54 e9 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (start <= b->bit_cnt);
c002b2c7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ca:	8b 00                	mov    (%eax),%eax
c002b2cc:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002b2cf:	73 21                	jae    c002b2f2 <bitmap_scan+0x5e>
c002b2d1:	83 ec 0c             	sub    $0xc,%esp
c002b2d4:	68 70 16 03 c0       	push   $0xc0031670
c002b2d9:	68 24 16 03 c0       	push   $0xc0031624
c002b2de:	68 14 17 03 c0       	push   $0xc0031714
c002b2e3:	68 2b 01 00 00       	push   $0x12b
c002b2e8:	68 3b 16 03 c0       	push   $0xc003163b
c002b2ed:	e8 29 e9 ff ff       	call   c0029c1b <debug_panic>

  if (cnt <= b->bit_cnt) 
c002b2f2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2f5:	8b 00                	mov    (%eax),%eax
c002b2f7:	3b 45 10             	cmp    0x10(%ebp),%eax
c002b2fa:	72 47                	jb     c002b343 <bitmap_scan+0xaf>
    {
      size_t last = b->bit_cnt - cnt;
c002b2fc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b2ff:	8b 00                	mov    (%eax),%eax
c002b301:	2b 45 10             	sub    0x10(%ebp),%eax
c002b304:	89 45 f0             	mov    %eax,-0x10(%ebp)
      size_t i;
      for (i = start; i <= last; i++)
c002b307:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b30a:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b30d:	eb 2c                	jmp    c002b33b <bitmap_scan+0xa7>
        if (!bitmap_contains (b, i, cnt, !value))
c002b30f:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b313:	83 f0 01             	xor    $0x1,%eax
c002b316:	0f b6 c0             	movzbl %al,%eax
c002b319:	50                   	push   %eax
c002b31a:	ff 75 10             	pushl  0x10(%ebp)
c002b31d:	ff 75 f4             	pushl  -0xc(%ebp)
c002b320:	ff 75 08             	pushl  0x8(%ebp)
c002b323:	e8 2a fe ff ff       	call   c002b152 <bitmap_contains>
c002b328:	83 c4 10             	add    $0x10,%esp
c002b32b:	83 f0 01             	xor    $0x1,%eax
c002b32e:	84 c0                	test   %al,%al
c002b330:	74 05                	je     c002b337 <bitmap_scan+0xa3>
          return i; 
c002b332:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b335:	eb 11                	jmp    c002b348 <bitmap_scan+0xb4>

  if (cnt <= b->bit_cnt) 
    {
      size_t last = b->bit_cnt - cnt;
      size_t i;
      for (i = start; i <= last; i++)
c002b337:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b33b:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b33e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b341:	76 cc                	jbe    c002b30f <bitmap_scan+0x7b>
        if (!bitmap_contains (b, i, cnt, !value))
          return i; 
    }
  return BITMAP_ERROR;
c002b343:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
c002b348:	c9                   	leave  
c002b349:	c3                   	ret    

c002b34a <bitmap_scan_and_flip>:
   If CNT is zero, returns 0.
   Bits are set atomically, but testing bits is not atomic with
   setting them. */
size_t
bitmap_scan_and_flip (struct bitmap *b, size_t start, size_t cnt, bool value)
{
c002b34a:	55                   	push   %ebp
c002b34b:	89 e5                	mov    %esp,%ebp
c002b34d:	83 ec 28             	sub    $0x28,%esp
c002b350:	8b 45 14             	mov    0x14(%ebp),%eax
c002b353:	88 45 e4             	mov    %al,-0x1c(%ebp)
  size_t idx = bitmap_scan (b, start, cnt, value);
c002b356:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b35a:	50                   	push   %eax
c002b35b:	ff 75 10             	pushl  0x10(%ebp)
c002b35e:	ff 75 0c             	pushl  0xc(%ebp)
c002b361:	ff 75 08             	pushl  0x8(%ebp)
c002b364:	e8 2b ff ff ff       	call   c002b294 <bitmap_scan>
c002b369:	83 c4 10             	add    $0x10,%esp
c002b36c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (idx != BITMAP_ERROR) 
c002b36f:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
c002b373:	74 1c                	je     c002b391 <bitmap_scan_and_flip+0x47>
    bitmap_set_multiple (b, idx, cnt, !value);
c002b375:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002b379:	83 f0 01             	xor    $0x1,%eax
c002b37c:	0f b6 c0             	movzbl %al,%eax
c002b37f:	50                   	push   %eax
c002b380:	ff 75 10             	pushl  0x10(%ebp)
c002b383:	ff 75 f4             	pushl  -0xc(%ebp)
c002b386:	ff 75 08             	pushl  0x8(%ebp)
c002b389:	e8 2f fc ff ff       	call   c002afbd <bitmap_set_multiple>
c002b38e:	83 c4 10             	add    $0x10,%esp
  return idx;
c002b391:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b394:	c9                   	leave  
c002b395:	c3                   	ret    

c002b396 <bitmap_dump>:
/* Debugging. */

/* Dumps the contents of B to the console as hexadecimal. */
void
bitmap_dump (const struct bitmap *b) 
{
c002b396:	55                   	push   %ebp
c002b397:	89 e5                	mov    %esp,%ebp
c002b399:	83 ec 08             	sub    $0x8,%esp
  hex_dump (0, b->bits, byte_cnt (b->bit_cnt), false);
c002b39c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b39f:	8b 00                	mov    (%eax),%eax
c002b3a1:	50                   	push   %eax
c002b3a2:	e8 b3 f8 ff ff       	call   c002ac5a <byte_cnt>
c002b3a7:	83 c4 04             	add    $0x4,%esp
c002b3aa:	89 c2                	mov    %eax,%edx
c002b3ac:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3af:	8b 40 04             	mov    0x4(%eax),%eax
c002b3b2:	6a 00                	push   $0x0
c002b3b4:	52                   	push   %edx
c002b3b5:	50                   	push   %eax
c002b3b6:	6a 00                	push   $0x0
c002b3b8:	e8 66 cf ff ff       	call   c0028323 <hex_dump>
c002b3bd:	83 c4 10             	add    $0x10,%esp
}
c002b3c0:	90                   	nop
c002b3c1:	c9                   	leave  
c002b3c2:	c3                   	ret    

c002b3c3 <hash_init>:
/* Initializes hash table H to compute hash values using HASH and
   compare hash elements using LESS, given auxiliary data AUX. */
bool
hash_init (struct hash *h,
           hash_hash_func *hash, hash_less_func *less, void *aux) 
{
c002b3c3:	55                   	push   %ebp
c002b3c4:	89 e5                	mov    %esp,%ebp
c002b3c6:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt = 0;
c002b3c9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3cc:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  h->bucket_cnt = 4;
c002b3d2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3d5:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
  h->buckets = malloc (sizeof *h->buckets * h->bucket_cnt);
c002b3dc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3df:	8b 40 04             	mov    0x4(%eax),%eax
c002b3e2:	c1 e0 04             	shl    $0x4,%eax
c002b3e5:	83 ec 0c             	sub    $0xc,%esp
c002b3e8:	50                   	push   %eax
c002b3e9:	e8 73 85 ff ff       	call   c0023961 <malloc>
c002b3ee:	83 c4 10             	add    $0x10,%esp
c002b3f1:	89 c2                	mov    %eax,%edx
c002b3f3:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3f6:	89 50 08             	mov    %edx,0x8(%eax)
  h->hash = hash;
c002b3f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b3fc:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b3ff:	89 50 0c             	mov    %edx,0xc(%eax)
  h->less = less;
c002b402:	8b 45 08             	mov    0x8(%ebp),%eax
c002b405:	8b 55 10             	mov    0x10(%ebp),%edx
c002b408:	89 50 10             	mov    %edx,0x10(%eax)
  h->aux = aux;
c002b40b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b40e:	8b 55 14             	mov    0x14(%ebp),%edx
c002b411:	89 50 14             	mov    %edx,0x14(%eax)

  if (h->buckets != NULL) 
c002b414:	8b 45 08             	mov    0x8(%ebp),%eax
c002b417:	8b 40 08             	mov    0x8(%eax),%eax
c002b41a:	85 c0                	test   %eax,%eax
c002b41c:	74 17                	je     c002b435 <hash_init+0x72>
    {
      hash_clear (h, NULL);
c002b41e:	83 ec 08             	sub    $0x8,%esp
c002b421:	6a 00                	push   $0x0
c002b423:	ff 75 08             	pushl  0x8(%ebp)
c002b426:	e8 11 00 00 00       	call   c002b43c <hash_clear>
c002b42b:	83 c4 10             	add    $0x10,%esp
      return true;
c002b42e:	b8 01 00 00 00       	mov    $0x1,%eax
c002b433:	eb 05                	jmp    c002b43a <hash_init+0x77>
    }
  else
    return false;
c002b435:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002b43a:	c9                   	leave  
c002b43b:	c3                   	ret    

c002b43c <hash_clear>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), yields undefined behavior,
   whether done in DESTRUCTOR or elsewhere. */
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
c002b43c:	55                   	push   %ebp
c002b43d:	89 e5                	mov    %esp,%ebp
c002b43f:	83 ec 18             	sub    $0x18,%esp
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b442:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b449:	eb 72                	jmp    c002b4bd <hash_clear+0x81>
    {
      struct list *bucket = &h->buckets[i];
c002b44b:	8b 45 08             	mov    0x8(%ebp),%eax
c002b44e:	8b 40 08             	mov    0x8(%eax),%eax
c002b451:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b454:	c1 e2 04             	shl    $0x4,%edx
c002b457:	01 d0                	add    %edx,%eax
c002b459:	89 45 f0             	mov    %eax,-0x10(%ebp)

      if (destructor != NULL) 
c002b45c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b460:	74 49                	je     c002b4ab <hash_clear+0x6f>
        while (!list_empty (bucket)) 
c002b462:	eb 32                	jmp    c002b496 <hash_clear+0x5a>
          {
            struct list_elem *list_elem = list_pop_front (bucket);
c002b464:	83 ec 0c             	sub    $0xc,%esp
c002b467:	ff 75 f0             	pushl  -0x10(%ebp)
c002b46a:	e8 7e ee ff ff       	call   c002a2ed <list_pop_front>
c002b46f:	83 c4 10             	add    $0x10,%esp
c002b472:	89 45 ec             	mov    %eax,-0x14(%ebp)
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
c002b475:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002b478:	83 c0 04             	add    $0x4,%eax
c002b47b:	83 e8 04             	sub    $0x4,%eax
c002b47e:	89 45 e8             	mov    %eax,-0x18(%ebp)
            destructor (hash_elem, h->aux);
c002b481:	8b 45 08             	mov    0x8(%ebp),%eax
c002b484:	8b 40 14             	mov    0x14(%eax),%eax
c002b487:	83 ec 08             	sub    $0x8,%esp
c002b48a:	50                   	push   %eax
c002b48b:	ff 75 e8             	pushl  -0x18(%ebp)
c002b48e:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b491:	ff d0                	call   *%eax
c002b493:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];

      if (destructor != NULL) 
        while (!list_empty (bucket)) 
c002b496:	83 ec 0c             	sub    $0xc,%esp
c002b499:	ff 75 f0             	pushl  -0x10(%ebp)
c002b49c:	e8 75 ef ff ff       	call   c002a416 <list_empty>
c002b4a1:	83 c4 10             	add    $0x10,%esp
c002b4a4:	83 f0 01             	xor    $0x1,%eax
c002b4a7:	84 c0                	test   %al,%al
c002b4a9:	75 b9                	jne    c002b464 <hash_clear+0x28>
            struct list_elem *list_elem = list_pop_front (bucket);
            struct hash_elem *hash_elem = list_elem_to_hash_elem (list_elem);
            destructor (hash_elem, h->aux);
          }

      list_init (bucket); 
c002b4ab:	83 ec 0c             	sub    $0xc,%esp
c002b4ae:	ff 75 f0             	pushl  -0x10(%ebp)
c002b4b1:	e8 d8 e9 ff ff       	call   c0029e8e <list_init>
c002b4b6:	83 c4 10             	add    $0x10,%esp
void
hash_clear (struct hash *h, hash_action_func *destructor) 
{
  size_t i;

  for (i = 0; i < h->bucket_cnt; i++) 
c002b4b9:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b4bd:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4c0:	8b 40 04             	mov    0x4(%eax),%eax
c002b4c3:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b4c6:	77 83                	ja     c002b44b <hash_clear+0xf>
          }

      list_init (bucket); 
    }    

  h->elem_cnt = 0;
c002b4c8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4cb:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
}
c002b4d1:	90                   	nop
c002b4d2:	c9                   	leave  
c002b4d3:	c3                   	ret    

c002b4d4 <hash_destroy>:
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done in DESTRUCTOR or
   elsewhere. */
void
hash_destroy (struct hash *h, hash_action_func *destructor) 
{
c002b4d4:	55                   	push   %ebp
c002b4d5:	89 e5                	mov    %esp,%ebp
c002b4d7:	83 ec 08             	sub    $0x8,%esp
  if (destructor != NULL)
c002b4da:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b4de:	74 11                	je     c002b4f1 <hash_destroy+0x1d>
    hash_clear (h, destructor);
c002b4e0:	83 ec 08             	sub    $0x8,%esp
c002b4e3:	ff 75 0c             	pushl  0xc(%ebp)
c002b4e6:	ff 75 08             	pushl  0x8(%ebp)
c002b4e9:	e8 4e ff ff ff       	call   c002b43c <hash_clear>
c002b4ee:	83 c4 10             	add    $0x10,%esp
  free (h->buckets);
c002b4f1:	8b 45 08             	mov    0x8(%ebp),%eax
c002b4f4:	8b 40 08             	mov    0x8(%eax),%eax
c002b4f7:	83 ec 0c             	sub    $0xc,%esp
c002b4fa:	50                   	push   %eax
c002b4fb:	e8 62 87 ff ff       	call   c0023c62 <free>
c002b500:	83 c4 10             	add    $0x10,%esp
}
c002b503:	90                   	nop
c002b504:	c9                   	leave  
c002b505:	c3                   	ret    

c002b506 <hash_insert>:
   no equal element is already in the table.
   If an equal element is already in the table, returns it
   without inserting NEW. */   
struct hash_elem *
hash_insert (struct hash *h, struct hash_elem *new)
{
c002b506:	55                   	push   %ebp
c002b507:	89 e5                	mov    %esp,%ebp
c002b509:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b50c:	83 ec 08             	sub    $0x8,%esp
c002b50f:	ff 75 0c             	pushl  0xc(%ebp)
c002b512:	ff 75 08             	pushl  0x8(%ebp)
c002b515:	e8 5a 04 00 00       	call   c002b974 <find_bucket>
c002b51a:	83 c4 10             	add    $0x10,%esp
c002b51d:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b520:	83 ec 04             	sub    $0x4,%esp
c002b523:	ff 75 0c             	pushl  0xc(%ebp)
c002b526:	ff 75 f4             	pushl  -0xc(%ebp)
c002b529:	ff 75 08             	pushl  0x8(%ebp)
c002b52c:	e8 81 04 00 00       	call   c002b9b2 <find_elem>
c002b531:	83 c4 10             	add    $0x10,%esp
c002b534:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old == NULL) 
c002b537:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b53b:	75 14                	jne    c002b551 <hash_insert+0x4b>
    insert_elem (h, bucket, new);
c002b53d:	83 ec 04             	sub    $0x4,%esp
c002b540:	ff 75 0c             	pushl  0xc(%ebp)
c002b543:	ff 75 f4             	pushl  -0xc(%ebp)
c002b546:	ff 75 08             	pushl  0x8(%ebp)
c002b549:	e8 d0 06 00 00       	call   c002bc1e <insert_elem>
c002b54e:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b551:	83 ec 0c             	sub    $0xc,%esp
c002b554:	ff 75 08             	pushl  0x8(%ebp)
c002b557:	e8 23 05 00 00       	call   c002ba7f <rehash>
c002b55c:	83 c4 10             	add    $0x10,%esp

  return old; 
c002b55f:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b562:	c9                   	leave  
c002b563:	c3                   	ret    

c002b564 <hash_replace>:

/* Inserts NEW into hash table H, replacing any equal element
   already in the table, which is returned. */
struct hash_elem *
hash_replace (struct hash *h, struct hash_elem *new) 
{
c002b564:	55                   	push   %ebp
c002b565:	89 e5                	mov    %esp,%ebp
c002b567:	83 ec 18             	sub    $0x18,%esp
  struct list *bucket = find_bucket (h, new);
c002b56a:	83 ec 08             	sub    $0x8,%esp
c002b56d:	ff 75 0c             	pushl  0xc(%ebp)
c002b570:	ff 75 08             	pushl  0x8(%ebp)
c002b573:	e8 fc 03 00 00       	call   c002b974 <find_bucket>
c002b578:	83 c4 10             	add    $0x10,%esp
c002b57b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  struct hash_elem *old = find_elem (h, bucket, new);
c002b57e:	83 ec 04             	sub    $0x4,%esp
c002b581:	ff 75 0c             	pushl  0xc(%ebp)
c002b584:	ff 75 f4             	pushl  -0xc(%ebp)
c002b587:	ff 75 08             	pushl  0x8(%ebp)
c002b58a:	e8 23 04 00 00       	call   c002b9b2 <find_elem>
c002b58f:	83 c4 10             	add    $0x10,%esp
c002b592:	89 45 f0             	mov    %eax,-0x10(%ebp)

  if (old != NULL)
c002b595:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002b599:	74 11                	je     c002b5ac <hash_replace+0x48>
    remove_elem (h, old);
c002b59b:	83 ec 08             	sub    $0x8,%esp
c002b59e:	ff 75 f0             	pushl  -0x10(%ebp)
c002b5a1:	ff 75 08             	pushl  0x8(%ebp)
c002b5a4:	e8 9d 06 00 00       	call   c002bc46 <remove_elem>
c002b5a9:	83 c4 10             	add    $0x10,%esp
  insert_elem (h, bucket, new);
c002b5ac:	83 ec 04             	sub    $0x4,%esp
c002b5af:	ff 75 0c             	pushl  0xc(%ebp)
c002b5b2:	ff 75 f4             	pushl  -0xc(%ebp)
c002b5b5:	ff 75 08             	pushl  0x8(%ebp)
c002b5b8:	e8 61 06 00 00       	call   c002bc1e <insert_elem>
c002b5bd:	83 c4 10             	add    $0x10,%esp

  rehash (h);
c002b5c0:	83 ec 0c             	sub    $0xc,%esp
c002b5c3:	ff 75 08             	pushl  0x8(%ebp)
c002b5c6:	e8 b4 04 00 00       	call   c002ba7f <rehash>
c002b5cb:	83 c4 10             	add    $0x10,%esp

  return old;
c002b5ce:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b5d1:	c9                   	leave  
c002b5d2:	c3                   	ret    

c002b5d3 <hash_find>:

/* Finds and returns an element equal to E in hash table H, or a
   null pointer if no equal element exists in the table. */
struct hash_elem *
hash_find (struct hash *h, struct hash_elem *e) 
{
c002b5d3:	55                   	push   %ebp
c002b5d4:	89 e5                	mov    %esp,%ebp
c002b5d6:	83 ec 08             	sub    $0x8,%esp
  return find_elem (h, find_bucket (h, e), e);
c002b5d9:	83 ec 08             	sub    $0x8,%esp
c002b5dc:	ff 75 0c             	pushl  0xc(%ebp)
c002b5df:	ff 75 08             	pushl  0x8(%ebp)
c002b5e2:	e8 8d 03 00 00       	call   c002b974 <find_bucket>
c002b5e7:	83 c4 10             	add    $0x10,%esp
c002b5ea:	83 ec 04             	sub    $0x4,%esp
c002b5ed:	ff 75 0c             	pushl  0xc(%ebp)
c002b5f0:	50                   	push   %eax
c002b5f1:	ff 75 08             	pushl  0x8(%ebp)
c002b5f4:	e8 b9 03 00 00       	call   c002b9b2 <find_elem>
c002b5f9:	83 c4 10             	add    $0x10,%esp
}
c002b5fc:	c9                   	leave  
c002b5fd:	c3                   	ret    

c002b5fe <hash_delete>:
   If the elements of the hash table are dynamically allocated,
   or own resources that are, then it is the caller's
   responsibility to deallocate them. */
struct hash_elem *
hash_delete (struct hash *h, struct hash_elem *e)
{
c002b5fe:	55                   	push   %ebp
c002b5ff:	89 e5                	mov    %esp,%ebp
c002b601:	83 ec 18             	sub    $0x18,%esp
  struct hash_elem *found = find_elem (h, find_bucket (h, e), e);
c002b604:	83 ec 08             	sub    $0x8,%esp
c002b607:	ff 75 0c             	pushl  0xc(%ebp)
c002b60a:	ff 75 08             	pushl  0x8(%ebp)
c002b60d:	e8 62 03 00 00       	call   c002b974 <find_bucket>
c002b612:	83 c4 10             	add    $0x10,%esp
c002b615:	83 ec 04             	sub    $0x4,%esp
c002b618:	ff 75 0c             	pushl  0xc(%ebp)
c002b61b:	50                   	push   %eax
c002b61c:	ff 75 08             	pushl  0x8(%ebp)
c002b61f:	e8 8e 03 00 00       	call   c002b9b2 <find_elem>
c002b624:	83 c4 10             	add    $0x10,%esp
c002b627:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (found != NULL) 
c002b62a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b62e:	74 1f                	je     c002b64f <hash_delete+0x51>
    {
      remove_elem (h, found);
c002b630:	83 ec 08             	sub    $0x8,%esp
c002b633:	ff 75 f4             	pushl  -0xc(%ebp)
c002b636:	ff 75 08             	pushl  0x8(%ebp)
c002b639:	e8 08 06 00 00       	call   c002bc46 <remove_elem>
c002b63e:	83 c4 10             	add    $0x10,%esp
      rehash (h); 
c002b641:	83 ec 0c             	sub    $0xc,%esp
c002b644:	ff 75 08             	pushl  0x8(%ebp)
c002b647:	e8 33 04 00 00       	call   c002ba7f <rehash>
c002b64c:	83 c4 10             	add    $0x10,%esp
    }
  return found;
c002b64f:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002b652:	c9                   	leave  
c002b653:	c3                   	ret    

c002b654 <hash_apply>:
   any of the functions hash_clear(), hash_destroy(),
   hash_insert(), hash_replace(), or hash_delete(), yields
   undefined behavior, whether done from ACTION or elsewhere. */
void
hash_apply (struct hash *h, hash_action_func *action) 
{
c002b654:	55                   	push   %ebp
c002b655:	89 e5                	mov    %esp,%ebp
c002b657:	83 ec 18             	sub    $0x18,%esp
  size_t i;
  
  ASSERT (action != NULL);
c002b65a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b65e:	75 21                	jne    c002b681 <hash_apply+0x2d>
c002b660:	83 ec 0c             	sub    $0xc,%esp
c002b663:	68 20 17 03 c0       	push   $0xc0031720
c002b668:	68 2f 17 03 c0       	push   $0xc003172f
c002b66d:	68 88 17 03 c0       	push   $0xc0031788
c002b672:	68 a7 00 00 00       	push   $0xa7
c002b677:	68 46 17 03 c0       	push   $0xc0031746
c002b67c:	e8 9a e5 ff ff       	call   c0029c1b <debug_panic>

  for (i = 0; i < h->bucket_cnt; i++) 
c002b681:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002b688:	eb 6e                	jmp    c002b6f8 <hash_apply+0xa4>
    {
      struct list *bucket = &h->buckets[i];
c002b68a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b68d:	8b 40 08             	mov    0x8(%eax),%eax
c002b690:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b693:	c1 e2 04             	shl    $0x4,%edx
c002b696:	01 d0                	add    %edx,%eax
c002b698:	89 45 ec             	mov    %eax,-0x14(%ebp)
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b69b:	83 ec 0c             	sub    $0xc,%esp
c002b69e:	ff 75 ec             	pushl  -0x14(%ebp)
c002b6a1:	e8 3d e8 ff ff       	call   c0029ee3 <list_begin>
c002b6a6:	83 c4 10             	add    $0x10,%esp
c002b6a9:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b6ac:	eb 33                	jmp    c002b6e1 <hash_apply+0x8d>
        {
          next = list_next (elem);
c002b6ae:	83 ec 0c             	sub    $0xc,%esp
c002b6b1:	ff 75 f0             	pushl  -0x10(%ebp)
c002b6b4:	e8 5c e8 ff ff       	call   c0029f15 <list_next>
c002b6b9:	83 c4 10             	add    $0x10,%esp
c002b6bc:	89 45 e8             	mov    %eax,-0x18(%ebp)
          action (list_elem_to_hash_elem (elem), h->aux);
c002b6bf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6c2:	8b 40 14             	mov    0x14(%eax),%eax
c002b6c5:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002b6c8:	83 c2 04             	add    $0x4,%edx
c002b6cb:	83 ea 04             	sub    $0x4,%edx
c002b6ce:	83 ec 08             	sub    $0x8,%esp
c002b6d1:	50                   	push   %eax
c002b6d2:	52                   	push   %edx
c002b6d3:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b6d6:	ff d0                	call   *%eax
c002b6d8:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < h->bucket_cnt; i++) 
    {
      struct list *bucket = &h->buckets[i];
      struct list_elem *elem, *next;

      for (elem = list_begin (bucket); elem != list_end (bucket); elem = next) 
c002b6db:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002b6de:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002b6e1:	83 ec 0c             	sub    $0xc,%esp
c002b6e4:	ff 75 ec             	pushl  -0x14(%ebp)
c002b6e7:	e8 73 e8 ff ff       	call   c0029f5f <list_end>
c002b6ec:	83 c4 10             	add    $0x10,%esp
c002b6ef:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002b6f2:	75 ba                	jne    c002b6ae <hash_apply+0x5a>
{
  size_t i;
  
  ASSERT (action != NULL);

  for (i = 0; i < h->bucket_cnt; i++) 
c002b6f4:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002b6f8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b6fb:	8b 40 04             	mov    0x4(%eax),%eax
c002b6fe:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002b701:	77 87                	ja     c002b68a <hash_apply+0x36>
        {
          next = list_next (elem);
          action (list_elem_to_hash_elem (elem), h->aux);
        }
    }
}
c002b703:	90                   	nop
c002b704:	c9                   	leave  
c002b705:	c3                   	ret    

c002b706 <hash_first>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
void
hash_first (struct hash_iterator *i, struct hash *h) 
{
c002b706:	55                   	push   %ebp
c002b707:	89 e5                	mov    %esp,%ebp
c002b709:	83 ec 08             	sub    $0x8,%esp
  ASSERT (i != NULL);
c002b70c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b710:	75 21                	jne    c002b733 <hash_first+0x2d>
c002b712:	83 ec 0c             	sub    $0xc,%esp
c002b715:	68 5e 17 03 c0       	push   $0xc003175e
c002b71a:	68 2f 17 03 c0       	push   $0xc003172f
c002b71f:	68 94 17 03 c0       	push   $0xc0031794
c002b724:	68 ca 00 00 00       	push   $0xca
c002b729:	68 46 17 03 c0       	push   $0xc0031746
c002b72e:	e8 e8 e4 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (h != NULL);
c002b733:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
c002b737:	75 21                	jne    c002b75a <hash_first+0x54>
c002b739:	83 ec 0c             	sub    $0xc,%esp
c002b73c:	68 68 17 03 c0       	push   $0xc0031768
c002b741:	68 2f 17 03 c0       	push   $0xc003172f
c002b746:	68 94 17 03 c0       	push   $0xc0031794
c002b74b:	68 cb 00 00 00       	push   $0xcb
c002b750:	68 46 17 03 c0       	push   $0xc0031746
c002b755:	e8 c1 e4 ff ff       	call   c0029c1b <debug_panic>

  i->hash = h;
c002b75a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b75d:	8b 55 0c             	mov    0xc(%ebp),%edx
c002b760:	89 10                	mov    %edx,(%eax)
  i->bucket = i->hash->buckets;
c002b762:	8b 45 08             	mov    0x8(%ebp),%eax
c002b765:	8b 00                	mov    (%eax),%eax
c002b767:	8b 50 08             	mov    0x8(%eax),%edx
c002b76a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b76d:	89 50 04             	mov    %edx,0x4(%eax)
  i->elem = list_elem_to_hash_elem (list_head (i->bucket));
c002b770:	8b 45 08             	mov    0x8(%ebp),%eax
c002b773:	8b 40 04             	mov    0x4(%eax),%eax
c002b776:	83 ec 0c             	sub    $0xc,%esp
c002b779:	50                   	push   %eax
c002b77a:	e8 bf e8 ff ff       	call   c002a03e <list_head>
c002b77f:	83 c4 10             	add    $0x10,%esp
c002b782:	83 c0 04             	add    $0x4,%eax
c002b785:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b788:	8b 45 08             	mov    0x8(%ebp),%eax
c002b78b:	89 50 08             	mov    %edx,0x8(%eax)
}
c002b78e:	90                   	nop
c002b78f:	c9                   	leave  
c002b790:	c3                   	ret    

c002b791 <hash_next>:
   functions hash_clear(), hash_destroy(), hash_insert(),
   hash_replace(), or hash_delete(), invalidates all
   iterators. */
struct hash_elem *
hash_next (struct hash_iterator *i)
{
c002b791:	55                   	push   %ebp
c002b792:	89 e5                	mov    %esp,%ebp
c002b794:	53                   	push   %ebx
c002b795:	83 ec 04             	sub    $0x4,%esp
  ASSERT (i != NULL);
c002b798:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002b79c:	75 21                	jne    c002b7bf <hash_next+0x2e>
c002b79e:	83 ec 0c             	sub    $0xc,%esp
c002b7a1:	68 5e 17 03 c0       	push   $0xc003175e
c002b7a6:	68 2f 17 03 c0       	push   $0xc003172f
c002b7ab:	68 a0 17 03 c0       	push   $0xc00317a0
c002b7b0:	68 dd 00 00 00       	push   $0xdd
c002b7b5:	68 46 17 03 c0       	push   $0xc0031746
c002b7ba:	e8 5c e4 ff ff       	call   c0029c1b <debug_panic>

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
c002b7bf:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7c2:	8b 40 08             	mov    0x8(%eax),%eax
c002b7c5:	83 ec 0c             	sub    $0xc,%esp
c002b7c8:	50                   	push   %eax
c002b7c9:	e8 47 e7 ff ff       	call   c0029f15 <list_next>
c002b7ce:	83 c4 10             	add    $0x10,%esp
c002b7d1:	83 c0 04             	add    $0x4,%eax
c002b7d4:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b7d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7da:	89 50 08             	mov    %edx,0x8(%eax)
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b7dd:	eb 58                	jmp    c002b837 <hash_next+0xa6>
    {
      if (++i->bucket >= i->hash->buckets + i->hash->bucket_cnt)
c002b7df:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7e2:	8b 40 04             	mov    0x4(%eax),%eax
c002b7e5:	8d 50 10             	lea    0x10(%eax),%edx
c002b7e8:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7eb:	89 50 04             	mov    %edx,0x4(%eax)
c002b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7f1:	8b 50 04             	mov    0x4(%eax),%edx
c002b7f4:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7f7:	8b 00                	mov    (%eax),%eax
c002b7f9:	8b 48 08             	mov    0x8(%eax),%ecx
c002b7fc:	8b 45 08             	mov    0x8(%ebp),%eax
c002b7ff:	8b 00                	mov    (%eax),%eax
c002b801:	8b 40 04             	mov    0x4(%eax),%eax
c002b804:	c1 e0 04             	shl    $0x4,%eax
c002b807:	01 c8                	add    %ecx,%eax
c002b809:	39 c2                	cmp    %eax,%edx
c002b80b:	72 0c                	jb     c002b819 <hash_next+0x88>
        {
          i->elem = NULL;
c002b80d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b810:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
          break;
c002b817:	eb 40                	jmp    c002b859 <hash_next+0xc8>
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
c002b819:	8b 45 08             	mov    0x8(%ebp),%eax
c002b81c:	8b 40 04             	mov    0x4(%eax),%eax
c002b81f:	83 ec 0c             	sub    $0xc,%esp
c002b822:	50                   	push   %eax
c002b823:	e8 bb e6 ff ff       	call   c0029ee3 <list_begin>
c002b828:	83 c4 10             	add    $0x10,%esp
c002b82b:	83 c0 04             	add    $0x4,%eax
c002b82e:	8d 50 fc             	lea    -0x4(%eax),%edx
c002b831:	8b 45 08             	mov    0x8(%ebp),%eax
c002b834:	89 50 08             	mov    %edx,0x8(%eax)
hash_next (struct hash_iterator *i)
{
  ASSERT (i != NULL);

  i->elem = list_elem_to_hash_elem (list_next (&i->elem->list_elem));
  while (i->elem == list_elem_to_hash_elem (list_end (i->bucket)))
c002b837:	8b 45 08             	mov    0x8(%ebp),%eax
c002b83a:	8b 58 08             	mov    0x8(%eax),%ebx
c002b83d:	8b 45 08             	mov    0x8(%ebp),%eax
c002b840:	8b 40 04             	mov    0x4(%eax),%eax
c002b843:	83 ec 0c             	sub    $0xc,%esp
c002b846:	50                   	push   %eax
c002b847:	e8 13 e7 ff ff       	call   c0029f5f <list_end>
c002b84c:	83 c4 10             	add    $0x10,%esp
c002b84f:	83 c0 04             	add    $0x4,%eax
c002b852:	83 e8 04             	sub    $0x4,%eax
c002b855:	39 c3                	cmp    %eax,%ebx
c002b857:	74 86                	je     c002b7df <hash_next+0x4e>
          break;
        }
      i->elem = list_elem_to_hash_elem (list_begin (i->bucket));
    }
  
  return i->elem;
c002b859:	8b 45 08             	mov    0x8(%ebp),%eax
c002b85c:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b85f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002b862:	c9                   	leave  
c002b863:	c3                   	ret    

c002b864 <hash_cur>:
/* Returns the current element in the hash table iteration, or a
   null pointer at the end of the table.  Undefined behavior
   after calling hash_first() but before hash_next(). */
struct hash_elem *
hash_cur (struct hash_iterator *i) 
{
c002b864:	55                   	push   %ebp
c002b865:	89 e5                	mov    %esp,%ebp
  return i->elem;
c002b867:	8b 45 08             	mov    0x8(%ebp),%eax
c002b86a:	8b 40 08             	mov    0x8(%eax),%eax
}
c002b86d:	5d                   	pop    %ebp
c002b86e:	c3                   	ret    

c002b86f <hash_size>:

/* Returns the number of elements in H. */
size_t
hash_size (struct hash *h) 
{
c002b86f:	55                   	push   %ebp
c002b870:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt;
c002b872:	8b 45 08             	mov    0x8(%ebp),%eax
c002b875:	8b 00                	mov    (%eax),%eax
}
c002b877:	5d                   	pop    %ebp
c002b878:	c3                   	ret    

c002b879 <hash_empty>:

/* Returns true if H contains no elements, false otherwise. */
bool
hash_empty (struct hash *h) 
{
c002b879:	55                   	push   %ebp
c002b87a:	89 e5                	mov    %esp,%ebp
  return h->elem_cnt == 0;
c002b87c:	8b 45 08             	mov    0x8(%ebp),%eax
c002b87f:	8b 00                	mov    (%eax),%eax
c002b881:	85 c0                	test   %eax,%eax
c002b883:	0f 94 c0             	sete   %al
}
c002b886:	5d                   	pop    %ebp
c002b887:	c3                   	ret    

c002b888 <hash_bytes>:
#define FNV_32_BASIS 2166136261u

/* Returns a hash of the SIZE bytes in BUF. */
unsigned
hash_bytes (const void *buf_, size_t size)
{
c002b888:	55                   	push   %ebp
c002b889:	89 e5                	mov    %esp,%ebp
c002b88b:	83 ec 18             	sub    $0x18,%esp
  /* Fowler-Noll-Vo 32-bit hash, for bytes. */
  const unsigned char *buf = buf_;
c002b88e:	8b 45 08             	mov    0x8(%ebp),%eax
c002b891:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);
c002b894:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b898:	75 21                	jne    c002b8bb <hash_bytes+0x33>
c002b89a:	83 ec 0c             	sub    $0xc,%esp
c002b89d:	68 72 17 03 c0       	push   $0xc0031772
c002b8a2:	68 2f 17 03 c0       	push   $0xc003172f
c002b8a7:	68 ac 17 03 c0       	push   $0xc00317ac
c002b8ac:	68 10 01 00 00       	push   $0x110
c002b8b1:	68 46 17 03 c0       	push   $0xc0031746
c002b8b6:	e8 60 e3 ff ff       	call   c0029c1b <debug_panic>

  hash = FNV_32_BASIS;
c002b8bb:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (size-- > 0)
c002b8c2:	eb 1d                	jmp    c002b8e1 <hash_bytes+0x59>
    hash = (hash * FNV_32_PRIME) ^ *buf++;
c002b8c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b8c7:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b8cd:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b8d0:	8d 50 01             	lea    0x1(%eax),%edx
c002b8d3:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b8d6:	0f b6 00             	movzbl (%eax),%eax
c002b8d9:	0f b6 c0             	movzbl %al,%eax
c002b8dc:	31 c8                	xor    %ecx,%eax
c002b8de:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (buf != NULL);

  hash = FNV_32_BASIS;
  while (size-- > 0)
c002b8e1:	8b 45 0c             	mov    0xc(%ebp),%eax
c002b8e4:	8d 50 ff             	lea    -0x1(%eax),%edx
c002b8e7:	89 55 0c             	mov    %edx,0xc(%ebp)
c002b8ea:	85 c0                	test   %eax,%eax
c002b8ec:	75 d6                	jne    c002b8c4 <hash_bytes+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *buf++;

  return hash;
c002b8ee:	8b 45 f0             	mov    -0x10(%ebp),%eax
} 
c002b8f1:	c9                   	leave  
c002b8f2:	c3                   	ret    

c002b8f3 <hash_string>:

/* Returns a hash of string S. */
unsigned
hash_string (const char *s_) 
{
c002b8f3:	55                   	push   %ebp
c002b8f4:	89 e5                	mov    %esp,%ebp
c002b8f6:	83 ec 18             	sub    $0x18,%esp
  const unsigned char *s = (const unsigned char *) s_;
c002b8f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b8fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
  unsigned hash;

  ASSERT (s != NULL);
c002b8ff:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002b903:	75 21                	jne    c002b926 <hash_string+0x33>
c002b905:	83 ec 0c             	sub    $0xc,%esp
c002b908:	68 7e 17 03 c0       	push   $0xc003177e
c002b90d:	68 2f 17 03 c0       	push   $0xc003172f
c002b912:	68 b8 17 03 c0       	push   $0xc00317b8
c002b917:	68 20 01 00 00       	push   $0x120
c002b91c:	68 46 17 03 c0       	push   $0xc0031746
c002b921:	e8 f5 e2 ff ff       	call   c0029c1b <debug_panic>

  hash = FNV_32_BASIS;
c002b926:	c7 45 f0 c5 9d 1c 81 	movl   $0x811c9dc5,-0x10(%ebp)
  while (*s != '\0')
c002b92d:	eb 1d                	jmp    c002b94c <hash_string+0x59>
    hash = (hash * FNV_32_PRIME) ^ *s++;
c002b92f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002b932:	69 c8 93 01 00 01    	imul   $0x1000193,%eax,%ecx
c002b938:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b93b:	8d 50 01             	lea    0x1(%eax),%edx
c002b93e:	89 55 f4             	mov    %edx,-0xc(%ebp)
c002b941:	0f b6 00             	movzbl (%eax),%eax
c002b944:	0f b6 c0             	movzbl %al,%eax
c002b947:	31 c8                	xor    %ecx,%eax
c002b949:	89 45 f0             	mov    %eax,-0x10(%ebp)
  unsigned hash;

  ASSERT (s != NULL);

  hash = FNV_32_BASIS;
  while (*s != '\0')
c002b94c:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b94f:	0f b6 00             	movzbl (%eax),%eax
c002b952:	84 c0                	test   %al,%al
c002b954:	75 d9                	jne    c002b92f <hash_string+0x3c>
    hash = (hash * FNV_32_PRIME) ^ *s++;

  return hash;
c002b956:	8b 45 f0             	mov    -0x10(%ebp),%eax
}
c002b959:	c9                   	leave  
c002b95a:	c3                   	ret    

c002b95b <hash_int>:

/* Returns a hash of integer I. */
unsigned
hash_int (int i) 
{
c002b95b:	55                   	push   %ebp
c002b95c:	89 e5                	mov    %esp,%ebp
c002b95e:	83 ec 08             	sub    $0x8,%esp
  return hash_bytes (&i, sizeof i);
c002b961:	83 ec 08             	sub    $0x8,%esp
c002b964:	6a 04                	push   $0x4
c002b966:	8d 45 08             	lea    0x8(%ebp),%eax
c002b969:	50                   	push   %eax
c002b96a:	e8 19 ff ff ff       	call   c002b888 <hash_bytes>
c002b96f:	83 c4 10             	add    $0x10,%esp
}
c002b972:	c9                   	leave  
c002b973:	c3                   	ret    

c002b974 <find_bucket>:

/* Returns the bucket in H that E belongs in. */
static struct list *
find_bucket (struct hash *h, struct hash_elem *e) 
{
c002b974:	55                   	push   %ebp
c002b975:	89 e5                	mov    %esp,%ebp
c002b977:	83 ec 18             	sub    $0x18,%esp
  size_t bucket_idx = h->hash (e, h->aux) & (h->bucket_cnt - 1);
c002b97a:	8b 45 08             	mov    0x8(%ebp),%eax
c002b97d:	8b 40 0c             	mov    0xc(%eax),%eax
c002b980:	8b 55 08             	mov    0x8(%ebp),%edx
c002b983:	8b 52 14             	mov    0x14(%edx),%edx
c002b986:	83 ec 08             	sub    $0x8,%esp
c002b989:	52                   	push   %edx
c002b98a:	ff 75 0c             	pushl  0xc(%ebp)
c002b98d:	ff d0                	call   *%eax
c002b98f:	83 c4 10             	add    $0x10,%esp
c002b992:	89 c2                	mov    %eax,%edx
c002b994:	8b 45 08             	mov    0x8(%ebp),%eax
c002b997:	8b 40 04             	mov    0x4(%eax),%eax
c002b99a:	83 e8 01             	sub    $0x1,%eax
c002b99d:	21 d0                	and    %edx,%eax
c002b99f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  return &h->buckets[bucket_idx];
c002b9a2:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9a5:	8b 40 08             	mov    0x8(%eax),%eax
c002b9a8:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002b9ab:	c1 e2 04             	shl    $0x4,%edx
c002b9ae:	01 d0                	add    %edx,%eax
}
c002b9b0:	c9                   	leave  
c002b9b1:	c3                   	ret    

c002b9b2 <find_elem>:

/* Searches BUCKET in H for a hash element equal to E.  Returns
   it if found or a null pointer otherwise. */
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002b9b2:	55                   	push   %ebp
c002b9b3:	89 e5                	mov    %esp,%ebp
c002b9b5:	83 ec 18             	sub    $0x18,%esp
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002b9b8:	83 ec 0c             	sub    $0xc,%esp
c002b9bb:	ff 75 0c             	pushl  0xc(%ebp)
c002b9be:	e8 20 e5 ff ff       	call   c0029ee3 <list_begin>
c002b9c3:	83 c4 10             	add    $0x10,%esp
c002b9c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002b9c9:	eb 66                	jmp    c002ba31 <find_elem+0x7f>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
c002b9cb:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002b9ce:	83 c0 04             	add    $0x4,%eax
c002b9d1:	83 e8 04             	sub    $0x4,%eax
c002b9d4:	89 45 f0             	mov    %eax,-0x10(%ebp)
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
c002b9d7:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9da:	8b 40 10             	mov    0x10(%eax),%eax
c002b9dd:	8b 55 08             	mov    0x8(%ebp),%edx
c002b9e0:	8b 52 14             	mov    0x14(%edx),%edx
c002b9e3:	83 ec 04             	sub    $0x4,%esp
c002b9e6:	52                   	push   %edx
c002b9e7:	ff 75 10             	pushl  0x10(%ebp)
c002b9ea:	ff 75 f0             	pushl  -0x10(%ebp)
c002b9ed:	ff d0                	call   *%eax
c002b9ef:	83 c4 10             	add    $0x10,%esp
c002b9f2:	83 f0 01             	xor    $0x1,%eax
c002b9f5:	84 c0                	test   %al,%al
c002b9f7:	74 27                	je     c002ba20 <find_elem+0x6e>
c002b9f9:	8b 45 08             	mov    0x8(%ebp),%eax
c002b9fc:	8b 40 10             	mov    0x10(%eax),%eax
c002b9ff:	8b 55 08             	mov    0x8(%ebp),%edx
c002ba02:	8b 52 14             	mov    0x14(%edx),%edx
c002ba05:	83 ec 04             	sub    $0x4,%esp
c002ba08:	52                   	push   %edx
c002ba09:	ff 75 f0             	pushl  -0x10(%ebp)
c002ba0c:	ff 75 10             	pushl  0x10(%ebp)
c002ba0f:	ff d0                	call   *%eax
c002ba11:	83 c4 10             	add    $0x10,%esp
c002ba14:	83 f0 01             	xor    $0x1,%eax
c002ba17:	84 c0                	test   %al,%al
c002ba19:	74 05                	je     c002ba20 <find_elem+0x6e>
        return hi; 
c002ba1b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002ba1e:	eb 29                	jmp    c002ba49 <find_elem+0x97>
static struct hash_elem *
find_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
  struct list_elem *i;

  for (i = list_begin (bucket); i != list_end (bucket); i = list_next (i)) 
c002ba20:	83 ec 0c             	sub    $0xc,%esp
c002ba23:	ff 75 f4             	pushl  -0xc(%ebp)
c002ba26:	e8 ea e4 ff ff       	call   c0029f15 <list_next>
c002ba2b:	83 c4 10             	add    $0x10,%esp
c002ba2e:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002ba31:	83 ec 0c             	sub    $0xc,%esp
c002ba34:	ff 75 0c             	pushl  0xc(%ebp)
c002ba37:	e8 23 e5 ff ff       	call   c0029f5f <list_end>
c002ba3c:	83 c4 10             	add    $0x10,%esp
c002ba3f:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002ba42:	75 87                	jne    c002b9cb <find_elem+0x19>
    {
      struct hash_elem *hi = list_elem_to_hash_elem (i);
      if (!h->less (hi, e, h->aux) && !h->less (e, hi, h->aux))
        return hi; 
    }
  return NULL;
c002ba44:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ba49:	c9                   	leave  
c002ba4a:	c3                   	ret    

c002ba4b <turn_off_least_1bit>:

/* Returns X with its lowest-order bit set to 1 turned off. */
static inline size_t
turn_off_least_1bit (size_t x) 
{
c002ba4b:	55                   	push   %ebp
c002ba4c:	89 e5                	mov    %esp,%ebp
  return x & (x - 1);
c002ba4e:	8b 45 08             	mov    0x8(%ebp),%eax
c002ba51:	83 e8 01             	sub    $0x1,%eax
c002ba54:	23 45 08             	and    0x8(%ebp),%eax
}
c002ba57:	5d                   	pop    %ebp
c002ba58:	c3                   	ret    

c002ba59 <is_power_of_2>:

/* Returns true if X is a power of 2, otherwise false. */
static inline size_t
is_power_of_2 (size_t x) 
{
c002ba59:	55                   	push   %ebp
c002ba5a:	89 e5                	mov    %esp,%ebp
  return x != 0 && turn_off_least_1bit (x) == 0;
c002ba5c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ba60:	74 16                	je     c002ba78 <is_power_of_2+0x1f>
c002ba62:	ff 75 08             	pushl  0x8(%ebp)
c002ba65:	e8 e1 ff ff ff       	call   c002ba4b <turn_off_least_1bit>
c002ba6a:	83 c4 04             	add    $0x4,%esp
c002ba6d:	85 c0                	test   %eax,%eax
c002ba6f:	75 07                	jne    c002ba78 <is_power_of_2+0x1f>
c002ba71:	b8 01 00 00 00       	mov    $0x1,%eax
c002ba76:	eb 05                	jmp    c002ba7d <is_power_of_2+0x24>
c002ba78:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002ba7d:	c9                   	leave  
c002ba7e:	c3                   	ret    

c002ba7f <rehash>:
   ideal.  This function can fail because of an out-of-memory
   condition, but that'll just make hash accesses less efficient;
   we can still continue. */
static void
rehash (struct hash *h) 
{
c002ba7f:	55                   	push   %ebp
c002ba80:	89 e5                	mov    %esp,%ebp
c002ba82:	83 ec 38             	sub    $0x38,%esp
  size_t old_bucket_cnt, new_bucket_cnt;
  struct list *new_buckets, *old_buckets;
  size_t i;

  ASSERT (h != NULL);
c002ba85:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
c002ba89:	75 21                	jne    c002baac <rehash+0x2d>
c002ba8b:	83 ec 0c             	sub    $0xc,%esp
c002ba8e:	68 68 17 03 c0       	push   $0xc0031768
c002ba93:	68 2f 17 03 c0       	push   $0xc003172f
c002ba98:	68 c4 17 03 c0       	push   $0xc00317c4
c002ba9d:	68 66 01 00 00       	push   $0x166
c002baa2:	68 46 17 03 c0       	push   $0xc0031746
c002baa7:	e8 6f e1 ff ff       	call   c0029c1b <debug_panic>

  /* Save old bucket info for later use. */
  old_buckets = h->buckets;
c002baac:	8b 45 08             	mov    0x8(%ebp),%eax
c002baaf:	8b 40 08             	mov    0x8(%eax),%eax
c002bab2:	89 45 e8             	mov    %eax,-0x18(%ebp)
  old_bucket_cnt = h->bucket_cnt;
c002bab5:	8b 45 08             	mov    0x8(%ebp),%eax
c002bab8:	8b 40 04             	mov    0x4(%eax),%eax
c002babb:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Calculate the number of buckets to use now.
     We want one bucket for about every BEST_ELEMS_PER_BUCKET.
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
c002babe:	8b 45 08             	mov    0x8(%ebp),%eax
c002bac1:	8b 00                	mov    (%eax),%eax
c002bac3:	d1 e8                	shr    %eax
c002bac5:	89 45 f4             	mov    %eax,-0xc(%ebp)
  if (new_bucket_cnt < 4)
c002bac8:	83 7d f4 03          	cmpl   $0x3,-0xc(%ebp)
c002bacc:	77 1a                	ja     c002bae8 <rehash+0x69>
    new_bucket_cnt = 4;
c002bace:	c7 45 f4 04 00 00 00 	movl   $0x4,-0xc(%ebp)
  while (!is_power_of_2 (new_bucket_cnt))
c002bad5:	eb 11                	jmp    c002bae8 <rehash+0x69>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);
c002bad7:	83 ec 0c             	sub    $0xc,%esp
c002bada:	ff 75 f4             	pushl  -0xc(%ebp)
c002badd:	e8 69 ff ff ff       	call   c002ba4b <turn_off_least_1bit>
c002bae2:	83 c4 10             	add    $0x10,%esp
c002bae5:	89 45 f4             	mov    %eax,-0xc(%ebp)
     We must have at least four buckets, and the number of
     buckets must be a power of 2. */
  new_bucket_cnt = h->elem_cnt / BEST_ELEMS_PER_BUCKET;
  if (new_bucket_cnt < 4)
    new_bucket_cnt = 4;
  while (!is_power_of_2 (new_bucket_cnt))
c002bae8:	83 ec 0c             	sub    $0xc,%esp
c002baeb:	ff 75 f4             	pushl  -0xc(%ebp)
c002baee:	e8 66 ff ff ff       	call   c002ba59 <is_power_of_2>
c002baf3:	83 c4 10             	add    $0x10,%esp
c002baf6:	85 c0                	test   %eax,%eax
c002baf8:	74 dd                	je     c002bad7 <rehash+0x58>
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
c002bafa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bafd:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002bb00:	0f 84 12 01 00 00    	je     c002bc18 <rehash+0x199>
    return;

  /* Allocate new buckets and initialize them as empty. */
  new_buckets = malloc (sizeof *new_buckets * new_bucket_cnt);
c002bb06:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bb09:	c1 e0 04             	shl    $0x4,%eax
c002bb0c:	83 ec 0c             	sub    $0xc,%esp
c002bb0f:	50                   	push   %eax
c002bb10:	e8 4c 7e ff ff       	call   c0023961 <malloc>
c002bb15:	83 c4 10             	add    $0x10,%esp
c002bb18:	89 45 e0             	mov    %eax,-0x20(%ebp)
  if (new_buckets == NULL) 
c002bb1b:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
c002bb1f:	0f 84 f6 00 00 00    	je     c002bc1b <rehash+0x19c>
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002bb25:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bb2c:	eb 1d                	jmp    c002bb4b <rehash+0xcc>
    list_init (&new_buckets[i]);
c002bb2e:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bb31:	c1 e0 04             	shl    $0x4,%eax
c002bb34:	89 c2                	mov    %eax,%edx
c002bb36:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002bb39:	01 d0                	add    %edx,%eax
c002bb3b:	83 ec 0c             	sub    $0xc,%esp
c002bb3e:	50                   	push   %eax
c002bb3f:	e8 4a e3 ff ff       	call   c0029e8e <list_init>
c002bb44:	83 c4 10             	add    $0x10,%esp
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
    }
  for (i = 0; i < new_bucket_cnt; i++) 
c002bb47:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002bb4b:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bb4e:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002bb51:	72 db                	jb     c002bb2e <rehash+0xaf>
    list_init (&new_buckets[i]);

  /* Install new bucket info. */
  h->buckets = new_buckets;
c002bb53:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb56:	8b 55 e0             	mov    -0x20(%ebp),%edx
c002bb59:	89 50 08             	mov    %edx,0x8(%eax)
  h->bucket_cnt = new_bucket_cnt;
c002bb5c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bb5f:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002bb62:	89 50 04             	mov    %edx,0x4(%eax)

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002bb65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002bb6c:	e9 8b 00 00 00       	jmp    c002bbfc <rehash+0x17d>
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
c002bb71:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bb74:	c1 e0 04             	shl    $0x4,%eax
c002bb77:	89 c2                	mov    %eax,%edx
c002bb79:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002bb7c:	01 d0                	add    %edx,%eax
c002bb7e:	89 45 dc             	mov    %eax,-0x24(%ebp)
      for (elem = list_begin (old_bucket);
c002bb81:	83 ec 0c             	sub    $0xc,%esp
c002bb84:	ff 75 dc             	pushl  -0x24(%ebp)
c002bb87:	e8 57 e3 ff ff       	call   c0029ee3 <list_begin>
c002bb8c:	83 c4 10             	add    $0x10,%esp
c002bb8f:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002bb92:	eb 51                	jmp    c002bbe5 <rehash+0x166>
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
            = find_bucket (h, list_elem_to_hash_elem (elem));
c002bb94:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002bb97:	83 c0 04             	add    $0x4,%eax
c002bb9a:	83 e8 04             	sub    $0x4,%eax

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
        {
          struct list *new_bucket
c002bb9d:	83 ec 08             	sub    $0x8,%esp
c002bba0:	50                   	push   %eax
c002bba1:	ff 75 08             	pushl  0x8(%ebp)
c002bba4:	e8 cb fd ff ff       	call   c002b974 <find_bucket>
c002bba9:	83 c4 10             	add    $0x10,%esp
c002bbac:	89 45 d8             	mov    %eax,-0x28(%ebp)
            = find_bucket (h, list_elem_to_hash_elem (elem));
          next = list_next (elem);
c002bbaf:	83 ec 0c             	sub    $0xc,%esp
c002bbb2:	ff 75 ec             	pushl  -0x14(%ebp)
c002bbb5:	e8 5b e3 ff ff       	call   c0029f15 <list_next>
c002bbba:	83 c4 10             	add    $0x10,%esp
c002bbbd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
          list_remove (elem);
c002bbc0:	83 ec 0c             	sub    $0xc,%esp
c002bbc3:	ff 75 ec             	pushl  -0x14(%ebp)
c002bbc6:	e8 c9 e6 ff ff       	call   c002a294 <list_remove>
c002bbcb:	83 c4 10             	add    $0x10,%esp
          list_push_front (new_bucket, elem);
c002bbce:	83 ec 08             	sub    $0x8,%esp
c002bbd1:	ff 75 ec             	pushl  -0x14(%ebp)
c002bbd4:	ff 75 d8             	pushl  -0x28(%ebp)
c002bbd7:	e8 6c e6 ff ff       	call   c002a248 <list_push_front>
c002bbdc:	83 c4 10             	add    $0x10,%esp
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
           elem != list_end (old_bucket); elem = next) 
c002bbdf:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002bbe2:	89 45 ec             	mov    %eax,-0x14(%ebp)
c002bbe5:	83 ec 0c             	sub    $0xc,%esp
c002bbe8:	ff 75 dc             	pushl  -0x24(%ebp)
c002bbeb:	e8 6f e3 ff ff       	call   c0029f5f <list_end>
c002bbf0:	83 c4 10             	add    $0x10,%esp
    {
      struct list *old_bucket;
      struct list_elem *elem, *next;

      old_bucket = &old_buckets[i];
      for (elem = list_begin (old_bucket);
c002bbf3:	3b 45 ec             	cmp    -0x14(%ebp),%eax
c002bbf6:	75 9c                	jne    c002bb94 <rehash+0x115>
  /* Install new bucket info. */
  h->buckets = new_buckets;
  h->bucket_cnt = new_bucket_cnt;

  /* Move each old element into the appropriate new bucket. */
  for (i = 0; i < old_bucket_cnt; i++) 
c002bbf8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002bbfc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002bbff:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002bc02:	0f 82 69 ff ff ff    	jb     c002bb71 <rehash+0xf2>
          list_remove (elem);
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
c002bc08:	83 ec 0c             	sub    $0xc,%esp
c002bc0b:	ff 75 e8             	pushl  -0x18(%ebp)
c002bc0e:	e8 4f 80 ff ff       	call   c0023c62 <free>
c002bc13:	83 c4 10             	add    $0x10,%esp
c002bc16:	eb 04                	jmp    c002bc1c <rehash+0x19d>
  while (!is_power_of_2 (new_bucket_cnt))
    new_bucket_cnt = turn_off_least_1bit (new_bucket_cnt);

  /* Don't do anything if the bucket count wouldn't change. */
  if (new_bucket_cnt == old_bucket_cnt)
    return;
c002bc18:	90                   	nop
c002bc19:	eb 01                	jmp    c002bc1c <rehash+0x19d>
  if (new_buckets == NULL) 
    {
      /* Allocation failed.  This means that use of the hash table will
         be less efficient.  However, it is still usable, so
         there's no reason for it to be an error. */
      return;
c002bc1b:	90                   	nop
          list_push_front (new_bucket, elem);
        }
    }

  free (old_buckets);
}
c002bc1c:	c9                   	leave  
c002bc1d:	c3                   	ret    

c002bc1e <insert_elem>:

/* Inserts E into BUCKET (in hash table H). */
static void
insert_elem (struct hash *h, struct list *bucket, struct hash_elem *e) 
{
c002bc1e:	55                   	push   %ebp
c002bc1f:	89 e5                	mov    %esp,%ebp
c002bc21:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt++;
c002bc24:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc27:	8b 00                	mov    (%eax),%eax
c002bc29:	8d 50 01             	lea    0x1(%eax),%edx
c002bc2c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc2f:	89 10                	mov    %edx,(%eax)
  list_push_front (bucket, &e->list_elem);
c002bc31:	8b 45 10             	mov    0x10(%ebp),%eax
c002bc34:	83 ec 08             	sub    $0x8,%esp
c002bc37:	50                   	push   %eax
c002bc38:	ff 75 0c             	pushl  0xc(%ebp)
c002bc3b:	e8 08 e6 ff ff       	call   c002a248 <list_push_front>
c002bc40:	83 c4 10             	add    $0x10,%esp
}
c002bc43:	90                   	nop
c002bc44:	c9                   	leave  
c002bc45:	c3                   	ret    

c002bc46 <remove_elem>:

/* Removes E from hash table H. */
static void
remove_elem (struct hash *h, struct hash_elem *e) 
{
c002bc46:	55                   	push   %ebp
c002bc47:	89 e5                	mov    %esp,%ebp
c002bc49:	83 ec 08             	sub    $0x8,%esp
  h->elem_cnt--;
c002bc4c:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc4f:	8b 00                	mov    (%eax),%eax
c002bc51:	8d 50 ff             	lea    -0x1(%eax),%edx
c002bc54:	8b 45 08             	mov    0x8(%ebp),%eax
c002bc57:	89 10                	mov    %edx,(%eax)
  list_remove (&e->list_elem);
c002bc59:	8b 45 0c             	mov    0xc(%ebp),%eax
c002bc5c:	83 ec 0c             	sub    $0xc,%esp
c002bc5f:	50                   	push   %eax
c002bc60:	e8 2f e6 ff ff       	call   c002a294 <list_remove>
c002bc65:	83 c4 10             	add    $0x10,%esp
}
c002bc68:	90                   	nop
c002bc69:	c9                   	leave  
c002bc6a:	c3                   	ret    

c002bc6b <console_init>:
static int64_t write_cnt;

/* Enable console locking. */
void
console_init (void) 
{
c002bc6b:	55                   	push   %ebp
c002bc6c:	89 e5                	mov    %esp,%ebp
c002bc6e:	83 ec 08             	sub    $0x8,%esp
  lock_init (&console_lock);
c002bc71:	83 ec 0c             	sub    $0xc,%esp
c002bc74:	68 e0 9d 03 c0       	push   $0xc0039de0
c002bc79:	e8 18 70 ff ff       	call   c0022c96 <lock_init>
c002bc7e:	83 c4 10             	add    $0x10,%esp
  use_console_lock = true;
c002bc81:	c6 05 00 9e 03 c0 01 	movb   $0x1,0xc0039e00
}
c002bc88:	90                   	nop
c002bc89:	c9                   	leave  
c002bc8a:	c3                   	ret    

c002bc8b <console_panic>:
/* Notifies the console that a kernel panic is underway,
   which warns it to avoid trying to take the console lock from
   now on. */
void
console_panic (void) 
{
c002bc8b:	55                   	push   %ebp
c002bc8c:	89 e5                	mov    %esp,%ebp
  use_console_lock = false;
c002bc8e:	c6 05 00 9e 03 c0 00 	movb   $0x0,0xc0039e00
}
c002bc95:	90                   	nop
c002bc96:	5d                   	pop    %ebp
c002bc97:	c3                   	ret    

c002bc98 <console_print_stats>:

/* Prints console statistics. */
void
console_print_stats (void) 
{
c002bc98:	55                   	push   %ebp
c002bc99:	89 e5                	mov    %esp,%ebp
c002bc9b:	83 ec 08             	sub    $0x8,%esp
  printf ("Console: %lld characters output\n", write_cnt);
c002bc9e:	a1 08 9e 03 c0       	mov    0xc0039e08,%eax
c002bca3:	8b 15 0c 9e 03 c0    	mov    0xc0039e0c,%edx
c002bca9:	83 ec 04             	sub    $0x4,%esp
c002bcac:	52                   	push   %edx
c002bcad:	50                   	push   %eax
c002bcae:	68 cc 17 03 c0       	push   $0xc00317cc
c002bcb3:	e8 30 bb ff ff       	call   c00277e8 <printf>
c002bcb8:	83 c4 10             	add    $0x10,%esp
}
c002bcbb:	90                   	nop
c002bcbc:	c9                   	leave  
c002bcbd:	c3                   	ret    

c002bcbe <acquire_console>:

/* Acquires the console lock. */
static void
acquire_console (void) 
{
c002bcbe:	55                   	push   %ebp
c002bcbf:	89 e5                	mov    %esp,%ebp
c002bcc1:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002bcc4:	e8 0d 5b ff ff       	call   c00217d6 <intr_context>
c002bcc9:	83 f0 01             	xor    $0x1,%eax
c002bccc:	84 c0                	test   %al,%al
c002bcce:	74 3e                	je     c002bd0e <acquire_console+0x50>
c002bcd0:	0f b6 05 00 9e 03 c0 	movzbl 0xc0039e00,%eax
c002bcd7:	84 c0                	test   %al,%al
c002bcd9:	74 33                	je     c002bd0e <acquire_console+0x50>
    {
      if (lock_held_by_current_thread (&console_lock)) 
c002bcdb:	83 ec 0c             	sub    $0xc,%esp
c002bcde:	68 e0 9d 03 c0       	push   $0xc0039de0
c002bce3:	e8 3d 74 ff ff       	call   c0023125 <lock_held_by_current_thread>
c002bce8:	83 c4 10             	add    $0x10,%esp
c002bceb:	84 c0                	test   %al,%al
c002bced:	74 0f                	je     c002bcfe <acquire_console+0x40>
        console_lock_depth++; 
c002bcef:	a1 04 9e 03 c0       	mov    0xc0039e04,%eax
c002bcf4:	83 c0 01             	add    $0x1,%eax
c002bcf7:	a3 04 9e 03 c0       	mov    %eax,0xc0039e04
      else
        lock_acquire (&console_lock); 
    }
}
c002bcfc:	eb 10                	jmp    c002bd0e <acquire_console+0x50>
  if (!intr_context () && use_console_lock) 
    {
      if (lock_held_by_current_thread (&console_lock)) 
        console_lock_depth++; 
      else
        lock_acquire (&console_lock); 
c002bcfe:	83 ec 0c             	sub    $0xc,%esp
c002bd01:	68 e0 9d 03 c0       	push   $0xc0039de0
c002bd06:	e8 d8 6f ff ff       	call   c0022ce3 <lock_acquire>
c002bd0b:	83 c4 10             	add    $0x10,%esp
    }
}
c002bd0e:	90                   	nop
c002bd0f:	c9                   	leave  
c002bd10:	c3                   	ret    

c002bd11 <release_console>:

/* Releases the console lock. */
static void
release_console (void) 
{
c002bd11:	55                   	push   %ebp
c002bd12:	89 e5                	mov    %esp,%ebp
c002bd14:	83 ec 08             	sub    $0x8,%esp
  if (!intr_context () && use_console_lock) 
c002bd17:	e8 ba 5a ff ff       	call   c00217d6 <intr_context>
c002bd1c:	83 f0 01             	xor    $0x1,%eax
c002bd1f:	84 c0                	test   %al,%al
c002bd21:	74 33                	je     c002bd56 <release_console+0x45>
c002bd23:	0f b6 05 00 9e 03 c0 	movzbl 0xc0039e00,%eax
c002bd2a:	84 c0                	test   %al,%al
c002bd2c:	74 28                	je     c002bd56 <release_console+0x45>
    {
      if (console_lock_depth > 0)
c002bd2e:	a1 04 9e 03 c0       	mov    0xc0039e04,%eax
c002bd33:	85 c0                	test   %eax,%eax
c002bd35:	7e 0f                	jle    c002bd46 <release_console+0x35>
        console_lock_depth--;
c002bd37:	a1 04 9e 03 c0       	mov    0xc0039e04,%eax
c002bd3c:	83 e8 01             	sub    $0x1,%eax
c002bd3f:	a3 04 9e 03 c0       	mov    %eax,0xc0039e04
      else
        lock_release (&console_lock); 
    }
}
c002bd44:	eb 10                	jmp    c002bd56 <release_console+0x45>
  if (!intr_context () && use_console_lock) 
    {
      if (console_lock_depth > 0)
        console_lock_depth--;
      else
        lock_release (&console_lock); 
c002bd46:	83 ec 0c             	sub    $0xc,%esp
c002bd49:	68 e0 9d 03 c0       	push   $0xc0039de0
c002bd4e:	e8 73 71 ff ff       	call   c0022ec6 <lock_release>
c002bd53:	83 c4 10             	add    $0x10,%esp
    }
}
c002bd56:	90                   	nop
c002bd57:	c9                   	leave  
c002bd58:	c3                   	ret    

c002bd59 <console_locked_by_current_thread>:

/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
c002bd59:	55                   	push   %ebp
c002bd5a:	89 e5                	mov    %esp,%ebp
c002bd5c:	83 ec 08             	sub    $0x8,%esp
  return (intr_context ()
c002bd5f:	e8 72 5a ff ff       	call   c00217d6 <intr_context>
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
c002bd64:	84 c0                	test   %al,%al
c002bd66:	75 22                	jne    c002bd8a <console_locked_by_current_thread+0x31>
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
          || !use_console_lock
c002bd68:	0f b6 05 00 9e 03 c0 	movzbl 0xc0039e00,%eax
c002bd6f:	83 f0 01             	xor    $0x1,%eax
c002bd72:	84 c0                	test   %al,%al
c002bd74:	75 14                	jne    c002bd8a <console_locked_by_current_thread+0x31>
          || lock_held_by_current_thread (&console_lock));
c002bd76:	83 ec 0c             	sub    $0xc,%esp
c002bd79:	68 e0 9d 03 c0       	push   $0xc0039de0
c002bd7e:	e8 a2 73 ff ff       	call   c0023125 <lock_held_by_current_thread>
c002bd83:	83 c4 10             	add    $0x10,%esp
c002bd86:	84 c0                	test   %al,%al
c002bd88:	74 07                	je     c002bd91 <console_locked_by_current_thread+0x38>
c002bd8a:	b8 01 00 00 00       	mov    $0x1,%eax
c002bd8f:	eb 05                	jmp    c002bd96 <console_locked_by_current_thread+0x3d>
c002bd91:	b8 00 00 00 00       	mov    $0x0,%eax
/* Returns true if the current thread has the console lock,
   false otherwise. */
static bool
console_locked_by_current_thread (void) 
{
  return (intr_context ()
c002bd96:	83 e0 01             	and    $0x1,%eax
          || !use_console_lock
          || lock_held_by_current_thread (&console_lock));
}
c002bd99:	c9                   	leave  
c002bd9a:	c3                   	ret    

c002bd9b <vprintf>:
/* The standard vprintf() function,
   which is like printf() but uses a va_list.
   Writes its output to both vga display and serial port. */
int
vprintf (const char *format, va_list args) 
{
c002bd9b:	55                   	push   %ebp
c002bd9c:	89 e5                	mov    %esp,%ebp
c002bd9e:	83 ec 18             	sub    $0x18,%esp
  int char_cnt = 0;
c002bda1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  acquire_console ();
c002bda8:	e8 11 ff ff ff       	call   c002bcbe <acquire_console>
  __vprintf (format, args, vprintf_helper, &char_cnt);
c002bdad:	8d 45 f4             	lea    -0xc(%ebp),%eax
c002bdb0:	50                   	push   %eax
c002bdb1:	68 7d be 02 c0       	push   $0xc002be7d
c002bdb6:	ff 75 0c             	pushl  0xc(%ebp)
c002bdb9:	ff 75 08             	pushl  0x8(%ebp)
c002bdbc:	e8 4d ba ff ff       	call   c002780e <__vprintf>
c002bdc1:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002bdc4:	e8 48 ff ff ff       	call   c002bd11 <release_console>

  return char_cnt;
c002bdc9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
c002bdcc:	c9                   	leave  
c002bdcd:	c3                   	ret    

c002bdce <puts>:

/* Writes string S to the console, followed by a new-line
   character. */
int
puts (const char *s) 
{
c002bdce:	55                   	push   %ebp
c002bdcf:	89 e5                	mov    %esp,%ebp
c002bdd1:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002bdd4:	e8 e5 fe ff ff       	call   c002bcbe <acquire_console>
  while (*s != '\0')
c002bdd9:	eb 1b                	jmp    c002bdf6 <puts+0x28>
    putchar_have_lock (*s++);
c002bddb:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdde:	8d 50 01             	lea    0x1(%eax),%edx
c002bde1:	89 55 08             	mov    %edx,0x8(%ebp)
c002bde4:	0f b6 00             	movzbl (%eax),%eax
c002bde7:	0f b6 c0             	movzbl %al,%eax
c002bdea:	83 ec 0c             	sub    $0xc,%esp
c002bded:	50                   	push   %eax
c002bdee:	e8 bf 00 00 00       	call   c002beb2 <putchar_have_lock>
c002bdf3:	83 c4 10             	add    $0x10,%esp
   character. */
int
puts (const char *s) 
{
  acquire_console ();
  while (*s != '\0')
c002bdf6:	8b 45 08             	mov    0x8(%ebp),%eax
c002bdf9:	0f b6 00             	movzbl (%eax),%eax
c002bdfc:	84 c0                	test   %al,%al
c002bdfe:	75 db                	jne    c002bddb <puts+0xd>
    putchar_have_lock (*s++);
  putchar_have_lock ('\n');
c002be00:	83 ec 0c             	sub    $0xc,%esp
c002be03:	6a 0a                	push   $0xa
c002be05:	e8 a8 00 00 00       	call   c002beb2 <putchar_have_lock>
c002be0a:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002be0d:	e8 ff fe ff ff       	call   c002bd11 <release_console>

  return 0;
c002be12:	b8 00 00 00 00       	mov    $0x0,%eax
}
c002be17:	c9                   	leave  
c002be18:	c3                   	ret    

c002be19 <putbuf>:

/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
c002be19:	55                   	push   %ebp
c002be1a:	89 e5                	mov    %esp,%ebp
c002be1c:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002be1f:	e8 9a fe ff ff       	call   c002bcbe <acquire_console>
  while (n-- > 0)
c002be24:	eb 1b                	jmp    c002be41 <putbuf+0x28>
    putchar_have_lock (*buffer++);
c002be26:	8b 45 08             	mov    0x8(%ebp),%eax
c002be29:	8d 50 01             	lea    0x1(%eax),%edx
c002be2c:	89 55 08             	mov    %edx,0x8(%ebp)
c002be2f:	0f b6 00             	movzbl (%eax),%eax
c002be32:	0f b6 c0             	movzbl %al,%eax
c002be35:	83 ec 0c             	sub    $0xc,%esp
c002be38:	50                   	push   %eax
c002be39:	e8 74 00 00 00       	call   c002beb2 <putchar_have_lock>
c002be3e:	83 c4 10             	add    $0x10,%esp
/* Writes the N characters in BUFFER to the console. */
void
putbuf (const char *buffer, size_t n) 
{
  acquire_console ();
  while (n-- > 0)
c002be41:	8b 45 0c             	mov    0xc(%ebp),%eax
c002be44:	8d 50 ff             	lea    -0x1(%eax),%edx
c002be47:	89 55 0c             	mov    %edx,0xc(%ebp)
c002be4a:	85 c0                	test   %eax,%eax
c002be4c:	75 d8                	jne    c002be26 <putbuf+0xd>
    putchar_have_lock (*buffer++);
  release_console ();
c002be4e:	e8 be fe ff ff       	call   c002bd11 <release_console>
}
c002be53:	90                   	nop
c002be54:	c9                   	leave  
c002be55:	c3                   	ret    

c002be56 <putchar>:

/* Writes C to the vga display and serial port. */
int
putchar (int c) 
{
c002be56:	55                   	push   %ebp
c002be57:	89 e5                	mov    %esp,%ebp
c002be59:	83 ec 08             	sub    $0x8,%esp
  acquire_console ();
c002be5c:	e8 5d fe ff ff       	call   c002bcbe <acquire_console>
  putchar_have_lock (c);
c002be61:	8b 45 08             	mov    0x8(%ebp),%eax
c002be64:	0f b6 c0             	movzbl %al,%eax
c002be67:	83 ec 0c             	sub    $0xc,%esp
c002be6a:	50                   	push   %eax
c002be6b:	e8 42 00 00 00       	call   c002beb2 <putchar_have_lock>
c002be70:	83 c4 10             	add    $0x10,%esp
  release_console ();
c002be73:	e8 99 fe ff ff       	call   c002bd11 <release_console>
  
  return c;
c002be78:	8b 45 08             	mov    0x8(%ebp),%eax
}
c002be7b:	c9                   	leave  
c002be7c:	c3                   	ret    

c002be7d <vprintf_helper>:

/* Helper function for vprintf(). */
static void
vprintf_helper (char c, void *char_cnt_) 
{
c002be7d:	55                   	push   %ebp
c002be7e:	89 e5                	mov    %esp,%ebp
c002be80:	83 ec 28             	sub    $0x28,%esp
c002be83:	8b 45 08             	mov    0x8(%ebp),%eax
c002be86:	88 45 e4             	mov    %al,-0x1c(%ebp)
  int *char_cnt = char_cnt_;
c002be89:	8b 45 0c             	mov    0xc(%ebp),%eax
c002be8c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  (*char_cnt)++;
c002be8f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002be92:	8b 00                	mov    (%eax),%eax
c002be94:	8d 50 01             	lea    0x1(%eax),%edx
c002be97:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002be9a:	89 10                	mov    %edx,(%eax)
  putchar_have_lock (c);
c002be9c:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
c002bea0:	0f b6 c0             	movzbl %al,%eax
c002bea3:	83 ec 0c             	sub    $0xc,%esp
c002bea6:	50                   	push   %eax
c002bea7:	e8 06 00 00 00       	call   c002beb2 <putchar_have_lock>
c002beac:	83 c4 10             	add    $0x10,%esp
}
c002beaf:	90                   	nop
c002beb0:	c9                   	leave  
c002beb1:	c3                   	ret    

c002beb2 <putchar_have_lock>:
/* Writes C to the vga display and serial port.
   The caller has already acquired the console lock if
   appropriate. */
static void
putchar_have_lock (uint8_t c) 
{
c002beb2:	55                   	push   %ebp
c002beb3:	89 e5                	mov    %esp,%ebp
c002beb5:	83 ec 18             	sub    $0x18,%esp
c002beb8:	8b 45 08             	mov    0x8(%ebp),%eax
c002bebb:	88 45 f4             	mov    %al,-0xc(%ebp)
  ASSERT (console_locked_by_current_thread ());
c002bebe:	e8 96 fe ff ff       	call   c002bd59 <console_locked_by_current_thread>
c002bec3:	84 c0                	test   %al,%al
c002bec5:	75 21                	jne    c002bee8 <putchar_have_lock+0x36>
c002bec7:	83 ec 0c             	sub    $0xc,%esp
c002beca:	68 f0 17 03 c0       	push   $0xc00317f0
c002becf:	68 14 18 03 c0       	push   $0xc0031814
c002bed4:	68 48 18 03 c0       	push   $0xc0031848
c002bed9:	68 bb 00 00 00       	push   $0xbb
c002bede:	68 2b 18 03 c0       	push   $0xc003182b
c002bee3:	e8 33 dd ff ff       	call   c0029c1b <debug_panic>
  write_cnt++;
c002bee8:	a1 08 9e 03 c0       	mov    0xc0039e08,%eax
c002beed:	8b 15 0c 9e 03 c0    	mov    0xc0039e0c,%edx
c002bef3:	83 c0 01             	add    $0x1,%eax
c002bef6:	83 d2 00             	adc    $0x0,%edx
c002bef9:	a3 08 9e 03 c0       	mov    %eax,0xc0039e08
c002befe:	89 15 0c 9e 03 c0    	mov    %edx,0xc0039e0c
  serial_putc (c);
c002bf04:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bf08:	83 ec 0c             	sub    $0xc,%esp
c002bf0b:	50                   	push   %eax
c002bf0c:	e8 d9 90 ff ff       	call   c0024fea <serial_putc>
c002bf11:	83 c4 10             	add    $0x10,%esp
  vga_putc (c);
c002bf14:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
c002bf18:	83 ec 0c             	sub    $0xc,%esp
c002bf1b:	50                   	push   %eax
c002bf1c:	e8 5b 8c ff ff       	call   c0024b7c <vga_putc>
c002bf21:	83 c4 10             	add    $0x10,%esp
}
c002bf24:	90                   	nop
c002bf25:	c9                   	leave  
c002bf26:	c3                   	ret    

c002bf27 <run_test>:
static const char *test_name;

/* Runs the test named NAME. */
void
run_test (const char *name) 
{
c002bf27:	55                   	push   %ebp
c002bf28:	89 e5                	mov    %esp,%ebp
c002bf2a:	83 ec 18             	sub    $0x18,%esp
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002bf2d:	c7 45 f4 20 1a 03 c0 	movl   $0xc0031a20,-0xc(%ebp)
c002bf34:	eb 4e                	jmp    c002bf84 <run_test+0x5d>
    if (!strcmp (name, t->name))
c002bf36:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf39:	8b 00                	mov    (%eax),%eax
c002bf3b:	83 ec 08             	sub    $0x8,%esp
c002bf3e:	50                   	push   %eax
c002bf3f:	ff 75 08             	pushl  0x8(%ebp)
c002bf42:	e8 ca cc ff ff       	call   c0028c11 <strcmp>
c002bf47:	83 c4 10             	add    $0x10,%esp
c002bf4a:	85 c0                	test   %eax,%eax
c002bf4c:	75 32                	jne    c002bf80 <run_test+0x59>
      {
        test_name = name;
c002bf4e:	8b 45 08             	mov    0x8(%ebp),%eax
c002bf51:	a3 10 9e 03 c0       	mov    %eax,0xc0039e10
        msg ("begin");
c002bf56:	83 ec 0c             	sub    $0xc,%esp
c002bf59:	68 f8 1a 03 c0       	push   $0xc0031af8
c002bf5e:	e8 49 00 00 00       	call   c002bfac <msg>
c002bf63:	83 c4 10             	add    $0x10,%esp
        t->function ();
c002bf66:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bf69:	8b 40 04             	mov    0x4(%eax),%eax
c002bf6c:	ff d0                	call   *%eax
        msg ("end");
c002bf6e:	83 ec 0c             	sub    $0xc,%esp
c002bf71:	68 fe 1a 03 c0       	push   $0xc0031afe
c002bf76:	e8 31 00 00 00       	call   c002bfac <msg>
c002bf7b:	83 c4 10             	add    $0x10,%esp
        return;
c002bf7e:	eb 2a                	jmp    c002bfaa <run_test+0x83>
void
run_test (const char *name) 
{
  const struct test *t;

  for (t = tests; t < tests + sizeof tests / sizeof *tests; t++)
c002bf80:	83 45 f4 08          	addl   $0x8,-0xc(%ebp)
c002bf84:	b8 f8 1a 03 c0       	mov    $0xc0031af8,%eax
c002bf89:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002bf8c:	72 a8                	jb     c002bf36 <run_test+0xf>
        msg ("begin");
        t->function ();
        msg ("end");
        return;
      }
  PANIC ("no test named \"%s\"", name);
c002bf8e:	83 ec 0c             	sub    $0xc,%esp
c002bf91:	ff 75 08             	pushl  0x8(%ebp)
c002bf94:	68 02 1b 03 c0       	push   $0xc0031b02
c002bf99:	68 5c 1b 03 c0       	push   $0xc0031b5c
c002bf9e:	6a 3c                	push   $0x3c
c002bfa0:	68 15 1b 03 c0       	push   $0xc0031b15
c002bfa5:	e8 71 dc ff ff       	call   c0029c1b <debug_panic>
}
c002bfaa:	c9                   	leave  
c002bfab:	c3                   	ret    

c002bfac <msg>:
/* Prints FORMAT as if with printf(),
   prefixing the output by the name of the test
   and following it with a new-line character. */
void
msg (const char *format, ...) 
{
c002bfac:	55                   	push   %ebp
c002bfad:	89 e5                	mov    %esp,%ebp
c002bfaf:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) ", test_name);
c002bfb2:	a1 10 9e 03 c0       	mov    0xc0039e10,%eax
c002bfb7:	83 ec 08             	sub    $0x8,%esp
c002bfba:	50                   	push   %eax
c002bfbb:	68 31 1b 03 c0       	push   $0xc0031b31
c002bfc0:	e8 23 b8 ff ff       	call   c00277e8 <printf>
c002bfc5:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002bfc8:	8d 45 0c             	lea    0xc(%ebp),%eax
c002bfcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002bfce:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002bfd1:	83 ec 08             	sub    $0x8,%esp
c002bfd4:	50                   	push   %eax
c002bfd5:	ff 75 08             	pushl  0x8(%ebp)
c002bfd8:	e8 be fd ff ff       	call   c002bd9b <vprintf>
c002bfdd:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002bfe0:	83 ec 0c             	sub    $0xc,%esp
c002bfe3:	6a 0a                	push   $0xa
c002bfe5:	e8 6c fe ff ff       	call   c002be56 <putchar>
c002bfea:	83 c4 10             	add    $0x10,%esp
}
c002bfed:	90                   	nop
c002bfee:	c9                   	leave  
c002bfef:	c3                   	ret    

c002bff0 <fail>:
   prefixing the output by the name of the test and FAIL:
   and following it with a new-line character,
   and then panics the kernel. */
void
fail (const char *format, ...) 
{
c002bff0:	55                   	push   %ebp
c002bff1:	89 e5                	mov    %esp,%ebp
c002bff3:	83 ec 18             	sub    $0x18,%esp
  va_list args;
  
  printf ("(%s) FAIL: ", test_name);
c002bff6:	a1 10 9e 03 c0       	mov    0xc0039e10,%eax
c002bffb:	83 ec 08             	sub    $0x8,%esp
c002bffe:	50                   	push   %eax
c002bfff:	68 37 1b 03 c0       	push   $0xc0031b37
c002c004:	e8 df b7 ff ff       	call   c00277e8 <printf>
c002c009:	83 c4 10             	add    $0x10,%esp
  va_start (args, format);
c002c00c:	8d 45 0c             	lea    0xc(%ebp),%eax
c002c00f:	89 45 f4             	mov    %eax,-0xc(%ebp)
  vprintf (format, args);
c002c012:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c015:	83 ec 08             	sub    $0x8,%esp
c002c018:	50                   	push   %eax
c002c019:	ff 75 08             	pushl  0x8(%ebp)
c002c01c:	e8 7a fd ff ff       	call   c002bd9b <vprintf>
c002c021:	83 c4 10             	add    $0x10,%esp
  va_end (args);
  putchar ('\n');
c002c024:	83 ec 0c             	sub    $0xc,%esp
c002c027:	6a 0a                	push   $0xa
c002c029:	e8 28 fe ff ff       	call   c002be56 <putchar>
c002c02e:	83 c4 10             	add    $0x10,%esp

  PANIC ("test failed");
c002c031:	68 43 1b 03 c0       	push   $0xc0031b43
c002c036:	68 68 1b 03 c0       	push   $0xc0031b68
c002c03b:	6a 5d                	push   $0x5d
c002c03d:	68 15 1b 03 c0       	push   $0xc0031b15
c002c042:	e8 d4 db ff ff       	call   c0029c1b <debug_panic>

c002c047 <pass>:
}

/* Prints a message indicating the current test passed. */
void
pass (void) 
{
c002c047:	55                   	push   %ebp
c002c048:	89 e5                	mov    %esp,%ebp
c002c04a:	83 ec 08             	sub    $0x8,%esp
  printf ("(%s) PASS\n", test_name);
c002c04d:	a1 10 9e 03 c0       	mov    0xc0039e10,%eax
c002c052:	83 ec 08             	sub    $0x8,%esp
c002c055:	50                   	push   %eax
c002c056:	68 4f 1b 03 c0       	push   $0xc0031b4f
c002c05b:	e8 88 b7 ff ff       	call   c00277e8 <printf>
c002c060:	83 c4 10             	add    $0x10,%esp
}
c002c063:	90                   	nop
c002c064:	c9                   	leave  
c002c065:	c3                   	ret    

c002c066 <test_alarm_single>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_single (void) 
{
c002c066:	55                   	push   %ebp
c002c067:	89 e5                	mov    %esp,%ebp
c002c069:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 1);
c002c06c:	83 ec 08             	sub    $0x8,%esp
c002c06f:	6a 01                	push   $0x1
c002c071:	6a 05                	push   $0x5
c002c073:	e8 1e 00 00 00       	call   c002c096 <test_sleep>
c002c078:	83 c4 10             	add    $0x10,%esp
}
c002c07b:	90                   	nop
c002c07c:	c9                   	leave  
c002c07d:	c3                   	ret    

c002c07e <test_alarm_multiple>:

void
test_alarm_multiple (void) 
{
c002c07e:	55                   	push   %ebp
c002c07f:	89 e5                	mov    %esp,%ebp
c002c081:	83 ec 08             	sub    $0x8,%esp
  test_sleep (5, 7);
c002c084:	83 ec 08             	sub    $0x8,%esp
c002c087:	6a 07                	push   $0x7
c002c089:	6a 05                	push   $0x5
c002c08b:	e8 06 00 00 00       	call   c002c096 <test_sleep>
c002c090:	83 c4 10             	add    $0x10,%esp
}
c002c093:	90                   	nop
c002c094:	c9                   	leave  
c002c095:	c3                   	ret    

c002c096 <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002c096:	55                   	push   %ebp
c002c097:	89 e5                	mov    %esp,%ebp
c002c099:	83 ec 68             	sub    $0x68,%esp
  int *output, *op;
  int product;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c09c:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002c0a3:	83 f0 01             	xor    $0x1,%eax
c002c0a6:	84 c0                	test   %al,%al
c002c0a8:	75 1e                	jne    c002c0c8 <test_sleep+0x32>
c002c0aa:	83 ec 0c             	sub    $0xc,%esp
c002c0ad:	68 70 1b 03 c0       	push   $0xc0031b70
c002c0b2:	68 7e 1b 03 c0       	push   $0xc0031b7e
c002c0b7:	68 84 1d 03 c0       	push   $0xc0031d84
c002c0bc:	6a 3c                	push   $0x3c
c002c0be:	68 98 1b 03 c0       	push   $0xc0031b98
c002c0c3:	e8 53 db ff ff       	call   c0029c1b <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002c0c8:	83 ec 04             	sub    $0x4,%esp
c002c0cb:	ff 75 0c             	pushl  0xc(%ebp)
c002c0ce:	ff 75 08             	pushl  0x8(%ebp)
c002c0d1:	68 bc 1b 03 c0       	push   $0xc0031bbc
c002c0d6:	e8 d1 fe ff ff       	call   c002bfac <msg>
c002c0db:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 0 sleeps 10 ticks each time,");
c002c0de:	83 ec 0c             	sub    $0xc,%esp
c002c0e1:	68 e8 1b 03 c0       	push   $0xc0031be8
c002c0e6:	e8 c1 fe ff ff       	call   c002bfac <msg>
c002c0eb:	83 c4 10             	add    $0x10,%esp
  msg ("thread 1 sleeps 20 ticks each time, and so on.");
c002c0ee:	83 ec 0c             	sub    $0xc,%esp
c002c0f1:	68 0c 1c 03 c0       	push   $0xc0031c0c
c002c0f6:	e8 b1 fe ff ff       	call   c002bfac <msg>
c002c0fb:	83 c4 10             	add    $0x10,%esp
  msg ("If successful, product of iteration count and");
c002c0fe:	83 ec 0c             	sub    $0xc,%esp
c002c101:	68 3c 1c 03 c0       	push   $0xc0031c3c
c002c106:	e8 a1 fe ff ff       	call   c002bfac <msg>
c002c10b:	83 c4 10             	add    $0x10,%esp
  msg ("sleep duration will appear in nondescending order.");
c002c10e:	83 ec 0c             	sub    $0xc,%esp
c002c111:	68 6c 1c 03 c0       	push   $0xc0031c6c
c002c116:	e8 91 fe ff ff       	call   c002bfac <msg>
c002c11b:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  threads = malloc (sizeof *threads * thread_cnt);
c002c11e:	8b 45 08             	mov    0x8(%ebp),%eax
c002c121:	c1 e0 04             	shl    $0x4,%eax
c002c124:	83 ec 0c             	sub    $0xc,%esp
c002c127:	50                   	push   %eax
c002c128:	e8 34 78 ff ff       	call   c0023961 <malloc>
c002c12d:	83 c4 10             	add    $0x10,%esp
c002c130:	89 45 e8             	mov    %eax,-0x18(%ebp)
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002c133:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c136:	8b 45 08             	mov    0x8(%ebp),%eax
c002c139:	0f af c2             	imul   %edx,%eax
c002c13c:	c1 e0 03             	shl    $0x3,%eax
c002c13f:	83 ec 0c             	sub    $0xc,%esp
c002c142:	50                   	push   %eax
c002c143:	e8 19 78 ff ff       	call   c0023961 <malloc>
c002c148:	83 c4 10             	add    $0x10,%esp
c002c14b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  if (threads == NULL || output == NULL)
c002c14e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
c002c152:	74 06                	je     c002c15a <test_sleep+0xc4>
c002c154:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002c158:	75 16                	jne    c002c170 <test_sleep+0xda>
    PANIC ("couldn't allocate memory for test");
c002c15a:	68 a0 1c 03 c0       	push   $0xc0031ca0
c002c15f:	68 84 1d 03 c0       	push   $0xc0031d84
c002c164:	6a 48                	push   $0x48
c002c166:	68 98 1b 03 c0       	push   $0xc0031b98
c002c16b:	e8 ab da ff ff       	call   c0029c1b <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002c170:	e8 88 80 ff ff       	call   c00241fd <timer_ticks>
c002c175:	83 c0 64             	add    $0x64,%eax
c002c178:	83 d2 00             	adc    $0x0,%edx
c002c17b:	89 45 a8             	mov    %eax,-0x58(%ebp)
c002c17e:	89 55 ac             	mov    %edx,-0x54(%ebp)
  test.iterations = iterations;
c002c181:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c184:	89 45 b0             	mov    %eax,-0x50(%ebp)
  lock_init (&test.output_lock);
c002c187:	83 ec 0c             	sub    $0xc,%esp
c002c18a:	8d 45 a8             	lea    -0x58(%ebp),%eax
c002c18d:	83 c0 0c             	add    $0xc,%eax
c002c190:	50                   	push   %eax
c002c191:	e8 00 6b ff ff       	call   c0022c96 <lock_init>
c002c196:	83 c4 10             	add    $0x10,%esp
  test.output_pos = output;
c002c199:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c19c:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002c19f:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
c002c1a3:	75 1e                	jne    c002c1c3 <test_sleep+0x12d>
c002c1a5:	83 ec 0c             	sub    $0xc,%esp
c002c1a8:	68 c2 1c 03 c0       	push   $0xc0031cc2
c002c1ad:	68 7e 1b 03 c0       	push   $0xc0031b7e
c002c1b2:	68 84 1d 03 c0       	push   $0xc0031d84
c002c1b7:	6a 51                	push   $0x51
c002c1b9:	68 98 1b 03 c0       	push   $0xc0031b98
c002c1be:	e8 58 da ff ff       	call   c0029c1b <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002c1c3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002c1ca:	eb 72                	jmp    c002c23e <test_sleep+0x1a8>
    {
      struct sleep_thread *t = threads + i;
c002c1cc:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c1cf:	c1 e0 04             	shl    $0x4,%eax
c002c1d2:	89 c2                	mov    %eax,%edx
c002c1d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c1d7:	01 d0                	add    %edx,%eax
c002c1d9:	89 45 e0             	mov    %eax,-0x20(%ebp)
      char name[16];
      
      t->test = &test;
c002c1dc:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c1df:	8d 55 a8             	lea    -0x58(%ebp),%edx
c002c1e2:	89 10                	mov    %edx,(%eax)
      t->id = i;
c002c1e4:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c1e7:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c1ea:	89 50 04             	mov    %edx,0x4(%eax)
      t->duration = (i + 1) * 10;
c002c1ed:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c1f0:	8d 50 01             	lea    0x1(%eax),%edx
c002c1f3:	89 d0                	mov    %edx,%eax
c002c1f5:	c1 e0 02             	shl    $0x2,%eax
c002c1f8:	01 d0                	add    %edx,%eax
c002c1fa:	01 c0                	add    %eax,%eax
c002c1fc:	89 c2                	mov    %eax,%edx
c002c1fe:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c201:	89 50 08             	mov    %edx,0x8(%eax)
      t->iterations = 0;
c002c204:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002c207:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)

      snprintf (name, sizeof name, "thread %d", i);
c002c20e:	ff 75 ec             	pushl  -0x14(%ebp)
c002c211:	68 d1 1c 03 c0       	push   $0xc0031cd1
c002c216:	6a 10                	push   $0x10
c002c218:	8d 45 98             	lea    -0x68(%ebp),%eax
c002c21b:	50                   	push   %eax
c002c21c:	e8 9e b5 ff ff       	call   c00277bf <snprintf>
c002c221:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, t);
c002c224:	ff 75 e0             	pushl  -0x20(%ebp)
c002c227:	68 d4 c3 02 c0       	push   $0xc002c3d4
c002c22c:	6a 1f                	push   $0x1f
c002c22e:	8d 45 98             	lea    -0x68(%ebp),%eax
c002c231:	50                   	push   %eax
c002c232:	e8 70 48 ff ff       	call   c0020aa7 <thread_create>
c002c237:	83 c4 10             	add    $0x10,%esp
  lock_init (&test.output_lock);
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002c23a:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002c23e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c241:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c244:	7c 86                	jl     c002c1cc <test_sleep+0x136>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, t);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + thread_cnt * iterations * 10 + 100);
c002c246:	8b 45 08             	mov    0x8(%ebp),%eax
c002c249:	0f af 45 0c          	imul   0xc(%ebp),%eax
c002c24d:	89 c2                	mov    %eax,%edx
c002c24f:	89 d0                	mov    %edx,%eax
c002c251:	c1 e0 02             	shl    $0x2,%eax
c002c254:	01 d0                	add    %edx,%eax
c002c256:	01 c0                	add    %eax,%eax
c002c258:	05 c8 00 00 00       	add    $0xc8,%eax
c002c25d:	99                   	cltd   
c002c25e:	83 ec 08             	sub    $0x8,%esp
c002c261:	52                   	push   %edx
c002c262:	50                   	push   %eax
c002c263:	e8 e9 7f ff ff       	call   c0024251 <timer_sleep>
c002c268:	83 c4 10             	add    $0x10,%esp

  /* Acquire the output lock in case some rogue thread is still
     running. */
  lock_acquire (&test.output_lock);
c002c26b:	83 ec 0c             	sub    $0xc,%esp
c002c26e:	8d 45 a8             	lea    -0x58(%ebp),%eax
c002c271:	83 c0 0c             	add    $0xc,%eax
c002c274:	50                   	push   %eax
c002c275:	e8 69 6a ff ff       	call   c0022ce3 <lock_acquire>
c002c27a:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  product = 0;
c002c27d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  for (op = output; op < test.output_pos; op++) 
c002c284:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002c287:	89 45 f4             	mov    %eax,-0xc(%ebp)
c002c28a:	e9 ba 00 00 00       	jmp    c002c349 <test_sleep+0x2b3>
    {
      struct sleep_thread *t;
      int new_prod;

      ASSERT (*op >= 0 && *op < thread_cnt);
c002c28f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c292:	8b 00                	mov    (%eax),%eax
c002c294:	85 c0                	test   %eax,%eax
c002c296:	78 0a                	js     c002c2a2 <test_sleep+0x20c>
c002c298:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c29b:	8b 00                	mov    (%eax),%eax
c002c29d:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c2a0:	7c 1e                	jl     c002c2c0 <test_sleep+0x22a>
c002c2a2:	83 ec 0c             	sub    $0xc,%esp
c002c2a5:	68 db 1c 03 c0       	push   $0xc0031cdb
c002c2aa:	68 7e 1b 03 c0       	push   $0xc0031b7e
c002c2af:	68 84 1d 03 c0       	push   $0xc0031d84
c002c2b4:	6a 6e                	push   $0x6e
c002c2b6:	68 98 1b 03 c0       	push   $0xc0031b98
c002c2bb:	e8 5b d9 ff ff       	call   c0029c1b <debug_panic>
      t = threads + *op;
c002c2c0:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c2c3:	8b 00                	mov    (%eax),%eax
c002c2c5:	c1 e0 04             	shl    $0x4,%eax
c002c2c8:	89 c2                	mov    %eax,%edx
c002c2ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c2cd:	01 d0                	add    %edx,%eax
c002c2cf:	89 45 dc             	mov    %eax,-0x24(%ebp)

      new_prod = ++t->iterations * t->duration;
c002c2d2:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2d5:	8b 40 0c             	mov    0xc(%eax),%eax
c002c2d8:	8d 50 01             	lea    0x1(%eax),%edx
c002c2db:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2de:	89 50 0c             	mov    %edx,0xc(%eax)
c002c2e1:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2e4:	8b 50 0c             	mov    0xc(%eax),%edx
c002c2e7:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2ea:	8b 40 08             	mov    0x8(%eax),%eax
c002c2ed:	0f af c2             	imul   %edx,%eax
c002c2f0:	89 45 d8             	mov    %eax,-0x28(%ebp)
        
      msg ("thread %d: duration=%d, iteration=%d, product=%d",
c002c2f3:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2f6:	8b 48 0c             	mov    0xc(%eax),%ecx
c002c2f9:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c2fc:	8b 50 08             	mov    0x8(%eax),%edx
c002c2ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c302:	8b 40 04             	mov    0x4(%eax),%eax
c002c305:	83 ec 0c             	sub    $0xc,%esp
c002c308:	ff 75 d8             	pushl  -0x28(%ebp)
c002c30b:	51                   	push   %ecx
c002c30c:	52                   	push   %edx
c002c30d:	50                   	push   %eax
c002c30e:	68 f8 1c 03 c0       	push   $0xc0031cf8
c002c313:	e8 94 fc ff ff       	call   c002bfac <msg>
c002c318:	83 c4 20             	add    $0x20,%esp
           t->id, t->duration, t->iterations, new_prod);
      
      if (new_prod >= product)
c002c31b:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c31e:	3b 45 f0             	cmp    -0x10(%ebp),%eax
c002c321:	7c 08                	jl     c002c32b <test_sleep+0x295>
        product = new_prod;
c002c323:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002c326:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c329:	eb 1a                	jmp    c002c345 <test_sleep+0x2af>
      else
        fail ("thread %d woke up out of order (%d > %d)!",
c002c32b:	8b 45 dc             	mov    -0x24(%ebp),%eax
c002c32e:	8b 40 04             	mov    0x4(%eax),%eax
c002c331:	ff 75 d8             	pushl  -0x28(%ebp)
c002c334:	ff 75 f0             	pushl  -0x10(%ebp)
c002c337:	50                   	push   %eax
c002c338:	68 2c 1d 03 c0       	push   $0xc0031d2c
c002c33d:	e8 ae fc ff ff       	call   c002bff0 <fail>
c002c342:	83 c4 10             	add    $0x10,%esp
     running. */
  lock_acquire (&test.output_lock);

  /* Print completion order. */
  product = 0;
  for (op = output; op < test.output_pos; op++) 
c002c345:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002c349:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002c34c:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c34f:	0f 87 3a ff ff ff    	ja     c002c28f <test_sleep+0x1f9>
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002c355:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
c002c35c:	eb 3d                	jmp    c002c39b <test_sleep+0x305>
    if (threads[i].iterations != iterations)
c002c35e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c361:	c1 e0 04             	shl    $0x4,%eax
c002c364:	89 c2                	mov    %eax,%edx
c002c366:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c369:	01 d0                	add    %edx,%eax
c002c36b:	8b 40 0c             	mov    0xc(%eax),%eax
c002c36e:	3b 45 0c             	cmp    0xc(%ebp),%eax
c002c371:	74 24                	je     c002c397 <test_sleep+0x301>
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
c002c373:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c376:	c1 e0 04             	shl    $0x4,%eax
c002c379:	89 c2                	mov    %eax,%edx
c002c37b:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002c37e:	01 d0                	add    %edx,%eax
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
c002c380:	8b 40 0c             	mov    0xc(%eax),%eax
c002c383:	ff 75 0c             	pushl  0xc(%ebp)
c002c386:	50                   	push   %eax
c002c387:	ff 75 ec             	pushl  -0x14(%ebp)
c002c38a:	68 58 1d 03 c0       	push   $0xc0031d58
c002c38f:	e8 5c fc ff ff       	call   c002bff0 <fail>
c002c394:	83 c4 10             	add    $0x10,%esp
        fail ("thread %d woke up out of order (%d > %d)!",
              t->id, product, new_prod);
    }

  /* Verify that we had the proper number of wakeups. */
  for (i = 0; i < thread_cnt; i++)
c002c397:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002c39b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c39e:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c3a1:	7c bb                	jl     c002c35e <test_sleep+0x2c8>
    if (threads[i].iterations != iterations)
      fail ("thread %d woke up %d times instead of %d",
            i, threads[i].iterations, iterations);
  
  lock_release (&test.output_lock);
c002c3a3:	83 ec 0c             	sub    $0xc,%esp
c002c3a6:	8d 45 a8             	lea    -0x58(%ebp),%eax
c002c3a9:	83 c0 0c             	add    $0xc,%eax
c002c3ac:	50                   	push   %eax
c002c3ad:	e8 14 6b ff ff       	call   c0022ec6 <lock_release>
c002c3b2:	83 c4 10             	add    $0x10,%esp
  free (output);
c002c3b5:	83 ec 0c             	sub    $0xc,%esp
c002c3b8:	ff 75 e4             	pushl  -0x1c(%ebp)
c002c3bb:	e8 a2 78 ff ff       	call   c0023c62 <free>
c002c3c0:	83 c4 10             	add    $0x10,%esp
  free (threads);
c002c3c3:	83 ec 0c             	sub    $0xc,%esp
c002c3c6:	ff 75 e8             	pushl  -0x18(%ebp)
c002c3c9:	e8 94 78 ff ff       	call   c0023c62 <free>
c002c3ce:	83 c4 10             	add    $0x10,%esp
}
c002c3d1:	90                   	nop
c002c3d2:	c9                   	leave  
c002c3d3:	c3                   	ret    

c002c3d4 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *t_) 
{
c002c3d4:	55                   	push   %ebp
c002c3d5:	89 e5                	mov    %esp,%ebp
c002c3d7:	53                   	push   %ebx
c002c3d8:	83 ec 24             	sub    $0x24,%esp
  struct sleep_thread *t = t_;
c002c3db:	8b 45 08             	mov    0x8(%ebp),%eax
c002c3de:	89 45 f0             	mov    %eax,-0x10(%ebp)
  struct sleep_test *test = t->test;
c002c3e1:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c3e4:	8b 00                	mov    (%eax),%eax
c002c3e6:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002c3e9:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c3f0:	eb 7c                	jmp    c002c46e <sleeper+0x9a>
    {
      int64_t sleep_until = test->start + i * t->duration;
c002c3f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c3f5:	8b 08                	mov    (%eax),%ecx
c002c3f7:	8b 58 04             	mov    0x4(%eax),%ebx
c002c3fa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c3fd:	8b 40 08             	mov    0x8(%eax),%eax
c002c400:	0f af 45 f4          	imul   -0xc(%ebp),%eax
c002c404:	99                   	cltd   
c002c405:	01 c8                	add    %ecx,%eax
c002c407:	11 da                	adc    %ebx,%edx
c002c409:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c40c:	89 55 e4             	mov    %edx,-0x1c(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002c40f:	e8 e9 7d ff ff       	call   c00241fd <timer_ticks>
c002c414:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002c417:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002c41a:	29 c1                	sub    %eax,%ecx
c002c41c:	19 d3                	sbb    %edx,%ebx
c002c41e:	89 c8                	mov    %ecx,%eax
c002c420:	89 da                	mov    %ebx,%edx
c002c422:	83 ec 08             	sub    $0x8,%esp
c002c425:	52                   	push   %edx
c002c426:	50                   	push   %eax
c002c427:	e8 25 7e ff ff       	call   c0024251 <timer_sleep>
c002c42c:	83 c4 10             	add    $0x10,%esp
      lock_acquire (&test->output_lock);
c002c42f:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c432:	83 c0 0c             	add    $0xc,%eax
c002c435:	83 ec 0c             	sub    $0xc,%esp
c002c438:	50                   	push   %eax
c002c439:	e8 a5 68 ff ff       	call   c0022ce3 <lock_acquire>
c002c43e:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = t->id;
c002c441:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c444:	8b 40 2c             	mov    0x2c(%eax),%eax
c002c447:	8d 48 04             	lea    0x4(%eax),%ecx
c002c44a:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002c44d:	89 4a 2c             	mov    %ecx,0x2c(%edx)
c002c450:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002c453:	8b 52 04             	mov    0x4(%edx),%edx
c002c456:	89 10                	mov    %edx,(%eax)
      lock_release (&test->output_lock);
c002c458:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c45b:	83 c0 0c             	add    $0xc,%eax
c002c45e:	83 ec 0c             	sub    $0xc,%esp
c002c461:	50                   	push   %eax
c002c462:	e8 5f 6a ff ff       	call   c0022ec6 <lock_release>
c002c467:	83 c4 10             	add    $0x10,%esp
{
  struct sleep_thread *t = t_;
  struct sleep_test *test = t->test;
  int i;

  for (i = 1; i <= test->iterations; i++) 
c002c46a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c46e:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c471:	8b 40 08             	mov    0x8(%eax),%eax
c002c474:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c477:	0f 8d 75 ff ff ff    	jge    c002c3f2 <sleeper+0x1e>
      timer_sleep (sleep_until - timer_ticks ());
      lock_acquire (&test->output_lock);
      *test->output_pos++ = t->id;
      lock_release (&test->output_lock);
    }
}
c002c47d:	90                   	nop
c002c47e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c481:	c9                   	leave  
c002c482:	c3                   	ret    

c002c483 <test_alarm_simultaneous>:

static void test_sleep (int thread_cnt, int iterations);

void
test_alarm_simultaneous (void) 
{
c002c483:	55                   	push   %ebp
c002c484:	89 e5                	mov    %esp,%ebp
c002c486:	83 ec 08             	sub    $0x8,%esp
  test_sleep (3, 5);
c002c489:	83 ec 08             	sub    $0x8,%esp
c002c48c:	6a 05                	push   $0x5
c002c48e:	6a 03                	push   $0x3
c002c490:	e8 06 00 00 00       	call   c002c49b <test_sleep>
c002c495:	83 c4 10             	add    $0x10,%esp
}
c002c498:	90                   	nop
c002c499:	c9                   	leave  
c002c49a:	c3                   	ret    

c002c49b <test_sleep>:
static void sleeper (void *);

/* Runs THREAD_CNT threads thread sleep ITERATIONS times each. */
static void
test_sleep (int thread_cnt, int iterations) 
{
c002c49b:	55                   	push   %ebp
c002c49c:	89 e5                	mov    %esp,%ebp
c002c49e:	53                   	push   %ebx
c002c49f:	83 ec 34             	sub    $0x34,%esp
  struct sleep_test test;
  int *output;
  int i;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c4a2:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002c4a9:	83 f0 01             	xor    $0x1,%eax
c002c4ac:	84 c0                	test   %al,%al
c002c4ae:	75 1e                	jne    c002c4ce <test_sleep+0x33>
c002c4b0:	83 ec 0c             	sub    $0xc,%esp
c002c4b3:	68 90 1d 03 c0       	push   $0xc0031d90
c002c4b8:	68 9e 1d 03 c0       	push   $0xc0031d9e
c002c4bd:	68 18 1f 03 c0       	push   $0xc0031f18
c002c4c2:	6a 28                	push   $0x28
c002c4c4:	68 b8 1d 03 c0       	push   $0xc0031db8
c002c4c9:	e8 4d d7 ff ff       	call   c0029c1b <debug_panic>

  msg ("Creating %d threads to sleep %d times each.", thread_cnt, iterations);
c002c4ce:	83 ec 04             	sub    $0x4,%esp
c002c4d1:	ff 75 0c             	pushl  0xc(%ebp)
c002c4d4:	ff 75 08             	pushl  0x8(%ebp)
c002c4d7:	68 e4 1d 03 c0       	push   $0xc0031de4
c002c4dc:	e8 cb fa ff ff       	call   c002bfac <msg>
c002c4e1:	83 c4 10             	add    $0x10,%esp
  msg ("Each thread sleeps 10 ticks each time.");
c002c4e4:	83 ec 0c             	sub    $0xc,%esp
c002c4e7:	68 10 1e 03 c0       	push   $0xc0031e10
c002c4ec:	e8 bb fa ff ff       	call   c002bfac <msg>
c002c4f1:	83 c4 10             	add    $0x10,%esp
  msg ("Within an iteration, all threads should wake up on the same tick.");
c002c4f4:	83 ec 0c             	sub    $0xc,%esp
c002c4f7:	68 38 1e 03 c0       	push   $0xc0031e38
c002c4fc:	e8 ab fa ff ff       	call   c002bfac <msg>
c002c501:	83 c4 10             	add    $0x10,%esp

  /* Allocate memory. */
  output = malloc (sizeof *output * iterations * thread_cnt * 2);
c002c504:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c507:	8b 45 08             	mov    0x8(%ebp),%eax
c002c50a:	0f af c2             	imul   %edx,%eax
c002c50d:	c1 e0 03             	shl    $0x3,%eax
c002c510:	83 ec 0c             	sub    $0xc,%esp
c002c513:	50                   	push   %eax
c002c514:	e8 48 74 ff ff       	call   c0023961 <malloc>
c002c519:	83 c4 10             	add    $0x10,%esp
c002c51c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  if (output == NULL)
c002c51f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c523:	75 16                	jne    c002c53b <test_sleep+0xa0>
    PANIC ("couldn't allocate memory for test");
c002c525:	68 7c 1e 03 c0       	push   $0xc0031e7c
c002c52a:	68 18 1f 03 c0       	push   $0xc0031f18
c002c52f:	6a 31                	push   $0x31
c002c531:	68 b8 1d 03 c0       	push   $0xc0031db8
c002c536:	e8 e0 d6 ff ff       	call   c0029c1b <debug_panic>

  /* Initialize test. */
  test.start = timer_ticks () + 100;
c002c53b:	e8 bd 7c ff ff       	call   c00241fd <timer_ticks>
c002c540:	83 c0 64             	add    $0x64,%eax
c002c543:	83 d2 00             	adc    $0x0,%edx
c002c546:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002c549:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  test.iterations = iterations;
c002c54c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002c54f:	89 45 e8             	mov    %eax,-0x18(%ebp)
  test.output_pos = output;
c002c552:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c555:	89 45 ec             	mov    %eax,-0x14(%ebp)

  /* Start threads. */
  ASSERT (output != NULL);
c002c558:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
c002c55c:	75 1e                	jne    c002c57c <test_sleep+0xe1>
c002c55e:	83 ec 0c             	sub    $0xc,%esp
c002c561:	68 9e 1e 03 c0       	push   $0xc0031e9e
c002c566:	68 9e 1d 03 c0       	push   $0xc0031d9e
c002c56b:	68 18 1f 03 c0       	push   $0xc0031f18
c002c570:	6a 39                	push   $0x39
c002c572:	68 b8 1d 03 c0       	push   $0xc0031db8
c002c577:	e8 9f d6 ff ff       	call   c0029c1b <debug_panic>
  for (i = 0; i < thread_cnt; i++)
c002c57c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c583:	eb 31                	jmp    c002c5b6 <test_sleep+0x11b>
    {
      char name[16];
      snprintf (name, sizeof name, "thread %d", i);
c002c585:	ff 75 f4             	pushl  -0xc(%ebp)
c002c588:	68 ad 1e 03 c0       	push   $0xc0031ead
c002c58d:	6a 10                	push   $0x10
c002c58f:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c592:	50                   	push   %eax
c002c593:	e8 27 b2 ff ff       	call   c00277bf <snprintf>
c002c598:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, sleeper, &test);
c002c59b:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c59e:	50                   	push   %eax
c002c59f:	68 73 c6 02 c0       	push   $0xc002c673
c002c5a4:	6a 1f                	push   $0x1f
c002c5a6:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002c5a9:	50                   	push   %eax
c002c5aa:	e8 f8 44 ff ff       	call   c0020aa7 <thread_create>
c002c5af:	83 c4 10             	add    $0x10,%esp
  test.iterations = iterations;
  test.output_pos = output;

  /* Start threads. */
  ASSERT (output != NULL);
  for (i = 0; i < thread_cnt; i++)
c002c5b2:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c5b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c5b9:	3b 45 08             	cmp    0x8(%ebp),%eax
c002c5bc:	7c c7                	jl     c002c585 <test_sleep+0xea>
      snprintf (name, sizeof name, "thread %d", i);
      thread_create (name, PRI_DEFAULT, sleeper, &test);
    }
  
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);
c002c5be:	8b 55 0c             	mov    0xc(%ebp),%edx
c002c5c1:	89 d0                	mov    %edx,%eax
c002c5c3:	c1 e0 02             	shl    $0x2,%eax
c002c5c6:	01 d0                	add    %edx,%eax
c002c5c8:	01 c0                	add    %eax,%eax
c002c5ca:	05 c8 00 00 00       	add    $0xc8,%eax
c002c5cf:	99                   	cltd   
c002c5d0:	83 ec 08             	sub    $0x8,%esp
c002c5d3:	52                   	push   %edx
c002c5d4:	50                   	push   %eax
c002c5d5:	e8 77 7c ff ff       	call   c0024251 <timer_sleep>
c002c5da:	83 c4 10             	add    $0x10,%esp

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
c002c5dd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c5e0:	8b 00                	mov    (%eax),%eax
c002c5e2:	83 ec 08             	sub    $0x8,%esp
c002c5e5:	50                   	push   %eax
c002c5e6:	68 b8 1e 03 c0       	push   $0xc0031eb8
c002c5eb:	e8 bc f9 ff ff       	call   c002bfac <msg>
c002c5f0:	83 c4 10             	add    $0x10,%esp
  for (i = 1; i < test.output_pos - output; i++) 
c002c5f3:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c5fa:	eb 4f                	jmp    c002c64b <test_sleep+0x1b0>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
c002c5fc:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c5ff:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
c002c606:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c609:	01 d0                	add    %edx,%eax
c002c60b:	8b 10                	mov    (%eax),%edx
c002c60d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c610:	05 ff ff ff 3f       	add    $0x3fffffff,%eax
c002c615:	8d 0c 85 00 00 00 00 	lea    0x0(,%eax,4),%ecx
c002c61c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c61f:	01 c8                	add    %ecx,%eax
c002c621:	8b 00                	mov    (%eax),%eax
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
    msg ("iteration %d, thread %d: woke up %d ticks later",
c002c623:	89 d1                	mov    %edx,%ecx
c002c625:	29 c1                	sub    %eax,%ecx
c002c627:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c62a:	99                   	cltd   
c002c62b:	f7 7d 08             	idivl  0x8(%ebp)
c002c62e:	89 d3                	mov    %edx,%ebx
c002c630:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c633:	99                   	cltd   
c002c634:	f7 7d 08             	idivl  0x8(%ebp)
c002c637:	51                   	push   %ecx
c002c638:	53                   	push   %ebx
c002c639:	50                   	push   %eax
c002c63a:	68 e8 1e 03 c0       	push   $0xc0031ee8
c002c63f:	e8 68 f9 ff ff       	call   c002bfac <msg>
c002c644:	83 c4 10             	add    $0x10,%esp
  /* Wait long enough for all the threads to finish. */
  timer_sleep (100 + iterations * 10 + 100);

  /* Print completion order. */
  msg ("iteration 0, thread 0: woke up after %d ticks", output[0]);
  for (i = 1; i < test.output_pos - output; i++) 
c002c647:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c64b:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002c64e:	89 c2                	mov    %eax,%edx
c002c650:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c653:	29 c2                	sub    %eax,%edx
c002c655:	89 d0                	mov    %edx,%eax
c002c657:	c1 f8 02             	sar    $0x2,%eax
c002c65a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c65d:	7f 9d                	jg     c002c5fc <test_sleep+0x161>
    msg ("iteration %d, thread %d: woke up %d ticks later",
         i / thread_cnt, i % thread_cnt, output[i] - output[i - 1]);
  
  free (output);
c002c65f:	83 ec 0c             	sub    $0xc,%esp
c002c662:	ff 75 f0             	pushl  -0x10(%ebp)
c002c665:	e8 f8 75 ff ff       	call   c0023c62 <free>
c002c66a:	83 c4 10             	add    $0x10,%esp
}
c002c66d:	90                   	nop
c002c66e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c671:	c9                   	leave  
c002c672:	c3                   	ret    

c002c673 <sleeper>:

/* Sleeper thread. */
static void
sleeper (void *test_) 
{
c002c673:	55                   	push   %ebp
c002c674:	89 e5                	mov    %esp,%ebp
c002c676:	53                   	push   %ebx
c002c677:	83 ec 14             	sub    $0x14,%esp
  struct sleep_test *test = test_;
c002c67a:	8b 45 08             	mov    0x8(%ebp),%eax
c002c67d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);
c002c680:	83 ec 08             	sub    $0x8,%esp
c002c683:	6a 00                	push   $0x0
c002c685:	6a 01                	push   $0x1
c002c687:	e8 c5 7b ff ff       	call   c0024251 <timer_sleep>
c002c68c:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i <= test->iterations; i++) 
c002c68f:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002c696:	eb 6c                	jmp    c002c704 <sleeper+0x91>
    {
      int64_t sleep_until = test->start + i * 10;
c002c698:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c69b:	8b 08                	mov    (%eax),%ecx
c002c69d:	8b 58 04             	mov    0x4(%eax),%ebx
c002c6a0:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002c6a3:	89 d0                	mov    %edx,%eax
c002c6a5:	c1 e0 02             	shl    $0x2,%eax
c002c6a8:	01 d0                	add    %edx,%eax
c002c6aa:	01 c0                	add    %eax,%eax
c002c6ac:	99                   	cltd   
c002c6ad:	01 c8                	add    %ecx,%eax
c002c6af:	11 da                	adc    %ebx,%edx
c002c6b1:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002c6b4:	89 55 ec             	mov    %edx,-0x14(%ebp)
      timer_sleep (sleep_until - timer_ticks ());
c002c6b7:	e8 41 7b ff ff       	call   c00241fd <timer_ticks>
c002c6bc:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002c6bf:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002c6c2:	29 c1                	sub    %eax,%ecx
c002c6c4:	19 d3                	sbb    %edx,%ebx
c002c6c6:	89 c8                	mov    %ecx,%eax
c002c6c8:	89 da                	mov    %ebx,%edx
c002c6ca:	83 ec 08             	sub    $0x8,%esp
c002c6cd:	52                   	push   %edx
c002c6ce:	50                   	push   %eax
c002c6cf:	e8 7d 7b ff ff       	call   c0024251 <timer_sleep>
c002c6d4:	83 c4 10             	add    $0x10,%esp
      *test->output_pos++ = timer_ticks () - test->start;
c002c6d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c6da:	8b 58 0c             	mov    0xc(%eax),%ebx
c002c6dd:	8d 53 04             	lea    0x4(%ebx),%edx
c002c6e0:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c6e3:	89 50 0c             	mov    %edx,0xc(%eax)
c002c6e6:	e8 12 7b ff ff       	call   c00241fd <timer_ticks>
c002c6eb:	89 c1                	mov    %eax,%ecx
c002c6ed:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c6f0:	8b 50 04             	mov    0x4(%eax),%edx
c002c6f3:	8b 00                	mov    (%eax),%eax
c002c6f5:	29 c1                	sub    %eax,%ecx
c002c6f7:	89 c8                	mov    %ecx,%eax
c002c6f9:	89 03                	mov    %eax,(%ebx)
      thread_yield ();
c002c6fb:	e8 e2 46 ff ff       	call   c0020de2 <thread_yield>
  int i;

  /* Make sure we're at the beginning of a timer tick. */
  timer_sleep (1);

  for (i = 1; i <= test->iterations; i++) 
c002c700:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c704:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002c707:	8b 40 08             	mov    0x8(%eax),%eax
c002c70a:	3b 45 f4             	cmp    -0xc(%ebp),%eax
c002c70d:	7d 89                	jge    c002c698 <sleeper+0x25>
      int64_t sleep_until = test->start + i * 10;
      timer_sleep (sleep_until - timer_ticks ());
      *test->output_pos++ = timer_ticks () - test->start;
      thread_yield ();
    }
}
c002c70f:	90                   	nop
c002c710:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002c713:	c9                   	leave  
c002c714:	c3                   	ret    

c002c715 <test_alarm_priority>:
static int64_t wake_time;
static struct semaphore wait_sema;

void
test_alarm_priority (void) 
{
c002c715:	55                   	push   %ebp
c002c716:	89 e5                	mov    %esp,%ebp
c002c718:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c71b:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002c722:	83 f0 01             	xor    $0x1,%eax
c002c725:	84 c0                	test   %al,%al
c002c727:	75 1e                	jne    c002c747 <test_alarm_priority+0x32>
c002c729:	83 ec 0c             	sub    $0xc,%esp
c002c72c:	68 24 1f 03 c0       	push   $0xc0031f24
c002c731:	68 32 1f 03 c0       	push   $0xc0031f32
c002c736:	68 90 1f 03 c0       	push   $0xc0031f90
c002c73b:	6a 16                	push   $0x16
c002c73d:	68 4c 1f 03 c0       	push   $0xc0031f4c
c002c742:	e8 d4 d4 ff ff       	call   c0029c1b <debug_panic>

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
c002c747:	e8 b1 7a ff ff       	call   c00241fd <timer_ticks>
c002c74c:	05 f4 01 00 00       	add    $0x1f4,%eax
c002c751:	83 d2 00             	adc    $0x0,%edx
c002c754:	a3 18 9e 03 c0       	mov    %eax,0xc0039e18
c002c759:	89 15 1c 9e 03 c0    	mov    %edx,0xc0039e1c
  sema_init (&wait_sema, 0);
c002c75f:	83 ec 08             	sub    $0x8,%esp
c002c762:	6a 00                	push   $0x0
c002c764:	68 20 9e 03 c0       	push   $0xc0039e20
c002c769:	e8 23 62 ff ff       	call   c0022991 <sema_init>
c002c76e:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < 10; i++) 
c002c771:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c778:	eb 60                	jmp    c002c7da <test_alarm_priority+0xc5>
    {
      int priority = PRI_DEFAULT - (i + 5) % 10 - 1;
c002c77a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002c77d:	8d 48 05             	lea    0x5(%eax),%ecx
c002c780:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002c785:	89 c8                	mov    %ecx,%eax
c002c787:	f7 ea                	imul   %edx
c002c789:	c1 fa 02             	sar    $0x2,%edx
c002c78c:	89 c8                	mov    %ecx,%eax
c002c78e:	c1 f8 1f             	sar    $0x1f,%eax
c002c791:	29 c2                	sub    %eax,%edx
c002c793:	89 d0                	mov    %edx,%eax
c002c795:	c1 e0 02             	shl    $0x2,%eax
c002c798:	01 d0                	add    %edx,%eax
c002c79a:	01 c0                	add    %eax,%eax
c002c79c:	29 c1                	sub    %eax,%ecx
c002c79e:	89 ca                	mov    %ecx,%edx
c002c7a0:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002c7a5:	29 d0                	sub    %edx,%eax
c002c7a7:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002c7aa:	ff 75 f0             	pushl  -0x10(%ebp)
c002c7ad:	68 71 1f 03 c0       	push   $0xc0031f71
c002c7b2:	6a 10                	push   $0x10
c002c7b4:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c7b7:	50                   	push   %eax
c002c7b8:	e8 02 b0 ff ff       	call   c00277bf <snprintf>
c002c7bd:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
c002c7c0:	6a 00                	push   $0x0
c002c7c2:	68 13 c8 02 c0       	push   $0xc002c813
c002c7c7:	ff 75 f0             	pushl  -0x10(%ebp)
c002c7ca:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002c7cd:	50                   	push   %eax
c002c7ce:	e8 d4 42 ff ff       	call   c0020aa7 <thread_create>
c002c7d3:	83 c4 10             	add    $0x10,%esp
  ASSERT (!thread_mlfqs);

  wake_time = timer_ticks () + 5 * TIMER_FREQ;
  sema_init (&wait_sema, 0);
  
  for (i = 0; i < 10; i++) 
c002c7d6:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c7da:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c7de:	7e 9a                	jle    c002c77a <test_alarm_priority+0x65>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);
c002c7e0:	83 ec 0c             	sub    $0xc,%esp
c002c7e3:	6a 00                	push   $0x0
c002c7e5:	e8 07 47 ff ff       	call   c0020ef1 <thread_set_priority>
c002c7ea:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 10; i++)
c002c7ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002c7f4:	eb 14                	jmp    c002c80a <test_alarm_priority+0xf5>
    sema_down (&wait_sema);
c002c7f6:	83 ec 0c             	sub    $0xc,%esp
c002c7f9:	68 20 9e 03 c0       	push   $0xc0039e20
c002c7fe:	e8 d5 61 ff ff       	call   c00229d8 <sema_down>
c002c803:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, alarm_priority_thread, NULL);
    }

  thread_set_priority (PRI_MIN);

  for (i = 0; i < 10; i++)
c002c806:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002c80a:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002c80e:	7e e6                	jle    c002c7f6 <test_alarm_priority+0xe1>
    sema_down (&wait_sema);
}
c002c810:	90                   	nop
c002c811:	c9                   	leave  
c002c812:	c3                   	ret    

c002c813 <alarm_priority_thread>:

static void
alarm_priority_thread (void *aux UNUSED) 
{
c002c813:	55                   	push   %ebp
c002c814:	89 e5                	mov    %esp,%ebp
c002c816:	56                   	push   %esi
c002c817:	53                   	push   %ebx
c002c818:	83 ec 10             	sub    $0x10,%esp
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
c002c81b:	e8 dd 79 ff ff       	call   c00241fd <timer_ticks>
c002c820:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002c823:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) == 0)
c002c826:	eb 01                	jmp    c002c829 <alarm_priority_thread+0x16>
    continue;
c002c828:	90                   	nop
static void
alarm_priority_thread (void *aux UNUSED) 
{
  /* Busy-wait until the current time changes. */
  int64_t start_time = timer_ticks ();
  while (timer_elapsed (start_time) == 0)
c002c829:	83 ec 08             	sub    $0x8,%esp
c002c82c:	ff 75 f4             	pushl  -0xc(%ebp)
c002c82f:	ff 75 f0             	pushl  -0x10(%ebp)
c002c832:	e8 fb 79 ff ff       	call   c0024232 <timer_elapsed>
c002c837:	83 c4 10             	add    $0x10,%esp
c002c83a:	09 d0                	or     %edx,%eax
c002c83c:	85 c0                	test   %eax,%eax
c002c83e:	74 e8                	je     c002c828 <alarm_priority_thread+0x15>
    continue;

  /* Now we know we're at the very beginning of a timer tick, so
     we can call timer_sleep() without worrying about races
     between checking the time and a timer interrupt. */
  timer_sleep (wake_time - timer_ticks ());
c002c840:	8b 1d 18 9e 03 c0    	mov    0xc0039e18,%ebx
c002c846:	8b 35 1c 9e 03 c0    	mov    0xc0039e1c,%esi
c002c84c:	e8 ac 79 ff ff       	call   c00241fd <timer_ticks>
c002c851:	29 c3                	sub    %eax,%ebx
c002c853:	19 d6                	sbb    %edx,%esi
c002c855:	89 d8                	mov    %ebx,%eax
c002c857:	89 f2                	mov    %esi,%edx
c002c859:	83 ec 08             	sub    $0x8,%esp
c002c85c:	52                   	push   %edx
c002c85d:	50                   	push   %eax
c002c85e:	e8 ee 79 ff ff       	call   c0024251 <timer_sleep>
c002c863:	83 c4 10             	add    $0x10,%esp

  /* Print a message on wake-up. */
  msg ("Thread %s woke up.", thread_name ());
c002c866:	e8 71 44 ff ff       	call   c0020cdc <thread_name>
c002c86b:	83 ec 08             	sub    $0x8,%esp
c002c86e:	50                   	push   %eax
c002c86f:	68 7d 1f 03 c0       	push   $0xc0031f7d
c002c874:	e8 33 f7 ff ff       	call   c002bfac <msg>
c002c879:	83 c4 10             	add    $0x10,%esp

  sema_up (&wait_sema);
c002c87c:	83 ec 0c             	sub    $0xc,%esp
c002c87f:	68 20 9e 03 c0       	push   $0xc0039e20
c002c884:	e8 5a 62 ff ff       	call   c0022ae3 <sema_up>
c002c889:	83 c4 10             	add    $0x10,%esp
}
c002c88c:	90                   	nop
c002c88d:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002c890:	5b                   	pop    %ebx
c002c891:	5e                   	pop    %esi
c002c892:	5d                   	pop    %ebp
c002c893:	c3                   	ret    

c002c894 <test_alarm_zero>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_zero (void) 
{
c002c894:	55                   	push   %ebp
c002c895:	89 e5                	mov    %esp,%ebp
c002c897:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (0);
c002c89a:	83 ec 08             	sub    $0x8,%esp
c002c89d:	6a 00                	push   $0x0
c002c89f:	6a 00                	push   $0x0
c002c8a1:	e8 ab 79 ff ff       	call   c0024251 <timer_sleep>
c002c8a6:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c8a9:	e8 99 f7 ff ff       	call   c002c047 <pass>
}
c002c8ae:	90                   	nop
c002c8af:	c9                   	leave  
c002c8b0:	c3                   	ret    

c002c8b1 <test_alarm_negative>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_alarm_negative (void) 
{
c002c8b1:	55                   	push   %ebp
c002c8b2:	89 e5                	mov    %esp,%ebp
c002c8b4:	83 ec 08             	sub    $0x8,%esp
  timer_sleep (-100);
c002c8b7:	83 ec 08             	sub    $0x8,%esp
c002c8ba:	6a ff                	push   $0xffffffff
c002c8bc:	6a 9c                	push   $0xffffff9c
c002c8be:	e8 8e 79 ff ff       	call   c0024251 <timer_sleep>
c002c8c3:	83 c4 10             	add    $0x10,%esp
  pass ();
c002c8c6:	e8 7c f7 ff ff       	call   c002c047 <pass>
}
c002c8cb:	90                   	nop
c002c8cc:	c9                   	leave  
c002c8cd:	c3                   	ret    

c002c8ce <test_priority_change>:

static thread_func changing_thread;

void
test_priority_change (void) 
{
c002c8ce:	55                   	push   %ebp
c002c8cf:	89 e5                	mov    %esp,%ebp
c002c8d1:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c8d4:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002c8db:	83 f0 01             	xor    $0x1,%eax
c002c8de:	84 c0                	test   %al,%al
c002c8e0:	75 1e                	jne    c002c900 <test_priority_change+0x32>
c002c8e2:	83 ec 0c             	sub    $0xc,%esp
c002c8e5:	68 a4 1f 03 c0       	push   $0xc0031fa4
c002c8ea:	68 b2 1f 03 c0       	push   $0xc0031fb2
c002c8ef:	68 a8 20 03 c0       	push   $0xc00320a8
c002c8f4:	6a 10                	push   $0x10
c002c8f6:	68 cc 1f 03 c0       	push   $0xc0031fcc
c002c8fb:	e8 1b d3 ff ff       	call   c0029c1b <debug_panic>

  msg ("Creating a high-priority thread 2.");
c002c900:	83 ec 0c             	sub    $0xc,%esp
c002c903:	68 f4 1f 03 c0       	push   $0xc0031ff4
c002c908:	e8 9f f6 ff ff       	call   c002bfac <msg>
c002c90d:	83 c4 10             	add    $0x10,%esp
  thread_create ("thread 2", PRI_DEFAULT + 1, changing_thread, NULL);
c002c910:	6a 00                	push   $0x0
c002c912:	68 56 c9 02 c0       	push   $0xc002c956
c002c917:	6a 20                	push   $0x20
c002c919:	68 17 20 03 c0       	push   $0xc0032017
c002c91e:	e8 84 41 ff ff       	call   c0020aa7 <thread_create>
c002c923:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just lowered its priority.");
c002c926:	83 ec 0c             	sub    $0xc,%esp
c002c929:	68 20 20 03 c0       	push   $0xc0032020
c002c92e:	e8 79 f6 ff ff       	call   c002bfac <msg>
c002c933:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 2);
c002c936:	83 ec 0c             	sub    $0xc,%esp
c002c939:	6a 1d                	push   $0x1d
c002c93b:	e8 b1 45 ff ff       	call   c0020ef1 <thread_set_priority>
c002c940:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 should have just exited.");
c002c943:	83 ec 0c             	sub    $0xc,%esp
c002c946:	68 50 20 03 c0       	push   $0xc0032050
c002c94b:	e8 5c f6 ff ff       	call   c002bfac <msg>
c002c950:	83 c4 10             	add    $0x10,%esp
}
c002c953:	90                   	nop
c002c954:	c9                   	leave  
c002c955:	c3                   	ret    

c002c956 <changing_thread>:

static void
changing_thread (void *aux UNUSED) 
{
c002c956:	55                   	push   %ebp
c002c957:	89 e5                	mov    %esp,%ebp
c002c959:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread 2 now lowering priority.");
c002c95c:	83 ec 0c             	sub    $0xc,%esp
c002c95f:	68 74 20 03 c0       	push   $0xc0032074
c002c964:	e8 43 f6 ff ff       	call   c002bfac <msg>
c002c969:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 1);
c002c96c:	83 ec 0c             	sub    $0xc,%esp
c002c96f:	6a 1e                	push   $0x1e
c002c971:	e8 7b 45 ff ff       	call   c0020ef1 <thread_set_priority>
c002c976:	83 c4 10             	add    $0x10,%esp
  msg ("Thread 2 exiting.");
c002c979:	83 ec 0c             	sub    $0xc,%esp
c002c97c:	68 94 20 03 c0       	push   $0xc0032094
c002c981:	e8 26 f6 ff ff       	call   c002bfac <msg>
c002c986:	83 c4 10             	add    $0x10,%esp
}
c002c989:	90                   	nop
c002c98a:	c9                   	leave  
c002c98b:	c3                   	ret    

c002c98c <test_priority_donate_one>:
static thread_func acquire1_thread_func;
static thread_func acquire2_thread_func;

void
test_priority_donate_one (void) 
{
c002c98c:	55                   	push   %ebp
c002c98d:	89 e5                	mov    %esp,%ebp
c002c98f:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002c992:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002c999:	83 f0 01             	xor    $0x1,%eax
c002c99c:	84 c0                	test   %al,%al
c002c99e:	75 1e                	jne    c002c9be <test_priority_donate_one+0x32>
c002c9a0:	83 ec 0c             	sub    $0xc,%esp
c002c9a3:	68 c0 20 03 c0       	push   $0xc00320c0
c002c9a8:	68 ce 20 03 c0       	push   $0xc00320ce
c002c9ad:	68 50 22 03 c0       	push   $0xc0032250
c002c9b2:	6a 1b                	push   $0x1b
c002c9b4:	68 e8 20 03 c0       	push   $0xc00320e8
c002c9b9:	e8 5d d2 ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002c9be:	e8 d7 45 ff ff       	call   c0020f9a <thread_get_priority>
c002c9c3:	83 f8 1f             	cmp    $0x1f,%eax
c002c9c6:	74 1e                	je     c002c9e6 <test_priority_donate_one+0x5a>
c002c9c8:	83 ec 0c             	sub    $0xc,%esp
c002c9cb:	68 14 21 03 c0       	push   $0xc0032114
c002c9d0:	68 ce 20 03 c0       	push   $0xc00320ce
c002c9d5:	68 50 22 03 c0       	push   $0xc0032250
c002c9da:	6a 1e                	push   $0x1e
c002c9dc:	68 e8 20 03 c0       	push   $0xc00320e8
c002c9e1:	e8 35 d2 ff ff       	call   c0029c1b <debug_panic>

  lock_init (&lock);
c002c9e6:	83 ec 0c             	sub    $0xc,%esp
c002c9e9:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002c9ec:	50                   	push   %eax
c002c9ed:	e8 a4 62 ff ff       	call   c0022c96 <lock_init>
c002c9f2:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002c9f5:	83 ec 0c             	sub    $0xc,%esp
c002c9f8:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002c9fb:	50                   	push   %eax
c002c9fc:	e8 e2 62 ff ff       	call   c0022ce3 <lock_acquire>
c002ca01:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire1", PRI_DEFAULT + 1, acquire1_thread_func, &lock);
c002ca04:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002ca07:	50                   	push   %eax
c002ca08:	68 96 ca 02 c0       	push   $0xc002ca96
c002ca0d:	6a 20                	push   $0x20
c002ca0f:	68 3a 21 03 c0       	push   $0xc003213a
c002ca14:	e8 8e 40 ff ff       	call   c0020aa7 <thread_create>
c002ca19:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ca1c:	e8 79 45 ff ff       	call   c0020f9a <thread_get_priority>
c002ca21:	83 ec 04             	sub    $0x4,%esp
c002ca24:	50                   	push   %eax
c002ca25:	6a 20                	push   $0x20
c002ca27:	68 44 21 03 c0       	push   $0xc0032144
c002ca2c:	e8 7b f5 ff ff       	call   c002bfac <msg>
c002ca31:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());
  thread_create ("acquire2", PRI_DEFAULT + 2, acquire2_thread_func, &lock);
c002ca34:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002ca37:	50                   	push   %eax
c002ca38:	68 e1 ca 02 c0       	push   $0xc002cae1
c002ca3d:	6a 21                	push   $0x21
c002ca3f:	68 7f 21 03 c0       	push   $0xc003217f
c002ca44:	e8 5e 40 ff ff       	call   c0020aa7 <thread_create>
c002ca49:	83 c4 10             	add    $0x10,%esp
  msg ("This thread should have priority %d.  Actual priority: %d.",
c002ca4c:	e8 49 45 ff ff       	call   c0020f9a <thread_get_priority>
c002ca51:	83 ec 04             	sub    $0x4,%esp
c002ca54:	50                   	push   %eax
c002ca55:	6a 21                	push   $0x21
c002ca57:	68 44 21 03 c0       	push   $0xc0032144
c002ca5c:	e8 4b f5 ff ff       	call   c002bfac <msg>
c002ca61:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  lock_release (&lock);
c002ca64:	83 ec 0c             	sub    $0xc,%esp
c002ca67:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002ca6a:	50                   	push   %eax
c002ca6b:	e8 56 64 ff ff       	call   c0022ec6 <lock_release>
c002ca70:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2, acquire1 must already have finished, in that order.");
c002ca73:	83 ec 0c             	sub    $0xc,%esp
c002ca76:	68 88 21 03 c0       	push   $0xc0032188
c002ca7b:	e8 2c f5 ff ff       	call   c002bfac <msg>
c002ca80:	83 c4 10             	add    $0x10,%esp
  msg ("This should be the last line before finishing this test.");
c002ca83:	83 ec 0c             	sub    $0xc,%esp
c002ca86:	68 c8 21 03 c0       	push   $0xc00321c8
c002ca8b:	e8 1c f5 ff ff       	call   c002bfac <msg>
c002ca90:	83 c4 10             	add    $0x10,%esp
}
c002ca93:	90                   	nop
c002ca94:	c9                   	leave  
c002ca95:	c3                   	ret    

c002ca96 <acquire1_thread_func>:

static void
acquire1_thread_func (void *lock_) 
{
c002ca96:	55                   	push   %ebp
c002ca97:	89 e5                	mov    %esp,%ebp
c002ca99:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ca9c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ca9f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002caa2:	83 ec 0c             	sub    $0xc,%esp
c002caa5:	ff 75 f4             	pushl  -0xc(%ebp)
c002caa8:	e8 36 62 ff ff       	call   c0022ce3 <lock_acquire>
c002caad:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: got the lock");
c002cab0:	83 ec 0c             	sub    $0xc,%esp
c002cab3:	68 01 22 03 c0       	push   $0xc0032201
c002cab8:	e8 ef f4 ff ff       	call   c002bfac <msg>
c002cabd:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cac0:	83 ec 0c             	sub    $0xc,%esp
c002cac3:	ff 75 f4             	pushl  -0xc(%ebp)
c002cac6:	e8 fb 63 ff ff       	call   c0022ec6 <lock_release>
c002cacb:	83 c4 10             	add    $0x10,%esp
  msg ("acquire1: done");
c002cace:	83 ec 0c             	sub    $0xc,%esp
c002cad1:	68 18 22 03 c0       	push   $0xc0032218
c002cad6:	e8 d1 f4 ff ff       	call   c002bfac <msg>
c002cadb:	83 c4 10             	add    $0x10,%esp
}
c002cade:	90                   	nop
c002cadf:	c9                   	leave  
c002cae0:	c3                   	ret    

c002cae1 <acquire2_thread_func>:

static void
acquire2_thread_func (void *lock_) 
{
c002cae1:	55                   	push   %ebp
c002cae2:	89 e5                	mov    %esp,%ebp
c002cae4:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cae7:	8b 45 08             	mov    0x8(%ebp),%eax
c002caea:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002caed:	83 ec 0c             	sub    $0xc,%esp
c002caf0:	ff 75 f4             	pushl  -0xc(%ebp)
c002caf3:	e8 eb 61 ff ff       	call   c0022ce3 <lock_acquire>
c002caf8:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: got the lock");
c002cafb:	83 ec 0c             	sub    $0xc,%esp
c002cafe:	68 27 22 03 c0       	push   $0xc0032227
c002cb03:	e8 a4 f4 ff ff       	call   c002bfac <msg>
c002cb08:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cb0b:	83 ec 0c             	sub    $0xc,%esp
c002cb0e:	ff 75 f4             	pushl  -0xc(%ebp)
c002cb11:	e8 b0 63 ff ff       	call   c0022ec6 <lock_release>
c002cb16:	83 c4 10             	add    $0x10,%esp
  msg ("acquire2: done");
c002cb19:	83 ec 0c             	sub    $0xc,%esp
c002cb1c:	68 3e 22 03 c0       	push   $0xc003223e
c002cb21:	e8 86 f4 ff ff       	call   c002bfac <msg>
c002cb26:	83 c4 10             	add    $0x10,%esp
}
c002cb29:	90                   	nop
c002cb2a:	c9                   	leave  
c002cb2b:	c3                   	ret    

c002cb2c <test_priority_donate_multiple>:
static thread_func a_thread_func;
static thread_func b_thread_func;

void
test_priority_donate_multiple (void) 
{
c002cb2c:	55                   	push   %ebp
c002cb2d:	89 e5                	mov    %esp,%ebp
c002cb2f:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cb32:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002cb39:	83 f0 01             	xor    $0x1,%eax
c002cb3c:	84 c0                	test   %al,%al
c002cb3e:	75 1e                	jne    c002cb5e <test_priority_donate_multiple+0x32>
c002cb40:	83 ec 0c             	sub    $0xc,%esp
c002cb43:	68 6c 22 03 c0       	push   $0xc003226c
c002cb48:	68 7a 22 03 c0       	push   $0xc003227a
c002cb4d:	68 d0 23 03 c0       	push   $0xc00323d0
c002cb52:	6a 1b                	push   $0x1b
c002cb54:	68 94 22 03 c0       	push   $0xc0032294
c002cb59:	e8 bd d0 ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cb5e:	e8 37 44 ff ff       	call   c0020f9a <thread_get_priority>
c002cb63:	83 f8 1f             	cmp    $0x1f,%eax
c002cb66:	74 1e                	je     c002cb86 <test_priority_donate_multiple+0x5a>
c002cb68:	83 ec 0c             	sub    $0xc,%esp
c002cb6b:	68 c4 22 03 c0       	push   $0xc00322c4
c002cb70:	68 7a 22 03 c0       	push   $0xc003227a
c002cb75:	68 d0 23 03 c0       	push   $0xc00323d0
c002cb7a:	6a 1e                	push   $0x1e
c002cb7c:	68 94 22 03 c0       	push   $0xc0032294
c002cb81:	e8 95 d0 ff ff       	call   c0029c1b <debug_panic>

  lock_init (&a);
c002cb86:	83 ec 0c             	sub    $0xc,%esp
c002cb89:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cb8c:	50                   	push   %eax
c002cb8d:	e8 04 61 ff ff       	call   c0022c96 <lock_init>
c002cb92:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002cb95:	83 ec 0c             	sub    $0xc,%esp
c002cb98:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cb9b:	50                   	push   %eax
c002cb9c:	e8 f5 60 ff ff       	call   c0022c96 <lock_init>
c002cba1:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002cba4:	83 ec 0c             	sub    $0xc,%esp
c002cba7:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cbaa:	50                   	push   %eax
c002cbab:	e8 33 61 ff ff       	call   c0022ce3 <lock_acquire>
c002cbb0:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002cbb3:	83 ec 0c             	sub    $0xc,%esp
c002cbb6:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cbb9:	50                   	push   %eax
c002cbba:	e8 24 61 ff ff       	call   c0022ce3 <lock_acquire>
c002cbbf:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 1, a_thread_func, &a);
c002cbc2:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cbc5:	50                   	push   %eax
c002cbc6:	68 93 cc 02 c0       	push   $0xc002cc93
c002cbcb:	6a 20                	push   $0x20
c002cbcd:	68 ea 22 03 c0       	push   $0xc00322ea
c002cbd2:	e8 d0 3e ff ff       	call   c0020aa7 <thread_create>
c002cbd7:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cbda:	e8 bb 43 ff ff       	call   c0020f9a <thread_get_priority>
c002cbdf:	83 ec 04             	sub    $0x4,%esp
c002cbe2:	50                   	push   %eax
c002cbe3:	6a 20                	push   $0x20
c002cbe5:	68 ec 22 03 c0       	push   $0xc00322ec
c002cbea:	e8 bd f3 ff ff       	call   c002bfac <msg>
c002cbef:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("b", PRI_DEFAULT + 2, b_thread_func, &b);
c002cbf2:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cbf5:	50                   	push   %eax
c002cbf6:	68 de cc 02 c0       	push   $0xc002ccde
c002cbfb:	6a 21                	push   $0x21
c002cbfd:	68 27 23 03 c0       	push   $0xc0032327
c002cc02:	e8 a0 3e ff ff       	call   c0020aa7 <thread_create>
c002cc07:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cc0a:	e8 8b 43 ff ff       	call   c0020f9a <thread_get_priority>
c002cc0f:	83 ec 04             	sub    $0x4,%esp
c002cc12:	50                   	push   %eax
c002cc13:	6a 21                	push   $0x21
c002cc15:	68 ec 22 03 c0       	push   $0xc00322ec
c002cc1a:	e8 8d f3 ff ff       	call   c002bfac <msg>
c002cc1f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&b);
c002cc22:	83 ec 0c             	sub    $0xc,%esp
c002cc25:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cc28:	50                   	push   %eax
c002cc29:	e8 98 62 ff ff       	call   c0022ec6 <lock_release>
c002cc2e:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b should have just finished.");
c002cc31:	83 ec 0c             	sub    $0xc,%esp
c002cc34:	68 2c 23 03 c0       	push   $0xc003232c
c002cc39:	e8 6e f3 ff ff       	call   c002bfac <msg>
c002cc3e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cc41:	e8 54 43 ff ff       	call   c0020f9a <thread_get_priority>
c002cc46:	83 ec 04             	sub    $0x4,%esp
c002cc49:	50                   	push   %eax
c002cc4a:	6a 20                	push   $0x20
c002cc4c:	68 ec 22 03 c0       	push   $0xc00322ec
c002cc51:	e8 56 f3 ff ff       	call   c002bfac <msg>
c002cc56:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  lock_release (&a);
c002cc59:	83 ec 0c             	sub    $0xc,%esp
c002cc5c:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cc5f:	50                   	push   %eax
c002cc60:	e8 61 62 ff ff       	call   c0022ec6 <lock_release>
c002cc65:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a should have just finished.");
c002cc68:	83 ec 0c             	sub    $0xc,%esp
c002cc6b:	68 50 23 03 c0       	push   $0xc0032350
c002cc70:	e8 37 f3 ff ff       	call   c002bfac <msg>
c002cc75:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cc78:	e8 1d 43 ff ff       	call   c0020f9a <thread_get_priority>
c002cc7d:	83 ec 04             	sub    $0x4,%esp
c002cc80:	50                   	push   %eax
c002cc81:	6a 1f                	push   $0x1f
c002cc83:	68 ec 22 03 c0       	push   $0xc00322ec
c002cc88:	e8 1f f3 ff ff       	call   c002bfac <msg>
c002cc8d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002cc90:	90                   	nop
c002cc91:	c9                   	leave  
c002cc92:	c3                   	ret    

c002cc93 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002cc93:	55                   	push   %ebp
c002cc94:	89 e5                	mov    %esp,%ebp
c002cc96:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cc99:	8b 45 08             	mov    0x8(%ebp),%eax
c002cc9c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cc9f:	83 ec 0c             	sub    $0xc,%esp
c002cca2:	ff 75 f4             	pushl  -0xc(%ebp)
c002cca5:	e8 39 60 ff ff       	call   c0022ce3 <lock_acquire>
c002ccaa:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002ccad:	83 ec 0c             	sub    $0xc,%esp
c002ccb0:	68 74 23 03 c0       	push   $0xc0032374
c002ccb5:	e8 f2 f2 ff ff       	call   c002bfac <msg>
c002ccba:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002ccbd:	83 ec 0c             	sub    $0xc,%esp
c002ccc0:	ff 75 f4             	pushl  -0xc(%ebp)
c002ccc3:	e8 fe 61 ff ff       	call   c0022ec6 <lock_release>
c002ccc8:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002cccb:	83 ec 0c             	sub    $0xc,%esp
c002ccce:	68 8e 23 03 c0       	push   $0xc003238e
c002ccd3:	e8 d4 f2 ff ff       	call   c002bfac <msg>
c002ccd8:	83 c4 10             	add    $0x10,%esp
}
c002ccdb:	90                   	nop
c002ccdc:	c9                   	leave  
c002ccdd:	c3                   	ret    

c002ccde <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002ccde:	55                   	push   %ebp
c002ccdf:	89 e5                	mov    %esp,%ebp
c002cce1:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cce4:	8b 45 08             	mov    0x8(%ebp),%eax
c002cce7:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ccea:	83 ec 0c             	sub    $0xc,%esp
c002cced:	ff 75 f4             	pushl  -0xc(%ebp)
c002ccf0:	e8 ee 5f ff ff       	call   c0022ce3 <lock_acquire>
c002ccf5:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002ccf8:	83 ec 0c             	sub    $0xc,%esp
c002ccfb:	68 a1 23 03 c0       	push   $0xc00323a1
c002cd00:	e8 a7 f2 ff ff       	call   c002bfac <msg>
c002cd05:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cd08:	83 ec 0c             	sub    $0xc,%esp
c002cd0b:	ff 75 f4             	pushl  -0xc(%ebp)
c002cd0e:	e8 b3 61 ff ff       	call   c0022ec6 <lock_release>
c002cd13:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002cd16:	83 ec 0c             	sub    $0xc,%esp
c002cd19:	68 bb 23 03 c0       	push   $0xc00323bb
c002cd1e:	e8 89 f2 ff ff       	call   c002bfac <msg>
c002cd23:	83 c4 10             	add    $0x10,%esp
}
c002cd26:	90                   	nop
c002cd27:	c9                   	leave  
c002cd28:	c3                   	ret    

c002cd29 <test_priority_donate_multiple2>:
static thread_func b_thread_func;
static thread_func c_thread_func;

void
test_priority_donate_multiple2 (void) 
{
c002cd29:	55                   	push   %ebp
c002cd2a:	89 e5                	mov    %esp,%ebp
c002cd2c:	83 ec 48             	sub    $0x48,%esp
  struct lock a, b;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cd2f:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002cd36:	83 f0 01             	xor    $0x1,%eax
c002cd39:	84 c0                	test   %al,%al
c002cd3b:	75 1e                	jne    c002cd5b <test_priority_donate_multiple2+0x32>
c002cd3d:	83 ec 0c             	sub    $0xc,%esp
c002cd40:	68 f0 23 03 c0       	push   $0xc00323f0
c002cd45:	68 fe 23 03 c0       	push   $0xc00323fe
c002cd4a:	68 58 25 03 c0       	push   $0xc0032558
c002cd4f:	6a 21                	push   $0x21
c002cd51:	68 18 24 03 c0       	push   $0xc0032418
c002cd56:	e8 c0 ce ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cd5b:	e8 3a 42 ff ff       	call   c0020f9a <thread_get_priority>
c002cd60:	83 f8 1f             	cmp    $0x1f,%eax
c002cd63:	74 1e                	je     c002cd83 <test_priority_donate_multiple2+0x5a>
c002cd65:	83 ec 0c             	sub    $0xc,%esp
c002cd68:	68 48 24 03 c0       	push   $0xc0032448
c002cd6d:	68 fe 23 03 c0       	push   $0xc00323fe
c002cd72:	68 58 25 03 c0       	push   $0xc0032558
c002cd77:	6a 24                	push   $0x24
c002cd79:	68 18 24 03 c0       	push   $0xc0032418
c002cd7e:	e8 98 ce ff ff       	call   c0029c1b <debug_panic>

  lock_init (&a);
c002cd83:	83 ec 0c             	sub    $0xc,%esp
c002cd86:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cd89:	50                   	push   %eax
c002cd8a:	e8 07 5f ff ff       	call   c0022c96 <lock_init>
c002cd8f:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002cd92:	83 ec 0c             	sub    $0xc,%esp
c002cd95:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cd98:	50                   	push   %eax
c002cd99:	e8 f8 5e ff ff       	call   c0022c96 <lock_init>
c002cd9e:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002cda1:	83 ec 0c             	sub    $0xc,%esp
c002cda4:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cda7:	50                   	push   %eax
c002cda8:	e8 36 5f ff ff       	call   c0022ce3 <lock_acquire>
c002cdad:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&b);
c002cdb0:	83 ec 0c             	sub    $0xc,%esp
c002cdb3:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cdb6:	50                   	push   %eax
c002cdb7:	e8 27 5f ff ff       	call   c0022ce3 <lock_acquire>
c002cdbc:	83 c4 10             	add    $0x10,%esp

  thread_create ("a", PRI_DEFAULT + 3, a_thread_func, &a);
c002cdbf:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cdc2:	50                   	push   %eax
c002cdc3:	68 96 ce 02 c0       	push   $0xc002ce96
c002cdc8:	6a 22                	push   $0x22
c002cdca:	68 6e 24 03 c0       	push   $0xc003246e
c002cdcf:	e8 d3 3c ff ff       	call   c0020aa7 <thread_create>
c002cdd4:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002cdd7:	e8 be 41 ff ff       	call   c0020f9a <thread_get_priority>
c002cddc:	83 ec 04             	sub    $0x4,%esp
c002cddf:	50                   	push   %eax
c002cde0:	6a 22                	push   $0x22
c002cde2:	68 70 24 03 c0       	push   $0xc0032470
c002cde7:	e8 c0 f1 ff ff       	call   c002bfac <msg>
c002cdec:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 3, thread_get_priority ());

  thread_create ("c", PRI_DEFAULT + 1, c_thread_func, NULL);
c002cdef:	6a 00                	push   $0x0
c002cdf1:	68 2c cf 02 c0       	push   $0xc002cf2c
c002cdf6:	6a 20                	push   $0x20
c002cdf8:	68 ab 24 03 c0       	push   $0xc00324ab
c002cdfd:	e8 a5 3c ff ff       	call   c0020aa7 <thread_create>
c002ce02:	83 c4 10             	add    $0x10,%esp

  thread_create ("b", PRI_DEFAULT + 5, b_thread_func, &b);
c002ce05:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002ce08:	50                   	push   %eax
c002ce09:	68 e1 ce 02 c0       	push   $0xc002cee1
c002ce0e:	6a 24                	push   $0x24
c002ce10:	68 ad 24 03 c0       	push   $0xc00324ad
c002ce15:	e8 8d 3c ff ff       	call   c0020aa7 <thread_create>
c002ce1a:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce1d:	e8 78 41 ff ff       	call   c0020f9a <thread_get_priority>
c002ce22:	83 ec 04             	sub    $0x4,%esp
c002ce25:	50                   	push   %eax
c002ce26:	6a 24                	push   $0x24
c002ce28:	68 70 24 03 c0       	push   $0xc0032470
c002ce2d:	e8 7a f1 ff ff       	call   c002bfac <msg>
c002ce32:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&a);
c002ce35:	83 ec 0c             	sub    $0xc,%esp
c002ce38:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002ce3b:	50                   	push   %eax
c002ce3c:	e8 85 60 ff ff       	call   c0022ec6 <lock_release>
c002ce41:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce44:	e8 51 41 ff ff       	call   c0020f9a <thread_get_priority>
c002ce49:	83 ec 04             	sub    $0x4,%esp
c002ce4c:	50                   	push   %eax
c002ce4d:	6a 24                	push   $0x24
c002ce4f:	68 70 24 03 c0       	push   $0xc0032470
c002ce54:	e8 53 f1 ff ff       	call   c002bfac <msg>
c002ce59:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 5, thread_get_priority ());

  lock_release (&b);
c002ce5c:	83 ec 0c             	sub    $0xc,%esp
c002ce5f:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002ce62:	50                   	push   %eax
c002ce63:	e8 5e 60 ff ff       	call   c0022ec6 <lock_release>
c002ce68:	83 c4 10             	add    $0x10,%esp
  msg ("Threads b, a, c should have just finished, in that order.");
c002ce6b:	83 ec 0c             	sub    $0xc,%esp
c002ce6e:	68 b0 24 03 c0       	push   $0xc00324b0
c002ce73:	e8 34 f1 ff ff       	call   c002bfac <msg>
c002ce78:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002ce7b:	e8 1a 41 ff ff       	call   c0020f9a <thread_get_priority>
c002ce80:	83 ec 04             	sub    $0x4,%esp
c002ce83:	50                   	push   %eax
c002ce84:	6a 1f                	push   $0x1f
c002ce86:	68 70 24 03 c0       	push   $0xc0032470
c002ce8b:	e8 1c f1 ff ff       	call   c002bfac <msg>
c002ce90:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002ce93:	90                   	nop
c002ce94:	c9                   	leave  
c002ce95:	c3                   	ret    

c002ce96 <a_thread_func>:

static void
a_thread_func (void *lock_) 
{
c002ce96:	55                   	push   %ebp
c002ce97:	89 e5                	mov    %esp,%ebp
c002ce99:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ce9c:	8b 45 08             	mov    0x8(%ebp),%eax
c002ce9f:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002cea2:	83 ec 0c             	sub    $0xc,%esp
c002cea5:	ff 75 f4             	pushl  -0xc(%ebp)
c002cea8:	e8 36 5e ff ff       	call   c0022ce3 <lock_acquire>
c002cead:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a acquired lock a.");
c002ceb0:	83 ec 0c             	sub    $0xc,%esp
c002ceb3:	68 ea 24 03 c0       	push   $0xc00324ea
c002ceb8:	e8 ef f0 ff ff       	call   c002bfac <msg>
c002cebd:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cec0:	83 ec 0c             	sub    $0xc,%esp
c002cec3:	ff 75 f4             	pushl  -0xc(%ebp)
c002cec6:	e8 fb 5f ff ff       	call   c0022ec6 <lock_release>
c002cecb:	83 c4 10             	add    $0x10,%esp
  msg ("Thread a finished.");
c002cece:	83 ec 0c             	sub    $0xc,%esp
c002ced1:	68 04 25 03 c0       	push   $0xc0032504
c002ced6:	e8 d1 f0 ff ff       	call   c002bfac <msg>
c002cedb:	83 c4 10             	add    $0x10,%esp
}
c002cede:	90                   	nop
c002cedf:	c9                   	leave  
c002cee0:	c3                   	ret    

c002cee1 <b_thread_func>:

static void
b_thread_func (void *lock_) 
{
c002cee1:	55                   	push   %ebp
c002cee2:	89 e5                	mov    %esp,%ebp
c002cee4:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002cee7:	8b 45 08             	mov    0x8(%ebp),%eax
c002ceea:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002ceed:	83 ec 0c             	sub    $0xc,%esp
c002cef0:	ff 75 f4             	pushl  -0xc(%ebp)
c002cef3:	e8 eb 5d ff ff       	call   c0022ce3 <lock_acquire>
c002cef8:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b acquired lock b.");
c002cefb:	83 ec 0c             	sub    $0xc,%esp
c002cefe:	68 17 25 03 c0       	push   $0xc0032517
c002cf03:	e8 a4 f0 ff ff       	call   c002bfac <msg>
c002cf08:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002cf0b:	83 ec 0c             	sub    $0xc,%esp
c002cf0e:	ff 75 f4             	pushl  -0xc(%ebp)
c002cf11:	e8 b0 5f ff ff       	call   c0022ec6 <lock_release>
c002cf16:	83 c4 10             	add    $0x10,%esp
  msg ("Thread b finished.");
c002cf19:	83 ec 0c             	sub    $0xc,%esp
c002cf1c:	68 31 25 03 c0       	push   $0xc0032531
c002cf21:	e8 86 f0 ff ff       	call   c002bfac <msg>
c002cf26:	83 c4 10             	add    $0x10,%esp
}
c002cf29:	90                   	nop
c002cf2a:	c9                   	leave  
c002cf2b:	c3                   	ret    

c002cf2c <c_thread_func>:

static void
c_thread_func (void *a_ UNUSED) 
{
c002cf2c:	55                   	push   %ebp
c002cf2d:	89 e5                	mov    %esp,%ebp
c002cf2f:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread c finished.");
c002cf32:	83 ec 0c             	sub    $0xc,%esp
c002cf35:	68 44 25 03 c0       	push   $0xc0032544
c002cf3a:	e8 6d f0 ff ff       	call   c002bfac <msg>
c002cf3f:	83 c4 10             	add    $0x10,%esp
}
c002cf42:	90                   	nop
c002cf43:	c9                   	leave  
c002cf44:	c3                   	ret    

c002cf45 <test_priority_donate_nest>:
static thread_func medium_thread_func;
static thread_func high_thread_func;

void
test_priority_donate_nest (void) 
{
c002cf45:	55                   	push   %ebp
c002cf46:	89 e5                	mov    %esp,%ebp
c002cf48:	83 ec 58             	sub    $0x58,%esp
  struct lock a, b;
  struct locks locks;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002cf4b:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002cf52:	83 f0 01             	xor    $0x1,%eax
c002cf55:	84 c0                	test   %al,%al
c002cf57:	75 1e                	jne    c002cf77 <test_priority_donate_nest+0x32>
c002cf59:	83 ec 0c             	sub    $0xc,%esp
c002cf5c:	68 78 25 03 c0       	push   $0xc0032578
c002cf61:	68 86 25 03 c0       	push   $0xc0032586
c002cf66:	68 34 27 03 c0       	push   $0xc0032734
c002cf6b:	6a 22                	push   $0x22
c002cf6d:	68 a0 25 03 c0       	push   $0xc00325a0
c002cf72:	e8 a4 cc ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002cf77:	e8 1e 40 ff ff       	call   c0020f9a <thread_get_priority>
c002cf7c:	83 f8 1f             	cmp    $0x1f,%eax
c002cf7f:	74 1e                	je     c002cf9f <test_priority_donate_nest+0x5a>
c002cf81:	83 ec 0c             	sub    $0xc,%esp
c002cf84:	68 cc 25 03 c0       	push   $0xc00325cc
c002cf89:	68 86 25 03 c0       	push   $0xc0032586
c002cf8e:	68 34 27 03 c0       	push   $0xc0032734
c002cf93:	6a 25                	push   $0x25
c002cf95:	68 a0 25 03 c0       	push   $0xc00325a0
c002cf9a:	e8 7c cc ff ff       	call   c0029c1b <debug_panic>

  lock_init (&a);
c002cf9f:	83 ec 0c             	sub    $0xc,%esp
c002cfa2:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cfa5:	50                   	push   %eax
c002cfa6:	e8 eb 5c ff ff       	call   c0022c96 <lock_init>
c002cfab:	83 c4 10             	add    $0x10,%esp
  lock_init (&b);
c002cfae:	83 ec 0c             	sub    $0xc,%esp
c002cfb1:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cfb4:	50                   	push   %eax
c002cfb5:	e8 dc 5c ff ff       	call   c0022c96 <lock_init>
c002cfba:	83 c4 10             	add    $0x10,%esp

  lock_acquire (&a);
c002cfbd:	83 ec 0c             	sub    $0xc,%esp
c002cfc0:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cfc3:	50                   	push   %eax
c002cfc4:	e8 1a 5d ff ff       	call   c0022ce3 <lock_acquire>
c002cfc9:	83 c4 10             	add    $0x10,%esp

  locks.a = &a;
c002cfcc:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002cfcf:	89 45 b0             	mov    %eax,-0x50(%ebp)
  locks.b = &b;
c002cfd2:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002cfd5:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  thread_create ("medium", PRI_DEFAULT + 1, medium_thread_func, &locks);
c002cfd8:	8d 45 b0             	lea    -0x50(%ebp),%eax
c002cfdb:	50                   	push   %eax
c002cfdc:	68 81 d0 02 c0       	push   $0xc002d081
c002cfe1:	6a 20                	push   $0x20
c002cfe3:	68 f2 25 03 c0       	push   $0xc00325f2
c002cfe8:	e8 ba 3a ff ff       	call   c0020aa7 <thread_create>
c002cfed:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002cff0:	e8 ed 3d ff ff       	call   c0020de2 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002cff5:	e8 a0 3f ff ff       	call   c0020f9a <thread_get_priority>
c002cffa:	83 ec 04             	sub    $0x4,%esp
c002cffd:	50                   	push   %eax
c002cffe:	6a 20                	push   $0x20
c002d000:	68 fc 25 03 c0       	push   $0xc00325fc
c002d005:	e8 a2 ef ff ff       	call   c002bfac <msg>
c002d00a:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 1, thread_get_priority ());

  thread_create ("high", PRI_DEFAULT + 2, high_thread_func, &b);
c002d00d:	8d 45 b8             	lea    -0x48(%ebp),%eax
c002d010:	50                   	push   %eax
c002d011:	68 28 d1 02 c0       	push   $0xc002d128
c002d016:	6a 21                	push   $0x21
c002d018:	68 36 26 03 c0       	push   $0xc0032636
c002d01d:	e8 85 3a ff ff       	call   c0020aa7 <thread_create>
c002d022:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d025:	e8 b8 3d ff ff       	call   c0020de2 <thread_yield>
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002d02a:	e8 6b 3f ff ff       	call   c0020f9a <thread_get_priority>
c002d02f:	83 ec 04             	sub    $0x4,%esp
c002d032:	50                   	push   %eax
c002d033:	6a 21                	push   $0x21
c002d035:	68 fc 25 03 c0       	push   $0xc00325fc
c002d03a:	e8 6d ef ff ff       	call   c002bfac <msg>
c002d03f:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());

  lock_release (&a);
c002d042:	83 ec 0c             	sub    $0xc,%esp
c002d045:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002d048:	50                   	push   %eax
c002d049:	e8 78 5e ff ff       	call   c0022ec6 <lock_release>
c002d04e:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d051:	e8 8c 3d ff ff       	call   c0020de2 <thread_yield>
  msg ("Medium thread should just have finished.");
c002d056:	83 ec 0c             	sub    $0xc,%esp
c002d059:	68 3c 26 03 c0       	push   $0xc003263c
c002d05e:	e8 49 ef ff ff       	call   c002bfac <msg>
c002d063:	83 c4 10             	add    $0x10,%esp
  msg ("Low thread should have priority %d.  Actual priority: %d.",
c002d066:	e8 2f 3f ff ff       	call   c0020f9a <thread_get_priority>
c002d06b:	83 ec 04             	sub    $0x4,%esp
c002d06e:	50                   	push   %eax
c002d06f:	6a 1f                	push   $0x1f
c002d071:	68 fc 25 03 c0       	push   $0xc00325fc
c002d076:	e8 31 ef ff ff       	call   c002bfac <msg>
c002d07b:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT, thread_get_priority ());
}
c002d07e:	90                   	nop
c002d07f:	c9                   	leave  
c002d080:	c3                   	ret    

c002d081 <medium_thread_func>:

static void
medium_thread_func (void *locks_) 
{
c002d081:	55                   	push   %ebp
c002d082:	89 e5                	mov    %esp,%ebp
c002d084:	83 ec 18             	sub    $0x18,%esp
  struct locks *locks = locks_;
c002d087:	8b 45 08             	mov    0x8(%ebp),%eax
c002d08a:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (locks->b);
c002d08d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d090:	8b 40 04             	mov    0x4(%eax),%eax
c002d093:	83 ec 0c             	sub    $0xc,%esp
c002d096:	50                   	push   %eax
c002d097:	e8 47 5c ff ff       	call   c0022ce3 <lock_acquire>
c002d09c:	83 c4 10             	add    $0x10,%esp
  lock_acquire (locks->a);
c002d09f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0a2:	8b 00                	mov    (%eax),%eax
c002d0a4:	83 ec 0c             	sub    $0xc,%esp
c002d0a7:	50                   	push   %eax
c002d0a8:	e8 36 5c ff ff       	call   c0022ce3 <lock_acquire>
c002d0ad:	83 c4 10             	add    $0x10,%esp

  msg ("Medium thread should have priority %d.  Actual priority: %d.",
c002d0b0:	e8 e5 3e ff ff       	call   c0020f9a <thread_get_priority>
c002d0b5:	83 ec 04             	sub    $0x4,%esp
c002d0b8:	50                   	push   %eax
c002d0b9:	6a 21                	push   $0x21
c002d0bb:	68 68 26 03 c0       	push   $0xc0032668
c002d0c0:	e8 e7 ee ff ff       	call   c002bfac <msg>
c002d0c5:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 2, thread_get_priority ());
  msg ("Medium thread got the lock.");
c002d0c8:	83 ec 0c             	sub    $0xc,%esp
c002d0cb:	68 a5 26 03 c0       	push   $0xc00326a5
c002d0d0:	e8 d7 ee ff ff       	call   c002bfac <msg>
c002d0d5:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->a);
c002d0d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0db:	8b 00                	mov    (%eax),%eax
c002d0dd:	83 ec 0c             	sub    $0xc,%esp
c002d0e0:	50                   	push   %eax
c002d0e1:	e8 e0 5d ff ff       	call   c0022ec6 <lock_release>
c002d0e6:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d0e9:	e8 f4 3c ff ff       	call   c0020de2 <thread_yield>

  lock_release (locks->b);
c002d0ee:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d0f1:	8b 40 04             	mov    0x4(%eax),%eax
c002d0f4:	83 ec 0c             	sub    $0xc,%esp
c002d0f7:	50                   	push   %eax
c002d0f8:	e8 c9 5d ff ff       	call   c0022ec6 <lock_release>
c002d0fd:	83 c4 10             	add    $0x10,%esp
  thread_yield ();
c002d100:	e8 dd 3c ff ff       	call   c0020de2 <thread_yield>

  msg ("High thread should have just finished.");
c002d105:	83 ec 0c             	sub    $0xc,%esp
c002d108:	68 c4 26 03 c0       	push   $0xc00326c4
c002d10d:	e8 9a ee ff ff       	call   c002bfac <msg>
c002d112:	83 c4 10             	add    $0x10,%esp
  msg ("Middle thread finished.");
c002d115:	83 ec 0c             	sub    $0xc,%esp
c002d118:	68 eb 26 03 c0       	push   $0xc00326eb
c002d11d:	e8 8a ee ff ff       	call   c002bfac <msg>
c002d122:	83 c4 10             	add    $0x10,%esp
}
c002d125:	90                   	nop
c002d126:	c9                   	leave  
c002d127:	c3                   	ret    

c002d128 <high_thread_func>:

static void
high_thread_func (void *lock_) 
{
c002d128:	55                   	push   %ebp
c002d129:	89 e5                	mov    %esp,%ebp
c002d12b:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d12e:	8b 45 08             	mov    0x8(%ebp),%eax
c002d131:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d134:	83 ec 0c             	sub    $0xc,%esp
c002d137:	ff 75 f4             	pushl  -0xc(%ebp)
c002d13a:	e8 a4 5b ff ff       	call   c0022ce3 <lock_acquire>
c002d13f:	83 c4 10             	add    $0x10,%esp
  msg ("High thread got the lock.");
c002d142:	83 ec 0c             	sub    $0xc,%esp
c002d145:	68 03 27 03 c0       	push   $0xc0032703
c002d14a:	e8 5d ee ff ff       	call   c002bfac <msg>
c002d14f:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d152:	83 ec 0c             	sub    $0xc,%esp
c002d155:	ff 75 f4             	pushl  -0xc(%ebp)
c002d158:	e8 69 5d ff ff       	call   c0022ec6 <lock_release>
c002d15d:	83 c4 10             	add    $0x10,%esp
  msg ("High thread finished.");
c002d160:	83 ec 0c             	sub    $0xc,%esp
c002d163:	68 1d 27 03 c0       	push   $0xc003271d
c002d168:	e8 3f ee ff ff       	call   c002bfac <msg>
c002d16d:	83 c4 10             	add    $0x10,%esp
}
c002d170:	90                   	nop
c002d171:	c9                   	leave  
c002d172:	c3                   	ret    

c002d173 <test_priority_donate_sema>:
static thread_func m_thread_func;
static thread_func h_thread_func;

void
test_priority_donate_sema (void) 
{
c002d173:	55                   	push   %ebp
c002d174:	89 e5                	mov    %esp,%ebp
c002d176:	83 ec 48             	sub    $0x48,%esp
  struct lock_and_sema ls;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d179:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d180:	83 f0 01             	xor    $0x1,%eax
c002d183:	84 c0                	test   %al,%al
c002d185:	75 1e                	jne    c002d1a5 <test_priority_donate_sema+0x32>
c002d187:	83 ec 0c             	sub    $0xc,%esp
c002d18a:	68 50 27 03 c0       	push   $0xc0032750
c002d18f:	68 5e 27 03 c0       	push   $0xc003275e
c002d194:	68 74 28 03 c0       	push   $0xc0032874
c002d199:	6a 23                	push   $0x23
c002d19b:	68 78 27 03 c0       	push   $0xc0032778
c002d1a0:	e8 76 ca ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d1a5:	e8 f0 3d ff ff       	call   c0020f9a <thread_get_priority>
c002d1aa:	83 f8 1f             	cmp    $0x1f,%eax
c002d1ad:	74 1e                	je     c002d1cd <test_priority_donate_sema+0x5a>
c002d1af:	83 ec 0c             	sub    $0xc,%esp
c002d1b2:	68 a4 27 03 c0       	push   $0xc00327a4
c002d1b7:	68 5e 27 03 c0       	push   $0xc003275e
c002d1bc:	68 74 28 03 c0       	push   $0xc0032874
c002d1c1:	6a 26                	push   $0x26
c002d1c3:	68 78 27 03 c0       	push   $0xc0032778
c002d1c8:	e8 4e ca ff ff       	call   c0029c1b <debug_panic>

  lock_init (&ls.lock);
c002d1cd:	83 ec 0c             	sub    $0xc,%esp
c002d1d0:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d1d3:	50                   	push   %eax
c002d1d4:	e8 bd 5a ff ff       	call   c0022c96 <lock_init>
c002d1d9:	83 c4 10             	add    $0x10,%esp
  sema_init (&ls.sema, 0);
c002d1dc:	83 ec 08             	sub    $0x8,%esp
c002d1df:	6a 00                	push   $0x0
c002d1e1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d1e4:	83 c0 20             	add    $0x20,%eax
c002d1e7:	50                   	push   %eax
c002d1e8:	e8 a4 57 ff ff       	call   c0022991 <sema_init>
c002d1ed:	83 c4 10             	add    $0x10,%esp
  thread_create ("low", PRI_DEFAULT + 1, l_thread_func, &ls);
c002d1f0:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d1f3:	50                   	push   %eax
c002d1f4:	68 5d d2 02 c0       	push   $0xc002d25d
c002d1f9:	6a 20                	push   $0x20
c002d1fb:	68 ca 27 03 c0       	push   $0xc00327ca
c002d200:	e8 a2 38 ff ff       	call   c0020aa7 <thread_create>
c002d205:	83 c4 10             	add    $0x10,%esp
  thread_create ("med", PRI_DEFAULT + 3, m_thread_func, &ls);
c002d208:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d20b:	50                   	push   %eax
c002d20c:	68 cc d2 02 c0       	push   $0xc002d2cc
c002d211:	6a 22                	push   $0x22
c002d213:	68 ce 27 03 c0       	push   $0xc00327ce
c002d218:	e8 8a 38 ff ff       	call   c0020aa7 <thread_create>
c002d21d:	83 c4 10             	add    $0x10,%esp
  thread_create ("high", PRI_DEFAULT + 5, h_thread_func, &ls);
c002d220:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d223:	50                   	push   %eax
c002d224:	68 fd d2 02 c0       	push   $0xc002d2fd
c002d229:	6a 24                	push   $0x24
c002d22b:	68 d2 27 03 c0       	push   $0xc00327d2
c002d230:	e8 72 38 ff ff       	call   c0020aa7 <thread_create>
c002d235:	83 c4 10             	add    $0x10,%esp
  sema_up (&ls.sema);
c002d238:	83 ec 0c             	sub    $0xc,%esp
c002d23b:	8d 45 c4             	lea    -0x3c(%ebp),%eax
c002d23e:	83 c0 20             	add    $0x20,%eax
c002d241:	50                   	push   %eax
c002d242:	e8 9c 58 ff ff       	call   c0022ae3 <sema_up>
c002d247:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread finished.");
c002d24a:	83 ec 0c             	sub    $0xc,%esp
c002d24d:	68 d7 27 03 c0       	push   $0xc00327d7
c002d252:	e8 55 ed ff ff       	call   c002bfac <msg>
c002d257:	83 c4 10             	add    $0x10,%esp
}
c002d25a:	90                   	nop
c002d25b:	c9                   	leave  
c002d25c:	c3                   	ret    

c002d25d <l_thread_func>:

static void
l_thread_func (void *ls_) 
{
c002d25d:	55                   	push   %ebp
c002d25e:	89 e5                	mov    %esp,%ebp
c002d260:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d263:	8b 45 08             	mov    0x8(%ebp),%eax
c002d266:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002d269:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d26c:	83 ec 0c             	sub    $0xc,%esp
c002d26f:	50                   	push   %eax
c002d270:	e8 6e 5a ff ff       	call   c0022ce3 <lock_acquire>
c002d275:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L acquired lock.");
c002d278:	83 ec 0c             	sub    $0xc,%esp
c002d27b:	68 ed 27 03 c0       	push   $0xc00327ed
c002d280:	e8 27 ed ff ff       	call   c002bfac <msg>
c002d285:	83 c4 10             	add    $0x10,%esp
  sema_down (&ls->sema);
c002d288:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d28b:	83 c0 20             	add    $0x20,%eax
c002d28e:	83 ec 0c             	sub    $0xc,%esp
c002d291:	50                   	push   %eax
c002d292:	e8 41 57 ff ff       	call   c00229d8 <sema_down>
c002d297:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L downed semaphore.");
c002d29a:	83 ec 0c             	sub    $0xc,%esp
c002d29d:	68 05 28 03 c0       	push   $0xc0032805
c002d2a2:	e8 05 ed ff ff       	call   c002bfac <msg>
c002d2a7:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002d2aa:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2ad:	83 ec 0c             	sub    $0xc,%esp
c002d2b0:	50                   	push   %eax
c002d2b1:	e8 10 5c ff ff       	call   c0022ec6 <lock_release>
c002d2b6:	83 c4 10             	add    $0x10,%esp
  msg ("Thread L finished.");
c002d2b9:	83 ec 0c             	sub    $0xc,%esp
c002d2bc:	68 20 28 03 c0       	push   $0xc0032820
c002d2c1:	e8 e6 ec ff ff       	call   c002bfac <msg>
c002d2c6:	83 c4 10             	add    $0x10,%esp
}
c002d2c9:	90                   	nop
c002d2ca:	c9                   	leave  
c002d2cb:	c3                   	ret    

c002d2cc <m_thread_func>:

static void
m_thread_func (void *ls_) 
{
c002d2cc:	55                   	push   %ebp
c002d2cd:	89 e5                	mov    %esp,%ebp
c002d2cf:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d2d2:	8b 45 08             	mov    0x8(%ebp),%eax
c002d2d5:	89 45 f4             	mov    %eax,-0xc(%ebp)

  sema_down (&ls->sema);
c002d2d8:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d2db:	83 c0 20             	add    $0x20,%eax
c002d2de:	83 ec 0c             	sub    $0xc,%esp
c002d2e1:	50                   	push   %eax
c002d2e2:	e8 f1 56 ff ff       	call   c00229d8 <sema_down>
c002d2e7:	83 c4 10             	add    $0x10,%esp
  msg ("Thread M finished.");
c002d2ea:	83 ec 0c             	sub    $0xc,%esp
c002d2ed:	68 33 28 03 c0       	push   $0xc0032833
c002d2f2:	e8 b5 ec ff ff       	call   c002bfac <msg>
c002d2f7:	83 c4 10             	add    $0x10,%esp
}
c002d2fa:	90                   	nop
c002d2fb:	c9                   	leave  
c002d2fc:	c3                   	ret    

c002d2fd <h_thread_func>:

static void
h_thread_func (void *ls_) 
{
c002d2fd:	55                   	push   %ebp
c002d2fe:	89 e5                	mov    %esp,%ebp
c002d300:	83 ec 18             	sub    $0x18,%esp
  struct lock_and_sema *ls = ls_;
c002d303:	8b 45 08             	mov    0x8(%ebp),%eax
c002d306:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (&ls->lock);
c002d309:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d30c:	83 ec 0c             	sub    $0xc,%esp
c002d30f:	50                   	push   %eax
c002d310:	e8 ce 59 ff ff       	call   c0022ce3 <lock_acquire>
c002d315:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H acquired lock.");
c002d318:	83 ec 0c             	sub    $0xc,%esp
c002d31b:	68 46 28 03 c0       	push   $0xc0032846
c002d320:	e8 87 ec ff ff       	call   c002bfac <msg>
c002d325:	83 c4 10             	add    $0x10,%esp

  sema_up (&ls->sema);
c002d328:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d32b:	83 c0 20             	add    $0x20,%eax
c002d32e:	83 ec 0c             	sub    $0xc,%esp
c002d331:	50                   	push   %eax
c002d332:	e8 ac 57 ff ff       	call   c0022ae3 <sema_up>
c002d337:	83 c4 10             	add    $0x10,%esp
  lock_release (&ls->lock);
c002d33a:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d33d:	83 ec 0c             	sub    $0xc,%esp
c002d340:	50                   	push   %eax
c002d341:	e8 80 5b ff ff       	call   c0022ec6 <lock_release>
c002d346:	83 c4 10             	add    $0x10,%esp
  msg ("Thread H finished.");
c002d349:	83 ec 0c             	sub    $0xc,%esp
c002d34c:	68 5e 28 03 c0       	push   $0xc003285e
c002d351:	e8 56 ec ff ff       	call   c002bfac <msg>
c002d356:	83 c4 10             	add    $0x10,%esp
}
c002d359:	90                   	nop
c002d35a:	c9                   	leave  
c002d35b:	c3                   	ret    

c002d35c <test_priority_donate_lower>:

static thread_func acquire_thread_func;

void
test_priority_donate_lower (void) 
{
c002d35c:	55                   	push   %ebp
c002d35d:	89 e5                	mov    %esp,%ebp
c002d35f:	83 ec 28             	sub    $0x28,%esp
  struct lock lock;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d362:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d369:	83 f0 01             	xor    $0x1,%eax
c002d36c:	84 c0                	test   %al,%al
c002d36e:	75 1e                	jne    c002d38e <test_priority_donate_lower+0x32>
c002d370:	83 ec 0c             	sub    $0xc,%esp
c002d373:	68 90 28 03 c0       	push   $0xc0032890
c002d378:	68 9e 28 03 c0       	push   $0xc003289e
c002d37d:	68 b4 29 03 c0       	push   $0xc00329b4
c002d382:	6a 15                	push   $0x15
c002d384:	68 b8 28 03 c0       	push   $0xc00328b8
c002d389:	e8 8d c8 ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d38e:	e8 07 3c ff ff       	call   c0020f9a <thread_get_priority>
c002d393:	83 f8 1f             	cmp    $0x1f,%eax
c002d396:	74 1e                	je     c002d3b6 <test_priority_donate_lower+0x5a>
c002d398:	83 ec 0c             	sub    $0xc,%esp
c002d39b:	68 e4 28 03 c0       	push   $0xc00328e4
c002d3a0:	68 9e 28 03 c0       	push   $0xc003289e
c002d3a5:	68 b4 29 03 c0       	push   $0xc00329b4
c002d3aa:	6a 18                	push   $0x18
c002d3ac:	68 b8 28 03 c0       	push   $0xc00328b8
c002d3b1:	e8 65 c8 ff ff       	call   c0029c1b <debug_panic>

  lock_init (&lock);
c002d3b6:	83 ec 0c             	sub    $0xc,%esp
c002d3b9:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002d3bc:	50                   	push   %eax
c002d3bd:	e8 d4 58 ff ff       	call   c0022c96 <lock_init>
c002d3c2:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002d3c5:	83 ec 0c             	sub    $0xc,%esp
c002d3c8:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002d3cb:	50                   	push   %eax
c002d3cc:	e8 12 59 ff ff       	call   c0022ce3 <lock_acquire>
c002d3d1:	83 c4 10             	add    $0x10,%esp
  thread_create ("acquire", PRI_DEFAULT + 10, acquire_thread_func, &lock);
c002d3d4:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002d3d7:	50                   	push   %eax
c002d3d8:	68 73 d4 02 c0       	push   $0xc002d473
c002d3dd:	6a 29                	push   $0x29
c002d3df:	68 0a 29 03 c0       	push   $0xc003290a
c002d3e4:	e8 be 36 ff ff       	call   c0020aa7 <thread_create>
c002d3e9:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d3ec:	e8 a9 3b ff ff       	call   c0020f9a <thread_get_priority>
c002d3f1:	83 ec 04             	sub    $0x4,%esp
c002d3f4:	50                   	push   %eax
c002d3f5:	6a 29                	push   $0x29
c002d3f7:	68 14 29 03 c0       	push   $0xc0032914
c002d3fc:	e8 ab eb ff ff       	call   c002bfac <msg>
c002d401:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());

  msg ("Lowering base priority...");
c002d404:	83 ec 0c             	sub    $0xc,%esp
c002d407:	68 4f 29 03 c0       	push   $0xc003294f
c002d40c:	e8 9b eb ff ff       	call   c002bfac <msg>
c002d411:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_DEFAULT - 10);
c002d414:	83 ec 0c             	sub    $0xc,%esp
c002d417:	6a 15                	push   $0x15
c002d419:	e8 d3 3a ff ff       	call   c0020ef1 <thread_set_priority>
c002d41e:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d421:	e8 74 3b ff ff       	call   c0020f9a <thread_get_priority>
c002d426:	83 ec 04             	sub    $0x4,%esp
c002d429:	50                   	push   %eax
c002d42a:	6a 29                	push   $0x29
c002d42c:	68 14 29 03 c0       	push   $0xc0032914
c002d431:	e8 76 eb ff ff       	call   c002bfac <msg>
c002d436:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT + 10, thread_get_priority ());
  lock_release (&lock);
c002d439:	83 ec 0c             	sub    $0xc,%esp
c002d43c:	8d 45 d8             	lea    -0x28(%ebp),%eax
c002d43f:	50                   	push   %eax
c002d440:	e8 81 5a ff ff       	call   c0022ec6 <lock_release>
c002d445:	83 c4 10             	add    $0x10,%esp
  msg ("acquire must already have finished.");
c002d448:	83 ec 0c             	sub    $0xc,%esp
c002d44b:	68 6c 29 03 c0       	push   $0xc003296c
c002d450:	e8 57 eb ff ff       	call   c002bfac <msg>
c002d455:	83 c4 10             	add    $0x10,%esp
  msg ("Main thread should have priority %d.  Actual priority: %d.",
c002d458:	e8 3d 3b ff ff       	call   c0020f9a <thread_get_priority>
c002d45d:	83 ec 04             	sub    $0x4,%esp
c002d460:	50                   	push   %eax
c002d461:	6a 15                	push   $0x15
c002d463:	68 14 29 03 c0       	push   $0xc0032914
c002d468:	e8 3f eb ff ff       	call   c002bfac <msg>
c002d46d:	83 c4 10             	add    $0x10,%esp
       PRI_DEFAULT - 10, thread_get_priority ());
}
c002d470:	90                   	nop
c002d471:	c9                   	leave  
c002d472:	c3                   	ret    

c002d473 <acquire_thread_func>:

static void
acquire_thread_func (void *lock_) 
{
c002d473:	55                   	push   %ebp
c002d474:	89 e5                	mov    %esp,%ebp
c002d476:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002d479:	8b 45 08             	mov    0x8(%ebp),%eax
c002d47c:	89 45 f4             	mov    %eax,-0xc(%ebp)

  lock_acquire (lock);
c002d47f:	83 ec 0c             	sub    $0xc,%esp
c002d482:	ff 75 f4             	pushl  -0xc(%ebp)
c002d485:	e8 59 58 ff ff       	call   c0022ce3 <lock_acquire>
c002d48a:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: got the lock");
c002d48d:	83 ec 0c             	sub    $0xc,%esp
c002d490:	68 90 29 03 c0       	push   $0xc0032990
c002d495:	e8 12 eb ff ff       	call   c002bfac <msg>
c002d49a:	83 c4 10             	add    $0x10,%esp
  lock_release (lock);
c002d49d:	83 ec 0c             	sub    $0xc,%esp
c002d4a0:	ff 75 f4             	pushl  -0xc(%ebp)
c002d4a3:	e8 1e 5a ff ff       	call   c0022ec6 <lock_release>
c002d4a8:	83 c4 10             	add    $0x10,%esp
  msg ("acquire: done");
c002d4ab:	83 ec 0c             	sub    $0xc,%esp
c002d4ae:	68 a6 29 03 c0       	push   $0xc00329a6
c002d4b3:	e8 f4 ea ff ff       	call   c002bfac <msg>
c002d4b8:	83 c4 10             	add    $0x10,%esp
}
c002d4bb:	90                   	nop
c002d4bc:	c9                   	leave  
c002d4bd:	c3                   	ret    

c002d4be <test_priority_fifo>:

static thread_func simple_thread_func;

void
test_priority_fifo (void) 
{
c002d4be:	55                   	push   %ebp
c002d4bf:	89 e5                	mov    %esp,%ebp
c002d4c1:	81 ec 58 01 00 00    	sub    $0x158,%esp
  struct lock lock;
  int *output, *op;
  int i, cnt;

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d4c7:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d4ce:	83 f0 01             	xor    $0x1,%eax
c002d4d1:	84 c0                	test   %al,%al
c002d4d3:	75 1e                	jne    c002d4f3 <test_priority_fifo+0x35>
c002d4d5:	83 ec 0c             	sub    $0xc,%esp
c002d4d8:	68 d0 29 03 c0       	push   $0xc00329d0
c002d4dd:	68 de 29 03 c0       	push   $0xc00329de
c002d4e2:	68 18 2b 03 c0       	push   $0xc0032b18
c002d4e7:	6a 28                	push   $0x28
c002d4e9:	68 f8 29 03 c0       	push   $0xc00329f8
c002d4ee:	e8 28 c7 ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d4f3:	e8 a2 3a ff ff       	call   c0020f9a <thread_get_priority>
c002d4f8:	83 f8 1f             	cmp    $0x1f,%eax
c002d4fb:	74 1e                	je     c002d51b <test_priority_fifo+0x5d>
c002d4fd:	83 ec 0c             	sub    $0xc,%esp
c002d500:	68 1c 2a 03 c0       	push   $0xc0032a1c
c002d505:	68 de 29 03 c0       	push   $0xc00329de
c002d50a:	68 18 2b 03 c0       	push   $0xc0032b18
c002d50f:	6a 2b                	push   $0x2b
c002d511:	68 f8 29 03 c0       	push   $0xc00329f8
c002d516:	e8 00 c7 ff ff       	call   c0029c1b <debug_panic>

  msg ("%d threads will iterate %d times in the same order each time.",
c002d51b:	83 ec 04             	sub    $0x4,%esp
c002d51e:	6a 10                	push   $0x10
c002d520:	6a 10                	push   $0x10
c002d522:	68 44 2a 03 c0       	push   $0xc0032a44
c002d527:	e8 80 ea ff ff       	call   c002bfac <msg>
c002d52c:	83 c4 10             	add    $0x10,%esp
       THREAD_CNT, ITER_CNT);
  msg ("If the order varies then there is a bug.");
c002d52f:	83 ec 0c             	sub    $0xc,%esp
c002d532:	68 84 2a 03 c0       	push   $0xc0032a84
c002d537:	e8 70 ea ff ff       	call   c002bfac <msg>
c002d53c:	83 c4 10             	add    $0x10,%esp

  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
c002d53f:	83 ec 0c             	sub    $0xc,%esp
c002d542:	68 00 08 00 00       	push   $0x800
c002d547:	e8 15 64 ff ff       	call   c0023961 <malloc>
c002d54c:	83 c4 10             	add    $0x10,%esp
c002d54f:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%ebp)
c002d555:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
c002d55b:	89 45 f4             	mov    %eax,-0xc(%ebp)
  ASSERT (output != NULL);
c002d55e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
c002d562:	75 1e                	jne    c002d582 <test_priority_fifo+0xc4>
c002d564:	83 ec 0c             	sub    $0xc,%esp
c002d567:	68 ad 2a 03 c0       	push   $0xc0032aad
c002d56c:	68 de 29 03 c0       	push   $0xc00329de
c002d571:	68 18 2b 03 c0       	push   $0xc0032b18
c002d576:	6a 32                	push   $0x32
c002d578:	68 f8 29 03 c0       	push   $0xc00329f8
c002d57d:	e8 99 c6 ff ff       	call   c0029c1b <debug_panic>
  lock_init (&lock);
c002d582:	83 ec 0c             	sub    $0xc,%esp
c002d585:	8d 85 c4 fe ff ff    	lea    -0x13c(%ebp),%eax
c002d58b:	50                   	push   %eax
c002d58c:	e8 05 57 ff ff       	call   c0022c96 <lock_init>
c002d591:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_DEFAULT + 2);
c002d594:	83 ec 0c             	sub    $0xc,%esp
c002d597:	6a 21                	push   $0x21
c002d599:	e8 53 39 ff ff       	call   c0020ef1 <thread_set_priority>
c002d59e:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002d5a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002d5a8:	eb 73                	jmp    c002d61d <test_priority_fifo+0x15f>
    {
      char name[16];
      struct simple_thread_data *d = data + i;
c002d5aa:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d5ad:	c1 e0 04             	shl    $0x4,%eax
c002d5b0:	89 c2                	mov    %eax,%edx
c002d5b2:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d5b8:	01 d0                	add    %edx,%eax
c002d5ba:	89 45 e8             	mov    %eax,-0x18(%ebp)
      snprintf (name, sizeof name, "%d", i);
c002d5bd:	ff 75 f0             	pushl  -0x10(%ebp)
c002d5c0:	68 bc 2a 03 c0       	push   $0xc0032abc
c002d5c5:	6a 10                	push   $0x10
c002d5c7:	8d 85 b0 fe ff ff    	lea    -0x150(%ebp),%eax
c002d5cd:	50                   	push   %eax
c002d5ce:	e8 ec a1 ff ff       	call   c00277bf <snprintf>
c002d5d3:	83 c4 10             	add    $0x10,%esp
      d->id = i;
c002d5d6:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d5d9:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d5dc:	89 10                	mov    %edx,(%eax)
      d->iterations = 0;
c002d5de:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d5e1:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
      d->lock = &lock;
c002d5e8:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d5eb:	8d 95 c4 fe ff ff    	lea    -0x13c(%ebp),%edx
c002d5f1:	89 50 08             	mov    %edx,0x8(%eax)
      d->op = &op;
c002d5f4:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002d5f7:	8d 95 c0 fe ff ff    	lea    -0x140(%ebp),%edx
c002d5fd:	89 50 0c             	mov    %edx,0xc(%eax)
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
c002d600:	ff 75 e8             	pushl  -0x18(%ebp)
c002d603:	68 1a d7 02 c0       	push   $0xc002d71a
c002d608:	6a 20                	push   $0x20
c002d60a:	8d 85 b0 fe ff ff    	lea    -0x150(%ebp),%eax
c002d610:	50                   	push   %eax
c002d611:	e8 91 34 ff ff       	call   c0020aa7 <thread_create>
c002d616:	83 c4 10             	add    $0x10,%esp
  output = op = malloc (sizeof *output * THREAD_CNT * ITER_CNT * 2);
  ASSERT (output != NULL);
  lock_init (&lock);

  thread_set_priority (PRI_DEFAULT + 2);
  for (i = 0; i < THREAD_CNT; i++) 
c002d619:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002d61d:	83 7d f0 0f          	cmpl   $0xf,-0x10(%ebp)
c002d621:	7e 87                	jle    c002d5aa <test_priority_fifo+0xec>
      d->lock = &lock;
      d->op = &op;
      thread_create (name, PRI_DEFAULT + 1, simple_thread_func, d);
    }

  thread_set_priority (PRI_DEFAULT);
c002d623:	83 ec 0c             	sub    $0xc,%esp
c002d626:	6a 1f                	push   $0x1f
c002d628:	e8 c4 38 ff ff       	call   c0020ef1 <thread_set_priority>
c002d62d:	83 c4 10             	add    $0x10,%esp
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);
c002d630:	8b 85 c4 fe ff ff    	mov    -0x13c(%ebp),%eax
c002d636:	85 c0                	test   %eax,%eax
c002d638:	74 1e                	je     c002d658 <test_priority_fifo+0x19a>
c002d63a:	83 ec 0c             	sub    $0xc,%esp
c002d63d:	68 bf 2a 03 c0       	push   $0xc0032abf
c002d642:	68 de 29 03 c0       	push   $0xc00329de
c002d647:	68 18 2b 03 c0       	push   $0xc0032b18
c002d64c:	6a 44                	push   $0x44
c002d64e:	68 f8 29 03 c0       	push   $0xc00329f8
c002d653:	e8 c3 c5 ff ff       	call   c0029c1b <debug_panic>

  cnt = 0;
c002d658:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
  for (; output < op; output++) 
c002d65f:	e9 a4 00 00 00       	jmp    c002d708 <test_priority_fifo+0x24a>
    {
      struct simple_thread_data *d;

      ASSERT (*output >= 0 && *output < THREAD_CNT);
c002d664:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d667:	8b 00                	mov    (%eax),%eax
c002d669:	85 c0                	test   %eax,%eax
c002d66b:	78 0a                	js     c002d677 <test_priority_fifo+0x1b9>
c002d66d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d670:	8b 00                	mov    (%eax),%eax
c002d672:	83 f8 0f             	cmp    $0xf,%eax
c002d675:	7e 1e                	jle    c002d695 <test_priority_fifo+0x1d7>
c002d677:	83 ec 0c             	sub    $0xc,%esp
c002d67a:	68 d4 2a 03 c0       	push   $0xc0032ad4
c002d67f:	68 de 29 03 c0       	push   $0xc00329de
c002d684:	68 18 2b 03 c0       	push   $0xc0032b18
c002d689:	6a 4b                	push   $0x4b
c002d68b:	68 f8 29 03 c0       	push   $0xc00329f8
c002d690:	e8 86 c5 ff ff       	call   c0029c1b <debug_panic>
      d = data + *output;
c002d695:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d698:	8b 00                	mov    (%eax),%eax
c002d69a:	c1 e0 04             	shl    $0x4,%eax
c002d69d:	89 c2                	mov    %eax,%edx
c002d69f:	8d 85 e4 fe ff ff    	lea    -0x11c(%ebp),%eax
c002d6a5:	01 d0                	add    %edx,%eax
c002d6a7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      if (cnt % THREAD_CNT == 0)
c002d6aa:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d6ad:	83 e0 0f             	and    $0xf,%eax
c002d6b0:	85 c0                	test   %eax,%eax
c002d6b2:	75 10                	jne    c002d6c4 <test_priority_fifo+0x206>
        printf ("(priority-fifo) iteration:");
c002d6b4:	83 ec 0c             	sub    $0xc,%esp
c002d6b7:	68 f9 2a 03 c0       	push   $0xc0032af9
c002d6bc:	e8 27 a1 ff ff       	call   c00277e8 <printf>
c002d6c1:	83 c4 10             	add    $0x10,%esp
      printf (" %d", d->id);
c002d6c4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d6c7:	8b 00                	mov    (%eax),%eax
c002d6c9:	83 ec 08             	sub    $0x8,%esp
c002d6cc:	50                   	push   %eax
c002d6cd:	68 14 2b 03 c0       	push   $0xc0032b14
c002d6d2:	e8 11 a1 ff ff       	call   c00277e8 <printf>
c002d6d7:	83 c4 10             	add    $0x10,%esp
      if (++cnt % THREAD_CNT == 0)
c002d6da:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
c002d6de:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002d6e1:	83 e0 0f             	and    $0xf,%eax
c002d6e4:	85 c0                	test   %eax,%eax
c002d6e6:	75 0d                	jne    c002d6f5 <test_priority_fifo+0x237>
        printf ("\n");
c002d6e8:	83 ec 0c             	sub    $0xc,%esp
c002d6eb:	6a 0a                	push   $0xa
c002d6ed:	e8 64 e7 ff ff       	call   c002be56 <putchar>
c002d6f2:	83 c4 10             	add    $0x10,%esp
      d->iterations++;
c002d6f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d6f8:	8b 40 04             	mov    0x4(%eax),%eax
c002d6fb:	8d 50 01             	lea    0x1(%eax),%edx
c002d6fe:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002d701:	89 50 04             	mov    %edx,0x4(%eax)
  thread_set_priority (PRI_DEFAULT);
  /* All the other threads now run to termination here. */
  ASSERT (lock.holder == NULL);

  cnt = 0;
  for (; output < op; output++) 
c002d704:	83 45 f4 04          	addl   $0x4,-0xc(%ebp)
c002d708:	8b 85 c0 fe ff ff    	mov    -0x140(%ebp),%eax
c002d70e:	39 45 f4             	cmp    %eax,-0xc(%ebp)
c002d711:	0f 82 4d ff ff ff    	jb     c002d664 <test_priority_fifo+0x1a6>
      printf (" %d", d->id);
      if (++cnt % THREAD_CNT == 0)
        printf ("\n");
      d->iterations++;
    }
}
c002d717:	90                   	nop
c002d718:	c9                   	leave  
c002d719:	c3                   	ret    

c002d71a <simple_thread_func>:

static void 
simple_thread_func (void *data_) 
{
c002d71a:	55                   	push   %ebp
c002d71b:	89 e5                	mov    %esp,%ebp
c002d71d:	83 ec 18             	sub    $0x18,%esp
  struct simple_thread_data *data = data_;
c002d720:	8b 45 08             	mov    0x8(%ebp),%eax
c002d723:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d726:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d72d:	eb 41                	jmp    c002d770 <simple_thread_func+0x56>
    {
      lock_acquire (data->lock);
c002d72f:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d732:	8b 40 08             	mov    0x8(%eax),%eax
c002d735:	83 ec 0c             	sub    $0xc,%esp
c002d738:	50                   	push   %eax
c002d739:	e8 a5 55 ff ff       	call   c0022ce3 <lock_acquire>
c002d73e:	83 c4 10             	add    $0x10,%esp
      *(*data->op)++ = data->id;
c002d741:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d744:	8b 50 0c             	mov    0xc(%eax),%edx
c002d747:	8b 02                	mov    (%edx),%eax
c002d749:	8d 48 04             	lea    0x4(%eax),%ecx
c002d74c:	89 0a                	mov    %ecx,(%edx)
c002d74e:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002d751:	8b 12                	mov    (%edx),%edx
c002d753:	89 10                	mov    %edx,(%eax)
      lock_release (data->lock);
c002d755:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002d758:	8b 40 08             	mov    0x8(%eax),%eax
c002d75b:	83 ec 0c             	sub    $0xc,%esp
c002d75e:	50                   	push   %eax
c002d75f:	e8 62 57 ff ff       	call   c0022ec6 <lock_release>
c002d764:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d767:	e8 76 36 ff ff       	call   c0020de2 <thread_yield>
simple_thread_func (void *data_) 
{
  struct simple_thread_data *data = data_;
  int i;
  
  for (i = 0; i < ITER_CNT; i++) 
c002d76c:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d770:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
c002d774:	7e b9                	jle    c002d72f <simple_thread_func+0x15>
      lock_acquire (data->lock);
      *(*data->op)++ = data->id;
      lock_release (data->lock);
      thread_yield ();
    }
}
c002d776:	90                   	nop
c002d777:	c9                   	leave  
c002d778:	c3                   	ret    

c002d779 <test_priority_preempt>:

static thread_func simple_thread_func;

void
test_priority_preempt (void) 
{
c002d779:	55                   	push   %ebp
c002d77a:	89 e5                	mov    %esp,%ebp
c002d77c:	83 ec 08             	sub    $0x8,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d77f:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d786:	83 f0 01             	xor    $0x1,%eax
c002d789:	84 c0                	test   %al,%al
c002d78b:	75 1e                	jne    c002d7ab <test_priority_preempt+0x32>
c002d78d:	83 ec 0c             	sub    $0xc,%esp
c002d790:	68 2c 2b 03 c0       	push   $0xc0032b2c
c002d795:	68 3a 2b 03 c0       	push   $0xc0032b3a
c002d79a:	68 10 2c 03 c0       	push   $0xc0032c10
c002d79f:	6a 15                	push   $0x15
c002d7a1:	68 54 2b 03 c0       	push   $0xc0032b54
c002d7a6:	e8 70 c4 ff ff       	call   c0029c1b <debug_panic>

  /* Make sure our priority is the default. */
  ASSERT (thread_get_priority () == PRI_DEFAULT);
c002d7ab:	e8 ea 37 ff ff       	call   c0020f9a <thread_get_priority>
c002d7b0:	83 f8 1f             	cmp    $0x1f,%eax
c002d7b3:	74 1e                	je     c002d7d3 <test_priority_preempt+0x5a>
c002d7b5:	83 ec 0c             	sub    $0xc,%esp
c002d7b8:	68 7c 2b 03 c0       	push   $0xc0032b7c
c002d7bd:	68 3a 2b 03 c0       	push   $0xc0032b3a
c002d7c2:	68 10 2c 03 c0       	push   $0xc0032c10
c002d7c7:	6a 18                	push   $0x18
c002d7c9:	68 54 2b 03 c0       	push   $0xc0032b54
c002d7ce:	e8 48 c4 ff ff       	call   c0029c1b <debug_panic>

  thread_create ("high-priority", PRI_DEFAULT + 1, simple_thread_func, NULL);
c002d7d3:	6a 00                	push   $0x0
c002d7d5:	68 fc d7 02 c0       	push   $0xc002d7fc
c002d7da:	6a 20                	push   $0x20
c002d7dc:	68 a2 2b 03 c0       	push   $0xc0032ba2
c002d7e1:	e8 c1 32 ff ff       	call   c0020aa7 <thread_create>
c002d7e6:	83 c4 10             	add    $0x10,%esp
  msg ("The high-priority thread should have already completed.");
c002d7e9:	83 ec 0c             	sub    $0xc,%esp
c002d7ec:	68 b0 2b 03 c0       	push   $0xc0032bb0
c002d7f1:	e8 b6 e7 ff ff       	call   c002bfac <msg>
c002d7f6:	83 c4 10             	add    $0x10,%esp
}
c002d7f9:	90                   	nop
c002d7fa:	c9                   	leave  
c002d7fb:	c3                   	ret    

c002d7fc <simple_thread_func>:

static void 
simple_thread_func (void *aux UNUSED) 
{
c002d7fc:	55                   	push   %ebp
c002d7fd:	89 e5                	mov    %esp,%ebp
c002d7ff:	83 ec 18             	sub    $0x18,%esp
  int i;
  
  for (i = 0; i < 5; i++) 
c002d802:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d809:	eb 22                	jmp    c002d82d <simple_thread_func+0x31>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
c002d80b:	e8 cc 34 ff ff       	call   c0020cdc <thread_name>
c002d810:	83 ec 04             	sub    $0x4,%esp
c002d813:	ff 75 f4             	pushl  -0xc(%ebp)
c002d816:	50                   	push   %eax
c002d817:	68 e8 2b 03 c0       	push   $0xc0032be8
c002d81c:	e8 8b e7 ff ff       	call   c002bfac <msg>
c002d821:	83 c4 10             	add    $0x10,%esp
      thread_yield ();
c002d824:	e8 b9 35 ff ff       	call   c0020de2 <thread_yield>
static void 
simple_thread_func (void *aux UNUSED) 
{
  int i;
  
  for (i = 0; i < 5; i++) 
c002d829:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d82d:	83 7d f4 04          	cmpl   $0x4,-0xc(%ebp)
c002d831:	7e d8                	jle    c002d80b <simple_thread_func+0xf>
    {
      msg ("Thread %s iteration %d", thread_name (), i);
      thread_yield ();
    }
  msg ("Thread %s done!", thread_name ());
c002d833:	e8 a4 34 ff ff       	call   c0020cdc <thread_name>
c002d838:	83 ec 08             	sub    $0x8,%esp
c002d83b:	50                   	push   %eax
c002d83c:	68 ff 2b 03 c0       	push   $0xc0032bff
c002d841:	e8 66 e7 ff ff       	call   c002bfac <msg>
c002d846:	83 c4 10             	add    $0x10,%esp
}
c002d849:	90                   	nop
c002d84a:	c9                   	leave  
c002d84b:	c3                   	ret    

c002d84c <test_priority_sema>:
static thread_func priority_sema_thread;
static struct semaphore sema;

void
test_priority_sema (void) 
{
c002d84c:	55                   	push   %ebp
c002d84d:	89 e5                	mov    %esp,%ebp
c002d84f:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d852:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d859:	83 f0 01             	xor    $0x1,%eax
c002d85c:	84 c0                	test   %al,%al
c002d85e:	75 1e                	jne    c002d87e <test_priority_sema+0x32>
c002d860:	83 ec 0c             	sub    $0xc,%esp
c002d863:	68 28 2c 03 c0       	push   $0xc0032c28
c002d868:	68 36 2c 03 c0       	push   $0xc0032c36
c002d86d:	68 a8 2c 03 c0       	push   $0xc0032ca8
c002d872:	6a 15                	push   $0x15
c002d874:	68 50 2c 03 c0       	push   $0xc0032c50
c002d879:	e8 9d c3 ff ff       	call   c0029c1b <debug_panic>

  sema_init (&sema, 0);
c002d87e:	83 ec 08             	sub    $0x8,%esp
c002d881:	6a 00                	push   $0x0
c002d883:	68 34 9e 03 c0       	push   $0xc0039e34
c002d888:	e8 04 51 ff ff       	call   c0022991 <sema_init>
c002d88d:	83 c4 10             	add    $0x10,%esp
  thread_set_priority (PRI_MIN);
c002d890:	83 ec 0c             	sub    $0xc,%esp
c002d893:	6a 00                	push   $0x0
c002d895:	e8 57 36 ff ff       	call   c0020ef1 <thread_set_priority>
c002d89a:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d89d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d8a4:	eb 60                	jmp    c002d906 <test_priority_sema+0xba>
    {
      int priority = PRI_DEFAULT - (i + 3) % 10 - 1;
c002d8a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d8a9:	8d 48 03             	lea    0x3(%eax),%ecx
c002d8ac:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d8b1:	89 c8                	mov    %ecx,%eax
c002d8b3:	f7 ea                	imul   %edx
c002d8b5:	c1 fa 02             	sar    $0x2,%edx
c002d8b8:	89 c8                	mov    %ecx,%eax
c002d8ba:	c1 f8 1f             	sar    $0x1f,%eax
c002d8bd:	29 c2                	sub    %eax,%edx
c002d8bf:	89 d0                	mov    %edx,%eax
c002d8c1:	c1 e0 02             	shl    $0x2,%eax
c002d8c4:	01 d0                	add    %edx,%eax
c002d8c6:	01 c0                	add    %eax,%eax
c002d8c8:	29 c1                	sub    %eax,%ecx
c002d8ca:	89 ca                	mov    %ecx,%edx
c002d8cc:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002d8d1:	29 d0                	sub    %edx,%eax
c002d8d3:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002d8d6:	ff 75 f0             	pushl  -0x10(%ebp)
c002d8d9:	68 74 2c 03 c0       	push   $0xc0032c74
c002d8de:	6a 10                	push   $0x10
c002d8e0:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d8e3:	50                   	push   %eax
c002d8e4:	e8 d6 9e ff ff       	call   c00277bf <snprintf>
c002d8e9:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_sema_thread, NULL);
c002d8ec:	6a 00                	push   $0x0
c002d8ee:	68 42 d9 02 c0       	push   $0xc002d942
c002d8f3:	ff 75 f0             	pushl  -0x10(%ebp)
c002d8f6:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002d8f9:	50                   	push   %eax
c002d8fa:	e8 a8 31 ff ff       	call   c0020aa7 <thread_create>
c002d8ff:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  sema_init (&sema, 0);
  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002d902:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d906:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d90a:	7e 9a                	jle    c002d8a6 <test_priority_sema+0x5a>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d90c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d913:	eb 24                	jmp    c002d939 <test_priority_sema+0xed>
    {
      sema_up (&sema);
c002d915:	83 ec 0c             	sub    $0xc,%esp
c002d918:	68 34 9e 03 c0       	push   $0xc0039e34
c002d91d:	e8 c1 51 ff ff       	call   c0022ae3 <sema_up>
c002d922:	83 c4 10             	add    $0x10,%esp
      msg ("Back in main thread."); 
c002d925:	83 ec 0c             	sub    $0xc,%esp
c002d928:	68 80 2c 03 c0       	push   $0xc0032c80
c002d92d:	e8 7a e6 ff ff       	call   c002bfac <msg>
c002d932:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_sema_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002d935:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002d939:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002d93d:	7e d6                	jle    c002d915 <test_priority_sema+0xc9>
    {
      sema_up (&sema);
      msg ("Back in main thread."); 
    }
}
c002d93f:	90                   	nop
c002d940:	c9                   	leave  
c002d941:	c3                   	ret    

c002d942 <priority_sema_thread>:

static void
priority_sema_thread (void *aux UNUSED) 
{
c002d942:	55                   	push   %ebp
c002d943:	89 e5                	mov    %esp,%ebp
c002d945:	83 ec 08             	sub    $0x8,%esp
  sema_down (&sema);
c002d948:	83 ec 0c             	sub    $0xc,%esp
c002d94b:	68 34 9e 03 c0       	push   $0xc0039e34
c002d950:	e8 83 50 ff ff       	call   c00229d8 <sema_down>
c002d955:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002d958:	e8 7f 33 ff ff       	call   c0020cdc <thread_name>
c002d95d:	83 ec 08             	sub    $0x8,%esp
c002d960:	50                   	push   %eax
c002d961:	68 95 2c 03 c0       	push   $0xc0032c95
c002d966:	e8 41 e6 ff ff       	call   c002bfac <msg>
c002d96b:	83 c4 10             	add    $0x10,%esp
}
c002d96e:	90                   	nop
c002d96f:	c9                   	leave  
c002d970:	c3                   	ret    

c002d971 <test_priority_condvar>:
static struct lock lock;
static struct condition condition;

void
test_priority_condvar (void) 
{
c002d971:	55                   	push   %ebp
c002d972:	89 e5                	mov    %esp,%ebp
c002d974:	83 ec 28             	sub    $0x28,%esp
  int i;
  
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002d977:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002d97e:	83 f0 01             	xor    $0x1,%eax
c002d981:	84 c0                	test   %al,%al
c002d983:	75 1e                	jne    c002d9a3 <test_priority_condvar+0x32>
c002d985:	83 ec 0c             	sub    $0xc,%esp
c002d988:	68 bc 2c 03 c0       	push   $0xc0032cbc
c002d98d:	68 ca 2c 03 c0       	push   $0xc0032cca
c002d992:	68 4c 2d 03 c0       	push   $0xc0032d4c
c002d997:	6a 16                	push   $0x16
c002d999:	68 e4 2c 03 c0       	push   $0xc0032ce4
c002d99e:	e8 78 c2 ff ff       	call   c0029c1b <debug_panic>

  lock_init (&lock);
c002d9a3:	83 ec 0c             	sub    $0xc,%esp
c002d9a6:	68 60 9e 03 c0       	push   $0xc0039e60
c002d9ab:	e8 e6 52 ff ff       	call   c0022c96 <lock_init>
c002d9b0:	83 c4 10             	add    $0x10,%esp
  cond_init (&condition);
c002d9b3:	83 ec 0c             	sub    $0xc,%esp
c002d9b6:	68 80 9e 03 c0       	push   $0xc0039e80
c002d9bb:	e8 a7 57 ff ff       	call   c0023167 <cond_init>
c002d9c0:	83 c4 10             	add    $0x10,%esp

  thread_set_priority (PRI_MIN);
c002d9c3:	83 ec 0c             	sub    $0xc,%esp
c002d9c6:	6a 00                	push   $0x0
c002d9c8:	e8 24 35 ff ff       	call   c0020ef1 <thread_set_priority>
c002d9cd:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < 10; i++) 
c002d9d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002d9d7:	eb 60                	jmp    c002da39 <test_priority_condvar+0xc8>
    {
      int priority = PRI_DEFAULT - (i + 7) % 10 - 1;
c002d9d9:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002d9dc:	8d 48 07             	lea    0x7(%eax),%ecx
c002d9df:	ba 67 66 66 66       	mov    $0x66666667,%edx
c002d9e4:	89 c8                	mov    %ecx,%eax
c002d9e6:	f7 ea                	imul   %edx
c002d9e8:	c1 fa 02             	sar    $0x2,%edx
c002d9eb:	89 c8                	mov    %ecx,%eax
c002d9ed:	c1 f8 1f             	sar    $0x1f,%eax
c002d9f0:	29 c2                	sub    %eax,%edx
c002d9f2:	89 d0                	mov    %edx,%eax
c002d9f4:	c1 e0 02             	shl    $0x2,%eax
c002d9f7:	01 d0                	add    %edx,%eax
c002d9f9:	01 c0                	add    %eax,%eax
c002d9fb:	29 c1                	sub    %eax,%ecx
c002d9fd:	89 ca                	mov    %ecx,%edx
c002d9ff:	b8 1e 00 00 00       	mov    $0x1e,%eax
c002da04:	29 d0                	sub    %edx,%eax
c002da06:	89 45 f0             	mov    %eax,-0x10(%ebp)
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
c002da09:	ff 75 f0             	pushl  -0x10(%ebp)
c002da0c:	68 0b 2d 03 c0       	push   $0xc0032d0b
c002da11:	6a 10                	push   $0x10
c002da13:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002da16:	50                   	push   %eax
c002da17:	e8 a3 9d ff ff       	call   c00277bf <snprintf>
c002da1c:	83 c4 10             	add    $0x10,%esp
      thread_create (name, priority, priority_condvar_thread, NULL);
c002da1f:	6a 00                	push   $0x0
c002da21:	68 9a da 02 c0       	push   $0xc002da9a
c002da26:	ff 75 f0             	pushl  -0x10(%ebp)
c002da29:	8d 45 e0             	lea    -0x20(%ebp),%eax
c002da2c:	50                   	push   %eax
c002da2d:	e8 75 30 ff ff       	call   c0020aa7 <thread_create>
c002da32:	83 c4 10             	add    $0x10,%esp

  lock_init (&lock);
  cond_init (&condition);

  thread_set_priority (PRI_MIN);
  for (i = 0; i < 10; i++) 
c002da35:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002da39:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002da3d:	7e 9a                	jle    c002d9d9 <test_priority_condvar+0x68>
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002da3f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002da46:	eb 49                	jmp    c002da91 <test_priority_condvar+0x120>
    {
      lock_acquire (&lock);
c002da48:	83 ec 0c             	sub    $0xc,%esp
c002da4b:	68 60 9e 03 c0       	push   $0xc0039e60
c002da50:	e8 8e 52 ff ff       	call   c0022ce3 <lock_acquire>
c002da55:	83 c4 10             	add    $0x10,%esp
      msg ("Signaling...");
c002da58:	83 ec 0c             	sub    $0xc,%esp
c002da5b:	68 17 2d 03 c0       	push   $0xc0032d17
c002da60:	e8 47 e5 ff ff       	call   c002bfac <msg>
c002da65:	83 c4 10             	add    $0x10,%esp
      cond_signal (&condition, &lock);
c002da68:	83 ec 08             	sub    $0x8,%esp
c002da6b:	68 60 9e 03 c0       	push   $0xc0039e60
c002da70:	68 80 9e 03 c0       	push   $0xc0039e80
c002da75:	e8 49 58 ff ff       	call   c00232c3 <cond_signal>
c002da7a:	83 c4 10             	add    $0x10,%esp
      lock_release (&lock);
c002da7d:	83 ec 0c             	sub    $0xc,%esp
c002da80:	68 60 9e 03 c0       	push   $0xc0039e60
c002da85:	e8 3c 54 ff ff       	call   c0022ec6 <lock_release>
c002da8a:	83 c4 10             	add    $0x10,%esp
      char name[16];
      snprintf (name, sizeof name, "priority %d", priority);
      thread_create (name, priority, priority_condvar_thread, NULL);
    }

  for (i = 0; i < 10; i++) 
c002da8d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002da91:	83 7d f4 09          	cmpl   $0x9,-0xc(%ebp)
c002da95:	7e b1                	jle    c002da48 <test_priority_condvar+0xd7>
      lock_acquire (&lock);
      msg ("Signaling...");
      cond_signal (&condition, &lock);
      lock_release (&lock);
    }
}
c002da97:	90                   	nop
c002da98:	c9                   	leave  
c002da99:	c3                   	ret    

c002da9a <priority_condvar_thread>:

static void
priority_condvar_thread (void *aux UNUSED) 
{
c002da9a:	55                   	push   %ebp
c002da9b:	89 e5                	mov    %esp,%ebp
c002da9d:	83 ec 08             	sub    $0x8,%esp
  msg ("Thread %s starting.", thread_name ());
c002daa0:	e8 37 32 ff ff       	call   c0020cdc <thread_name>
c002daa5:	83 ec 08             	sub    $0x8,%esp
c002daa8:	50                   	push   %eax
c002daa9:	68 24 2d 03 c0       	push   $0xc0032d24
c002daae:	e8 f9 e4 ff ff       	call   c002bfac <msg>
c002dab3:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002dab6:	83 ec 0c             	sub    $0xc,%esp
c002dab9:	68 60 9e 03 c0       	push   $0xc0039e60
c002dabe:	e8 20 52 ff ff       	call   c0022ce3 <lock_acquire>
c002dac3:	83 c4 10             	add    $0x10,%esp
  cond_wait (&condition, &lock);
c002dac6:	83 ec 08             	sub    $0x8,%esp
c002dac9:	68 60 9e 03 c0       	push   $0xc0039e60
c002dace:	68 80 9e 03 c0       	push   $0xc0039e80
c002dad3:	e8 ce 56 ff ff       	call   c00231a6 <cond_wait>
c002dad8:	83 c4 10             	add    $0x10,%esp
  msg ("Thread %s woke up.", thread_name ());
c002dadb:	e8 fc 31 ff ff       	call   c0020cdc <thread_name>
c002dae0:	83 ec 08             	sub    $0x8,%esp
c002dae3:	50                   	push   %eax
c002dae4:	68 38 2d 03 c0       	push   $0xc0032d38
c002dae9:	e8 be e4 ff ff       	call   c002bfac <msg>
c002daee:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002daf1:	83 ec 0c             	sub    $0xc,%esp
c002daf4:	68 60 9e 03 c0       	push   $0xc0039e60
c002daf9:	e8 c8 53 ff ff       	call   c0022ec6 <lock_release>
c002dafe:	83 c4 10             	add    $0x10,%esp
}
c002db01:	90                   	nop
c002db02:	c9                   	leave  
c002db03:	c3                   	ret    

c002db04 <test_priority_donate_chain>:
static thread_func donor_thread_func;
static thread_func interloper_thread_func;

void
test_priority_donate_chain (void) 
{
c002db04:	55                   	push   %ebp
c002db05:	89 e5                	mov    %esp,%ebp
c002db07:	53                   	push   %ebx
c002db08:	81 ec 44 01 00 00    	sub    $0x144,%esp
  int i;  
  struct lock locks[NESTING_DEPTH - 1];
  struct lock_pair lock_pairs[NESTING_DEPTH];

  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);
c002db0e:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002db15:	83 f0 01             	xor    $0x1,%eax
c002db18:	84 c0                	test   %al,%al
c002db1a:	75 1e                	jne    c002db3a <test_priority_donate_chain+0x36>
c002db1c:	83 ec 0c             	sub    $0xc,%esp
c002db1f:	68 64 2d 03 c0       	push   $0xc0032d64
c002db24:	68 72 2d 03 c0       	push   $0xc0032d72
c002db29:	68 7c 2e 03 c0       	push   $0xc0032e7c
c002db2e:	6a 34                	push   $0x34
c002db30:	68 8c 2d 03 c0       	push   $0xc0032d8c
c002db35:	e8 e1 c0 ff ff       	call   c0029c1b <debug_panic>

  thread_set_priority (PRI_MIN);
c002db3a:	83 ec 0c             	sub    $0xc,%esp
c002db3d:	6a 00                	push   $0x0
c002db3f:	e8 ad 33 ff ff       	call   c0020ef1 <thread_set_priority>
c002db44:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002db47:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002db4e:	eb 1e                	jmp    c002db6e <test_priority_donate_chain+0x6a>
    lock_init (&locks[i]);
c002db50:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002db56:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002db59:	c1 e2 05             	shl    $0x5,%edx
c002db5c:	01 d0                	add    %edx,%eax
c002db5e:	83 ec 0c             	sub    $0xc,%esp
c002db61:	50                   	push   %eax
c002db62:	e8 2f 51 ff ff       	call   c0022c96 <lock_init>
c002db67:	83 c4 10             	add    $0x10,%esp
  /* This test does not work with the MLFQS. */
  ASSERT (!thread_mlfqs);

  thread_set_priority (PRI_MIN);

  for (i = 0; i < NESTING_DEPTH - 1; i++)
c002db6a:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002db6e:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002db72:	7e dc                	jle    c002db50 <test_priority_donate_chain+0x4c>
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
c002db74:	83 ec 0c             	sub    $0xc,%esp
c002db77:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002db7d:	50                   	push   %eax
c002db7e:	e8 60 51 ff ff       	call   c0022ce3 <lock_acquire>
c002db83:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock.", thread_name ());
c002db86:	e8 51 31 ff ff       	call   c0020cdc <thread_name>
c002db8b:	83 ec 08             	sub    $0x8,%esp
c002db8e:	50                   	push   %eax
c002db8f:	68 b8 2d 03 c0       	push   $0xc0032db8
c002db94:	e8 13 e4 ff ff       	call   c002bfac <msg>
c002db99:	83 c4 10             	add    $0x10,%esp

  for (i = 1; i < NESTING_DEPTH; i++)
c002db9c:	c7 45 f4 01 00 00 00 	movl   $0x1,-0xc(%ebp)
c002dba3:	e9 ed 00 00 00       	jmp    c002dc95 <test_priority_donate_chain+0x191>
    {
      char name[16];
      int thread_priority;

      snprintf (name, sizeof name, "thread %d", i);
c002dba8:	ff 75 f4             	pushl  -0xc(%ebp)
c002dbab:	68 c5 2d 03 c0       	push   $0xc0032dc5
c002dbb0:	6a 10                	push   $0x10
c002dbb2:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
c002dbb8:	50                   	push   %eax
c002dbb9:	e8 01 9c ff ff       	call   c00277bf <snprintf>
c002dbbe:	83 c4 10             	add    $0x10,%esp
      thread_priority = PRI_MIN + i * 3;
c002dbc1:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002dbc4:	89 d0                	mov    %edx,%eax
c002dbc6:	01 c0                	add    %eax,%eax
c002dbc8:	01 d0                	add    %edx,%eax
c002dbca:	89 45 f0             	mov    %eax,-0x10(%ebp)
      lock_pairs[i].first = i < NESTING_DEPTH - 1 ? locks + i: NULL;
c002dbcd:	83 7d f4 06          	cmpl   $0x6,-0xc(%ebp)
c002dbd1:	7f 12                	jg     c002dbe5 <test_priority_donate_chain+0xe1>
c002dbd3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbd6:	c1 e0 05             	shl    $0x5,%eax
c002dbd9:	89 c2                	mov    %eax,%edx
c002dbdb:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002dbe1:	01 c2                	add    %eax,%edx
c002dbe3:	eb 05                	jmp    c002dbea <test_priority_donate_chain+0xe6>
c002dbe5:	ba 00 00 00 00       	mov    $0x0,%edx
c002dbea:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbed:	89 94 c5 d4 fe ff ff 	mov    %edx,-0x12c(%ebp,%eax,8)
      lock_pairs[i].second = locks + i - 1;
c002dbf4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dbf7:	05 ff ff ff 07       	add    $0x7ffffff,%eax
c002dbfc:	c1 e0 05             	shl    $0x5,%eax
c002dbff:	89 c2                	mov    %eax,%edx
c002dc01:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002dc07:	01 c2                	add    %eax,%edx
c002dc09:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc0c:	89 94 c5 d0 fe ff ff 	mov    %edx,-0x130(%ebp,%eax,8)

      thread_create (name, thread_priority, donor_thread_func, lock_pairs + i);
c002dc13:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dc16:	8d 14 c5 00 00 00 00 	lea    0x0(,%eax,8),%edx
c002dc1d:	8d 85 d0 fe ff ff    	lea    -0x130(%ebp),%eax
c002dc23:	01 d0                	add    %edx,%eax
c002dc25:	50                   	push   %eax
c002dc26:	68 d5 dc 02 c0       	push   $0xc002dcd5
c002dc2b:	ff 75 f0             	pushl  -0x10(%ebp)
c002dc2e:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
c002dc34:	50                   	push   %eax
c002dc35:	e8 6d 2e ff ff       	call   c0020aa7 <thread_create>
c002dc3a:	83 c4 10             	add    $0x10,%esp
      msg ("%s should have priority %d.  Actual priority: %d.",
c002dc3d:	e8 58 33 ff ff       	call   c0020f9a <thread_get_priority>
c002dc42:	89 c3                	mov    %eax,%ebx
c002dc44:	e8 93 30 ff ff       	call   c0020cdc <thread_name>
c002dc49:	53                   	push   %ebx
c002dc4a:	ff 75 f0             	pushl  -0x10(%ebp)
c002dc4d:	50                   	push   %eax
c002dc4e:	68 d0 2d 03 c0       	push   $0xc0032dd0
c002dc53:	e8 54 e3 ff ff       	call   c002bfac <msg>
c002dc58:	83 c4 10             	add    $0x10,%esp
          thread_name (), thread_priority, thread_get_priority ());

      snprintf (name, sizeof name, "interloper %d", i);
c002dc5b:	ff 75 f4             	pushl  -0xc(%ebp)
c002dc5e:	68 02 2e 03 c0       	push   $0xc0032e02
c002dc63:	6a 10                	push   $0x10
c002dc65:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
c002dc6b:	50                   	push   %eax
c002dc6c:	e8 4e 9b ff ff       	call   c00277bf <snprintf>
c002dc71:	83 c4 10             	add    $0x10,%esp
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
c002dc74:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002dc77:	83 e8 01             	sub    $0x1,%eax
c002dc7a:	6a 00                	push   $0x0
c002dc7c:	68 93 dd 02 c0       	push   $0xc002dd93
c002dc81:	50                   	push   %eax
c002dc82:	8d 85 c0 fe ff ff    	lea    -0x140(%ebp),%eax
c002dc88:	50                   	push   %eax
c002dc89:	e8 19 2e ff ff       	call   c0020aa7 <thread_create>
c002dc8e:	83 c4 10             	add    $0x10,%esp
    lock_init (&locks[i]);

  lock_acquire (&locks[0]);
  msg ("%s got lock.", thread_name ());

  for (i = 1; i < NESTING_DEPTH; i++)
c002dc91:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002dc95:	83 7d f4 07          	cmpl   $0x7,-0xc(%ebp)
c002dc99:	0f 8e 09 ff ff ff    	jle    c002dba8 <test_priority_donate_chain+0xa4>

      snprintf (name, sizeof name, "interloper %d", i);
      thread_create (name, thread_priority - 1, interloper_thread_func, NULL);
    }

  lock_release (&locks[0]);
c002dc9f:	83 ec 0c             	sub    $0xc,%esp
c002dca2:	8d 85 10 ff ff ff    	lea    -0xf0(%ebp),%eax
c002dca8:	50                   	push   %eax
c002dca9:	e8 18 52 ff ff       	call   c0022ec6 <lock_release>
c002dcae:	83 c4 10             	add    $0x10,%esp
  msg ("%s finishing with priority %d.", thread_name (),
c002dcb1:	e8 e4 32 ff ff       	call   c0020f9a <thread_get_priority>
c002dcb6:	89 c3                	mov    %eax,%ebx
c002dcb8:	e8 1f 30 ff ff       	call   c0020cdc <thread_name>
c002dcbd:	83 ec 04             	sub    $0x4,%esp
c002dcc0:	53                   	push   %ebx
c002dcc1:	50                   	push   %eax
c002dcc2:	68 10 2e 03 c0       	push   $0xc0032e10
c002dcc7:	e8 e0 e2 ff ff       	call   c002bfac <msg>
c002dccc:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002dccf:	90                   	nop
c002dcd0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dcd3:	c9                   	leave  
c002dcd4:	c3                   	ret    

c002dcd5 <donor_thread_func>:

static void
donor_thread_func (void *locks_) 
{
c002dcd5:	55                   	push   %ebp
c002dcd6:	89 e5                	mov    %esp,%ebp
c002dcd8:	53                   	push   %ebx
c002dcd9:	83 ec 14             	sub    $0x14,%esp
  struct lock_pair *locks = locks_;
c002dcdc:	8b 45 08             	mov    0x8(%ebp),%eax
c002dcdf:	89 45 f4             	mov    %eax,-0xc(%ebp)

  if (locks->first)
c002dce2:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dce5:	8b 40 04             	mov    0x4(%eax),%eax
c002dce8:	85 c0                	test   %eax,%eax
c002dcea:	74 12                	je     c002dcfe <donor_thread_func+0x29>
    lock_acquire (locks->first);
c002dcec:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dcef:	8b 40 04             	mov    0x4(%eax),%eax
c002dcf2:	83 ec 0c             	sub    $0xc,%esp
c002dcf5:	50                   	push   %eax
c002dcf6:	e8 e8 4f ff ff       	call   c0022ce3 <lock_acquire>
c002dcfb:	83 c4 10             	add    $0x10,%esp

  lock_acquire (locks->second);
c002dcfe:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd01:	8b 00                	mov    (%eax),%eax
c002dd03:	83 ec 0c             	sub    $0xc,%esp
c002dd06:	50                   	push   %eax
c002dd07:	e8 d7 4f ff ff       	call   c0022ce3 <lock_acquire>
c002dd0c:	83 c4 10             	add    $0x10,%esp
  msg ("%s got lock", thread_name ());
c002dd0f:	e8 c8 2f ff ff       	call   c0020cdc <thread_name>
c002dd14:	83 ec 08             	sub    $0x8,%esp
c002dd17:	50                   	push   %eax
c002dd18:	68 2f 2e 03 c0       	push   $0xc0032e2f
c002dd1d:	e8 8a e2 ff ff       	call   c002bfac <msg>
c002dd22:	83 c4 10             	add    $0x10,%esp

  lock_release (locks->second);
c002dd25:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd28:	8b 00                	mov    (%eax),%eax
c002dd2a:	83 ec 0c             	sub    $0xc,%esp
c002dd2d:	50                   	push   %eax
c002dd2e:	e8 93 51 ff ff       	call   c0022ec6 <lock_release>
c002dd33:	83 c4 10             	add    $0x10,%esp
  msg ("%s should have priority %d. Actual priority: %d", 
c002dd36:	e8 5f 32 ff ff       	call   c0020f9a <thread_get_priority>
c002dd3b:	89 c3                	mov    %eax,%ebx
c002dd3d:	e8 9a 2f ff ff       	call   c0020cdc <thread_name>
c002dd42:	53                   	push   %ebx
c002dd43:	6a 15                	push   $0x15
c002dd45:	50                   	push   %eax
c002dd46:	68 3c 2e 03 c0       	push   $0xc0032e3c
c002dd4b:	e8 5c e2 ff ff       	call   c002bfac <msg>
c002dd50:	83 c4 10             	add    $0x10,%esp
        thread_name (), (NESTING_DEPTH - 1) * 3,
        thread_get_priority ());

  if (locks->first)
c002dd53:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd56:	8b 40 04             	mov    0x4(%eax),%eax
c002dd59:	85 c0                	test   %eax,%eax
c002dd5b:	74 12                	je     c002dd6f <donor_thread_func+0x9a>
    lock_release (locks->first);
c002dd5d:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002dd60:	8b 40 04             	mov    0x4(%eax),%eax
c002dd63:	83 ec 0c             	sub    $0xc,%esp
c002dd66:	50                   	push   %eax
c002dd67:	e8 5a 51 ff ff       	call   c0022ec6 <lock_release>
c002dd6c:	83 c4 10             	add    $0x10,%esp

  msg ("%s finishing with priority %d.", thread_name (),
c002dd6f:	e8 26 32 ff ff       	call   c0020f9a <thread_get_priority>
c002dd74:	89 c3                	mov    %eax,%ebx
c002dd76:	e8 61 2f ff ff       	call   c0020cdc <thread_name>
c002dd7b:	83 ec 04             	sub    $0x4,%esp
c002dd7e:	53                   	push   %ebx
c002dd7f:	50                   	push   %eax
c002dd80:	68 10 2e 03 c0       	push   $0xc0032e10
c002dd85:	e8 22 e2 ff ff       	call   c002bfac <msg>
c002dd8a:	83 c4 10             	add    $0x10,%esp
                                         thread_get_priority ());
}
c002dd8d:	90                   	nop
c002dd8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002dd91:	c9                   	leave  
c002dd92:	c3                   	ret    

c002dd93 <interloper_thread_func>:

static void
interloper_thread_func (void *arg_ UNUSED)
{
c002dd93:	55                   	push   %ebp
c002dd94:	89 e5                	mov    %esp,%ebp
c002dd96:	83 ec 08             	sub    $0x8,%esp
  msg ("%s finished.", thread_name ());
c002dd99:	e8 3e 2f ff ff       	call   c0020cdc <thread_name>
c002dd9e:	83 ec 08             	sub    $0x8,%esp
c002dda1:	50                   	push   %eax
c002dda2:	68 6c 2e 03 c0       	push   $0xc0032e6c
c002dda7:	e8 00 e2 ff ff       	call   c002bfac <msg>
c002ddac:	83 c4 10             	add    $0x10,%esp
}
c002ddaf:	90                   	nop
c002ddb0:	c9                   	leave  
c002ddb1:	c3                   	ret    

c002ddb2 <test_mlfqs_load_1>:
#include "threads/thread.h"
#include "devices/timer.h"

void
test_mlfqs_load_1 (void) 
{
c002ddb2:	55                   	push   %ebp
c002ddb3:	89 e5                	mov    %esp,%ebp
c002ddb5:	53                   	push   %ebx
c002ddb6:	83 ec 14             	sub    $0x14,%esp
  int64_t start_time;
  int elapsed;
  int load_avg;
  
  ASSERT (thread_mlfqs);
c002ddb9:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002ddc0:	84 c0                	test   %al,%al
c002ddc2:	75 1e                	jne    c002dde2 <test_mlfqs_load_1+0x30>
c002ddc4:	83 ec 0c             	sub    $0xc,%esp
c002ddc7:	68 98 2e 03 c0       	push   $0xc0032e98
c002ddcc:	68 a5 2e 03 c0       	push   $0xc0032ea5
c002ddd1:	68 b4 30 03 c0       	push   $0xc00330b4
c002ddd6:	6a 18                	push   $0x18
c002ddd8:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002dddd:	e8 39 be ff ff       	call   c0029c1b <debug_panic>

  msg ("spinning for up to 45 seconds, please wait...");
c002dde2:	83 ec 0c             	sub    $0xc,%esp
c002dde5:	68 e0 2e 03 c0       	push   $0xc0032ee0
c002ddea:	e8 bd e1 ff ff       	call   c002bfac <msg>
c002ddef:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002ddf2:	e8 06 64 ff ff       	call   c00241fd <timer_ticks>
c002ddf7:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ddfa:	89 55 f4             	mov    %edx,-0xc(%ebp)
  for (;;) 
    {
      load_avg = thread_get_load_avg ();
c002ddfd:	e8 bb 31 ff ff       	call   c0020fbd <thread_get_load_avg>
c002de02:	89 45 ec             	mov    %eax,-0x14(%ebp)
      ASSERT (load_avg >= 0);
c002de05:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002de09:	79 1e                	jns    c002de29 <test_mlfqs_load_1+0x77>
c002de0b:	83 ec 0c             	sub    $0xc,%esp
c002de0e:	68 0e 2f 03 c0       	push   $0xc0032f0e
c002de13:	68 a5 2e 03 c0       	push   $0xc0032ea5
c002de18:	68 b4 30 03 c0       	push   $0xc00330b4
c002de1d:	6a 20                	push   $0x20
c002de1f:	68 bc 2e 03 c0       	push   $0xc0032ebc
c002de24:	e8 f2 bd ff ff       	call   c0029c1b <debug_panic>
      elapsed = timer_elapsed (start_time) / TIMER_FREQ;
c002de29:	83 ec 08             	sub    $0x8,%esp
c002de2c:	ff 75 f4             	pushl  -0xc(%ebp)
c002de2f:	ff 75 f0             	pushl  -0x10(%ebp)
c002de32:	e8 fb 63 ff ff       	call   c0024232 <timer_elapsed>
c002de37:	83 c4 10             	add    $0x10,%esp
c002de3a:	6a 00                	push   $0x0
c002de3c:	6a 64                	push   $0x64
c002de3e:	52                   	push   %edx
c002de3f:	50                   	push   %eax
c002de40:	e8 b0 b7 ff ff       	call   c00295f5 <__divdi3>
c002de45:	83 c4 10             	add    $0x10,%esp
c002de48:	89 45 e8             	mov    %eax,-0x18(%ebp)
      if (load_avg > 100)
c002de4b:	83 7d ec 64          	cmpl   $0x64,-0x14(%ebp)
c002de4f:	7e 4e                	jle    c002de9f <test_mlfqs_load_1+0xed>
        fail ("load average is %d.%02d "
c002de51:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002de54:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002de59:	89 d8                	mov    %ebx,%eax
c002de5b:	f7 ea                	imul   %edx
c002de5d:	c1 fa 05             	sar    $0x5,%edx
c002de60:	89 d8                	mov    %ebx,%eax
c002de62:	c1 f8 1f             	sar    $0x1f,%eax
c002de65:	89 d1                	mov    %edx,%ecx
c002de67:	29 c1                	sub    %eax,%ecx
c002de69:	6b c1 64             	imul   $0x64,%ecx,%eax
c002de6c:	89 d9                	mov    %ebx,%ecx
c002de6e:	29 c1                	sub    %eax,%ecx
c002de70:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002de73:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002de78:	89 d8                	mov    %ebx,%eax
c002de7a:	f7 ea                	imul   %edx
c002de7c:	c1 fa 05             	sar    $0x5,%edx
c002de7f:	89 d8                	mov    %ebx,%eax
c002de81:	c1 f8 1f             	sar    $0x1f,%eax
c002de84:	29 c2                	sub    %eax,%edx
c002de86:	89 d0                	mov    %edx,%eax
c002de88:	ff 75 e8             	pushl  -0x18(%ebp)
c002de8b:	51                   	push   %ecx
c002de8c:	50                   	push   %eax
c002de8d:	68 1c 2f 03 c0       	push   $0xc0032f1c
c002de92:	e8 59 e1 ff ff       	call   c002bff0 <fail>
c002de97:	83 c4 10             	add    $0x10,%esp
c002de9a:	e9 5e ff ff ff       	jmp    c002ddfd <test_mlfqs_load_1+0x4b>
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
c002de9f:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002dea3:	7f 1f                	jg     c002dec4 <test_mlfqs_load_1+0x112>
        break;
      else if (elapsed > 45)
c002dea5:	83 7d e8 2d          	cmpl   $0x2d,-0x18(%ebp)
c002dea9:	0f 8e 4e ff ff ff    	jle    c002ddfd <test_mlfqs_load_1+0x4b>
        fail ("load average stayed below 0.5 for more than 45 seconds");
c002deaf:	83 ec 0c             	sub    $0xc,%esp
c002deb2:	68 68 2f 03 c0       	push   $0xc0032f68
c002deb7:	e8 34 e1 ff ff       	call   c002bff0 <fail>
c002debc:	83 c4 10             	add    $0x10,%esp
    }
c002debf:	e9 39 ff ff ff       	jmp    c002ddfd <test_mlfqs_load_1+0x4b>
      if (load_avg > 100)
        fail ("load average is %d.%02d "
              "but should be between 0 and 1 (after %d seconds)",
              load_avg / 100, load_avg % 100, elapsed);
      else if (load_avg > 50)
        break;
c002dec4:	90                   	nop
      else if (elapsed > 45)
        fail ("load average stayed below 0.5 for more than 45 seconds");
    }

  if (elapsed < 38)
c002dec5:	83 7d e8 25          	cmpl   $0x25,-0x18(%ebp)
c002dec9:	7f 13                	jg     c002dede <test_mlfqs_load_1+0x12c>
    fail ("load average took only %d seconds to rise above 0.5", elapsed);
c002decb:	83 ec 08             	sub    $0x8,%esp
c002dece:	ff 75 e8             	pushl  -0x18(%ebp)
c002ded1:	68 a0 2f 03 c0       	push   $0xc0032fa0
c002ded6:	e8 15 e1 ff ff       	call   c002bff0 <fail>
c002dedb:	83 c4 10             	add    $0x10,%esp
  msg ("load average rose to 0.5 after %d seconds", elapsed);
c002dede:	83 ec 08             	sub    $0x8,%esp
c002dee1:	ff 75 e8             	pushl  -0x18(%ebp)
c002dee4:	68 d4 2f 03 c0       	push   $0xc0032fd4
c002dee9:	e8 be e0 ff ff       	call   c002bfac <msg>
c002deee:	83 c4 10             	add    $0x10,%esp

  msg ("sleeping for another 10 seconds, please wait...");
c002def1:	83 ec 0c             	sub    $0xc,%esp
c002def4:	68 00 30 03 c0       	push   $0xc0033000
c002def9:	e8 ae e0 ff ff       	call   c002bfac <msg>
c002defe:	83 c4 10             	add    $0x10,%esp
  timer_sleep (TIMER_FREQ * 10);
c002df01:	83 ec 08             	sub    $0x8,%esp
c002df04:	6a 00                	push   $0x0
c002df06:	68 e8 03 00 00       	push   $0x3e8
c002df0b:	e8 41 63 ff ff       	call   c0024251 <timer_sleep>
c002df10:	83 c4 10             	add    $0x10,%esp

  load_avg = thread_get_load_avg ();
c002df13:	e8 a5 30 ff ff       	call   c0020fbd <thread_get_load_avg>
c002df18:	89 45 ec             	mov    %eax,-0x14(%ebp)
  if (load_avg < 0)
c002df1b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
c002df1f:	79 10                	jns    c002df31 <test_mlfqs_load_1+0x17f>
    fail ("load average fell below 0");
c002df21:	83 ec 0c             	sub    $0xc,%esp
c002df24:	68 30 30 03 c0       	push   $0xc0033030
c002df29:	e8 c2 e0 ff ff       	call   c002bff0 <fail>
c002df2e:	83 c4 10             	add    $0x10,%esp
  if (load_avg > 50)
c002df31:	83 7d ec 32          	cmpl   $0x32,-0x14(%ebp)
c002df35:	7e 10                	jle    c002df47 <test_mlfqs_load_1+0x195>
    fail ("load average stayed above 0.5 for more than 10 seconds");
c002df37:	83 ec 0c             	sub    $0xc,%esp
c002df3a:	68 4c 30 03 c0       	push   $0xc003304c
c002df3f:	e8 ac e0 ff ff       	call   c002bff0 <fail>
c002df44:	83 c4 10             	add    $0x10,%esp
  msg ("load average fell back below 0.5 (to %d.%02d)",
c002df47:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002df4a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002df4f:	89 d8                	mov    %ebx,%eax
c002df51:	f7 ea                	imul   %edx
c002df53:	c1 fa 05             	sar    $0x5,%edx
c002df56:	89 d8                	mov    %ebx,%eax
c002df58:	c1 f8 1f             	sar    $0x1f,%eax
c002df5b:	89 d1                	mov    %edx,%ecx
c002df5d:	29 c1                	sub    %eax,%ecx
c002df5f:	6b c1 64             	imul   $0x64,%ecx,%eax
c002df62:	29 c3                	sub    %eax,%ebx
c002df64:	89 d9                	mov    %ebx,%ecx
c002df66:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002df69:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002df6e:	89 d8                	mov    %ebx,%eax
c002df70:	f7 ea                	imul   %edx
c002df72:	c1 fa 05             	sar    $0x5,%edx
c002df75:	89 d8                	mov    %ebx,%eax
c002df77:	c1 f8 1f             	sar    $0x1f,%eax
c002df7a:	29 c2                	sub    %eax,%edx
c002df7c:	89 d0                	mov    %edx,%eax
c002df7e:	83 ec 04             	sub    $0x4,%esp
c002df81:	51                   	push   %ecx
c002df82:	50                   	push   %eax
c002df83:	68 84 30 03 c0       	push   $0xc0033084
c002df88:	e8 1f e0 ff ff       	call   c002bfac <msg>
c002df8d:	83 c4 10             	add    $0x10,%esp
       load_avg / 100, load_avg % 100);

  pass ();
c002df90:	e8 b2 e0 ff ff       	call   c002c047 <pass>
}
c002df95:	90                   	nop
c002df96:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002df99:	c9                   	leave  
c002df9a:	c3                   	ret    

c002df9b <test_mlfqs_load_60>:

#define THREAD_CNT 60

void
test_mlfqs_load_60 (void) 
{
c002df9b:	55                   	push   %ebp
c002df9c:	89 e5                	mov    %esp,%ebp
c002df9e:	53                   	push   %ebx
c002df9f:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002dfa2:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002dfa9:	84 c0                	test   %al,%al
c002dfab:	75 1e                	jne    c002dfcb <test_mlfqs_load_60+0x30>
c002dfad:	83 ec 0c             	sub    $0xc,%esp
c002dfb0:	68 c8 30 03 c0       	push   $0xc00330c8
c002dfb5:	68 d5 30 03 c0       	push   $0xc00330d5
c002dfba:	68 88 31 03 c0       	push   $0xc0033188
c002dfbf:	6a 77                	push   $0x77
c002dfc1:	68 ec 30 03 c0       	push   $0xc00330ec
c002dfc6:	e8 50 bc ff ff       	call   c0029c1b <debug_panic>

  start_time = timer_ticks ();
c002dfcb:	e8 2d 62 ff ff       	call   c00241fd <timer_ticks>
c002dfd0:	a3 90 9e 03 c0       	mov    %eax,0xc0039e90
c002dfd5:	89 15 94 9e 03 c0    	mov    %edx,0xc0039e94
  msg ("Starting %d niced load threads...", THREAD_CNT);
c002dfdb:	83 ec 08             	sub    $0x8,%esp
c002dfde:	6a 3c                	push   $0x3c
c002dfe0:	68 10 31 03 c0       	push   $0xc0033110
c002dfe5:	e8 c2 df ff ff       	call   c002bfac <msg>
c002dfea:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002dfed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002dff4:	eb 2f                	jmp    c002e025 <test_mlfqs_load_60+0x8a>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002dff6:	ff 75 f4             	pushl  -0xc(%ebp)
c002dff9:	68 32 31 03 c0       	push   $0xc0033132
c002dffe:	6a 10                	push   $0x10
c002e000:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e003:	50                   	push   %eax
c002e004:	e8 b6 97 ff ff       	call   c00277bf <snprintf>
c002e009:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
c002e00c:	6a 00                	push   $0x0
c002e00e:	68 1d e1 02 c0       	push   $0xc002e11d
c002e013:	6a 1f                	push   $0x1f
c002e015:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e018:	50                   	push   %eax
c002e019:	e8 89 2a ff ff       	call   c0020aa7 <thread_create>
c002e01e:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d niced load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002e021:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e025:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002e029:	7e cb                	jle    c002dff6 <test_mlfqs_load_60+0x5b>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002e02b:	a1 90 9e 03 c0       	mov    0xc0039e90,%eax
c002e030:	8b 15 94 9e 03 c0    	mov    0xc0039e94,%edx
c002e036:	83 ec 08             	sub    $0x8,%esp
c002e039:	52                   	push   %edx
c002e03a:	50                   	push   %eax
c002e03b:	e8 f2 61 ff ff       	call   c0024232 <timer_elapsed>
c002e040:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
c002e043:	6a 00                	push   $0x0
c002e045:	6a 64                	push   $0x64
c002e047:	52                   	push   %edx
c002e048:	50                   	push   %eax
c002e049:	e8 a7 b5 ff ff       	call   c00295f5 <__divdi3>
c002e04e:	83 c4 10             	add    $0x10,%esp
c002e051:	83 ec 04             	sub    $0x4,%esp
c002e054:	52                   	push   %edx
c002e055:	50                   	push   %eax
c002e056:	68 3c 31 03 c0       	push   $0xc003313c
c002e05b:	e8 4c df ff ff       	call   c002bfac <msg>
c002e060:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002e063:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e06a:	e9 9e 00 00 00       	jmp    c002e10d <test_mlfqs_load_60+0x172>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002e06f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e072:	83 c0 05             	add    $0x5,%eax
c002e075:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002e07b:	89 c1                	mov    %eax,%ecx
c002e07d:	89 c3                	mov    %eax,%ebx
c002e07f:	c1 fb 1f             	sar    $0x1f,%ebx
c002e082:	a1 90 9e 03 c0       	mov    0xc0039e90,%eax
c002e087:	8b 15 94 9e 03 c0    	mov    0xc0039e94,%edx
c002e08d:	01 c8                	add    %ecx,%eax
c002e08f:	11 da                	adc    %ebx,%edx
c002e091:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e094:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002e097:	e8 61 61 ff ff       	call   c00241fd <timer_ticks>
c002e09c:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002e09f:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e0a2:	29 c1                	sub    %eax,%ecx
c002e0a4:	19 d3                	sbb    %edx,%ebx
c002e0a6:	89 c8                	mov    %ecx,%eax
c002e0a8:	89 da                	mov    %ebx,%edx
c002e0aa:	83 ec 08             	sub    $0x8,%esp
c002e0ad:	52                   	push   %edx
c002e0ae:	50                   	push   %eax
c002e0af:	e8 9d 61 ff ff       	call   c0024251 <timer_sleep>
c002e0b4:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002e0b7:	e8 01 2f ff ff       	call   c0020fbd <thread_get_load_avg>
c002e0bc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002e0bf:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e0c2:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e0c7:	89 d8                	mov    %ebx,%eax
c002e0c9:	f7 ea                	imul   %edx
c002e0cb:	c1 fa 05             	sar    $0x5,%edx
c002e0ce:	89 d8                	mov    %ebx,%eax
c002e0d0:	c1 f8 1f             	sar    $0x1f,%eax
c002e0d3:	89 d1                	mov    %edx,%ecx
c002e0d5:	29 c1                	sub    %eax,%ecx
c002e0d7:	6b c1 64             	imul   $0x64,%ecx,%eax
c002e0da:	29 c3                	sub    %eax,%ebx
c002e0dc:	89 d9                	mov    %ebx,%ecx
c002e0de:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e0e1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e0e6:	89 d8                	mov    %ebx,%eax
c002e0e8:	f7 ea                	imul   %edx
c002e0ea:	c1 fa 05             	sar    $0x5,%edx
c002e0ed:	89 d8                	mov    %ebx,%eax
c002e0ef:	c1 f8 1f             	sar    $0x1f,%eax
c002e0f2:	29 c2                	sub    %eax,%edx
c002e0f4:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e0f7:	01 c0                	add    %eax,%eax
c002e0f9:	51                   	push   %ecx
c002e0fa:	52                   	push   %edx
c002e0fb:	50                   	push   %eax
c002e0fc:	68 60 31 03 c0       	push   $0xc0033160
c002e101:	e8 a6 de ff ff       	call   c002bfac <msg>
c002e106:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, NULL);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  
  for (i = 0; i < 90; i++) 
c002e109:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e10d:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002e111:	0f 8e 58 ff ff ff    	jle    c002e06f <test_mlfqs_load_60+0xd4>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002e117:	90                   	nop
c002e118:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e11b:	c9                   	leave  
c002e11c:	c3                   	ret    

c002e11d <load_thread>:

static void
load_thread (void *aux UNUSED) 
{
c002e11d:	55                   	push   %ebp
c002e11e:	89 e5                	mov    %esp,%ebp
c002e120:	53                   	push   %ebx
c002e121:	83 ec 24             	sub    $0x24,%esp
  int64_t sleep_time = 10 * TIMER_FREQ;
c002e124:	c7 45 f0 e8 03 00 00 	movl   $0x3e8,-0x10(%ebp)
c002e12b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
c002e132:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e135:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e138:	05 70 17 00 00       	add    $0x1770,%eax
c002e13d:	83 d2 00             	adc    $0x0,%edx
c002e140:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e143:	89 55 ec             	mov    %edx,-0x14(%ebp)
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;
c002e146:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e149:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e14c:	05 70 17 00 00       	add    $0x1770,%eax
c002e151:	83 d2 00             	adc    $0x0,%edx
c002e154:	89 45 e0             	mov    %eax,-0x20(%ebp)
c002e157:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  thread_set_nice (20);
c002e15a:	83 ec 0c             	sub    $0xc,%esp
c002e15d:	6a 14                	push   $0x14
c002e15f:	e8 49 2e ff ff       	call   c0020fad <thread_set_nice>
c002e164:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (start_time));
c002e167:	a1 90 9e 03 c0       	mov    0xc0039e90,%eax
c002e16c:	8b 15 94 9e 03 c0    	mov    0xc0039e94,%edx
c002e172:	83 ec 08             	sub    $0x8,%esp
c002e175:	52                   	push   %edx
c002e176:	50                   	push   %eax
c002e177:	e8 b6 60 ff ff       	call   c0024232 <timer_elapsed>
c002e17c:	83 c4 10             	add    $0x10,%esp
c002e17f:	8b 4d f0             	mov    -0x10(%ebp),%ecx
c002e182:	8b 5d f4             	mov    -0xc(%ebp),%ebx
c002e185:	29 c1                	sub    %eax,%ecx
c002e187:	19 d3                	sbb    %edx,%ebx
c002e189:	89 c8                	mov    %ecx,%eax
c002e18b:	89 da                	mov    %ebx,%edx
c002e18d:	83 ec 08             	sub    $0x8,%esp
c002e190:	52                   	push   %edx
c002e191:	50                   	push   %eax
c002e192:	e8 ba 60 ff ff       	call   c0024251 <timer_sleep>
c002e197:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002e19a:	eb 01                	jmp    c002e19d <load_thread+0x80>
    continue;
c002e19c:	90                   	nop
  int64_t spin_time = sleep_time + 60 * TIMER_FREQ;
  int64_t exit_time = spin_time + 60 * TIMER_FREQ;

  thread_set_nice (20);
  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002e19d:	a1 90 9e 03 c0       	mov    0xc0039e90,%eax
c002e1a2:	8b 15 94 9e 03 c0    	mov    0xc0039e94,%edx
c002e1a8:	83 ec 08             	sub    $0x8,%esp
c002e1ab:	52                   	push   %edx
c002e1ac:	50                   	push   %eax
c002e1ad:	e8 80 60 ff ff       	call   c0024232 <timer_elapsed>
c002e1b2:	83 c4 10             	add    $0x10,%esp
c002e1b5:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002e1b8:	7c e2                	jl     c002e19c <load_thread+0x7f>
c002e1ba:	3b 55 ec             	cmp    -0x14(%ebp),%edx
c002e1bd:	7f 05                	jg     c002e1c4 <load_thread+0xa7>
c002e1bf:	3b 45 e8             	cmp    -0x18(%ebp),%eax
c002e1c2:	72 d8                	jb     c002e19c <load_thread+0x7f>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002e1c4:	a1 90 9e 03 c0       	mov    0xc0039e90,%eax
c002e1c9:	8b 15 94 9e 03 c0    	mov    0xc0039e94,%edx
c002e1cf:	83 ec 08             	sub    $0x8,%esp
c002e1d2:	52                   	push   %edx
c002e1d3:	50                   	push   %eax
c002e1d4:	e8 59 60 ff ff       	call   c0024232 <timer_elapsed>
c002e1d9:	83 c4 10             	add    $0x10,%esp
c002e1dc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002e1df:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e1e2:	29 c1                	sub    %eax,%ecx
c002e1e4:	19 d3                	sbb    %edx,%ebx
c002e1e6:	89 c8                	mov    %ecx,%eax
c002e1e8:	89 da                	mov    %ebx,%edx
c002e1ea:	83 ec 08             	sub    $0x8,%esp
c002e1ed:	52                   	push   %edx
c002e1ee:	50                   	push   %eax
c002e1ef:	e8 5d 60 ff ff       	call   c0024251 <timer_sleep>
c002e1f4:	83 c4 10             	add    $0x10,%esp
}
c002e1f7:	90                   	nop
c002e1f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e1fb:	c9                   	leave  
c002e1fc:	c3                   	ret    

c002e1fd <test_mlfqs_load_avg>:

#define THREAD_CNT 60

void
test_mlfqs_load_avg (void) 
{
c002e1fd:	55                   	push   %ebp
c002e1fe:	89 e5                	mov    %esp,%ebp
c002e200:	53                   	push   %ebx
c002e201:	83 ec 34             	sub    $0x34,%esp
  int i;
  
  ASSERT (thread_mlfqs);
c002e204:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002e20b:	84 c0                	test   %al,%al
c002e20d:	75 21                	jne    c002e230 <test_mlfqs_load_avg+0x33>
c002e20f:	83 ec 0c             	sub    $0xc,%esp
c002e212:	68 9c 31 03 c0       	push   $0xc003319c
c002e217:	68 a9 31 03 c0       	push   $0xc00331a9
c002e21c:	68 58 32 03 c0       	push   $0xc0033258
c002e221:	68 82 00 00 00       	push   $0x82
c002e226:	68 c0 31 03 c0       	push   $0xc00331c0
c002e22b:	e8 eb b9 ff ff       	call   c0029c1b <debug_panic>

  start_time = timer_ticks ();
c002e230:	e8 c8 5f ff ff       	call   c00241fd <timer_ticks>
c002e235:	a3 98 9e 03 c0       	mov    %eax,0xc0039e98
c002e23a:	89 15 9c 9e 03 c0    	mov    %edx,0xc0039e9c
  msg ("Starting %d load threads...", THREAD_CNT);
c002e240:	83 ec 08             	sub    $0x8,%esp
c002e243:	6a 3c                	push   $0x3c
c002e245:	68 e5 31 03 c0       	push   $0xc00331e5
c002e24a:	e8 5d dd ff ff       	call   c002bfac <msg>
c002e24f:	83 c4 10             	add    $0x10,%esp
  for (i = 0; i < THREAD_CNT; i++) 
c002e252:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e259:	eb 31                	jmp    c002e28c <test_mlfqs_load_avg+0x8f>
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
c002e25b:	ff 75 f4             	pushl  -0xc(%ebp)
c002e25e:	68 01 32 03 c0       	push   $0xc0033201
c002e263:	6a 10                	push   $0x10
c002e265:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e268:	50                   	push   %eax
c002e269:	e8 51 95 ff ff       	call   c00277bf <snprintf>
c002e26e:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
c002e271:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e274:	50                   	push   %eax
c002e275:	68 91 e3 02 c0       	push   $0xc002e391
c002e27a:	6a 1f                	push   $0x1f
c002e27c:	8d 45 d4             	lea    -0x2c(%ebp),%eax
c002e27f:	50                   	push   %eax
c002e280:	e8 22 28 ff ff       	call   c0020aa7 <thread_create>
c002e285:	83 c4 10             	add    $0x10,%esp
  
  ASSERT (thread_mlfqs);

  start_time = timer_ticks ();
  msg ("Starting %d load threads...", THREAD_CNT);
  for (i = 0; i < THREAD_CNT; i++) 
c002e288:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e28c:	83 7d f4 3b          	cmpl   $0x3b,-0xc(%ebp)
c002e290:	7e c9                	jle    c002e25b <test_mlfqs_load_avg+0x5e>
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
c002e292:	a1 98 9e 03 c0       	mov    0xc0039e98,%eax
c002e297:	8b 15 9c 9e 03 c0    	mov    0xc0039e9c,%edx
c002e29d:	83 ec 08             	sub    $0x8,%esp
c002e2a0:	52                   	push   %edx
c002e2a1:	50                   	push   %eax
c002e2a2:	e8 8b 5f ff ff       	call   c0024232 <timer_elapsed>
c002e2a7:	83 c4 10             	add    $0x10,%esp
    {
      char name[16];
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, (void *) i);
    }
  msg ("Starting threads took %d seconds.",
c002e2aa:	6a 00                	push   $0x0
c002e2ac:	6a 64                	push   $0x64
c002e2ae:	52                   	push   %edx
c002e2af:	50                   	push   %eax
c002e2b0:	e8 40 b3 ff ff       	call   c00295f5 <__divdi3>
c002e2b5:	83 c4 10             	add    $0x10,%esp
c002e2b8:	83 ec 04             	sub    $0x4,%esp
c002e2bb:	52                   	push   %edx
c002e2bc:	50                   	push   %eax
c002e2bd:	68 0c 32 03 c0       	push   $0xc003320c
c002e2c2:	e8 e5 dc ff ff       	call   c002bfac <msg>
c002e2c7:	83 c4 10             	add    $0x10,%esp
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);
c002e2ca:	83 ec 0c             	sub    $0xc,%esp
c002e2cd:	6a ec                	push   $0xffffffec
c002e2cf:	e8 d9 2c ff ff       	call   c0020fad <thread_set_nice>
c002e2d4:	83 c4 10             	add    $0x10,%esp

  for (i = 0; i < 90; i++) 
c002e2d7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
c002e2de:	e9 9e 00 00 00       	jmp    c002e381 <test_mlfqs_load_avg+0x184>
    {
      int64_t sleep_until = start_time + TIMER_FREQ * (2 * i + 10);
c002e2e3:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e2e6:	83 c0 05             	add    $0x5,%eax
c002e2e9:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002e2ef:	89 c1                	mov    %eax,%ecx
c002e2f1:	89 c3                	mov    %eax,%ebx
c002e2f3:	c1 fb 1f             	sar    $0x1f,%ebx
c002e2f6:	a1 98 9e 03 c0       	mov    0xc0039e98,%eax
c002e2fb:	8b 15 9c 9e 03 c0    	mov    0xc0039e9c,%edx
c002e301:	01 c8                	add    %ecx,%eax
c002e303:	11 da                	adc    %ebx,%edx
c002e305:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e308:	89 55 ec             	mov    %edx,-0x14(%ebp)
      int load_avg;
      timer_sleep (sleep_until - timer_ticks ());
c002e30b:	e8 ed 5e ff ff       	call   c00241fd <timer_ticks>
c002e310:	8b 4d e8             	mov    -0x18(%ebp),%ecx
c002e313:	8b 5d ec             	mov    -0x14(%ebp),%ebx
c002e316:	29 c1                	sub    %eax,%ecx
c002e318:	19 d3                	sbb    %edx,%ebx
c002e31a:	89 c8                	mov    %ecx,%eax
c002e31c:	89 da                	mov    %ebx,%edx
c002e31e:	83 ec 08             	sub    $0x8,%esp
c002e321:	52                   	push   %edx
c002e322:	50                   	push   %eax
c002e323:	e8 29 5f ff ff       	call   c0024251 <timer_sleep>
c002e328:	83 c4 10             	add    $0x10,%esp
      load_avg = thread_get_load_avg ();
c002e32b:	e8 8d 2c ff ff       	call   c0020fbd <thread_get_load_avg>
c002e330:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      msg ("After %d seconds, load average=%d.%02d.",
c002e333:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e336:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e33b:	89 d8                	mov    %ebx,%eax
c002e33d:	f7 ea                	imul   %edx
c002e33f:	c1 fa 05             	sar    $0x5,%edx
c002e342:	89 d8                	mov    %ebx,%eax
c002e344:	c1 f8 1f             	sar    $0x1f,%eax
c002e347:	89 d1                	mov    %edx,%ecx
c002e349:	29 c1                	sub    %eax,%ecx
c002e34b:	6b c1 64             	imul   $0x64,%ecx,%eax
c002e34e:	29 c3                	sub    %eax,%ebx
c002e350:	89 d9                	mov    %ebx,%ecx
c002e352:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e355:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e35a:	89 d8                	mov    %ebx,%eax
c002e35c:	f7 ea                	imul   %edx
c002e35e:	c1 fa 05             	sar    $0x5,%edx
c002e361:	89 d8                	mov    %ebx,%eax
c002e363:	c1 f8 1f             	sar    $0x1f,%eax
c002e366:	29 c2                	sub    %eax,%edx
c002e368:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e36b:	01 c0                	add    %eax,%eax
c002e36d:	51                   	push   %ecx
c002e36e:	52                   	push   %edx
c002e36f:	50                   	push   %eax
c002e370:	68 30 32 03 c0       	push   $0xc0033230
c002e375:	e8 32 dc ff ff       	call   c002bfac <msg>
c002e37a:	83 c4 10             	add    $0x10,%esp
    }
  msg ("Starting threads took %d seconds.",
       timer_elapsed (start_time) / TIMER_FREQ);
  thread_set_nice (-20);

  for (i = 0; i < 90; i++) 
c002e37d:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
c002e381:	83 7d f4 59          	cmpl   $0x59,-0xc(%ebp)
c002e385:	0f 8e 58 ff ff ff    	jle    c002e2e3 <test_mlfqs_load_avg+0xe6>
      timer_sleep (sleep_until - timer_ticks ());
      load_avg = thread_get_load_avg ();
      msg ("After %d seconds, load average=%d.%02d.",
           i * 2, load_avg / 100, load_avg % 100);
    }
}
c002e38b:	90                   	nop
c002e38c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e38f:	c9                   	leave  
c002e390:	c3                   	ret    

c002e391 <load_thread>:

static void
load_thread (void *seq_no_) 
{
c002e391:	55                   	push   %ebp
c002e392:	89 e5                	mov    %esp,%ebp
c002e394:	56                   	push   %esi
c002e395:	53                   	push   %ebx
c002e396:	83 ec 10             	sub    $0x10,%esp
  int seq_no = (int) seq_no_;
c002e399:	8b 45 08             	mov    0x8(%ebp),%eax
c002e39c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int sleep_time = TIMER_FREQ * (10 + seq_no);
c002e39f:	8b 45 f4             	mov    -0xc(%ebp),%eax
c002e3a2:	83 c0 0a             	add    $0xa,%eax
c002e3a5:	6b c0 64             	imul   $0x64,%eax,%eax
c002e3a8:	89 45 f0             	mov    %eax,-0x10(%ebp)
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
c002e3ab:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e3ae:	05 70 17 00 00       	add    $0x1770,%eax
c002e3b3:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);
c002e3b6:	c7 45 e8 e0 2e 00 00 	movl   $0x2ee0,-0x18(%ebp)

  timer_sleep (sleep_time - timer_elapsed (start_time));
c002e3bd:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e3c0:	89 c3                	mov    %eax,%ebx
c002e3c2:	89 c6                	mov    %eax,%esi
c002e3c4:	c1 fe 1f             	sar    $0x1f,%esi
c002e3c7:	a1 98 9e 03 c0       	mov    0xc0039e98,%eax
c002e3cc:	8b 15 9c 9e 03 c0    	mov    0xc0039e9c,%edx
c002e3d2:	83 ec 08             	sub    $0x8,%esp
c002e3d5:	52                   	push   %edx
c002e3d6:	50                   	push   %eax
c002e3d7:	e8 56 5e ff ff       	call   c0024232 <timer_elapsed>
c002e3dc:	83 c4 10             	add    $0x10,%esp
c002e3df:	29 c3                	sub    %eax,%ebx
c002e3e1:	19 d6                	sbb    %edx,%esi
c002e3e3:	89 d8                	mov    %ebx,%eax
c002e3e5:	89 f2                	mov    %esi,%edx
c002e3e7:	83 ec 08             	sub    $0x8,%esp
c002e3ea:	52                   	push   %edx
c002e3eb:	50                   	push   %eax
c002e3ec:	e8 60 5e ff ff       	call   c0024251 <timer_sleep>
c002e3f1:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (start_time) < spin_time)
c002e3f4:	eb 01                	jmp    c002e3f7 <load_thread+0x66>
    continue;
c002e3f6:	90                   	nop
  int sleep_time = TIMER_FREQ * (10 + seq_no);
  int spin_time = sleep_time + TIMER_FREQ * THREAD_CNT;
  int exit_time = TIMER_FREQ * (THREAD_CNT * 2);

  timer_sleep (sleep_time - timer_elapsed (start_time));
  while (timer_elapsed (start_time) < spin_time)
c002e3f7:	a1 98 9e 03 c0       	mov    0xc0039e98,%eax
c002e3fc:	8b 15 9c 9e 03 c0    	mov    0xc0039e9c,%edx
c002e402:	83 ec 08             	sub    $0x8,%esp
c002e405:	52                   	push   %edx
c002e406:	50                   	push   %eax
c002e407:	e8 26 5e ff ff       	call   c0024232 <timer_elapsed>
c002e40c:	83 c4 10             	add    $0x10,%esp
c002e40f:	89 c1                	mov    %eax,%ecx
c002e411:	89 d3                	mov    %edx,%ebx
c002e413:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e416:	99                   	cltd   
c002e417:	39 d3                	cmp    %edx,%ebx
c002e419:	7c db                	jl     c002e3f6 <load_thread+0x65>
c002e41b:	39 d3                	cmp    %edx,%ebx
c002e41d:	7f 04                	jg     c002e423 <load_thread+0x92>
c002e41f:	39 c1                	cmp    %eax,%ecx
c002e421:	72 d3                	jb     c002e3f6 <load_thread+0x65>
    continue;
  timer_sleep (exit_time - timer_elapsed (start_time));
c002e423:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e426:	89 c3                	mov    %eax,%ebx
c002e428:	89 c6                	mov    %eax,%esi
c002e42a:	c1 fe 1f             	sar    $0x1f,%esi
c002e42d:	a1 98 9e 03 c0       	mov    0xc0039e98,%eax
c002e432:	8b 15 9c 9e 03 c0    	mov    0xc0039e9c,%edx
c002e438:	83 ec 08             	sub    $0x8,%esp
c002e43b:	52                   	push   %edx
c002e43c:	50                   	push   %eax
c002e43d:	e8 f0 5d ff ff       	call   c0024232 <timer_elapsed>
c002e442:	83 c4 10             	add    $0x10,%esp
c002e445:	29 c3                	sub    %eax,%ebx
c002e447:	19 d6                	sbb    %edx,%esi
c002e449:	89 d8                	mov    %ebx,%eax
c002e44b:	89 f2                	mov    %esi,%edx
c002e44d:	83 ec 08             	sub    $0x8,%esp
c002e450:	52                   	push   %edx
c002e451:	50                   	push   %eax
c002e452:	e8 fa 5d ff ff       	call   c0024251 <timer_sleep>
c002e457:	83 c4 10             	add    $0x10,%esp
}
c002e45a:	90                   	nop
c002e45b:	8d 65 f8             	lea    -0x8(%ebp),%esp
c002e45e:	5b                   	pop    %ebx
c002e45f:	5e                   	pop    %esi
c002e460:	5d                   	pop    %ebp
c002e461:	c3                   	ret    

c002e462 <test_mlfqs_recent_1>:
/* Sensitive to assumption that recent_cpu updates happen exactly
   when timer_ticks() % TIMER_FREQ == 0. */

void
test_mlfqs_recent_1 (void) 
{
c002e462:	55                   	push   %ebp
c002e463:	89 e5                	mov    %esp,%ebp
c002e465:	57                   	push   %edi
c002e466:	56                   	push   %esi
c002e467:	53                   	push   %ebx
c002e468:	83 ec 2c             	sub    $0x2c,%esp
  int64_t start_time;
  int last_elapsed = 0;
c002e46b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  
  ASSERT (thread_mlfqs);
c002e472:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002e479:	84 c0                	test   %al,%al
c002e47b:	75 1e                	jne    c002e49b <test_mlfqs_recent_1+0x39>
c002e47d:	83 ec 0c             	sub    $0xc,%esp
c002e480:	68 6c 32 03 c0       	push   $0xc003326c
c002e485:	68 79 32 03 c0       	push   $0xc0033279
c002e48a:	68 3c 33 03 c0       	push   $0xc003333c
c002e48f:	6a 73                	push   $0x73
c002e491:	68 90 32 03 c0       	push   $0xc0033290
c002e496:	e8 80 b7 ff ff       	call   c0029c1b <debug_panic>

  do 
    {
      msg ("Sleeping 10 seconds to allow recent_cpu to decay, please wait...");
c002e49b:	83 ec 0c             	sub    $0xc,%esp
c002e49e:	68 b8 32 03 c0       	push   $0xc00332b8
c002e4a3:	e8 04 db ff ff       	call   c002bfac <msg>
c002e4a8:	83 c4 10             	add    $0x10,%esp
      start_time = timer_ticks ();
c002e4ab:	e8 4d 5d ff ff       	call   c00241fd <timer_ticks>
c002e4b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e4b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
      timer_sleep (DIV_ROUND_UP (start_time, TIMER_FREQ) - start_time
c002e4b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
c002e4b9:	8b 55 dc             	mov    -0x24(%ebp),%edx
c002e4bc:	83 c0 63             	add    $0x63,%eax
c002e4bf:	83 d2 00             	adc    $0x0,%edx
c002e4c2:	6a 00                	push   $0x0
c002e4c4:	6a 64                	push   $0x64
c002e4c6:	52                   	push   %edx
c002e4c7:	50                   	push   %eax
c002e4c8:	e8 28 b1 ff ff       	call   c00295f5 <__divdi3>
c002e4cd:	83 c4 10             	add    $0x10,%esp
c002e4d0:	2b 45 d8             	sub    -0x28(%ebp),%eax
c002e4d3:	1b 55 dc             	sbb    -0x24(%ebp),%edx
c002e4d6:	05 e8 03 00 00       	add    $0x3e8,%eax
c002e4db:	83 d2 00             	adc    $0x0,%edx
c002e4de:	83 ec 08             	sub    $0x8,%esp
c002e4e1:	52                   	push   %edx
c002e4e2:	50                   	push   %eax
c002e4e3:	e8 69 5d ff ff       	call   c0024251 <timer_sleep>
c002e4e8:	83 c4 10             	add    $0x10,%esp
                   + 10 * TIMER_FREQ);
    }
  while (thread_get_recent_cpu () > 700);
c002e4eb:	e8 d7 2a ff ff       	call   c0020fc7 <thread_get_recent_cpu>
c002e4f0:	3d bc 02 00 00       	cmp    $0x2bc,%eax
c002e4f5:	7f a4                	jg     c002e49b <test_mlfqs_recent_1+0x39>

  start_time = timer_ticks ();
c002e4f7:	e8 01 5d ff ff       	call   c00241fd <timer_ticks>
c002e4fc:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e4ff:	89 55 dc             	mov    %edx,-0x24(%ebp)
  for (;;) 
    {
      int elapsed = timer_elapsed (start_time);
c002e502:	83 ec 08             	sub    $0x8,%esp
c002e505:	ff 75 dc             	pushl  -0x24(%ebp)
c002e508:	ff 75 d8             	pushl  -0x28(%ebp)
c002e50b:	e8 22 5d ff ff       	call   c0024232 <timer_elapsed>
c002e510:	83 c4 10             	add    $0x10,%esp
c002e513:	89 45 d4             	mov    %eax,-0x2c(%ebp)
      if (elapsed % (TIMER_FREQ * 2) == 0 && elapsed > last_elapsed) 
c002e516:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002e519:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e51e:	89 c8                	mov    %ecx,%eax
c002e520:	f7 ea                	imul   %edx
c002e522:	c1 fa 06             	sar    $0x6,%edx
c002e525:	89 c8                	mov    %ecx,%eax
c002e527:	c1 f8 1f             	sar    $0x1f,%eax
c002e52a:	29 c2                	sub    %eax,%edx
c002e52c:	89 d0                	mov    %edx,%eax
c002e52e:	69 c0 c8 00 00 00    	imul   $0xc8,%eax,%eax
c002e534:	29 c1                	sub    %eax,%ecx
c002e536:	89 c8                	mov    %ecx,%eax
c002e538:	85 c0                	test   %eax,%eax
c002e53a:	0f 85 c5 00 00 00    	jne    c002e605 <test_mlfqs_recent_1+0x1a3>
c002e540:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e543:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
c002e546:	0f 8e b9 00 00 00    	jle    c002e605 <test_mlfqs_recent_1+0x1a3>
        {
          int recent_cpu = thread_get_recent_cpu ();
c002e54c:	e8 76 2a ff ff       	call   c0020fc7 <thread_get_recent_cpu>
c002e551:	89 45 d0             	mov    %eax,-0x30(%ebp)
          int load_avg = thread_get_load_avg ();
c002e554:	e8 64 2a ff ff       	call   c0020fbd <thread_get_load_avg>
c002e559:	89 45 cc             	mov    %eax,-0x34(%ebp)
          int elapsed_seconds = elapsed / TIMER_FREQ;
c002e55c:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
c002e55f:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e564:	89 c8                	mov    %ecx,%eax
c002e566:	f7 ea                	imul   %edx
c002e568:	c1 fa 05             	sar    $0x5,%edx
c002e56b:	89 c8                	mov    %ecx,%eax
c002e56d:	c1 f8 1f             	sar    $0x1f,%eax
c002e570:	29 c2                	sub    %eax,%edx
c002e572:	89 d0                	mov    %edx,%eax
c002e574:	89 45 c8             	mov    %eax,-0x38(%ebp)
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
c002e577:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e57a:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e57f:	89 c8                	mov    %ecx,%eax
c002e581:	f7 ea                	imul   %edx
c002e583:	c1 fa 05             	sar    $0x5,%edx
c002e586:	89 c8                	mov    %ecx,%eax
c002e588:	c1 f8 1f             	sar    $0x1f,%eax
c002e58b:	89 d3                	mov    %edx,%ebx
c002e58d:	29 c3                	sub    %eax,%ebx
c002e58f:	6b c3 64             	imul   $0x64,%ebx,%eax
c002e592:	89 cb                	mov    %ecx,%ebx
c002e594:	29 c3                	sub    %eax,%ebx
c002e596:	8b 4d cc             	mov    -0x34(%ebp),%ecx
c002e599:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e59e:	89 c8                	mov    %ecx,%eax
c002e5a0:	f7 ea                	imul   %edx
c002e5a2:	c1 fa 05             	sar    $0x5,%edx
c002e5a5:	89 c8                	mov    %ecx,%eax
c002e5a7:	c1 f8 1f             	sar    $0x1f,%eax
c002e5aa:	89 d7                	mov    %edx,%edi
c002e5ac:	29 c7                	sub    %eax,%edi
c002e5ae:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e5b1:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e5b6:	89 f0                	mov    %esi,%eax
c002e5b8:	f7 ea                	imul   %edx
c002e5ba:	c1 fa 05             	sar    $0x5,%edx
c002e5bd:	89 f0                	mov    %esi,%eax
c002e5bf:	c1 f8 1f             	sar    $0x1f,%eax
c002e5c2:	89 d1                	mov    %edx,%ecx
c002e5c4:	29 c1                	sub    %eax,%ecx
c002e5c6:	6b c1 64             	imul   $0x64,%ecx,%eax
c002e5c9:	29 c6                	sub    %eax,%esi
c002e5cb:	89 f1                	mov    %esi,%ecx
c002e5cd:	8b 75 d0             	mov    -0x30(%ebp),%esi
c002e5d0:	ba 1f 85 eb 51       	mov    $0x51eb851f,%edx
c002e5d5:	89 f0                	mov    %esi,%eax
c002e5d7:	f7 ea                	imul   %edx
c002e5d9:	c1 fa 05             	sar    $0x5,%edx
c002e5dc:	89 f0                	mov    %esi,%eax
c002e5de:	c1 f8 1f             	sar    $0x1f,%eax
c002e5e1:	29 c2                	sub    %eax,%edx
c002e5e3:	89 d0                	mov    %edx,%eax
c002e5e5:	83 ec 08             	sub    $0x8,%esp
c002e5e8:	53                   	push   %ebx
c002e5e9:	57                   	push   %edi
c002e5ea:	51                   	push   %ecx
c002e5eb:	50                   	push   %eax
c002e5ec:	ff 75 c8             	pushl  -0x38(%ebp)
c002e5ef:	68 fc 32 03 c0       	push   $0xc00332fc
c002e5f4:	e8 b3 d9 ff ff       	call   c002bfac <msg>
c002e5f9:	83 c4 20             	add    $0x20,%esp
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
c002e5fc:	81 7d c8 b3 00 00 00 	cmpl   $0xb3,-0x38(%ebp)
c002e603:	7f 0b                	jg     c002e610 <test_mlfqs_recent_1+0x1ae>
            break;
        } 
      last_elapsed = elapsed;
c002e605:	8b 45 d4             	mov    -0x2c(%ebp),%eax
c002e608:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
c002e60b:	e9 f2 fe ff ff       	jmp    c002e502 <test_mlfqs_recent_1+0xa0>
          msg ("After %d seconds, recent_cpu is %d.%02d, load_avg is %d.%02d.",
               elapsed_seconds,
               recent_cpu / 100, recent_cpu % 100,
               load_avg / 100, load_avg % 100);
          if (elapsed_seconds >= 180)
            break;
c002e610:	90                   	nop
        } 
      last_elapsed = elapsed;
    }
}
c002e611:	90                   	nop
c002e612:	8d 65 f4             	lea    -0xc(%ebp),%esp
c002e615:	5b                   	pop    %ebx
c002e616:	5e                   	pop    %esi
c002e617:	5f                   	pop    %edi
c002e618:	5d                   	pop    %ebp
c002e619:	c3                   	ret    

c002e61a <test_mlfqs_fair_2>:

static void test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step);

void
test_mlfqs_fair_2 (void) 
{
c002e61a:	55                   	push   %ebp
c002e61b:	89 e5                	mov    %esp,%ebp
c002e61d:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 0);
c002e620:	83 ec 04             	sub    $0x4,%esp
c002e623:	6a 00                	push   $0x0
c002e625:	6a 00                	push   $0x0
c002e627:	6a 02                	push   $0x2
c002e629:	e8 54 00 00 00       	call   c002e682 <test_mlfqs_fair>
c002e62e:	83 c4 10             	add    $0x10,%esp
}
c002e631:	90                   	nop
c002e632:	c9                   	leave  
c002e633:	c3                   	ret    

c002e634 <test_mlfqs_fair_20>:

void
test_mlfqs_fair_20 (void) 
{
c002e634:	55                   	push   %ebp
c002e635:	89 e5                	mov    %esp,%ebp
c002e637:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (20, 0, 0);
c002e63a:	83 ec 04             	sub    $0x4,%esp
c002e63d:	6a 00                	push   $0x0
c002e63f:	6a 00                	push   $0x0
c002e641:	6a 14                	push   $0x14
c002e643:	e8 3a 00 00 00       	call   c002e682 <test_mlfqs_fair>
c002e648:	83 c4 10             	add    $0x10,%esp
}
c002e64b:	90                   	nop
c002e64c:	c9                   	leave  
c002e64d:	c3                   	ret    

c002e64e <test_mlfqs_nice_2>:

void
test_mlfqs_nice_2 (void) 
{
c002e64e:	55                   	push   %ebp
c002e64f:	89 e5                	mov    %esp,%ebp
c002e651:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (2, 0, 5);
c002e654:	83 ec 04             	sub    $0x4,%esp
c002e657:	6a 05                	push   $0x5
c002e659:	6a 00                	push   $0x0
c002e65b:	6a 02                	push   $0x2
c002e65d:	e8 20 00 00 00       	call   c002e682 <test_mlfqs_fair>
c002e662:	83 c4 10             	add    $0x10,%esp
}
c002e665:	90                   	nop
c002e666:	c9                   	leave  
c002e667:	c3                   	ret    

c002e668 <test_mlfqs_nice_10>:

void
test_mlfqs_nice_10 (void) 
{
c002e668:	55                   	push   %ebp
c002e669:	89 e5                	mov    %esp,%ebp
c002e66b:	83 ec 08             	sub    $0x8,%esp
  test_mlfqs_fair (10, 0, 1);
c002e66e:	83 ec 04             	sub    $0x4,%esp
c002e671:	6a 01                	push   $0x1
c002e673:	6a 00                	push   $0x0
c002e675:	6a 0a                	push   $0xa
c002e677:	e8 06 00 00 00       	call   c002e682 <test_mlfqs_fair>
c002e67c:	83 c4 10             	add    $0x10,%esp
}
c002e67f:	90                   	nop
c002e680:	c9                   	leave  
c002e681:	c3                   	ret    

c002e682 <test_mlfqs_fair>:

static void load_thread (void *aux);

static void
test_mlfqs_fair (int thread_cnt, int nice_min, int nice_step)
{
c002e682:	55                   	push   %ebp
c002e683:	89 e5                	mov    %esp,%ebp
c002e685:	81 ec 78 01 00 00    	sub    $0x178,%esp
  struct thread_info info[MAX_THREAD_CNT];
  int64_t start_time;
  int nice;
  int i;

  ASSERT (thread_mlfqs);
c002e68b:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002e692:	84 c0                	test   %al,%al
c002e694:	75 1e                	jne    c002e6b4 <test_mlfqs_fair+0x32>
c002e696:	83 ec 0c             	sub    $0xc,%esp
c002e699:	68 50 33 03 c0       	push   $0xc0033350
c002e69e:	68 5d 33 03 c0       	push   $0xc003335d
c002e6a3:	68 9c 34 03 c0       	push   $0xc003349c
c002e6a8:	6a 49                	push   $0x49
c002e6aa:	68 74 33 03 c0       	push   $0xc0033374
c002e6af:	e8 67 b5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (thread_cnt <= MAX_THREAD_CNT);
c002e6b4:	83 7d 08 14          	cmpl   $0x14,0x8(%ebp)
c002e6b8:	7e 1e                	jle    c002e6d8 <test_mlfqs_fair+0x56>
c002e6ba:	83 ec 0c             	sub    $0xc,%esp
c002e6bd:	68 95 33 03 c0       	push   $0xc0033395
c002e6c2:	68 5d 33 03 c0       	push   $0xc003335d
c002e6c7:	68 9c 34 03 c0       	push   $0xc003349c
c002e6cc:	6a 4a                	push   $0x4a
c002e6ce:	68 74 33 03 c0       	push   $0xc0033374
c002e6d3:	e8 43 b5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (nice_min >= -10);
c002e6d8:	83 7d 0c f6          	cmpl   $0xfffffff6,0xc(%ebp)
c002e6dc:	7d 1e                	jge    c002e6fc <test_mlfqs_fair+0x7a>
c002e6de:	83 ec 0c             	sub    $0xc,%esp
c002e6e1:	68 b2 33 03 c0       	push   $0xc00333b2
c002e6e6:	68 5d 33 03 c0       	push   $0xc003335d
c002e6eb:	68 9c 34 03 c0       	push   $0xc003349c
c002e6f0:	6a 4b                	push   $0x4b
c002e6f2:	68 74 33 03 c0       	push   $0xc0033374
c002e6f7:	e8 1f b5 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (nice_step >= 0);
c002e6fc:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
c002e700:	79 1e                	jns    c002e720 <test_mlfqs_fair+0x9e>
c002e702:	83 ec 0c             	sub    $0xc,%esp
c002e705:	68 c2 33 03 c0       	push   $0xc00333c2
c002e70a:	68 5d 33 03 c0       	push   $0xc003335d
c002e70f:	68 9c 34 03 c0       	push   $0xc003349c
c002e714:	6a 4c                	push   $0x4c
c002e716:	68 74 33 03 c0       	push   $0xc0033374
c002e71b:	e8 fb b4 ff ff       	call   c0029c1b <debug_panic>
  ASSERT (nice_min + nice_step * (thread_cnt - 1) <= 20);
c002e720:	8b 45 08             	mov    0x8(%ebp),%eax
c002e723:	83 e8 01             	sub    $0x1,%eax
c002e726:	0f af 45 10          	imul   0x10(%ebp),%eax
c002e72a:	89 c2                	mov    %eax,%edx
c002e72c:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e72f:	01 d0                	add    %edx,%eax
c002e731:	83 f8 14             	cmp    $0x14,%eax
c002e734:	7e 1e                	jle    c002e754 <test_mlfqs_fair+0xd2>
c002e736:	83 ec 0c             	sub    $0xc,%esp
c002e739:	68 d4 33 03 c0       	push   $0xc00333d4
c002e73e:	68 5d 33 03 c0       	push   $0xc003335d
c002e743:	68 9c 34 03 c0       	push   $0xc003349c
c002e748:	6a 4d                	push   $0x4d
c002e74a:	68 74 33 03 c0       	push   $0xc0033374
c002e74f:	e8 c7 b4 ff ff       	call   c0029c1b <debug_panic>

  thread_set_nice (-20);
c002e754:	83 ec 0c             	sub    $0xc,%esp
c002e757:	6a ec                	push   $0xffffffec
c002e759:	e8 4f 28 ff ff       	call   c0020fad <thread_set_nice>
c002e75e:	83 c4 10             	add    $0x10,%esp

  start_time = timer_ticks ();
c002e761:	e8 97 5a ff ff       	call   c00241fd <timer_ticks>
c002e766:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002e769:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg ("Starting %d threads...", thread_cnt);
c002e76c:	83 ec 08             	sub    $0x8,%esp
c002e76f:	ff 75 08             	pushl  0x8(%ebp)
c002e772:	68 02 34 03 c0       	push   $0xc0033402
c002e777:	e8 30 d8 ff ff       	call   c002bfac <msg>
c002e77c:	83 c4 10             	add    $0x10,%esp
  nice = nice_min;
c002e77f:	8b 45 0c             	mov    0xc(%ebp),%eax
c002e782:	89 45 f4             	mov    %eax,-0xc(%ebp)
  for (i = 0; i < thread_cnt; i++) 
c002e785:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e78c:	eb 6e                	jmp    c002e7fc <test_mlfqs_fair+0x17a>
    {
      struct thread_info *ti = &info[i];
c002e78e:	8d 85 a4 fe ff ff    	lea    -0x15c(%ebp),%eax
c002e794:	8b 55 f0             	mov    -0x10(%ebp),%edx
c002e797:	c1 e2 04             	shl    $0x4,%edx
c002e79a:	01 d0                	add    %edx,%eax
c002e79c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
      char name[16];

      ti->start_time = start_time;
c002e79f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
c002e7a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
c002e7a5:	8b 55 ec             	mov    -0x14(%ebp),%edx
c002e7a8:	89 01                	mov    %eax,(%ecx)
c002e7aa:	89 51 04             	mov    %edx,0x4(%ecx)
      ti->tick_count = 0;
c002e7ad:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e7b0:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
      ti->nice = nice;
c002e7b7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
c002e7ba:	8b 55 f4             	mov    -0xc(%ebp),%edx
c002e7bd:	89 50 0c             	mov    %edx,0xc(%eax)

      snprintf(name, sizeof name, "load %d", i);
c002e7c0:	ff 75 f0             	pushl  -0x10(%ebp)
c002e7c3:	68 19 34 03 c0       	push   $0xc0033419
c002e7c8:	6a 10                	push   $0x10
c002e7ca:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e7d0:	50                   	push   %eax
c002e7d1:	e8 e9 8f ff ff       	call   c00277bf <snprintf>
c002e7d6:	83 c4 10             	add    $0x10,%esp
      thread_create (name, PRI_DEFAULT, load_thread, ti);
c002e7d9:	ff 75 e4             	pushl  -0x1c(%ebp)
c002e7dc:	68 87 e8 02 c0       	push   $0xc002e887
c002e7e1:	6a 1f                	push   $0x1f
c002e7e3:	8d 85 94 fe ff ff    	lea    -0x16c(%ebp),%eax
c002e7e9:	50                   	push   %eax
c002e7ea:	e8 b8 22 ff ff       	call   c0020aa7 <thread_create>
c002e7ef:	83 c4 10             	add    $0x10,%esp

      nice += nice_step;
c002e7f2:	8b 45 10             	mov    0x10(%ebp),%eax
c002e7f5:	01 45 f4             	add    %eax,-0xc(%ebp)
  thread_set_nice (-20);

  start_time = timer_ticks ();
  msg ("Starting %d threads...", thread_cnt);
  nice = nice_min;
  for (i = 0; i < thread_cnt; i++) 
c002e7f8:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e7fc:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e7ff:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e802:	7c 8a                	jl     c002e78e <test_mlfqs_fair+0x10c>
      snprintf(name, sizeof name, "load %d", i);
      thread_create (name, PRI_DEFAULT, load_thread, ti);

      nice += nice_step;
    }
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));
c002e804:	83 ec 08             	sub    $0x8,%esp
c002e807:	ff 75 ec             	pushl  -0x14(%ebp)
c002e80a:	ff 75 e8             	pushl  -0x18(%ebp)
c002e80d:	e8 20 5a ff ff       	call   c0024232 <timer_elapsed>
c002e812:	83 c4 10             	add    $0x10,%esp
c002e815:	83 ec 04             	sub    $0x4,%esp
c002e818:	52                   	push   %edx
c002e819:	50                   	push   %eax
c002e81a:	68 24 34 03 c0       	push   $0xc0033424
c002e81f:	e8 88 d7 ff ff       	call   c002bfac <msg>
c002e824:	83 c4 10             	add    $0x10,%esp

  msg ("Sleeping 40 seconds to let threads run, please wait...");
c002e827:	83 ec 0c             	sub    $0xc,%esp
c002e82a:	68 48 34 03 c0       	push   $0xc0033448
c002e82f:	e8 78 d7 ff ff       	call   c002bfac <msg>
c002e834:	83 c4 10             	add    $0x10,%esp
  timer_sleep (40 * TIMER_FREQ);
c002e837:	83 ec 08             	sub    $0x8,%esp
c002e83a:	6a 00                	push   $0x0
c002e83c:	68 a0 0f 00 00       	push   $0xfa0
c002e841:	e8 0b 5a ff ff       	call   c0024251 <timer_sleep>
c002e846:	83 c4 10             	add    $0x10,%esp
  
  for (i = 0; i < thread_cnt; i++)
c002e849:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e850:	eb 2a                	jmp    c002e87c <test_mlfqs_fair+0x1fa>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
c002e852:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e855:	c1 e0 04             	shl    $0x4,%eax
c002e858:	8d 4d f8             	lea    -0x8(%ebp),%ecx
c002e85b:	01 c8                	add    %ecx,%eax
c002e85d:	2d 4c 01 00 00       	sub    $0x14c,%eax
c002e862:	8b 00                	mov    (%eax),%eax
c002e864:	83 ec 04             	sub    $0x4,%esp
c002e867:	50                   	push   %eax
c002e868:	ff 75 f0             	pushl  -0x10(%ebp)
c002e86b:	68 7f 34 03 c0       	push   $0xc003347f
c002e870:	e8 37 d7 ff ff       	call   c002bfac <msg>
c002e875:	83 c4 10             	add    $0x10,%esp
  msg ("Starting threads took %"PRId64" ticks.", timer_elapsed (start_time));

  msg ("Sleeping 40 seconds to let threads run, please wait...");
  timer_sleep (40 * TIMER_FREQ);
  
  for (i = 0; i < thread_cnt; i++)
c002e878:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
c002e87c:	8b 45 f0             	mov    -0x10(%ebp),%eax
c002e87f:	3b 45 08             	cmp    0x8(%ebp),%eax
c002e882:	7c ce                	jl     c002e852 <test_mlfqs_fair+0x1d0>
    msg ("Thread %d received %d ticks.", i, info[i].tick_count);
}
c002e884:	90                   	nop
c002e885:	c9                   	leave  
c002e886:	c3                   	ret    

c002e887 <load_thread>:

static void
load_thread (void *ti_) 
{
c002e887:	55                   	push   %ebp
c002e888:	89 e5                	mov    %esp,%ebp
c002e88a:	53                   	push   %ebx
c002e88b:	83 ec 34             	sub    $0x34,%esp
  struct thread_info *ti = ti_;
c002e88e:	8b 45 08             	mov    0x8(%ebp),%eax
c002e891:	89 45 ec             	mov    %eax,-0x14(%ebp)
  int64_t sleep_time = 5 * TIMER_FREQ;
c002e894:	c7 45 e0 f4 01 00 00 	movl   $0x1f4,-0x20(%ebp)
c002e89b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
c002e8a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
c002e8a5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
c002e8a8:	05 b8 0b 00 00       	add    $0xbb8,%eax
c002e8ad:	83 d2 00             	adc    $0x0,%edx
c002e8b0:	89 45 d8             	mov    %eax,-0x28(%ebp)
c002e8b3:	89 55 dc             	mov    %edx,-0x24(%ebp)
  int64_t last_time = 0;
c002e8b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
c002e8bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

  thread_set_nice (ti->nice);
c002e8c4:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e8c7:	8b 40 0c             	mov    0xc(%eax),%eax
c002e8ca:	83 ec 0c             	sub    $0xc,%esp
c002e8cd:	50                   	push   %eax
c002e8ce:	e8 da 26 ff ff       	call   c0020fad <thread_set_nice>
c002e8d3:	83 c4 10             	add    $0x10,%esp
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
c002e8d6:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e8d9:	8b 50 04             	mov    0x4(%eax),%edx
c002e8dc:	8b 00                	mov    (%eax),%eax
c002e8de:	83 ec 08             	sub    $0x8,%esp
c002e8e1:	52                   	push   %edx
c002e8e2:	50                   	push   %eax
c002e8e3:	e8 4a 59 ff ff       	call   c0024232 <timer_elapsed>
c002e8e8:	83 c4 10             	add    $0x10,%esp
c002e8eb:	8b 4d e0             	mov    -0x20(%ebp),%ecx
c002e8ee:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
c002e8f1:	29 c1                	sub    %eax,%ecx
c002e8f3:	19 d3                	sbb    %edx,%ebx
c002e8f5:	89 c8                	mov    %ecx,%eax
c002e8f7:	89 da                	mov    %ebx,%edx
c002e8f9:	83 ec 08             	sub    $0x8,%esp
c002e8fc:	52                   	push   %edx
c002e8fd:	50                   	push   %eax
c002e8fe:	e8 4e 59 ff ff       	call   c0024251 <timer_sleep>
c002e903:	83 c4 10             	add    $0x10,%esp
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e906:	eb 3a                	jmp    c002e942 <load_thread+0xbb>
    {
      int64_t cur_time = timer_ticks ();
c002e908:	e8 f0 58 ff ff       	call   c00241fd <timer_ticks>
c002e90d:	89 45 d0             	mov    %eax,-0x30(%ebp)
c002e910:	89 55 d4             	mov    %edx,-0x2c(%ebp)
      if (cur_time != last_time)
c002e913:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e916:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e919:	89 d1                	mov    %edx,%ecx
c002e91b:	33 4d f4             	xor    -0xc(%ebp),%ecx
c002e91e:	33 45 f0             	xor    -0x10(%ebp),%eax
c002e921:	09 c8                	or     %ecx,%eax
c002e923:	85 c0                	test   %eax,%eax
c002e925:	74 0f                	je     c002e936 <load_thread+0xaf>
        ti->tick_count++;
c002e927:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e92a:	8b 40 08             	mov    0x8(%eax),%eax
c002e92d:	8d 50 01             	lea    0x1(%eax),%edx
c002e930:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e933:	89 50 08             	mov    %edx,0x8(%eax)
      last_time = cur_time;
c002e936:	8b 45 d0             	mov    -0x30(%ebp),%eax
c002e939:	8b 55 d4             	mov    -0x2c(%ebp),%edx
c002e93c:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002e93f:	89 55 f4             	mov    %edx,-0xc(%ebp)
  int64_t spin_time = sleep_time + 30 * TIMER_FREQ;
  int64_t last_time = 0;

  thread_set_nice (ti->nice);
  timer_sleep (sleep_time - timer_elapsed (ti->start_time));
  while (timer_elapsed (ti->start_time) < spin_time) 
c002e942:	8b 45 ec             	mov    -0x14(%ebp),%eax
c002e945:	8b 50 04             	mov    0x4(%eax),%edx
c002e948:	8b 00                	mov    (%eax),%eax
c002e94a:	83 ec 08             	sub    $0x8,%esp
c002e94d:	52                   	push   %edx
c002e94e:	50                   	push   %eax
c002e94f:	e8 de 58 ff ff       	call   c0024232 <timer_elapsed>
c002e954:	83 c4 10             	add    $0x10,%esp
c002e957:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e95a:	7c ac                	jl     c002e908 <load_thread+0x81>
c002e95c:	3b 55 dc             	cmp    -0x24(%ebp),%edx
c002e95f:	7f 05                	jg     c002e966 <load_thread+0xdf>
c002e961:	3b 45 d8             	cmp    -0x28(%ebp),%eax
c002e964:	72 a2                	jb     c002e908 <load_thread+0x81>
      int64_t cur_time = timer_ticks ();
      if (cur_time != last_time)
        ti->tick_count++;
      last_time = cur_time;
    }
}
c002e966:	90                   	nop
c002e967:	8b 5d fc             	mov    -0x4(%ebp),%ebx
c002e96a:	c9                   	leave  
c002e96b:	c3                   	ret    

c002e96c <test_mlfqs_block>:

static void block_thread (void *lock_);

void
test_mlfqs_block (void) 
{
c002e96c:	55                   	push   %ebp
c002e96d:	89 e5                	mov    %esp,%ebp
c002e96f:	83 ec 38             	sub    $0x38,%esp
  int64_t start_time;
  struct lock lock;
  
  ASSERT (thread_mlfqs);
c002e972:	0f b6 05 a4 9e 03 c0 	movzbl 0xc0039ea4,%eax
c002e979:	84 c0                	test   %al,%al
c002e97b:	75 1e                	jne    c002e99b <test_mlfqs_block+0x2f>
c002e97d:	83 ec 0c             	sub    $0xc,%esp
c002e980:	68 ac 34 03 c0       	push   $0xc00334ac
c002e985:	68 b9 34 03 c0       	push   $0xc00334b9
c002e98a:	68 18 36 03 c0       	push   $0xc0033618
c002e98f:	6a 1c                	push   $0x1c
c002e991:	68 d0 34 03 c0       	push   $0xc00334d0
c002e996:	e8 80 b2 ff ff       	call   c0029c1b <debug_panic>

  msg ("Main thread acquiring lock.");
c002e99b:	83 ec 0c             	sub    $0xc,%esp
c002e99e:	68 f2 34 03 c0       	push   $0xc00334f2
c002e9a3:	e8 04 d6 ff ff       	call   c002bfac <msg>
c002e9a8:	83 c4 10             	add    $0x10,%esp
  lock_init (&lock);
c002e9ab:	83 ec 0c             	sub    $0xc,%esp
c002e9ae:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e9b1:	50                   	push   %eax
c002e9b2:	e8 df 42 ff ff       	call   c0022c96 <lock_init>
c002e9b7:	83 c4 10             	add    $0x10,%esp
  lock_acquire (&lock);
c002e9ba:	83 ec 0c             	sub    $0xc,%esp
c002e9bd:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e9c0:	50                   	push   %eax
c002e9c1:	e8 1d 43 ff ff       	call   c0022ce3 <lock_acquire>
c002e9c6:	83 c4 10             	add    $0x10,%esp
  
  msg ("Main thread creating block thread, sleeping 25 seconds...");
c002e9c9:	83 ec 0c             	sub    $0xc,%esp
c002e9cc:	68 10 35 03 c0       	push   $0xc0033510
c002e9d1:	e8 d6 d5 ff ff       	call   c002bfac <msg>
c002e9d6:	83 c4 10             	add    $0x10,%esp
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
c002e9d9:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002e9dc:	50                   	push   %eax
c002e9dd:	68 73 ea 02 c0       	push   $0xc002ea73
c002e9e2:	6a 1f                	push   $0x1f
c002e9e4:	68 4a 35 03 c0       	push   $0xc003354a
c002e9e9:	e8 b9 20 ff ff       	call   c0020aa7 <thread_create>
c002e9ee:	83 c4 10             	add    $0x10,%esp
  timer_sleep (25 * TIMER_FREQ);
c002e9f1:	83 ec 08             	sub    $0x8,%esp
c002e9f4:	6a 00                	push   $0x0
c002e9f6:	68 c4 09 00 00       	push   $0x9c4
c002e9fb:	e8 51 58 ff ff       	call   c0024251 <timer_sleep>
c002ea00:	83 c4 10             	add    $0x10,%esp

  msg ("Main thread spinning for 5 seconds...");
c002ea03:	83 ec 0c             	sub    $0xc,%esp
c002ea06:	68 50 35 03 c0       	push   $0xc0033550
c002ea0b:	e8 9c d5 ff ff       	call   c002bfac <msg>
c002ea10:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002ea13:	e8 e5 57 ff ff       	call   c00241fd <timer_ticks>
c002ea18:	89 45 f0             	mov    %eax,-0x10(%ebp)
c002ea1b:	89 55 f4             	mov    %edx,-0xc(%ebp)
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002ea1e:	eb 01                	jmp    c002ea21 <test_mlfqs_block+0xb5>
    continue;
c002ea20:	90                   	nop
  thread_create ("block", PRI_DEFAULT, block_thread, &lock);
  timer_sleep (25 * TIMER_FREQ);

  msg ("Main thread spinning for 5 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 5 * TIMER_FREQ)
c002ea21:	83 ec 08             	sub    $0x8,%esp
c002ea24:	ff 75 f4             	pushl  -0xc(%ebp)
c002ea27:	ff 75 f0             	pushl  -0x10(%ebp)
c002ea2a:	e8 03 58 ff ff       	call   c0024232 <timer_elapsed>
c002ea2f:	83 c4 10             	add    $0x10,%esp
c002ea32:	85 d2                	test   %edx,%edx
c002ea34:	78 ea                	js     c002ea20 <test_mlfqs_block+0xb4>
c002ea36:	85 d2                	test   %edx,%edx
c002ea38:	7f 07                	jg     c002ea41 <test_mlfqs_block+0xd5>
c002ea3a:	3d f3 01 00 00       	cmp    $0x1f3,%eax
c002ea3f:	76 df                	jbe    c002ea20 <test_mlfqs_block+0xb4>
    continue;

  msg ("Main thread releasing lock.");
c002ea41:	83 ec 0c             	sub    $0xc,%esp
c002ea44:	68 76 35 03 c0       	push   $0xc0033576
c002ea49:	e8 5e d5 ff ff       	call   c002bfac <msg>
c002ea4e:	83 c4 10             	add    $0x10,%esp
  lock_release (&lock);
c002ea51:	83 ec 0c             	sub    $0xc,%esp
c002ea54:	8d 45 d0             	lea    -0x30(%ebp),%eax
c002ea57:	50                   	push   %eax
c002ea58:	e8 69 44 ff ff       	call   c0022ec6 <lock_release>
c002ea5d:	83 c4 10             	add    $0x10,%esp

  msg ("Block thread should have already acquired lock.");
c002ea60:	83 ec 0c             	sub    $0xc,%esp
c002ea63:	68 94 35 03 c0       	push   $0xc0033594
c002ea68:	e8 3f d5 ff ff       	call   c002bfac <msg>
c002ea6d:	83 c4 10             	add    $0x10,%esp
}
c002ea70:	90                   	nop
c002ea71:	c9                   	leave  
c002ea72:	c3                   	ret    

c002ea73 <block_thread>:

static void
block_thread (void *lock_) 
{
c002ea73:	55                   	push   %ebp
c002ea74:	89 e5                	mov    %esp,%ebp
c002ea76:	83 ec 18             	sub    $0x18,%esp
  struct lock *lock = lock_;
c002ea79:	8b 45 08             	mov    0x8(%ebp),%eax
c002ea7c:	89 45 f4             	mov    %eax,-0xc(%ebp)
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
c002ea7f:	83 ec 0c             	sub    $0xc,%esp
c002ea82:	68 c4 35 03 c0       	push   $0xc00335c4
c002ea87:	e8 20 d5 ff ff       	call   c002bfac <msg>
c002ea8c:	83 c4 10             	add    $0x10,%esp
  start_time = timer_ticks ();
c002ea8f:	e8 69 57 ff ff       	call   c00241fd <timer_ticks>
c002ea94:	89 45 e8             	mov    %eax,-0x18(%ebp)
c002ea97:	89 55 ec             	mov    %edx,-0x14(%ebp)
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002ea9a:	eb 01                	jmp    c002ea9d <block_thread+0x2a>
    continue;
c002ea9c:	90                   	nop
  struct lock *lock = lock_;
  int64_t start_time;

  msg ("Block thread spinning for 20 seconds...");
  start_time = timer_ticks ();
  while (timer_elapsed (start_time) < 20 * TIMER_FREQ)
c002ea9d:	83 ec 08             	sub    $0x8,%esp
c002eaa0:	ff 75 ec             	pushl  -0x14(%ebp)
c002eaa3:	ff 75 e8             	pushl  -0x18(%ebp)
c002eaa6:	e8 87 57 ff ff       	call   c0024232 <timer_elapsed>
c002eaab:	83 c4 10             	add    $0x10,%esp
c002eaae:	85 d2                	test   %edx,%edx
c002eab0:	78 ea                	js     c002ea9c <block_thread+0x29>
c002eab2:	85 d2                	test   %edx,%edx
c002eab4:	7f 07                	jg     c002eabd <block_thread+0x4a>
c002eab6:	3d cf 07 00 00       	cmp    $0x7cf,%eax
c002eabb:	76 df                	jbe    c002ea9c <block_thread+0x29>
    continue;

  msg ("Block thread acquiring lock...");
c002eabd:	83 ec 0c             	sub    $0xc,%esp
c002eac0:	68 ec 35 03 c0       	push   $0xc00335ec
c002eac5:	e8 e2 d4 ff ff       	call   c002bfac <msg>
c002eaca:	83 c4 10             	add    $0x10,%esp
  lock_acquire (lock);
c002eacd:	83 ec 0c             	sub    $0xc,%esp
c002ead0:	ff 75 f4             	pushl  -0xc(%ebp)
c002ead3:	e8 0b 42 ff ff       	call   c0022ce3 <lock_acquire>
c002ead8:	83 c4 10             	add    $0x10,%esp

  msg ("...got it.");
c002eadb:	83 ec 0c             	sub    $0xc,%esp
c002eade:	68 0b 36 03 c0       	push   $0xc003360b
c002eae3:	e8 c4 d4 ff ff       	call   c002bfac <msg>
c002eae8:	83 c4 10             	add    $0x10,%esp
}
c002eaeb:	90                   	nop
c002eaec:	c9                   	leave  
c002eaed:	c3                   	ret    
